<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>EncoderTest.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">core$All_in_core.exec</a> &gt; <a href="index.source.html" class="el_package">com.google.zxing.aztec.encoder</a> &gt; <span class="el_source">EncoderTest.java</span></div><h1>EncoderTest.java</h1><pre class="source lang-java linenums">/*
 * Copyright 2013 ZXing authors
 *
 * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package com.google.zxing.aztec.encoder;

import com.google.zxing.BarcodeFormat;
import com.google.zxing.EncodeHintType;
import com.google.zxing.FormatException;
import com.google.zxing.ResultPoint;
import com.google.zxing.aztec.AztecDetectorResult;
import com.google.zxing.aztec.AztecWriter;
import com.google.zxing.aztec.decoder.Decoder;
import com.google.zxing.common.BitArray;
import com.google.zxing.common.BitMatrix;
import com.google.zxing.common.DecoderResult;
import org.junit.Assert;
import org.junit.Test;

import java.nio.charset.Charset;
import java.nio.charset.StandardCharsets;
import java.util.EnumMap;
import java.util.Map;
import java.util.Random;
import java.util.regex.Pattern;

/**
 * Aztec 2D generator unit tests.
 *
 * @author Rustam Abdullaev
 * @author Frank Yellin
 */
<span class="fc" id="L45">public final class EncoderTest extends Assert {</span>

<span class="fc" id="L47">  private static final Pattern DOTX = Pattern.compile(&quot;[^.X]&quot;);</span>
<span class="fc" id="L48">  private static final Pattern SPACES = Pattern.compile(&quot;\\s+&quot;);</span>
<span class="fc" id="L49">  private static final ResultPoint[] NO_POINTS = new ResultPoint[0];</span>

  // real life tests

  @Test
  public void testEncode1() {
<span class="fc" id="L55">    testEncode(&quot;This is an example Aztec symbol for Wikipedia.&quot;, true, 3,</span>
        &quot;X     X X       X     X X     X     X         \n&quot; +
        &quot;X         X     X X     X   X X   X X       X \n&quot; +
        &quot;X X   X X X X X   X X X                 X     \n&quot; +
        &quot;X X                 X X   X       X X X X X X \n&quot; +
        &quot;    X X X   X   X     X X X X         X X     \n&quot; +
        &quot;  X X X   X X X X   X     X   X     X X   X   \n&quot; +
        &quot;        X X X X X     X X X X   X   X     X   \n&quot; +
        &quot;X       X   X X X X X X X X X X X     X   X X \n&quot; +
        &quot;X   X     X X X               X X X X   X X   \n&quot; +
        &quot;X     X X   X X   X X X X X   X X   X   X X X \n&quot; +
        &quot;X   X         X   X       X   X X X X       X \n&quot; +
        &quot;X       X     X   X   X   X   X   X X   X     \n&quot; +
        &quot;      X   X X X   X       X   X     X X X     \n&quot; +
        &quot;    X X X X X X   X X X X X   X X X X X X   X \n&quot; +
        &quot;  X X   X   X X               X X X   X X X X \n&quot; +
        &quot;  X   X       X X X X X X X X X X X X   X X   \n&quot; +
        &quot;  X X   X       X X X   X X X       X X       \n&quot; +
        &quot;  X               X   X X     X     X X X     \n&quot; +
        &quot;  X   X X X   X X   X   X X X X   X   X X X X \n&quot; +
        &quot;    X   X   X X X   X   X   X X X X     X     \n&quot; +
        &quot;        X               X                 X   \n&quot; +
        &quot;        X X     X   X X   X   X   X       X X \n&quot; +
        &quot;  X   X   X X       X   X         X X X     X \n&quot;);
<span class="fc" id="L79">  }</span>
  
  @Test
  public void testEncode2() {
<span class="fc" id="L83">    testEncode(&quot;Aztec Code is a public domain 2D matrix barcode symbology&quot; +</span>
                &quot; of nominally square symbols built on a square grid with a &quot; +
                &quot;distinctive square bullseye pattern at their center.&quot;, false, 6,
          &quot;        X X     X X     X     X     X   X X X         X   X         X   X X       \n&quot; +
          &quot;  X       X X     X   X X   X X       X             X     X   X X   X           X \n&quot; +
          &quot;  X   X X X     X   X   X X     X X X   X   X X               X X       X X     X \n&quot; +
          &quot;X X X             X   X         X         X     X     X   X     X X       X   X   \n&quot; +
          &quot;X   X   X   X   X   X   X   X   X   X   X   X   X   X   X   X   X   X   X   X   X \n&quot; +
          &quot;    X X   X   X   X X X               X       X       X X     X X   X X       X   \n&quot; +
          &quot;X X     X       X       X X X X   X   X X       X   X X   X       X X   X X   X   \n&quot; +
          &quot;  X       X   X     X X   X   X X   X X   X X X X X X   X X           X   X   X X \n&quot; +
          &quot;X X   X X   X   X X X X   X X X X X X X X   X   X       X X   X X X X   X X X     \n&quot; +
          &quot;  X       X   X     X       X X     X X   X   X   X     X X   X X X   X     X X X \n&quot; +
          &quot;  X   X X X   X X       X X X         X X           X   X   X   X X X   X X     X \n&quot; +
          &quot;    X     X   X X     X X X X     X   X     X X X X   X X   X X   X X X     X   X \n&quot; +
          &quot;X X X   X             X         X X X X X   X   X X   X   X   X X   X   X   X   X \n&quot; +
          &quot;          X       X X X   X X     X   X           X   X X X X   X X               \n&quot; +
          &quot;  X     X X   X   X       X X X X X X X X X X X X X X X   X   X X   X   X X X     \n&quot; +
          &quot;    X X                 X   X                       X X   X       X         X X X \n&quot; +
          &quot;        X   X X   X X X X X X   X X X X X X X X X   X     X X           X X X X   \n&quot; +
          &quot;          X X X   X     X   X   X               X   X X     X X X   X X           \n&quot; +
          &quot;X X     X     X   X   X   X X   X   X X X X X   X   X X X X X X X       X   X X X \n&quot; +
          &quot;X X X X       X       X   X X   X   X       X   X   X     X X X     X X       X X \n&quot; +
          &quot;X   X   X   X   X   X   X   X   X   X   X   X   X   X   X   X   X   X   X   X   X \n&quot; +
          &quot;    X     X       X         X   X   X       X   X   X     X   X X                 \n&quot; +
          &quot;        X X     X X X X X   X   X   X X X X X   X   X X X     X X X X   X         \n&quot; +
          &quot;X     X   X   X         X   X   X               X   X X   X X   X X X     X   X   \n&quot; +
          &quot;  X   X X X   X   X X   X X X   X X X X X X X X X   X X         X X     X X X X   \n&quot; +
          &quot;    X X   X   X   X X X     X                       X X X   X X   X   X     X     \n&quot; +
          &quot;    X X X X   X         X   X X X X X X X X X X X X X X   X       X X   X X   X X \n&quot; +
          &quot;            X   X   X X       X X X X X     X X X       X       X X X         X   \n&quot; +
          &quot;X       X         X   X X X X   X     X X     X X     X X           X   X       X \n&quot; +
          &quot;X     X       X X X X X     X   X X X X   X X X     X       X X X X   X   X X   X \n&quot; +
          &quot;  X X X X X               X     X X X   X       X X   X X   X X X X     X X       \n&quot; +
          &quot;X             X         X   X X   X X     X     X     X   X   X X X X             \n&quot; +
          &quot;    X   X X       X     X       X   X X X X X X   X X   X X X X X X X X X   X   X \n&quot; +
          &quot;    X         X X   X       X     X   X   X       X     X X X     X       X X X X \n&quot; +
          &quot;X     X X     X X X X X X             X X X   X               X   X     X     X X \n&quot; +
          &quot;X   X X     X               X X X X X     X X     X X X X X X X X     X   X   X X \n&quot; +
          &quot;X   X   X   X   X   X   X   X   X   X   X   X   X   X   X   X   X   X   X   X   X \n&quot; +
          &quot;X           X     X X X X     X     X         X         X   X       X X   X X X   \n&quot; +
          &quot;X   X   X X   X X X   X         X X     X X X X     X X   X   X     X   X       X \n&quot; +
          &quot;      X     X     X     X X     X   X X   X X   X         X X       X       X   X \n&quot; +
          &quot;X       X           X   X   X     X X   X               X     X     X X X         \n&quot;);
<span class="fc" id="L127">  }</span>

  @Test
  public void testAztecWriter() throws Exception {
<span class="fc bfc" id="L131" title="All 2 branches covered.">    for (int i = 0; i &lt; 1000; i++) {</span>
<span class="fc" id="L132">      testWriter(&quot;\u20AC 1 sample data.&quot;, &quot;ISO-8859-1&quot;, 25, true, 2);</span>
<span class="fc" id="L133">      testWriter(&quot;\u20AC 1 sample data.&quot;, &quot;ISO-8859-15&quot;, 25, true, 2);</span>
<span class="fc" id="L134">      testWriter(&quot;\u20AC 1 sample data.&quot;, &quot;UTF-8&quot;, 25, true, 2);</span>
<span class="fc" id="L135">      testWriter(&quot;\u20AC 1 sample data.&quot;, &quot;UTF-8&quot;, 100, true, 3);</span>
<span class="fc" id="L136">      testWriter(&quot;\u20AC 1 sample data.&quot;, &quot;UTF-8&quot;, 300, true, 4);</span>
<span class="fc" id="L137">      testWriter(&quot;\u20AC 1 sample data.&quot;, &quot;UTF-8&quot;, 500, false, 5);</span>
      // Test AztecWriter defaults
<span class="fc" id="L139">      String data = &quot;In ut magna vel mauris malesuada&quot;;</span>
<span class="fc" id="L140">      AztecWriter writer = new AztecWriter();</span>
<span class="fc" id="L141">      BitMatrix matrix = writer.encode(data, BarcodeFormat.AZTEC, 0, 0);</span>
<span class="fc" id="L142">      AztecCode aztec = Encoder.encode(data.getBytes(StandardCharsets.ISO_8859_1),</span>
          Encoder.DEFAULT_EC_PERCENT, Encoder.DEFAULT_AZTEC_LAYERS);
<span class="fc" id="L144">      BitMatrix expectedMatrix = aztec.getMatrix();</span>
<span class="fc" id="L145">      assertEquals(matrix, expectedMatrix);</span>
    }
<span class="fc" id="L147">  }</span>
  
  // synthetic tests (encode-decode round-trip)

  @Test
  public void testEncodeDecode1() throws Exception {
<span class="fc" id="L153">    testEncodeDecode(&quot;Abc123!&quot;, true, 1);</span>
<span class="fc" id="L154">  }</span>
  
  @Test
  public void testEncodeDecode2() throws Exception {
<span class="fc" id="L158">    testEncodeDecode(&quot;Lorem ipsum. http://test/&quot;, true, 2);</span>
<span class="fc" id="L159">  }</span>
  
  @Test
  public void testEncodeDecode3() throws Exception {
<span class="fc" id="L163">    testEncodeDecode(&quot;AAAANAAAANAAAANAAAANAAAANAAAANAAAANAAAANAAAANAAAAN&quot;, true, 3);</span>
<span class="fc" id="L164">  }</span>
  
  @Test
  public void testEncodeDecode4() throws Exception {
<span class="fc" id="L168">    testEncodeDecode(&quot;http://test/~!@#*^%&amp;)__ ;:'\&quot;[]{}\\|-+-=`1029384&quot;, true, 4);</span>
<span class="fc" id="L169">  }</span>
  
  @Test
  public void testEncodeDecode5() throws Exception {
<span class="fc" id="L173">    testEncodeDecode(&quot;http://test/~!@#*^%&amp;)__ ;:'\&quot;[]{}\\|-+-=`1029384756&lt;&gt;/?abc&quot;</span>
        + &quot;Four score and seven our forefathers brought forth&quot;, false, 5);
<span class="fc" id="L175">  }</span>
  
  @Test
  public void testEncodeDecode10() throws Exception {
<span class="fc" id="L179">    testEncodeDecode(&quot;In ut magna vel mauris malesuada dictum. Nulla ullamcorper metus quis diam&quot; +</span>
        &quot; cursus facilisis. Sed mollis quam id justo rutrum sagittis. Donec laoreet rutrum&quot; +
        &quot; est, nec convallis mauris condimentum sit amet. Phasellus gravida, justo et congue&quot; +
        &quot; auctor, nisi ipsum viverra erat, eget hendrerit felis turpis nec lorem. Nulla&quot; +
        &quot; ultrices, elit pellentesque aliquet laoreet, justo erat pulvinar nisi, id&quot; +
        &quot; elementum sapien dolor et diam.&quot;, false, 10);
<span class="fc" id="L185">  }</span>
  
  @Test
  public void testEncodeDecode23() throws Exception {
<span class="fc" id="L189">    testEncodeDecode(&quot;In ut magna vel mauris malesuada dictum. Nulla ullamcorper metus quis diam&quot; +</span>
        &quot; cursus facilisis. Sed mollis quam id justo rutrum sagittis. Donec laoreet rutrum&quot; +
        &quot; est, nec convallis mauris condimentum sit amet. Phasellus gravida, justo et congue&quot; +
        &quot; auctor, nisi ipsum viverra erat, eget hendrerit felis turpis nec lorem. Nulla&quot; +
        &quot; ultrices, elit pellentesque aliquet laoreet, justo erat pulvinar nisi, id&quot; +
        &quot; elementum sapien dolor et diam. Donec ac nunc sodales elit placerat eleifend.&quot; +
        &quot; Sed ornare luctus ornare. Vestibulum vehicula, massa at pharetra fringilla, risus&quot; +
        &quot; justo faucibus erat, nec porttitor nibh tellus sed est. Ut justo diam, lobortis eu&quot; +
        &quot; tristique ac, p.In ut magna vel mauris malesuada dictum. Nulla ullamcorper metus&quot; +
        &quot; quis diam cursus facilisis. Sed mollis quam id justo rutrum sagittis. Donec&quot; +
        &quot; laoreet rutrum est, nec convallis mauris condimentum sit amet. Phasellus gravida,&quot; +
        &quot; justo et congue auctor, nisi ipsum viverra erat, eget hendrerit felis turpis nec&quot; +
        &quot; lorem. Nulla ultrices, elit pellentesque aliquet laoreet, justo erat pulvinar&quot; +
        &quot; nisi, id elementum sapien dolor et diam. Donec ac nunc sodales elit placerat&quot; +
        &quot; eleifend. Sed ornare luctus ornare. Vestibulum vehicula, massa at pharetra&quot; +
        &quot; fringilla, risus justo faucibus erat, nec porttitor nibh tellus sed est. Ut justo&quot; +
        &quot; diam, lobortis eu tristique ac, p. In ut magna vel mauris malesuada dictum. Nulla&quot; +
        &quot; ullamcorper metus quis diam cursus facilisis. Sed mollis quam id justo rutrum&quot; +
        &quot; sagittis. Donec laoreet rutrum est, nec convallis mauris condimentum sit amet.&quot; +
        &quot; Phasellus gravida, justo et congue auctor, nisi ipsum viverra erat, eget hendrerit&quot; +
        &quot; felis turpis nec lorem. Nulla ultrices, elit pellentesque aliquet laoreet, justo&quot; +
        &quot; erat pulvinar nisi, id elementum sapien dolor et diam.&quot;, false, 23);
<span class="fc" id="L211">  }</span>

  @Test
  public void testEncodeDecode31() throws Exception {
<span class="fc" id="L215">    testEncodeDecode(&quot;In ut magna vel mauris malesuada dictum. Nulla ullamcorper metus quis diam&quot; +</span>
      &quot; cursus facilisis. Sed mollis quam id justo rutrum sagittis. Donec laoreet rutrum&quot; +
      &quot; est, nec convallis mauris condimentum sit amet. Phasellus gravida, justo et congue&quot; +
      &quot; auctor, nisi ipsum viverra erat, eget hendrerit felis turpis nec lorem. Nulla&quot; +
      &quot; ultrices, elit pellentesque aliquet laoreet, justo erat pulvinar nisi, id&quot; +
      &quot; elementum sapien dolor et diam. Donec ac nunc sodales elit placerat eleifend.&quot; +
      &quot; Sed ornare luctus ornare. Vestibulum vehicula, massa at pharetra fringilla, risus&quot; +
      &quot; justo faucibus erat, nec porttitor nibh tellus sed est. Ut justo diam, lobortis eu&quot; +
      &quot; tristique ac, p.In ut magna vel mauris malesuada dictum. Nulla ullamcorper metus&quot; +
      &quot; quis diam cursus facilisis. Sed mollis quam id justo rutrum sagittis. Donec&quot; +
      &quot; laoreet rutrum est, nec convallis mauris condimentum sit amet. Phasellus gravida,&quot; +
      &quot; justo et congue auctor, nisi ipsum viverra erat, eget hendrerit felis turpis nec&quot; +
      &quot; lorem. Nulla ultrices, elit pellentesque aliquet laoreet, justo erat pulvinar&quot; +
      &quot; nisi, id elementum sapien dolor et diam. Donec ac nunc sodales elit placerat&quot; +
      &quot; eleifend. Sed ornare luctus ornare. Vestibulum vehicula, massa at pharetra&quot; +
      &quot; fringilla, risus justo faucibus erat, nec porttitor nibh tellus sed est. Ut justo&quot; +
      &quot; diam, lobortis eu tristique ac, p. In ut magna vel mauris malesuada dictum. Nulla&quot; +
      &quot; ullamcorper metus quis diam cursus facilisis. Sed mollis quam id justo rutrum&quot; +
      &quot; sagittis. Donec laoreet rutrum est, nec convallis mauris condimentum sit amet.&quot; +
      &quot; Phasellus gravida, justo et congue auctor, nisi ipsum viverra erat, eget hendrerit&quot; +
      &quot; felis turpis nec lorem. Nulla ultrices, elit pellentesque aliquet laoreet, justo&quot; +
      &quot; erat pulvinar nisi, id elementum sapien dolor et diam. Donec ac nunc sodales elit&quot; +
      &quot; placerat eleifend. Sed ornare luctus ornare. Vestibulum vehicula, massa at&quot; +
      &quot; pharetra fringilla, risus justo faucibus erat, nec porttitor nibh tellus sed est.&quot; +
      &quot; Ut justo diam, lobortis eu tristique ac, p.In ut magna vel mauris malesuada&quot; +
      &quot; dictum. Nulla ullamcorper metus quis diam cursus facilisis. Sed mollis quam id&quot; +
      &quot; justo rutrum sagittis. Donec laoreet rutrum est, nec convallis mauris condimentum&quot; +
      &quot; sit amet. Phasellus gravida, justo et congue auctor, nisi ipsum viverra erat,&quot; +
      &quot; eget hendrerit felis turpis nec lorem. Nulla ultrices, elit pellentesque aliquet&quot; +
      &quot; laoreet, justo erat pulvinar nisi, id elementum sapien dolor et diam. Donec ac&quot; +
      &quot; nunc sodales elit placerat eleifend. Sed ornare luctus ornare. Vestibulum vehicula,&quot; +
      &quot; massa at pharetra fringilla, risus justo faucibus erat, nec porttitor nibh tellus&quot; +
      &quot; sed est. Ut justo diam, lobortis eu tris. In ut magna vel mauris malesuada dictum.&quot; +
      &quot; Nulla ullamcorper metus quis diam cursus facilisis. Sed mollis quam id justo rutrum&quot; +
      &quot; sagittis. Donec laoreet rutrum est, nec convallis mauris condimentum sit amet.&quot; +
      &quot; Phasellus gravida, justo et congue auctor, nisi ipsum viverra erat, eget&quot; +
      &quot; hendrerit felis turpis nec lorem.&quot;, false, 31);
<span class="fc" id="L252">  }</span>

  @Test
  public void testGenerateModeMessage() {
<span class="fc" id="L256">    testModeMessage(true, 2, 29, &quot;.X .XXX.. ...X XX.. ..X .XX. .XX.X&quot;);</span>
<span class="fc" id="L257">    testModeMessage(true, 4, 64, &quot;XX XXXXXX .X.. ...X ..XX .X.. XX..&quot;);</span>
<span class="fc" id="L258">    testModeMessage(false, 21, 660,  &quot;X.X.. .X.X..X..XX .XXX ..X.. .XXX. .X... ..XXX&quot;);</span>
<span class="fc" id="L259">    testModeMessage(false, 32, 4096, &quot;XXXXX XXXXXXXXXXX X.X. ..... XXX.X ..X.. X.XXX&quot;);</span>
<span class="fc" id="L260">  }</span>

  @Test
  public void testStuffBits() {
<span class="fc" id="L264">    testStuffBits(5, &quot;.X.X. X.X.X .X.X.&quot;,</span>
        &quot;.X.X. X.X.X .X.X.&quot;);
<span class="fc" id="L266">    testStuffBits(5, &quot;.X.X. ..... .X.X&quot;,</span>
        &quot;.X.X. ....X ..X.X&quot;);
<span class="fc" id="L268">    testStuffBits(3, &quot;XX. ... ... ..X XXX .X. ..&quot;,</span>
        &quot;XX. ..X ..X ..X ..X .XX XX. .X. ..X&quot;);
<span class="fc" id="L270">    testStuffBits(6, &quot;.X.X.. ...... ..X.XX&quot;,</span>
        &quot;.X.X.. .....X. ..X.XX XXXX.&quot;);
<span class="fc" id="L272">    testStuffBits(6, &quot;.X.X.. ...... ...... ..X.X.&quot;,</span>
        &quot;.X.X.. .....X .....X ....X. X.XXXX&quot;);
<span class="fc" id="L274">    testStuffBits(6, &quot;.X.X.. XXXXXX ...... ..X.XX&quot;,</span>
        &quot;.X.X.. XXXXX. X..... ...X.X XXXXX.&quot;);
<span class="fc" id="L276">    testStuffBits(6,</span>
        &quot;...... ..XXXX X..XX. .X.... .X.X.X .....X .X.... ...X.X .....X ....XX ..X... ....X. X..XXX X.XX.X&quot;,
        &quot;.....X ...XXX XX..XX ..X... ..X.X. X..... X.X... ....X. X..... X....X X..X.. .....X X.X..X XXX.XX .XXXXX&quot;);
<span class="fc" id="L279">  }</span>

  @Test
  public void testHighLevelEncode() {
<span class="fc" id="L283">    testHighLevelEncodeString(&quot;A. b.&quot;,</span>
        // 'A'  P/S   '. ' L/L    b    D/L    '.'
        &quot;...X. ..... ...XX XXX.. ...XX XXXX. XX.X&quot;);
<span class="fc" id="L286">    testHighLevelEncodeString(&quot;Lorem ipsum.&quot;,</span>
        // 'L'  L/L   'o'   'r'   'e'   'm'   ' '   'i'   'p'   's'   'u'   'm'   D/L   '.'
        &quot;.XX.X XXX.. X.... X..XX ..XX. .XXX. ....X .X.X. X...X X.X.. X.XX. .XXX. XXXX. XX.X&quot;);
<span class="fc" id="L289">    testHighLevelEncodeString(&quot;Lo. Test 123.&quot;,</span>
        // 'L'  L/L   'o'   P/S   '. '  U/S   'T'   'e'   's'   't'    D/L   ' '  '1'  '2'  '3'  '.'
        &quot;.XX.X XXX.. X.... ..... ...XX XXX.. X.X.X ..XX. X.X.. X.X.X  XXXX. ...X ..XX .X.. .X.X XX.X&quot;);
<span class="fc" id="L292">    testHighLevelEncodeString(&quot;Lo...x&quot;,</span>
        // 'L'  L/L   'o'   D/L   '.'  '.'  '.'  U/L  L/L   'x'
        &quot;.XX.X XXX.. X.... XXXX. XX.X XX.X XX.X XXX. XXX.. XX..X&quot;);
<span class="fc" id="L295">    testHighLevelEncodeString(&quot;. x://abc/.&quot;,</span>
        //P/S   '. '  L/L   'x'   P/S   ':'   P/S   '/'   P/S   '/'   'a'   'b'   'c'   P/S   '/'   D/L   '.'
        &quot;..... ...XX XXX.. XX..X ..... X.X.X ..... X.X.. ..... X.X.. ...X. ...XX ..X.. ..... X.X.. XXXX. XX.X&quot;);
    // Uses Binary/Shift rather than Lower/Shift to save two bits.
<span class="fc" id="L299">    testHighLevelEncodeString(&quot;ABCdEFG&quot;,</span>
        //'A'   'B'   'C'   B/S    =1    'd'     'E'   'F'   'G'
        &quot;...X. ...XX ..X.. XXXXX ....X .XX..X.. ..XX. ..XXX .X...&quot;);

<span class="fc" id="L303">    testHighLevelEncodeString(</span>
        // Found on an airline boarding pass.  Several stretches of Binary shift are
        // necessary to keep the bitcount so low.
        &quot;09  UAG    ^160MEUCIQC0sYS/HpKxnBELR1uB85R20OoqqwFGa0q2uEi&quot;
            + &quot;Ygh6utAIgLl1aBVM4EOTQtMQQYH9M2Z3Dp4qnA/fwWuQ+M8L3V8U=&quot;,
        823);
<span class="fc" id="L309">  }</span>
  
  @Test
  public void testHighLevelEncodeBinary() {
    // binary short form single byte
<span class="fc" id="L314">    testHighLevelEncodeString(&quot;N\0N&quot;,</span>
        // 'N'  B/S    =1   '\0'      N
        &quot;.XXXX XXXXX ....X ........ .XXXX&quot;);   // Encode &quot;N&quot; in UPPER

<span class="fc" id="L318">    testHighLevelEncodeString(&quot;N\0n&quot;,</span>
        // 'N'  B/S    =2   '\0'       'n'
        &quot;.XXXX XXXXX ...X. ........ .XX.XXX.&quot;);   // Encode &quot;n&quot; in BINARY

    // binary short form consecutive bytes
<span class="fc" id="L323">    testHighLevelEncodeString(&quot;N\0\u0080 A&quot;,</span>
        // 'N'  B/S    =2    '\0'    \u0080   ' '  'A'
        &quot;.XXXX XXXXX ...X. ........ X....... ....X ...X.&quot;);

    // binary skipping over single character
<span class="fc" id="L328">    testHighLevelEncodeString(&quot;\0a\u00FF\u0080 A&quot;,</span>
        // B/S  =4    '\0'      'a'     '\3ff'   '\200'   ' '   'A'
        &quot;XXXXX ..X.. ........ .XX....X XXXXXXXX X....... ....X ...X.&quot;);

    // getting into binary mode from digit mode
<span class="fc" id="L333">    testHighLevelEncodeString(&quot;1234\0&quot;,</span>
        //D/L   '1'  '2'  '3'  '4'  U/L  B/S    =1    \0
        &quot;XXXX. ..XX .X.. .X.X .XX. XXX. XXXXX ....X ........&quot;
    );

    // Create a string in which every character requires binary
<span class="fc" id="L339">    StringBuilder sb = new StringBuilder();</span>
<span class="fc bfc" id="L340" title="All 2 branches covered.">    for (int i = 0; i &lt;= 3000; i++) {</span>
<span class="fc" id="L341">      sb.append((char) (128 + (i % 30)));</span>
    }
    // Test the output generated by Binary/Switch, particularly near the
    // places where the encoding changes: 31, 62, and 2047+31=2078
<span class="fc bfc" id="L345" title="All 2 branches covered.">    for (int i : new int[] { 1, 2, 3, 10, 29, 30, 31, 32, 33,</span>
                             60, 61, 62, 63, 64, 2076, 2077, 2078, 2079, 2080, 2100 }) {
      // This is the expected length of a binary string of length &quot;i&quot;
<span class="fc bfc" id="L348" title="All 6 branches covered.">      int expectedLength = (8 * i) +</span>
          ((i &lt;= 31) ? 10 : (i &lt;= 62) ? 20 : (i &lt;= 2078) ? 21 : 31);
      // Verify that we are correct about the length.
<span class="fc" id="L351">      testHighLevelEncodeString(sb.substring(0, i), expectedLength);</span>
<span class="fc bfc" id="L352" title="All 6 branches covered.">      if (i != 1 &amp;&amp; i != 32 &amp;&amp; i != 2079) {</span>
        // The addition of an 'a' at the beginning or end gets merged into the binary code
        // in those cases where adding another binary character only adds 8 or 9 bits to the result.
        // So we exclude the border cases i=1,32,2079
        // A lower case letter at the beginning will be merged into binary mode
<span class="fc" id="L357">        testHighLevelEncodeString('a' + sb.substring(0, i - 1), expectedLength);</span>
        // A lower case letter at the end will also be merged into binary mode
<span class="fc" id="L359">        testHighLevelEncodeString(sb.substring(0, i - 1) + 'a', expectedLength);</span>
      }
      // A lower case letter at both ends will enough to latch us into LOWER.
<span class="fc" id="L362">      testHighLevelEncodeString('a' + sb.substring(0, i) + 'b', expectedLength + 15);</span>
    }

<span class="fc" id="L365">    sb = new StringBuilder();</span>
<span class="fc bfc" id="L366" title="All 2 branches covered.">    for (int i = 0; i &lt; 32; i++) {</span>
<span class="fc" id="L367">      sb.append('§'); // § forces binary encoding</span>
    }
<span class="fc" id="L369">    sb.setCharAt(1, 'A');</span>
    // expect B/S(1) A B/S(30)
<span class="fc" id="L371">    testHighLevelEncodeString(sb.toString(), 5 + 20 + 31 * 8);</span>

<span class="fc" id="L373">    sb = new StringBuilder();</span>
<span class="fc bfc" id="L374" title="All 2 branches covered.">    for (int i = 0; i &lt; 31; i++) {</span>
<span class="fc" id="L375">      sb.append('§');</span>
    }
<span class="fc" id="L377">    sb.setCharAt(1, 'A');</span>
    // expect B/S(31)
<span class="fc" id="L379">    testHighLevelEncodeString(sb.toString(), 10 + 31 * 8);</span>

<span class="fc" id="L381">    sb = new StringBuilder();</span>
<span class="fc bfc" id="L382" title="All 2 branches covered.">    for (int i = 0; i &lt; 34; i++) {</span>
<span class="fc" id="L383">      sb.append('§');</span>
    }
<span class="fc" id="L385">    sb.setCharAt(1, 'A');</span>
    // expect B/S(31) B/S(3)
<span class="fc" id="L387">    testHighLevelEncodeString(sb.toString(), 20 + 34 * 8);</span>

<span class="fc" id="L389">    sb = new StringBuilder();</span>
<span class="fc bfc" id="L390" title="All 2 branches covered.">    for (int i = 0; i &lt; 64; i++) {</span>
<span class="fc" id="L391">      sb.append('§');</span>
    }
<span class="fc" id="L393">    sb.setCharAt(30, 'A');</span>
    // expect B/S(64)
<span class="fc" id="L395">    testHighLevelEncodeString(sb.toString(), 21 + 64 * 8);</span>
<span class="fc" id="L396">  }</span>

  @Test
  public void testHighLevelEncodePairs() {
    // Typical usage
<span class="fc" id="L401">    testHighLevelEncodeString(&quot;ABC. DEF\r\n&quot;,</span>
        //  A     B    C    P/S   .&lt;sp&gt;   D    E     F    P/S   \r\n
        &quot;...X. ...XX ..X.. ..... ...XX ..X.X ..XX. ..XXX ..... ...X.&quot;);

    // We should latch to PUNCT mode, rather than shift.  Also check all pairs
<span class="fc" id="L406">    testHighLevelEncodeString(&quot;A. : , \r\n&quot;,</span>
        // 'A'    M/L   P/L   &quot;. &quot;  &quot;: &quot;   &quot;, &quot; &quot;\r\n&quot;
        &quot;...X. XXX.X XXXX. ...XX ..X.X  ..X.. ...X.&quot;);

    // Latch to DIGIT rather than shift to PUNCT
<span class="fc" id="L411">    testHighLevelEncodeString(&quot;A. 1234&quot;,</span>
        // 'A'  D/L   '.'  ' '  '1' '2'   '3'  '4'
        &quot;...X. XXXX. XX.X ...X ..XX .X.. .X.X .X X.&quot;
        );
    // Don't bother leaving Binary Shift.
<span class="fc" id="L416">    testHighLevelEncodeString(&quot;A\200. \200&quot;,</span>
        // 'A'  B/S    =2    \200      &quot;.&quot;     &quot; &quot;     \200
        &quot;...X. XXXXX ..X.. X....... ..X.XXX. ..X..... X.......&quot;);
<span class="fc" id="L419">  }</span>

  @Test
  public void testUserSpecifiedLayers() {
<span class="fc" id="L423">    byte[] alphabet = &quot;ABCDEFGHIJKLMNOPQRSTUVWXYZ&quot;.getBytes(StandardCharsets.ISO_8859_1);</span>
<span class="fc" id="L424">    AztecCode aztec = Encoder.encode(alphabet, 25, -2);</span>
<span class="fc" id="L425">    assertEquals(2, aztec.getLayers());</span>
<span class="fc" id="L426">    assertTrue(aztec.isCompact());</span>

<span class="fc" id="L428">    aztec = Encoder.encode(alphabet, 25, 32);</span>
<span class="fc" id="L429">    assertEquals(32, aztec.getLayers());</span>
<span class="fc" id="L430">    assertFalse(aztec.isCompact());</span>

    try {
<span class="nc" id="L433">      Encoder.encode(alphabet, 25, 33);</span>
<span class="nc" id="L434">      fail(&quot;Encode should have failed.  No such thing as 33 layers&quot;);</span>
<span class="fc" id="L435">    } catch (IllegalArgumentException expected) {</span>
      // continue
<span class="nc" id="L437">    }</span>

    try {
<span class="nc" id="L440">      Encoder.encode(alphabet, 25, -1);</span>
<span class="nc" id="L441">      fail(&quot;Encode should have failed.  Text can't fit in 1-layer compact&quot;);</span>
<span class="fc" id="L442">    } catch (IllegalArgumentException expected) {</span>
      // continue
<span class="nc" id="L444">    }</span>
<span class="fc" id="L445">  }</span>

  @Test
  public void testBorderCompact4Case() {
    // Compact(4) con hold 608 bits of information, but at most 504 can be data.  Rest must
    // be error correction
<span class="fc" id="L451">    String alphabet = &quot;ABCDEFGHIJKLMNOPQRSTUVWXYZ&quot;;</span>
    // encodes as 26 * 5 * 4 = 520 bits of data
<span class="fc" id="L453">    String alphabet4 = alphabet + alphabet + alphabet + alphabet;</span>
<span class="fc" id="L454">    byte[] data = alphabet4.getBytes(StandardCharsets.ISO_8859_1);</span>
    try {
<span class="nc" id="L456">      Encoder.encode(data, 0, -4);</span>
<span class="nc" id="L457">      fail(&quot;Encode should have failed.  Text can't fit in 1-layer compact&quot;);</span>
<span class="fc" id="L458">    } catch (IllegalArgumentException expected) {</span>
      // continue
<span class="nc" id="L460">    }</span>

    // If we just try to encode it normally, it will go to a non-compact 4 layer
<span class="fc" id="L463">    AztecCode aztecCode = Encoder.encode(data, 0, Encoder.DEFAULT_AZTEC_LAYERS);</span>
<span class="fc" id="L464">    assertFalse(aztecCode.isCompact());</span>
<span class="fc" id="L465">    assertEquals(4, aztecCode.getLayers());</span>

    // But shortening the string to 100 bytes (500 bits of data), compact works fine, even if we
    // include more error checking.
<span class="fc" id="L469">    aztecCode = Encoder.encode(alphabet4.substring(0, 100).getBytes(StandardCharsets.ISO_8859_1), 10, Encoder.DEFAULT_AZTEC_LAYERS);</span>
<span class="fc" id="L470">    assertTrue(aztecCode.isCompact());</span>
<span class="fc" id="L471">    assertEquals(4, aztecCode.getLayers());</span>
<span class="fc" id="L472">  }</span>

  // Helper routines

  private static void testEncode(String data, boolean compact, int layers, String expected) {
<span class="fc" id="L477">    AztecCode aztec = Encoder.encode(data.getBytes(StandardCharsets.ISO_8859_1), 33, Encoder.DEFAULT_AZTEC_LAYERS);</span>
<span class="fc" id="L478">    assertEquals(&quot;Unexpected symbol format (compact)&quot;, compact, aztec.isCompact());</span>
<span class="fc" id="L479">    assertEquals(&quot;Unexpected nr. of layers&quot;, layers, aztec.getLayers());</span>
<span class="fc" id="L480">    BitMatrix matrix = aztec.getMatrix();</span>
<span class="fc" id="L481">    assertEquals(&quot;encode() failed&quot;, expected, matrix.toString());</span>
<span class="fc" id="L482">  }</span>

  private static void testEncodeDecode(String data, boolean compact, int layers) throws Exception {
<span class="fc" id="L485">    AztecCode aztec = Encoder.encode(data.getBytes(StandardCharsets.ISO_8859_1), 25, Encoder.DEFAULT_AZTEC_LAYERS);</span>
<span class="fc" id="L486">    assertEquals(&quot;Unexpected symbol format (compact)&quot;, compact, aztec.isCompact());</span>
<span class="fc" id="L487">    assertEquals(&quot;Unexpected nr. of layers&quot;, layers, aztec.getLayers());</span>
<span class="fc" id="L488">    BitMatrix matrix = aztec.getMatrix();</span>
<span class="fc" id="L489">    AztecDetectorResult r = </span>
<span class="fc" id="L490">        new AztecDetectorResult(matrix, NO_POINTS, aztec.isCompact(), aztec.getCodeWords(), aztec.getLayers());</span>
<span class="fc" id="L491">    DecoderResult res = new Decoder().decode(r);</span>
<span class="fc" id="L492">    assertEquals(data, res.getText());</span>
    // Check error correction by introducing a few minor errors
<span class="fc" id="L494">    Random random = getPseudoRandom();</span>
<span class="fc" id="L495">    matrix.flip(random.nextInt(matrix.getWidth()), random.nextInt(2));</span>
<span class="fc" id="L496">    matrix.flip(random.nextInt(matrix.getWidth()), matrix.getHeight() - 2 + random.nextInt(2));</span>
<span class="fc" id="L497">    matrix.flip(random.nextInt(2), random.nextInt(matrix.getHeight()));</span>
<span class="fc" id="L498">    matrix.flip(matrix.getWidth() - 2 + random.nextInt(2), random.nextInt(matrix.getHeight()));</span>
<span class="fc" id="L499">    r = new AztecDetectorResult(matrix, NO_POINTS, aztec.isCompact(), aztec.getCodeWords(), aztec.getLayers());</span>
<span class="fc" id="L500">    res = new Decoder().decode(r);</span>
<span class="fc" id="L501">    assertEquals(data, res.getText());</span>
<span class="fc" id="L502">  }</span>

  private static void testWriter(String data, 
                                 String charset, 
                                 int eccPercent, 
                                 boolean compact, 
                                 int layers) throws FormatException {
    // 1. Perform an encode-decode round-trip because it can be lossy.
    // 2. Aztec Decoder currently always decodes the data with a LATIN-1 charset:
<span class="fc" id="L511">    String expectedData = new String(data.getBytes(Charset.forName(charset)), StandardCharsets.ISO_8859_1);</span>
<span class="fc" id="L512">    Map&lt;EncodeHintType,Object&gt; hints = new EnumMap&lt;&gt;(EncodeHintType.class);</span>
<span class="fc" id="L513">    hints.put(EncodeHintType.CHARACTER_SET, charset);</span>
<span class="fc" id="L514">    hints.put(EncodeHintType.ERROR_CORRECTION, eccPercent);</span>
<span class="fc" id="L515">    AztecWriter writer = new AztecWriter();</span>
<span class="fc" id="L516">    BitMatrix matrix = writer.encode(data, BarcodeFormat.AZTEC, 0, 0, hints);</span>
<span class="fc" id="L517">    AztecCode aztec = Encoder.encode(data.getBytes(Charset.forName(charset)), eccPercent,</span>
        Encoder.DEFAULT_AZTEC_LAYERS);
<span class="fc" id="L519">    assertEquals(&quot;Unexpected symbol format (compact)&quot;, compact, aztec.isCompact());</span>
<span class="fc" id="L520">    assertEquals(&quot;Unexpected nr. of layers&quot;, layers, aztec.getLayers());</span>
<span class="fc" id="L521">    BitMatrix matrix2 = aztec.getMatrix();</span>
<span class="fc" id="L522">    assertEquals(matrix, matrix2);</span>
<span class="fc" id="L523">    AztecDetectorResult r = </span>
<span class="fc" id="L524">        new AztecDetectorResult(matrix, NO_POINTS, aztec.isCompact(), aztec.getCodeWords(), aztec.getLayers());</span>
<span class="fc" id="L525">    DecoderResult res = new Decoder().decode(r);</span>
<span class="fc" id="L526">    assertEquals(expectedData, res.getText());</span>
    // Check error correction by introducing up to eccPercent/2 errors
<span class="fc" id="L528">    int ecWords = aztec.getCodeWords() * eccPercent / 100 / 2;</span>
<span class="fc" id="L529">    Random random = getPseudoRandom();</span>
<span class="fc bfc" id="L530" title="All 2 branches covered.">    for (int i = 0; i &lt; ecWords; i++) {</span>
      // don't touch the core
<span class="fc bfc" id="L532" title="All 2 branches covered.">      int x = random.nextBoolean() ?</span>
<span class="fc" id="L533">                random.nextInt(aztec.getLayers() * 2)</span>
<span class="fc" id="L534">                : matrix.getWidth() - 1 - random.nextInt(aztec.getLayers() * 2);</span>
<span class="fc bfc" id="L535" title="All 2 branches covered.">      int y = random.nextBoolean() ?</span>
<span class="fc" id="L536">                random.nextInt(aztec.getLayers() * 2)</span>
<span class="fc" id="L537">                : matrix.getHeight() - 1 - random.nextInt(aztec.getLayers() * 2);</span>
<span class="fc" id="L538">      matrix.flip(x, y);</span>
    }
<span class="fc" id="L540">    r = new AztecDetectorResult(matrix, NO_POINTS, aztec.isCompact(), aztec.getCodeWords(), aztec.getLayers());</span>
<span class="fc" id="L541">    res = new Decoder().decode(r);</span>
<span class="fc" id="L542">    assertEquals(expectedData, res.getText());</span>
<span class="fc" id="L543">  }</span>

  private static Random getPseudoRandom() {
<span class="fc" id="L546">    return new Random(0xDEADBEEF);</span>
  }

  private static void testModeMessage(boolean compact, int layers, int words, String expected) {
<span class="fc" id="L550">    BitArray in = Encoder.generateModeMessage(compact, layers, words);</span>
<span class="fc" id="L551">    assertEquals(&quot;generateModeMessage() failed&quot;, stripSpace(expected), stripSpace(in.toString()));</span>
<span class="fc" id="L552">  }</span>

  private static void testStuffBits(int wordSize, String bits, String expected) {
<span class="fc" id="L555">    BitArray in = toBitArray(bits);</span>
<span class="fc" id="L556">    BitArray stuffed = Encoder.stuffBits(in, wordSize);</span>
<span class="fc" id="L557">    assertEquals(&quot;stuffBits() failed for input string: &quot; + bits, </span>
<span class="fc" id="L558">                 stripSpace(expected), stripSpace(stuffed.toString()));</span>
<span class="fc" id="L559">  }</span>

  private static BitArray toBitArray(CharSequence bits) {
<span class="fc" id="L562">    BitArray in = new BitArray();</span>
<span class="fc" id="L563">    char[] str = DOTX.matcher(bits).replaceAll(&quot;&quot;).toCharArray();</span>
<span class="fc bfc" id="L564" title="All 2 branches covered.">    for (char aStr : str) {</span>
<span class="fc bfc" id="L565" title="All 2 branches covered.">      in.appendBit(aStr == 'X');</span>
    }
<span class="fc" id="L567">    return in;</span>
  }

  private static boolean[] toBooleanArray(BitArray bitArray) {
<span class="fc" id="L571">    boolean[] result = new boolean[bitArray.getSize()];</span>
<span class="fc bfc" id="L572" title="All 2 branches covered.">    for (int i = 0; i &lt; result.length; i++) {</span>
<span class="fc" id="L573">      result[i] = bitArray.get(i);</span>
    }
<span class="fc" id="L575">    return result;</span>
  }

  private static void testHighLevelEncodeString(String s, String expectedBits) {
<span class="fc" id="L579">    BitArray bits = new HighLevelEncoder(s.getBytes(StandardCharsets.ISO_8859_1)).encode();</span>
<span class="fc" id="L580">    String receivedBits = stripSpace(bits.toString());</span>
<span class="fc" id="L581">    assertEquals(&quot;highLevelEncode() failed for input string: &quot; + s, stripSpace(expectedBits), receivedBits);</span>
<span class="fc" id="L582">    assertEquals(s, Decoder.highLevelDecode(toBooleanArray(bits)));</span>
<span class="fc" id="L583">  }</span>

  private static void testHighLevelEncodeString(String s, int expectedReceivedBits) {
<span class="fc" id="L586">    BitArray bits = new HighLevelEncoder(s.getBytes(StandardCharsets.ISO_8859_1)).encode();</span>
<span class="fc" id="L587">    int receivedBitCount = stripSpace(bits.toString()).length();</span>
<span class="fc" id="L588">    assertEquals(&quot;highLevelEncode() failed for input string: &quot; + s, </span>
                 expectedReceivedBits, receivedBitCount);
<span class="fc" id="L590">    assertEquals(s, Decoder.highLevelDecode(toBooleanArray(bits)));</span>
<span class="fc" id="L591">  }</span>

  private static String stripSpace(String s) {
<span class="fc" id="L594">    return SPACES.matcher(s).replaceAll(&quot;&quot;);</span>
  }

}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.1.201803210924</span></div></body></html>