<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>DateTimeFormatter.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">Joda-Time</a> &gt; <a href="index.source.html" class="el_package">org.joda.time.format</a> &gt; <span class="el_source">DateTimeFormatter.java</span></div><h1>DateTimeFormatter.java</h1><pre class="source lang-java linenums">/*
 *  Copyright 2001-2014 Stephen Colebourne
 *
 *  Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
 *  you may not use this file except in compliance with the License.
 *  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the License for the specific language governing permissions and
 *  limitations under the License.
 */
package org.joda.time.format;

import java.io.IOException;
import java.io.Writer;
import java.util.Locale;

import org.joda.time.Chronology;
import org.joda.time.DateTime;
import org.joda.time.DateTimeUtils;
import org.joda.time.DateTimeZone;
import org.joda.time.LocalDate;
import org.joda.time.LocalDateTime;
import org.joda.time.LocalTime;
import org.joda.time.MutableDateTime;
import org.joda.time.ReadWritableInstant;
import org.joda.time.ReadableInstant;
import org.joda.time.ReadablePartial;

/**
 * Controls the printing and parsing of a datetime to and from a string.
 * &lt;p&gt;
 * This class is the main API for printing and parsing used by most applications.
 * Instances of this class are created via one of three factory classes:
 * &lt;ul&gt;
 * &lt;li&gt;{@link DateTimeFormat} - formats by pattern and style&lt;/li&gt;
 * &lt;li&gt;{@link ISODateTimeFormat} - ISO8601 formats&lt;/li&gt;
 * &lt;li&gt;{@link DateTimeFormatterBuilder} - complex formats created via method calls&lt;/li&gt;
 * &lt;/ul&gt;
 * &lt;p&gt;
 * An instance of this class holds a reference internally to one printer and
 * one parser. It is possible that one of these may be null, in which case the
 * formatter cannot print/parse. This can be checked via the {@link #isPrinter()}
 * and {@link #isParser()} methods.
 * &lt;p&gt;
 * The underlying printer/parser can be altered to behave exactly as required
 * by using one of the decorator modifiers:
 * &lt;ul&gt;
 * &lt;li&gt;{@link #withLocale(Locale)} - returns a new formatter that uses the specified locale&lt;/li&gt;
 * &lt;li&gt;{@link #withZone(DateTimeZone)} - returns a new formatter that uses the specified time zone&lt;/li&gt;
 * &lt;li&gt;{@link #withChronology(Chronology)} - returns a new formatter that uses the specified chronology&lt;/li&gt;
 * &lt;li&gt;{@link #withOffsetParsed()} - returns a new formatter that returns the parsed time zone offset&lt;/li&gt;
 * &lt;li&gt;{@link #withPivotYear(int)} - returns a new formatter with the specified pivot year&lt;/li&gt;
 * &lt;li&gt;{@link #withDefaultYear(int)} - returns a new formatter with the specified default year&lt;/li&gt;
 * &lt;/ul&gt;
 * Each of these returns a new formatter (instances of this class are immutable).
 * &lt;p&gt;
 * The main methods of the class are the &lt;code&gt;printXxx&lt;/code&gt; and
 * &lt;code&gt;parseXxx&lt;/code&gt; methods. These are used as follows:
 * &lt;pre&gt;
 * // print using the defaults (default locale, chronology/zone of the datetime)
 * String dateStr = formatter.print(dt);
 * // print using the French locale
 * String dateStr = formatter.withLocale(Locale.FRENCH).print(dt);
 * // print using the UTC zone
 * String dateStr = formatter.withZone(DateTimeZone.UTC).print(dt);
 * 
 * // parse using the Paris zone
 * DateTime date = formatter.withZone(DateTimeZone.forID(&quot;Europe/Paris&quot;)).parseDateTime(str);
 * &lt;/pre&gt;
 * &lt;p&gt;
 * Parsing builds up the resultant instant by 'setting' the value of each parsed field
 * from largest to smallest onto an initial instant, typically 1970-01-01T00:00Z.
 * This design means that day-of-month is set before day-of-week.
 * As such, if both the day-of-month and day-of-week are parsed, and the day-of-week
 * is incorrect, then the day-of-week overrides the day-of-month.
 * 
 * This has a side effect if the input is not consistent.
 * 
 * 
 * @author Brian S O'Neill
 * @author Stephen Colebourne
 * @author Fredrik Borgh
 * @since 1.0
 */
public class DateTimeFormatter {

    /** The internal printer used to output the datetime. */
    private final InternalPrinter iPrinter;
    /** The internal parser used to output the datetime. */
    private final InternalParser iParser;
    /** The locale to use for printing and parsing. */
    private final Locale iLocale;
    /** Whether the offset is parsed. */
    private final boolean iOffsetParsed;
    /** The chronology to use as an override. */
    private final Chronology iChrono;
    /** The zone to use as an override. */
    private final DateTimeZone iZone;
    /** The pivot year to use for two-digit year parsing. */
    private final Integer iPivotYear;
    /** The default year for parsing month/day without year. */
    private final int iDefaultYear;

    /**
     * Creates a new formatter, however you will normally use the factory
     * or the builder.
     * 
     * @param printer  the internal printer, null if cannot print
     * @param parser  the internal parser, null if cannot parse
     */
    public DateTimeFormatter(
            DateTimePrinter printer, DateTimeParser parser) {
<span class="fc" id="L118">        this(DateTimePrinterInternalPrinter.of(printer), DateTimeParserInternalParser.of(parser));</span>
<span class="fc" id="L119">    }</span>

    /**
     * Creates a new formatter, however you will normally use the factory
     * or the builder.
     * 
     * @param printer  the internal printer, null if cannot print
     * @param parser  the internal parser, null if cannot parse
     */
    DateTimeFormatter(
            InternalPrinter printer, InternalParser parser) {
<span class="fc" id="L130">        super();</span>
<span class="fc" id="L131">        iPrinter = printer;</span>
<span class="fc" id="L132">        iParser = parser;</span>
<span class="fc" id="L133">        iLocale = null;</span>
<span class="fc" id="L134">        iOffsetParsed = false;</span>
<span class="fc" id="L135">        iChrono = null;</span>
<span class="fc" id="L136">        iZone = null;</span>
<span class="fc" id="L137">        iPivotYear = null;</span>
<span class="fc" id="L138">        iDefaultYear = 2000;</span>
<span class="fc" id="L139">    }</span>

    /**
     * Constructor.
     */
    private DateTimeFormatter(
            InternalPrinter printer, InternalParser parser,
            Locale locale, boolean offsetParsed,
            Chronology chrono, DateTimeZone zone,
            Integer pivotYear, int defaultYear) {
<span class="fc" id="L149">        super();</span>
<span class="fc" id="L150">        iPrinter = printer;</span>
<span class="fc" id="L151">        iParser = parser;</span>
<span class="fc" id="L152">        iLocale = locale;</span>
<span class="fc" id="L153">        iOffsetParsed = offsetParsed;</span>
<span class="fc" id="L154">        iChrono = chrono;</span>
<span class="fc" id="L155">        iZone = zone;</span>
<span class="fc" id="L156">        iPivotYear = pivotYear;</span>
<span class="fc" id="L157">        iDefaultYear = defaultYear;</span>
<span class="fc" id="L158">    }</span>

    //-----------------------------------------------------------------------
    /**
     * Is this formatter capable of printing.
     * 
     * @return true if this is a printer
     */
    public boolean isPrinter() {
<span class="fc bfc" id="L167" title="All 2 branches covered.">        return (iPrinter != null);</span>
    }

    /**
     * Gets the internal printer object that performs the real printing work.
     * 
     * @return the internal printer; is null if printing not supported
     */
    public DateTimePrinter getPrinter() {
<span class="fc" id="L176">        return InternalPrinterDateTimePrinter.of(iPrinter);</span>
    }

    /**
     * Gets the internal printer object that performs the real printing work.
     * 
     * @return the internal printer; is null if printing not supported
     */
    InternalPrinter getPrinter0() {
<span class="fc" id="L185">        return iPrinter;</span>
    }

    /**
     * Is this formatter capable of parsing.
     * 
     * @return true if this is a parser
     */
    public boolean isParser() {
<span class="fc bfc" id="L194" title="All 2 branches covered.">        return (iParser != null);</span>
    }

    /**
     * Gets the internal parser object that performs the real parsing work.
     * 
     * @return the internal parser; is null if parsing not supported
     */
    public DateTimeParser getParser() {
<span class="fc" id="L203">        return InternalParserDateTimeParser.of(iParser);</span>
    }

    InternalParser getParser0() {
<span class="fc" id="L207">        return iParser;</span>
    }

    //-----------------------------------------------------------------------
    /**
     * Returns a new formatter with a different locale that will be used
     * for printing and parsing.
     * &lt;p&gt;
     * A DateTimeFormatter is immutable, so a new instance is returned,
     * and the original is unaltered and still usable.
     * 
     * @param locale the locale to use; if null, formatter uses default locale
     * at invocation time
     * @return the new formatter
     */
    public DateTimeFormatter withLocale(Locale locale) {
<span class="pc bpc" id="L223" title="2 of 6 branches missed.">        if (locale == getLocale() || (locale != null &amp;&amp; locale.equals(getLocale()))) {</span>
<span class="fc" id="L224">            return this;</span>
        }
<span class="fc" id="L226">        return new DateTimeFormatter(iPrinter, iParser, locale,</span>
                iOffsetParsed, iChrono, iZone, iPivotYear, iDefaultYear);
    }

    /**
     * Gets the locale that will be used for printing and parsing.
     * 
     * @return the locale to use; if null, formatter uses default locale at
     * invocation time
     */
    public Locale getLocale() {
<span class="fc" id="L237">        return iLocale;</span>
    }

    //-----------------------------------------------------------------------
    /**
     * Returns a new formatter that will create a datetime with a time zone
     * equal to that of the offset of the parsed string.
     * &lt;p&gt;
     * After calling this method, a string '2004-06-09T10:20:30-08:00' will
     * create a datetime with a zone of -08:00 (a fixed zone, with no daylight
     * savings rules). If the parsed string represents a local time (no zone
     * offset) the parsed datetime will be in the default zone.
     * &lt;p&gt;
     * Calling this method sets the override zone to null.
     * Calling the override zone method sets this flag off.
     * 
     * @return the new formatter
     */
    public DateTimeFormatter withOffsetParsed() {
<span class="fc bfc" id="L256" title="All 2 branches covered.">        if (iOffsetParsed == true) {</span>
<span class="fc" id="L257">            return this;</span>
        }
<span class="fc" id="L259">        return new DateTimeFormatter(iPrinter, iParser, iLocale,</span>
                true, iChrono, null, iPivotYear, iDefaultYear);
    }

    /**
     * Checks whether the offset from the string is used as the zone of
     * the parsed datetime.
     * 
     * @return true if the offset from the string is used as the zone
     */
    public boolean isOffsetParsed() {
<span class="fc" id="L270">        return iOffsetParsed;</span>
    }

    //-----------------------------------------------------------------------
    /**
     * Returns a new formatter that will use the specified chronology in
     * preference to that of the printed object, or ISO on a parse.
     * &lt;p&gt;
     * When printing, this chronology will be used in preference to the chronology
     * from the datetime that would otherwise be used.
     * &lt;p&gt;
     * When parsing, this chronology will be set on the parsed datetime.
     * &lt;p&gt;
     * A null chronology means no-override.
     * If both an override chronology and an override zone are set, the
     * override zone will take precedence over the zone in the chronology.
     * 
     * @param chrono  the chronology to use as an override
     * @return the new formatter
     */
    public DateTimeFormatter withChronology(Chronology chrono) {
<span class="fc bfc" id="L291" title="All 2 branches covered.">        if (iChrono == chrono) {</span>
<span class="fc" id="L292">            return this;</span>
        }
<span class="fc" id="L294">        return new DateTimeFormatter(iPrinter, iParser, iLocale,</span>
                iOffsetParsed, chrono, iZone, iPivotYear, iDefaultYear);
    }

    /**
     * Gets the chronology to use as an override.
     * 
     * @return the chronology to use as an override
     */
    public Chronology getChronology() {
<span class="fc" id="L304">        return iChrono;</span>
    }

    /**
     * Gets the chronology to use as an override.
     * 
     * @return the chronology to use as an override
     * @deprecated Use the method with the correct spelling
     */
    @Deprecated
    public Chronology getChronolgy() {
<span class="nc" id="L315">        return iChrono;</span>
    }

    //-----------------------------------------------------------------------
    /**
     * Returns a new formatter that will use the UTC zone in preference
     * to the zone of the printed object, or default zone on a parse.
     * &lt;p&gt;
     * When printing, UTC will be used in preference to the zone
     * from the datetime that would otherwise be used.
     * &lt;p&gt;
     * When parsing, UTC will be set on the parsed datetime.
     * &lt;p&gt;
     * If both an override chronology and an override zone are set, the
     * override zone will take precedence over the zone in the chronology.
     * 
     * @return the new formatter, never null
     * @since 2.0
     */
    public DateTimeFormatter withZoneUTC() {
<span class="fc" id="L335">        return withZone(DateTimeZone.UTC);</span>
    }

    /**
     * Returns a new formatter that will use the specified zone in preference
     * to the zone of the printed object, or default zone on a parse.
     * &lt;p&gt;
     * When printing, this zone will be used in preference to the zone
     * from the datetime that would otherwise be used.
     * &lt;p&gt;
     * When parsing, this zone will be set on the parsed datetime.
     * &lt;p&gt;
     * A null zone means of no-override.
     * If both an override chronology and an override zone are set, the
     * override zone will take precedence over the zone in the chronology.
     * 
     * @param zone  the zone to use as an override
     * @return the new formatter
     */
    public DateTimeFormatter withZone(DateTimeZone zone) {
<span class="fc bfc" id="L355" title="All 2 branches covered.">        if (iZone == zone) {</span>
<span class="fc" id="L356">            return this;</span>
        }
<span class="fc" id="L358">        return new DateTimeFormatter(iPrinter, iParser, iLocale,</span>
                false, iChrono, zone, iPivotYear, iDefaultYear);
    }

    /**
     * Gets the zone to use as an override.
     * 
     * @return the zone to use as an override
     */
    public DateTimeZone getZone() {
<span class="fc" id="L368">        return iZone;</span>
    }

    //-----------------------------------------------------------------------
    /**
     * Returns a new formatter that will use the specified pivot year for two
     * digit year parsing in preference to that stored in the parser.
     * &lt;p&gt;
     * This setting is useful for changing the pivot year of formats built
     * using a pattern - {@link DateTimeFormat#forPattern(String)}.
     * &lt;p&gt;
     * When parsing, this pivot year is used. Null means no-override.
     * There is no effect when printing.
     * &lt;p&gt;
     * The pivot year enables a two digit year to be converted to a four
     * digit year. The pivot represents the year in the middle of the
     * supported range of years. Thus the full range of years that will
     * be built is &lt;code&gt;(pivot - 50) .. (pivot + 49)&lt;/code&gt;.
     *
     * &lt;pre&gt;
     * pivot   supported range   00 is   20 is   40 is   60 is   80 is
     * ---------------------------------------------------------------
     * 1950      1900..1999      1900    1920    1940    1960    1980
     * 1975      1925..2024      2000    2020    1940    1960    1980
     * 2000      1950..2049      2000    2020    2040    1960    1980
     * 2025      1975..2074      2000    2020    2040    2060    1980
     * 2050      2000..2099      2000    2020    2040    2060    2080
     * &lt;/pre&gt;
     *
     * @param pivotYear  the pivot year to use as an override when parsing
     * @return the new formatter
     * @since 1.1
     */
    public DateTimeFormatter withPivotYear(Integer pivotYear) {
<span class="pc bpc" id="L402" title="1 of 6 branches missed.">        if (iPivotYear == pivotYear || (iPivotYear != null &amp;&amp; iPivotYear.equals(pivotYear))) {</span>
<span class="fc" id="L403">            return this;</span>
        }
<span class="fc" id="L405">        return new DateTimeFormatter(iPrinter, iParser, iLocale,</span>
                iOffsetParsed, iChrono, iZone, pivotYear, iDefaultYear);
    }

    /**
     * Returns a new formatter that will use the specified pivot year for two
     * digit year parsing in preference to that stored in the parser.
     * &lt;p&gt;
     * This setting is useful for changing the pivot year of formats built
     * using a pattern - {@link DateTimeFormat#forPattern(String)}.
     * &lt;p&gt;
     * When parsing, this pivot year is used.
     * There is no effect when printing.
     * &lt;p&gt;
     * The pivot year enables a two digit year to be converted to a four
     * digit year. The pivot represents the year in the middle of the
     * supported range of years. Thus the full range of years that will
     * be built is &lt;code&gt;(pivot - 50) .. (pivot + 49)&lt;/code&gt;.
     *
     * &lt;pre&gt;
     * pivot   supported range   00 is   20 is   40 is   60 is   80 is
     * ---------------------------------------------------------------
     * 1950      1900..1999      1900    1920    1940    1960    1980
     * 1975      1925..2024      2000    2020    1940    1960    1980
     * 2000      1950..2049      2000    2020    2040    1960    1980
     * 2025      1975..2074      2000    2020    2040    2060    1980
     * 2050      2000..2099      2000    2020    2040    2060    2080
     * &lt;/pre&gt;
     *
     * @param pivotYear  the pivot year to use as an override when parsing
     * @return the new formatter
     * @since 1.1
     */
    public DateTimeFormatter withPivotYear(int pivotYear) {
<span class="fc" id="L439">        return withPivotYear(Integer.valueOf(pivotYear));</span>
    }

    /**
     * Gets the pivot year to use as an override.
     *
     * @return the pivot year to use as an override
     * @since 1.1
     */
    public Integer getPivotYear() {
<span class="fc" id="L449">      return iPivotYear;</span>
    }

    //-----------------------------------------------------------------------
    /**
     * Returns a new formatter that will use the specified default year.
     * &lt;p&gt;
     * The default year is used when parsing in the case where there is a
     * month or a day but not a year. Specifically, it is used if there is
     * a field parsed with a duration between the length of a month and the
     * length of a day inclusive.
     * &lt;p&gt;
     * This value is typically used to move the year from 1970 to a leap year
     * to enable February 29th to be parsed.
     * Unless customised, the year 2000 is used.
     * &lt;p&gt;
     * This setting has no effect when printing.
     *
     * @param defaultYear  the default year to use
     * @return the new formatter, not null
     * @since 2.0
     */
    public DateTimeFormatter withDefaultYear(int defaultYear) {
<span class="fc" id="L472">        return new DateTimeFormatter(iPrinter, iParser, iLocale,</span>
                iOffsetParsed, iChrono, iZone, iPivotYear, defaultYear);
    }

    /**
     * Gets the default year for parsing months and days.
     *
     * @return the default year for parsing months and days
     * @since 2.0
     */
    public int getDefaultYear() {
<span class="nc" id="L483">      return iDefaultYear;</span>
    }

    //-----------------------------------------------------------------------
    /**
     * Prints a ReadableInstant, using the chronology supplied by the instant.
     *
     * @param buf  the destination to format to, not null
     * @param instant  instant to format, null means now
     */
    public void printTo(StringBuffer buf, ReadableInstant instant) {
        try {
<span class="fc" id="L495">            printTo((Appendable) buf, instant);</span>
<span class="nc" id="L496">        } catch (IOException ex) {</span>
            // StringBuffer does not throw IOException
<span class="fc" id="L498">        }</span>
<span class="fc" id="L499">    }</span>

    /**
     * Prints a ReadableInstant, using the chronology supplied by the instant.
     *
     * @param buf  the destination to format to, not null
     * @param instant  instant to format, null means now
     */
    public void printTo(StringBuilder buf, ReadableInstant instant) {
        try {
<span class="fc" id="L509">            printTo((Appendable) buf, instant);</span>
<span class="nc" id="L510">        } catch (IOException ex) {</span>
            // StringBuilder does not throw IOException
<span class="fc" id="L512">        }</span>
<span class="fc" id="L513">    }</span>

    /**
     * Prints a ReadableInstant, using the chronology supplied by the instant.
     *
     * @param out  the destination to format to, not null
     * @param instant  instant to format, null means now
     */
    public void printTo(Writer out, ReadableInstant instant) throws IOException {
<span class="fc" id="L522">        printTo((Appendable) out, instant);</span>
<span class="fc" id="L523">    }</span>

    /**
     * Prints a ReadableInstant, using the chronology supplied by the instant.
     *
     * @param appendable  the destination to format to, not null
     * @param instant  instant to format, null means now
     * @since 2.0
     */
    public void printTo(Appendable appendable, ReadableInstant instant) throws IOException {
<span class="fc" id="L533">        long millis = DateTimeUtils.getInstantMillis(instant);</span>
<span class="fc" id="L534">        Chronology chrono = DateTimeUtils.getInstantChronology(instant);</span>
<span class="fc" id="L535">        printTo(appendable, millis, chrono);</span>
<span class="fc" id="L536">    }</span>

    //-----------------------------------------------------------------------
    /**
     * Prints an instant from milliseconds since 1970-01-01T00:00:00Z,
     * using ISO chronology in the default DateTimeZone.
     *
     * @param buf  the destination to format to, not null
     * @param instant  millis since 1970-01-01T00:00:00Z
     */
    public void printTo(StringBuffer buf, long instant) {
        try {
<span class="fc" id="L548">            printTo((Appendable) buf, instant);</span>
<span class="nc" id="L549">        } catch (IOException ex) {</span>
            // StringBuffer does not throw IOException
<span class="fc" id="L551">        }</span>
<span class="fc" id="L552">    }</span>

    /**
     * Prints an instant from milliseconds since 1970-01-01T00:00:00Z,
     * using ISO chronology in the default DateTimeZone.
     *
     * @param buf  the destination to format to, not null
     * @param instant  millis since 1970-01-01T00:00:00Z
     */
    public void printTo(StringBuilder buf, long instant) {
        try {
<span class="fc" id="L563">            printTo((Appendable) buf, instant);</span>
<span class="nc" id="L564">        } catch (IOException ex) {</span>
            // StringBuilder does not throw IOException
<span class="fc" id="L566">        }</span>
<span class="fc" id="L567">    }</span>

    /**
     * Prints an instant from milliseconds since 1970-01-01T00:00:00Z,
     * using ISO chronology in the default DateTimeZone.
     *
     * @param out  the destination to format to, not null
     * @param instant  millis since 1970-01-01T00:00:00Z
     */
    public void printTo(Writer out, long instant) throws IOException {
<span class="fc" id="L577">        printTo((Appendable) out, instant);</span>
<span class="fc" id="L578">    }</span>

    /**
     * Prints an instant from milliseconds since 1970-01-01T00:00:00Z,
     * using ISO chronology in the default DateTimeZone.
     *
     * @param appendable  the destination to format to, not null
     * @param instant  millis since 1970-01-01T00:00:00Z
     * @since 2.0
     */
    public void printTo(Appendable appendable, long instant) throws IOException {
<span class="fc" id="L589">        printTo(appendable, instant, null);</span>
<span class="fc" id="L590">    }</span>

    //-----------------------------------------------------------------------
    /**
     * Prints a ReadablePartial.
     * &lt;p&gt;
     * Neither the override chronology nor the override zone are used
     * by this method.
     *
     * @param buf  the destination to format to, not null
     * @param partial  partial to format
     */
    public void printTo(StringBuffer buf, ReadablePartial partial) {
        try {
<span class="fc" id="L604">            printTo((Appendable) buf, partial);</span>
<span class="nc" id="L605">        } catch (IOException ex) {</span>
            // StringBuffer does not throw IOException
<span class="fc" id="L607">        }</span>
<span class="fc" id="L608">    }</span>

    /**
     * Prints a ReadablePartial.
     * &lt;p&gt;
     * Neither the override chronology nor the override zone are used
     * by this method.
     *
     * @param buf  the destination to format to, not null
     * @param partial  partial to format
     */
    public void printTo(StringBuilder buf, ReadablePartial partial) {
        try {
<span class="fc" id="L621">            printTo((Appendable) buf, partial);</span>
<span class="nc" id="L622">        } catch (IOException ex) {</span>
            // StringBuilder does not throw IOException
<span class="fc" id="L624">        }</span>
<span class="fc" id="L625">    }</span>

    /**
     * Prints a ReadablePartial.
     * &lt;p&gt;
     * Neither the override chronology nor the override zone are used
     * by this method.
     *
     * @param out  the destination to format to, not null
     * @param partial  partial to format
     */
    public void printTo(Writer out, ReadablePartial partial) throws IOException {
<span class="fc" id="L637">        printTo((Appendable) out, partial);</span>
<span class="fc" id="L638">    }</span>

    /**
     * Prints a ReadablePartial.
     * &lt;p&gt;
     * Neither the override chronology nor the override zone are used
     * by this method.
     *
     * @param appendable  the destination to format to, not null
     * @param partial  partial to format
     * @since 2.0
     */
    public void printTo(Appendable appendable, ReadablePartial partial) throws IOException {
<span class="fc" id="L651">        InternalPrinter printer = requirePrinter();</span>
<span class="fc bfc" id="L652" title="All 2 branches covered.">        if (partial == null) {</span>
<span class="fc" id="L653">            throw new IllegalArgumentException(&quot;The partial must not be null&quot;);</span>
        }
<span class="fc" id="L655">        printer.printTo(appendable, partial, iLocale);</span>
<span class="fc" id="L656">    }</span>

    //-----------------------------------------------------------------------
    /**
     * Prints a ReadableInstant to a String.
     * &lt;p&gt;
     * This method will use the override zone and the override chronology if
     * they are set. Otherwise it will use the chronology and zone of the instant.
     *
     * @param instant  instant to format, null means now
     * @return the printed result
     */
    public String print(ReadableInstant instant) {
<span class="fc" id="L669">        StringBuilder buf = new StringBuilder(requirePrinter().estimatePrintedLength());</span>
        try {
<span class="fc" id="L671">            printTo((Appendable) buf, instant);</span>
<span class="nc" id="L672">        } catch (IOException ex) {</span>
            // StringBuilder does not throw IOException
<span class="fc" id="L674">        }</span>
<span class="fc" id="L675">        return buf.toString();</span>
    }

    /**
     * Prints a millisecond instant to a String.
     * &lt;p&gt;
     * This method will use the override zone and the override chronology if
     * they are set. Otherwise it will use the ISO chronology and default zone.
     *
     * @param instant  millis since 1970-01-01T00:00:00Z
     * @return the printed result
     */
    public String print(long instant) {
<span class="fc" id="L688">        StringBuilder buf = new StringBuilder(requirePrinter().estimatePrintedLength());</span>
        try {
<span class="fc" id="L690">            printTo((Appendable) buf, instant);</span>
<span class="nc" id="L691">        } catch (IOException ex) {</span>
            // StringBuilder does not throw IOException
<span class="fc" id="L693">        }</span>
<span class="fc" id="L694">        return buf.toString();</span>
    }

    /**
     * Prints a ReadablePartial to a new String.
     * &lt;p&gt;
     * Neither the override chronology nor the override zone are used
     * by this method.
     *
     * @param partial  partial to format
     * @return the printed result
     */
    public String print(ReadablePartial partial) {
<span class="fc" id="L707">        StringBuilder buf = new StringBuilder(requirePrinter().estimatePrintedLength());</span>
        try {
<span class="fc" id="L709">            printTo((Appendable) buf, partial);</span>
<span class="nc" id="L710">        } catch (IOException ex) {</span>
            // StringBuilder does not throw IOException
<span class="fc" id="L712">        }</span>
<span class="fc" id="L713">        return buf.toString();</span>
    }

    private void printTo(Appendable appendable, long instant, Chronology chrono) throws IOException {
<span class="fc" id="L717">        InternalPrinter printer = requirePrinter();</span>
<span class="fc" id="L718">        chrono = selectChronology(chrono);</span>
        // Shift instant into local time (UTC) to avoid excessive offset
        // calculations when printing multiple fields in a composite printer.
<span class="fc" id="L721">        DateTimeZone zone = chrono.getZone();</span>
<span class="fc" id="L722">        int offset = zone.getOffset(instant);</span>
<span class="fc" id="L723">        long adjustedInstant = instant + offset;</span>
<span class="fc bfc" id="L724" title="All 4 branches covered.">        if ((instant ^ adjustedInstant) &lt; 0 &amp;&amp; (instant ^ offset) &gt;= 0) {</span>
            // Time zone offset overflow, so revert to UTC.
<span class="fc" id="L726">            zone = DateTimeZone.UTC;</span>
<span class="fc" id="L727">            offset = 0;</span>
<span class="fc" id="L728">            adjustedInstant = instant;</span>
        }
<span class="fc" id="L730">        printer.printTo(appendable, adjustedInstant, chrono.withUTC(), offset, zone, iLocale);</span>
<span class="fc" id="L731">    }</span>

    /**
     * Checks whether printing is supported.
     * 
     * @throws UnsupportedOperationException if printing is not supported
     */
    private InternalPrinter requirePrinter() {
<span class="fc" id="L739">        InternalPrinter printer = iPrinter;</span>
<span class="fc bfc" id="L740" title="All 2 branches covered.">        if (printer == null) {</span>
<span class="fc" id="L741">            throw new UnsupportedOperationException(&quot;Printing not supported&quot;);</span>
        }
<span class="fc" id="L743">        return printer;</span>
    }

    //-----------------------------------------------------------------------
    /**
     * Parses a datetime from the given text, at the given position, saving the
     * result into the fields of the given ReadWritableInstant. If the parse
     * succeeds, the return value is the new text position. Note that the parse
     * may succeed without fully reading the text and in this case those fields
     * that were read will be set.
     * &lt;p&gt;
     * Only those fields present in the string will be changed in the specified
     * instant. All other fields will remain unaltered. Thus if the string only
     * contains a year and a month, then the day and time will be retained from
     * the input instant. If this is not the behaviour you want, then reset the
     * fields before calling this method, or use {@link #parseDateTime(String)}
     * or {@link #parseMutableDateTime(String)}.
     * &lt;p&gt;
     * If it fails, the return value is negative, but the instant may still be
     * modified. To determine the position where the parse failed, apply the
     * one's complement operator (~) on the return value.
     * &lt;p&gt;
     * This parse method ignores the {@link #getDefaultYear() default year} and
     * parses using the year from the supplied instant based on the chronology
     * and time-zone of the supplied instant.
     * &lt;p&gt;
     * The parse will use the chronology of the instant.
     *
     * @param instant  an instant that will be modified, not null
     * @param text  the text to parse
     * @param position  position to start parsing from
     * @return new position, negative value means parse failed -
     *  apply complement operator (~) to get position of failure
     * @throws UnsupportedOperationException if parsing is not supported
     * @throws IllegalArgumentException if the instant is null
     * @throws IllegalArgumentException if any field is out of range
     */
    public int parseInto(ReadWritableInstant instant, String text, int position) {
<span class="fc" id="L781">        InternalParser parser = requireParser();</span>
<span class="fc bfc" id="L782" title="All 2 branches covered.">        if (instant == null) {</span>
<span class="fc" id="L783">            throw new IllegalArgumentException(&quot;Instant must not be null&quot;);</span>
        }
        
<span class="fc" id="L786">        long instantMillis = instant.getMillis();</span>
<span class="fc" id="L787">        Chronology chrono = instant.getChronology();</span>
<span class="fc" id="L788">        int defaultYear = DateTimeUtils.getChronology(chrono).year().get(instantMillis);</span>
<span class="fc" id="L789">        long instantLocal = instantMillis + chrono.getZone().getOffset(instantMillis);</span>
<span class="fc" id="L790">        chrono = selectChronology(chrono);</span>
        
<span class="fc" id="L792">        DateTimeParserBucket bucket = new DateTimeParserBucket(</span>
            instantLocal, chrono, iLocale, iPivotYear, defaultYear);
<span class="fc" id="L794">        int newPos = parser.parseInto(bucket, text, position);</span>
<span class="fc" id="L795">        instant.setMillis(bucket.computeMillis(false, text));</span>
<span class="pc bpc" id="L796" title="1 of 4 branches missed.">        if (iOffsetParsed &amp;&amp; bucket.getOffsetInteger() != null) {</span>
<span class="fc" id="L797">            int parsedOffset = bucket.getOffsetInteger();</span>
<span class="fc" id="L798">            DateTimeZone parsedZone = DateTimeZone.forOffsetMillis(parsedOffset);</span>
<span class="fc" id="L799">            chrono = chrono.withZone(parsedZone);</span>
<span class="pc bpc" id="L800" title="1 of 2 branches missed.">        } else if (bucket.getZone() != null) {</span>
<span class="fc" id="L801">            chrono = chrono.withZone(bucket.getZone());</span>
        }
<span class="fc" id="L803">        instant.setChronology(chrono);</span>
<span class="fc bfc" id="L804" title="All 2 branches covered.">        if (iZone != null) {</span>
<span class="fc" id="L805">            instant.setZone(iZone);</span>
        }
<span class="fc" id="L807">        return newPos;</span>
    }

    /**
     * Parses a datetime from the given text, returning the number of
     * milliseconds since the epoch, 1970-01-01T00:00:00Z.
     * &lt;p&gt;
     * The parse will use the ISO chronology, and the default time zone.
     * If the text contains a time zone string then that will be taken into account.
     *
     * @param text  the text to parse, not null
     * @return parsed value expressed in milliseconds since the epoch
     * @throws UnsupportedOperationException if parsing is not supported
     * @throws IllegalArgumentException if the text to parse is invalid
     */
    public long parseMillis(String text) {
<span class="fc" id="L823">        InternalParser parser = requireParser();</span>
<span class="fc" id="L824">        Chronology chrono = selectChronology(iChrono);</span>
<span class="fc" id="L825">        DateTimeParserBucket bucket = new DateTimeParserBucket(0, chrono, iLocale, iPivotYear, iDefaultYear);</span>
<span class="fc" id="L826">        return bucket.doParseMillis(parser, text);</span>
    }

    /**
     * Parses only the local date from the given text, returning a new LocalDate.
     * &lt;p&gt;
     * This will parse the text fully according to the formatter, using the UTC zone.
     * Once parsed, only the local date will be used.
     * This means that any parsed time, time-zone or offset field is completely ignored.
     * It also means that the zone and offset-parsed settings are ignored.
     *
     * @param text  the text to parse, not null
     * @return the parsed date, never null
     * @throws UnsupportedOperationException if parsing is not supported
     * @throws IllegalArgumentException if the text to parse is invalid
     * @since 2.0
     */
    public LocalDate parseLocalDate(String text) {
<span class="fc" id="L844">        return parseLocalDateTime(text).toLocalDate();</span>
    }

    /**
     * Parses only the local time from the given text, returning a new LocalTime.
     * &lt;p&gt;
     * This will parse the text fully according to the formatter, using the UTC zone.
     * Once parsed, only the local time will be used.
     * This means that any parsed date, time-zone or offset field is completely ignored.
     * It also means that the zone and offset-parsed settings are ignored.
     *
     * @param text  the text to parse, not null
     * @return the parsed time, never null
     * @throws UnsupportedOperationException if parsing is not supported
     * @throws IllegalArgumentException if the text to parse is invalid
     * @since 2.0
     */
    public LocalTime parseLocalTime(String text) {
<span class="fc" id="L862">        return parseLocalDateTime(text).toLocalTime();</span>
    }

    /**
     * Parses only the local date-time from the given text, returning a new LocalDateTime.
     * &lt;p&gt;
     * This will parse the text fully according to the formatter, using the UTC zone.
     * Once parsed, only the local date-time will be used.
     * This means that any parsed time-zone or offset field is completely ignored.
     * It also means that the zone and offset-parsed settings are ignored.
     *
     * @param text  the text to parse, not null
     * @return the parsed date-time, never null
     * @throws UnsupportedOperationException if parsing is not supported
     * @throws IllegalArgumentException if the text to parse is invalid
     * @since 2.0
     */
    public LocalDateTime parseLocalDateTime(String text) {
<span class="fc" id="L880">        InternalParser parser = requireParser();</span>
        
<span class="fc" id="L882">        Chronology chrono = selectChronology(null).withUTC();  // always use UTC, avoiding DST gaps</span>
<span class="fc" id="L883">        DateTimeParserBucket bucket = new DateTimeParserBucket(0, chrono, iLocale, iPivotYear, iDefaultYear);</span>
<span class="fc" id="L884">        int newPos = parser.parseInto(bucket, text, 0);</span>
<span class="pc bpc" id="L885" title="1 of 2 branches missed.">        if (newPos &gt;= 0) {</span>
<span class="pc bpc" id="L886" title="1 of 2 branches missed.">            if (newPos &gt;= text.length()) {</span>
<span class="fc" id="L887">                long millis = bucket.computeMillis(true, text);</span>
<span class="fc bfc" id="L888" title="All 2 branches covered.">                if (bucket.getOffsetInteger() != null) {  // treat withOffsetParsed() as being true</span>
<span class="fc" id="L889">                    int parsedOffset = bucket.getOffsetInteger();</span>
<span class="fc" id="L890">                    DateTimeZone parsedZone = DateTimeZone.forOffsetMillis(parsedOffset);</span>
<span class="fc" id="L891">                    chrono = chrono.withZone(parsedZone);</span>
<span class="pc bpc" id="L892" title="1 of 2 branches missed.">                } else if (bucket.getZone() != null) {</span>
<span class="fc" id="L893">                    chrono = chrono.withZone(bucket.getZone());</span>
                }
<span class="fc" id="L895">                return new LocalDateTime(millis, chrono);</span>
            }
        } else {
<span class="nc" id="L898">            newPos = ~newPos;</span>
        }
<span class="nc" id="L900">        throw new IllegalArgumentException(FormatUtils.createErrorMessage(text, newPos));</span>
    }

    /**
     * Parses a date-time from the given text, returning a new DateTime.
     * &lt;p&gt;
     * The parse will use the zone and chronology specified on this formatter.
     * &lt;p&gt;
     * If the text contains a time zone string then that will be taken into
     * account in adjusting the time of day as follows.
     * If the {@link #withOffsetParsed()} has been called, then the resulting
     * DateTime will have a fixed offset based on the parsed time zone.
     * Otherwise the resulting DateTime will have the zone of this formatter,
     * but the parsed zone may have caused the time to be adjusted.
     *
     * @param text  the text to parse, not null
     * @return the parsed date-time, never null
     * @throws UnsupportedOperationException if parsing is not supported
     * @throws IllegalArgumentException if the text to parse is invalid
     */
    public DateTime parseDateTime(String text) {
<span class="fc" id="L921">        InternalParser parser = requireParser();</span>
        
<span class="fc" id="L923">        Chronology chrono = selectChronology(null);</span>
<span class="fc" id="L924">        DateTimeParserBucket bucket = new DateTimeParserBucket(0, chrono, iLocale, iPivotYear, iDefaultYear);</span>
<span class="fc" id="L925">        int newPos = parser.parseInto(bucket, text, 0);</span>
<span class="fc bfc" id="L926" title="All 2 branches covered.">        if (newPos &gt;= 0) {</span>
<span class="fc bfc" id="L927" title="All 2 branches covered.">            if (newPos &gt;= text.length()) {</span>
<span class="fc" id="L928">                long millis = bucket.computeMillis(true, text);</span>
<span class="fc bfc" id="L929" title="All 4 branches covered.">                if (iOffsetParsed &amp;&amp; bucket.getOffsetInteger() != null) {</span>
<span class="fc" id="L930">                    int parsedOffset = bucket.getOffsetInteger();</span>
<span class="fc" id="L931">                    DateTimeZone parsedZone = DateTimeZone.forOffsetMillis(parsedOffset);</span>
<span class="fc" id="L932">                    chrono = chrono.withZone(parsedZone);</span>
<span class="pc bpc" id="L933" title="1 of 2 branches missed.">                } else if (bucket.getZone() != null) {</span>
<span class="fc" id="L934">                    chrono = chrono.withZone(bucket.getZone());</span>
                }
<span class="fc" id="L936">                DateTime dt = new DateTime(millis, chrono);</span>
<span class="fc bfc" id="L937" title="All 2 branches covered.">                if (iZone != null) {</span>
<span class="fc" id="L938">                    dt = dt.withZone(iZone);</span>
                }
<span class="fc" id="L940">                return dt;</span>
            }
        } else {
<span class="fc" id="L943">            newPos = ~newPos;</span>
        }
<span class="fc" id="L945">        throw new IllegalArgumentException(FormatUtils.createErrorMessage(text, newPos));</span>
    }

    /**
     * Parses a date-time from the given text, returning a new MutableDateTime.
     * &lt;p&gt;
     * The parse will use the zone and chronology specified on this formatter.
     * &lt;p&gt;
     * If the text contains a time zone string then that will be taken into
     * account in adjusting the time of day as follows.
     * If the {@link #withOffsetParsed()} has been called, then the resulting
     * DateTime will have a fixed offset based on the parsed time zone.
     * Otherwise the resulting DateTime will have the zone of this formatter,
     * but the parsed zone may have caused the time to be adjusted.
     *
     * @param text  the text to parse, not null
     * @return the parsed date-time, never null
     * @throws UnsupportedOperationException if parsing is not supported
     * @throws IllegalArgumentException if the text to parse is invalid
     */
    public MutableDateTime parseMutableDateTime(String text) {
<span class="fc" id="L966">        InternalParser parser = requireParser();</span>
        
<span class="fc" id="L968">        Chronology chrono = selectChronology(null);</span>
<span class="fc" id="L969">        DateTimeParserBucket bucket = new DateTimeParserBucket(0, chrono, iLocale, iPivotYear, iDefaultYear);</span>
<span class="fc" id="L970">        int newPos = parser.parseInto(bucket, text, 0);</span>
<span class="fc bfc" id="L971" title="All 2 branches covered.">        if (newPos &gt;= 0) {</span>
<span class="pc bpc" id="L972" title="1 of 2 branches missed.">            if (newPos &gt;= text.length()) {</span>
<span class="fc" id="L973">                long millis = bucket.computeMillis(true, text);</span>
<span class="pc bpc" id="L974" title="1 of 4 branches missed.">                if (iOffsetParsed &amp;&amp; bucket.getOffsetInteger() != null) {</span>
<span class="fc" id="L975">                    int parsedOffset = bucket.getOffsetInteger();</span>
<span class="fc" id="L976">                    DateTimeZone parsedZone = DateTimeZone.forOffsetMillis(parsedOffset);</span>
<span class="fc" id="L977">                    chrono = chrono.withZone(parsedZone);</span>
<span class="pc bpc" id="L978" title="1 of 2 branches missed.">                } else if (bucket.getZone() != null) {</span>
<span class="fc" id="L979">                    chrono = chrono.withZone(bucket.getZone());</span>
                }
<span class="fc" id="L981">                MutableDateTime dt = new MutableDateTime(millis, chrono);</span>
<span class="fc bfc" id="L982" title="All 2 branches covered.">                if (iZone != null) {</span>
<span class="fc" id="L983">                    dt.setZone(iZone);</span>
                }
<span class="fc" id="L985">                return dt;</span>
            }
        } else {
<span class="fc" id="L988">            newPos = ~newPos;</span>
        }
<span class="fc" id="L990">        throw new IllegalArgumentException(FormatUtils.createErrorMessage(text, newPos));</span>
    }

    /**
     * Checks whether parsing is supported.
     * 
     * @throws UnsupportedOperationException if parsing is not supported
     */
    private InternalParser requireParser() {
<span class="fc" id="L999">        InternalParser parser = iParser;</span>
<span class="fc bfc" id="L1000" title="All 2 branches covered.">        if (parser == null) {</span>
<span class="fc" id="L1001">            throw new UnsupportedOperationException(&quot;Parsing not supported&quot;);</span>
        }
<span class="fc" id="L1003">        return parser;</span>
    }

    //-----------------------------------------------------------------------
    /**
     * Determines the correct chronology to use.
     *
     * @param chrono  the proposed chronology
     * @return the actual chronology
     */
    private Chronology selectChronology(Chronology chrono) {
<span class="fc" id="L1014">        chrono = DateTimeUtils.getChronology(chrono);</span>
<span class="fc bfc" id="L1015" title="All 2 branches covered.">        if (iChrono != null) {</span>
<span class="fc" id="L1016">            chrono = iChrono;</span>
        }
<span class="fc bfc" id="L1018" title="All 2 branches covered.">        if (iZone != null) {</span>
<span class="fc" id="L1019">            chrono = chrono.withZone(iZone);</span>
        }
<span class="fc" id="L1021">        return chrono;</span>
    }

}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.2.201808211720</span></div></body></html>