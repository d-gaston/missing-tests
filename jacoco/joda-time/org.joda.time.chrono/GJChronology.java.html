<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>GJChronology.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">Joda-Time</a> &gt; <a href="index.source.html" class="el_package">org.joda.time.chrono</a> &gt; <span class="el_source">GJChronology.java</span></div><h1>GJChronology.java</h1><pre class="source lang-java linenums">/*
 *  Copyright 2001-2014 Stephen Colebourne
 *
 *  Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
 *  you may not use this file except in compliance with the License.
 *  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the License for the specific language governing permissions and
 *  limitations under the License.
 */
package org.joda.time.chrono;

import java.util.Locale;
import java.util.concurrent.ConcurrentHashMap;

import org.joda.time.Chronology;
import org.joda.time.DateTimeField;
import org.joda.time.DateTimeUtils;
import org.joda.time.DateTimeZone;
import org.joda.time.DurationField;
import org.joda.time.IllegalFieldValueException;
import org.joda.time.Instant;
import org.joda.time.LocalDate;
import org.joda.time.ReadableInstant;
import org.joda.time.ReadablePartial;
import org.joda.time.field.BaseDateTimeField;
import org.joda.time.field.DecoratedDurationField;
import org.joda.time.format.DateTimeFormatter;
import org.joda.time.format.ISODateTimeFormat;

/**
 * Implements the Gregorian/Julian calendar system which is the calendar system
 * used in most of the world. Wherever possible, it is recommended to use the
 * {@link ISOChronology} instead.
 * &lt;p&gt;
 * The Gregorian calendar replaced the Julian calendar, and the point in time
 * when this chronology switches can be controlled using the second parameter
 * of the getInstance method. By default this cutover is set to the date the
 * Gregorian calendar was first instituted, October 15, 1582.
 * &lt;p&gt;
 * Before this date, this chronology uses the proleptic Julian calendar
 * (proleptic means extending indefinitely). The Julian calendar has leap years
 * every four years, whereas the Gregorian has special rules for 100 and 400
 * years. A meaningful result will thus be obtained for all input values.
 * However before 8 CE, Julian leap years were irregular, and before 45 BCE
 * there was no Julian calendar.
 * &lt;p&gt;
 * This chronology differs from
 * {@link java.util.GregorianCalendar GregorianCalendar} in that years
 * in BCE are returned correctly. Thus year 1 BCE is returned as -1 instead of 1.
 * The yearOfEra field produces results compatible with GregorianCalendar.
 * &lt;p&gt;
 * The Julian calendar does not have a year zero, and so year -1 is followed by
 * year 1. If the Gregorian cutover date is specified at or before year -1
 * (Julian), year zero is defined. In other words, the proleptic Gregorian
 * chronology used by this class has a year zero.
 * &lt;p&gt;
 * To create a pure proleptic Julian chronology, use {@link JulianChronology},
 * and to create a pure proleptic Gregorian chronology, use
 * {@link GregorianChronology}.
 * &lt;p&gt;
 * GJChronology is thread-safe and immutable.
 * 
 * @author Brian S O'Neill
 * @author Stephen Colebourne
 * @since 1.0
 */
public final class GJChronology extends AssembledChronology {

    /** Serialization lock */
    private static final long serialVersionUID = -2545574827706931671L;

    /**
     * Convert a datetime from one chronology to another.
     */
    private static long convertByYear(long instant, Chronology from, Chronology to) {
<span class="fc" id="L82">        return to.getDateTimeMillis</span>
<span class="fc" id="L83">            (from.year().get(instant),</span>
<span class="fc" id="L84">             from.monthOfYear().get(instant),</span>
<span class="fc" id="L85">             from.dayOfMonth().get(instant),</span>
<span class="fc" id="L86">             from.millisOfDay().get(instant));</span>
    }

    /**
     * Convert a datetime from one chronology to another.
     */
    private static long convertByWeekyear(final long instant, Chronology from, Chronology to) {
        long newInstant;
<span class="fc" id="L94">        newInstant = to.weekyear().set(0, from.weekyear().get(instant));</span>
<span class="fc" id="L95">        newInstant = to.weekOfWeekyear().set(newInstant, from.weekOfWeekyear().get(instant));</span>
<span class="fc" id="L96">        newInstant = to.dayOfWeek().set(newInstant, from.dayOfWeek().get(instant));</span>
<span class="fc" id="L97">        newInstant = to.millisOfDay().set(newInstant, from.millisOfDay().get(instant));</span>
<span class="fc" id="L98">        return newInstant;</span>
    }

    /**
     * The default GregorianJulian cutover point.
     */
<span class="fc" id="L104">    static final Instant DEFAULT_CUTOVER = new Instant(-12219292800000L);</span>

    /** Cache of zone to chronology list */
<span class="fc" id="L107">    private static final ConcurrentHashMap&lt;GJCacheKey, GJChronology&gt; cCache = new ConcurrentHashMap&lt;GJCacheKey, GJChronology&gt;();</span>

    /**
     * Factory method returns instances of the default GJ cutover
     * chronology. This uses a cutover date of October 15, 1582 (Gregorian)
     * 00:00:00 UTC. For this value, October 4, 1582 (Julian) is followed by
     * October 15, 1582 (Gregorian).
     *
     * &lt;p&gt;The first day of the week is designated to be
     * {@link org.joda.time.DateTimeConstants#MONDAY Monday},
     * and the minimum days in the first week of the year is 4.
     *
     * &lt;p&gt;The time zone of the returned instance is UTC.
     */
    public static GJChronology getInstanceUTC() {
<span class="fc" id="L122">        return getInstance(DateTimeZone.UTC, DEFAULT_CUTOVER, 4);</span>
    }

    /**
     * Factory method returns instances of the default GJ cutover
     * chronology. This uses a cutover date of October 15, 1582 (Gregorian)
     * 00:00:00 UTC. For this value, October 4, 1582 (Julian) is followed by
     * October 15, 1582 (Gregorian).
     *
     * &lt;p&gt;The first day of the week is designated to be
     * {@link org.joda.time.DateTimeConstants#MONDAY Monday},
     * and the minimum days in the first week of the year is 4.
     *
     * &lt;p&gt;The returned chronology is in the default time zone.
     */
    public static GJChronology getInstance() {
<span class="fc" id="L138">        return getInstance(DateTimeZone.getDefault(), DEFAULT_CUTOVER, 4);</span>
    }

    /**
     * Factory method returns instances of the GJ cutover chronology. This uses
     * a cutover date of October 15, 1582 (Gregorian) 00:00:00 UTC. For this
     * value, October 4, 1582 (Julian) is followed by October 15, 1582
     * (Gregorian).
     *
     * &lt;p&gt;The first day of the week is designated to be
     * {@link org.joda.time.DateTimeConstants#MONDAY Monday},
     * and the minimum days in the first week of the year is 4.
     *
     * @param zone  the time zone to use, null is default
     */
    public static GJChronology getInstance(DateTimeZone zone) {
<span class="fc" id="L154">        return getInstance(zone, DEFAULT_CUTOVER, 4);</span>
    }

    /**
     * Factory method returns instances of the GJ cutover chronology. Any
     * cutover date may be specified.
     *
     * &lt;p&gt;The first day of the week is designated to be
     * {@link org.joda.time.DateTimeConstants#MONDAY Monday},
     * and the minimum days in the first week of the year is 4.
     *
     * @param zone  the time zone to use, null is default
     * @param gregorianCutover  the cutover to use, null means default
     */
    public static GJChronology getInstance(
            DateTimeZone zone,
            ReadableInstant gregorianCutover) {
        
<span class="fc" id="L172">        return getInstance(zone, gregorianCutover, 4);</span>
    }
    
    /**
     * Factory method returns instances of the GJ cutover chronology. Any
     * cutover date may be specified.
     *
     * @param zone  the time zone to use, null is default
     * @param gregorianCutover  the cutover to use, null means default
     * @param minDaysInFirstWeek  minimum number of days in first week of the year; default is 4
     */
    public static GJChronology getInstance(
            DateTimeZone zone,
            ReadableInstant gregorianCutover,
            int minDaysInFirstWeek) {
        
<span class="fc" id="L188">        zone = DateTimeUtils.getZone(zone);</span>
        Instant cutoverInstant;
<span class="fc bfc" id="L190" title="All 2 branches covered.">        if (gregorianCutover == null) {</span>
<span class="fc" id="L191">            cutoverInstant = DEFAULT_CUTOVER;</span>
        } else {
<span class="fc" id="L193">            cutoverInstant = gregorianCutover.toInstant();</span>
<span class="fc" id="L194">            LocalDate cutoverDate = new LocalDate(cutoverInstant.getMillis(), GregorianChronology.getInstance(zone));</span>
<span class="fc bfc" id="L195" title="All 2 branches covered.">            if (cutoverDate.getYear() &lt;= 0) {</span>
<span class="fc" id="L196">                throw new IllegalArgumentException(&quot;Cutover too early. Must be on or after 0001-01-01.&quot;);</span>
            }
        }

<span class="fc" id="L200">        GJCacheKey cacheKey = new GJCacheKey(zone, cutoverInstant, minDaysInFirstWeek);</span>
<span class="fc" id="L201">        GJChronology chrono = cCache.get(cacheKey);</span>
<span class="fc bfc" id="L202" title="All 2 branches covered.">        if (chrono == null) {</span>
<span class="fc bfc" id="L203" title="All 2 branches covered.">            if (zone == DateTimeZone.UTC) {</span>
<span class="fc" id="L204">                chrono = new GJChronology</span>
<span class="fc" id="L205">                    (JulianChronology.getInstance(zone, minDaysInFirstWeek),</span>
<span class="fc" id="L206">                     GregorianChronology.getInstance(zone, minDaysInFirstWeek),</span>
                     cutoverInstant);
            } else {
<span class="fc" id="L209">                chrono = getInstance(DateTimeZone.UTC, cutoverInstant, minDaysInFirstWeek);</span>
<span class="fc" id="L210">                chrono = new GJChronology</span>
<span class="fc" id="L211">                    (ZonedChronology.getInstance(chrono, zone),</span>
                     chrono.iJulianChronology,
                     chrono.iGregorianChronology,
                     chrono.iCutoverInstant);
            }
<span class="fc" id="L216">            GJChronology oldChrono = cCache.putIfAbsent(cacheKey, chrono);</span>
<span class="pc bpc" id="L217" title="1 of 2 branches missed.">            if (oldChrono != null) {</span>
<span class="nc" id="L218">                chrono = oldChrono;</span>
            }
        }
<span class="fc" id="L221">        return chrono;</span>
    }

    /**
     * Factory method returns instances of the GJ cutover chronology. Any
     * cutover date may be specified.
     *
     * @param zone  the time zone to use, null is default
     * @param gregorianCutover  the cutover to use
     * @param minDaysInFirstWeek  minimum number of days in first week of the year; default is 4
     */
    public static GJChronology getInstance(
            DateTimeZone zone,
            long gregorianCutover,
            int minDaysInFirstWeek) {
        
        Instant cutoverInstant;
<span class="fc bfc" id="L238" title="All 2 branches covered.">        if (gregorianCutover == DEFAULT_CUTOVER.getMillis()) {</span>
<span class="fc" id="L239">            cutoverInstant = null;</span>
        } else {
<span class="fc" id="L241">            cutoverInstant = new Instant(gregorianCutover);</span>
        }
<span class="fc" id="L243">        return getInstance(zone, cutoverInstant, minDaysInFirstWeek);</span>
    }

    //-----------------------------------------------------------------------
    private JulianChronology iJulianChronology;
    private GregorianChronology iGregorianChronology;
    private Instant iCutoverInstant;

    private long iCutoverMillis;
    private long iGapDuration;

    /**
     * @param julian chronology used before the cutover instant
     * @param gregorian chronology used at and after the cutover instant
     * @param cutoverInstant instant when the gregorian chronology began
     */
    private GJChronology(JulianChronology julian,
                         GregorianChronology gregorian,
                         Instant cutoverInstant) {
<span class="fc" id="L262">        super(null, new Object[] {julian, gregorian, cutoverInstant});</span>
<span class="fc" id="L263">    }</span>

    /**
     * Called when applying a time zone.
     */
    private GJChronology(Chronology base,
                         JulianChronology julian,
                         GregorianChronology gregorian,
                         Instant cutoverInstant) {
<span class="fc" id="L272">        super(base, new Object[] {julian, gregorian, cutoverInstant});</span>
<span class="fc" id="L273">    }</span>

    /**
     * Serialization singleton
     */
    private Object readResolve() {
<span class="fc" id="L279">        return getInstance(getZone(), iCutoverInstant, getMinimumDaysInFirstWeek());</span>
    }

    public DateTimeZone getZone() {
        Chronology base;
<span class="fc bfc" id="L284" title="All 2 branches covered.">        if ((base = getBase()) != null) {</span>
<span class="fc" id="L285">            return base.getZone();</span>
        }
<span class="fc" id="L287">        return DateTimeZone.UTC;</span>
    }

    // Conversion
    //-----------------------------------------------------------------------
    /**
     * Gets the Chronology in the UTC time zone.
     * 
     * @return the chronology in UTC
     */
    public Chronology withUTC() {
<span class="fc" id="L298">        return withZone(DateTimeZone.UTC);</span>
    }

    /**
     * Gets the Chronology in a specific time zone.
     * 
     * @param zone  the zone to get the chronology in, null is default
     * @return the chronology
     */
    public Chronology withZone(DateTimeZone zone) {
<span class="fc bfc" id="L308" title="All 2 branches covered.">        if (zone == null) {</span>
<span class="fc" id="L309">            zone = DateTimeZone.getDefault();</span>
        }
<span class="fc bfc" id="L311" title="All 2 branches covered.">        if (zone == getZone()) {</span>
<span class="fc" id="L312">            return this;</span>
        }
<span class="fc" id="L314">        return getInstance(zone, iCutoverInstant, getMinimumDaysInFirstWeek());</span>
    }

    public long getDateTimeMillis(int year, int monthOfYear, int dayOfMonth,
                                  int millisOfDay)
        throws IllegalArgumentException
    {
        Chronology base;
<span class="pc bpc" id="L322" title="1 of 2 branches missed.">        if ((base = getBase()) != null) {</span>
<span class="nc" id="L323">            return base.getDateTimeMillis(year, monthOfYear, dayOfMonth, millisOfDay);</span>
        }

        // Assume date is Gregorian.
<span class="fc" id="L327">        long instant = iGregorianChronology.getDateTimeMillis</span>
<span class="fc" id="L328">            (year, monthOfYear, dayOfMonth, millisOfDay);</span>
<span class="fc bfc" id="L329" title="All 2 branches covered.">        if (instant &lt; iCutoverMillis) {</span>
            // Maybe it's Julian.
<span class="fc" id="L331">            instant = iJulianChronology.getDateTimeMillis</span>
<span class="fc" id="L332">                (year, monthOfYear, dayOfMonth, millisOfDay);</span>
<span class="pc bpc" id="L333" title="1 of 2 branches missed.">            if (instant &gt;= iCutoverMillis) {</span>
                // Okay, it's in the illegal cutover gap.
<span class="nc" id="L335">                throw new IllegalArgumentException(&quot;Specified date does not exist&quot;);</span>
            }
        }
<span class="fc" id="L338">        return instant;</span>
    }

    public long getDateTimeMillis(int year, int monthOfYear, int dayOfMonth,
                                  int hourOfDay, int minuteOfHour,
                                  int secondOfMinute, int millisOfSecond)
        throws IllegalArgumentException
    {
        Chronology base;
<span class="fc bfc" id="L347" title="All 2 branches covered.">        if ((base = getBase()) != null) {</span>
<span class="fc" id="L348">            return base.getDateTimeMillis</span>
<span class="fc" id="L349">                (year, monthOfYear, dayOfMonth,</span>
                 hourOfDay, minuteOfHour, secondOfMinute, millisOfSecond);
        }

        // Assume date is Gregorian.
        long instant;
        try {
<span class="fc" id="L356">            instant = iGregorianChronology.getDateTimeMillis</span>
<span class="fc" id="L357">                (year, monthOfYear, dayOfMonth,</span>
                 hourOfDay, minuteOfHour, secondOfMinute, millisOfSecond);
<span class="fc" id="L359">        } catch (IllegalFieldValueException ex) {</span>
<span class="pc bpc" id="L360" title="1 of 4 branches missed.">            if (monthOfYear != 2 || dayOfMonth != 29) {</span>
<span class="fc" id="L361">                throw ex;</span>
            }
<span class="fc" id="L363">            instant = iGregorianChronology.getDateTimeMillis</span>
<span class="fc" id="L364">                (year, monthOfYear, 28,</span>
                 hourOfDay, minuteOfHour, secondOfMinute, millisOfSecond);
<span class="pc bpc" id="L366" title="1 of 2 branches missed.">            if (instant &gt;= iCutoverMillis) {</span>
<span class="nc" id="L367">                throw ex;</span>
            }
<span class="fc" id="L369">        }</span>
<span class="fc bfc" id="L370" title="All 2 branches covered.">        if (instant &lt; iCutoverMillis) {</span>
            // Maybe it's Julian.
<span class="fc" id="L372">            instant = iJulianChronology.getDateTimeMillis</span>
<span class="fc" id="L373">                (year, monthOfYear, dayOfMonth,</span>
                 hourOfDay, minuteOfHour, secondOfMinute, millisOfSecond);
<span class="fc bfc" id="L375" title="All 2 branches covered.">            if (instant &gt;= iCutoverMillis) {</span>
                // Okay, it's in the illegal cutover gap.
<span class="fc" id="L377">                throw new IllegalArgumentException(&quot;Specified date does not exist&quot;);</span>
            }
        }
<span class="fc" id="L380">        return instant;</span>
    }

    /**
     * Gets the cutover instant between Gregorian and Julian chronologies.
     * @return the cutover instant
     */
    public Instant getGregorianCutover() {
<span class="fc" id="L388">        return iCutoverInstant;</span>
    }

    /**
     * Gets the minimum days needed for a week to be the first week in a year.
     * 
     * @return the minimum days
     */
    public int getMinimumDaysInFirstWeek() {
<span class="fc" id="L397">        return iGregorianChronology.getMinimumDaysInFirstWeek();</span>
    }

    //-----------------------------------------------------------------------
    /**
     * Checks if this chronology instance equals another.
     * 
     * @param obj  the object to compare to
     * @return true if equal
     * @since 1.6
     */
    public boolean equals(Object obj) {
<span class="fc bfc" id="L409" title="All 2 branches covered.">        if (this == obj) {</span>
<span class="fc" id="L410">            return true;</span>
        }
<span class="pc bpc" id="L412" title="1 of 2 branches missed.">        if (obj instanceof GJChronology) {</span>
<span class="nc" id="L413">            GJChronology chrono = (GJChronology) obj;</span>
<span class="nc bnc" id="L414" title="All 2 branches missed.">            return iCutoverMillis == chrono.iCutoverMillis &amp;&amp;</span>
<span class="nc bnc" id="L415" title="All 2 branches missed.">                    getMinimumDaysInFirstWeek() == chrono.getMinimumDaysInFirstWeek() &amp;&amp;</span>
<span class="nc bnc" id="L416" title="All 2 branches missed.">                    getZone().equals(chrono.getZone());</span>
        }
<span class="fc" id="L418">        return false;</span>
    }

    /**
     * A suitable hash code for the chronology.
     * 
     * @return the hash code
     * @since 1.6
     */
    public int hashCode() {
<span class="fc" id="L428">        return &quot;GJ&quot;.hashCode() * 11 + getZone().hashCode() +</span>
<span class="fc" id="L429">                getMinimumDaysInFirstWeek() + iCutoverInstant.hashCode();</span>
    }

    // Output
    //-----------------------------------------------------------------------
    /**
     * Gets a debugging toString.
     * 
     * @return a debugging string
     */
    public String toString() {
<span class="fc" id="L440">        StringBuffer sb = new StringBuffer(60);</span>
<span class="fc" id="L441">        sb.append(&quot;GJChronology&quot;);</span>
<span class="fc" id="L442">        sb.append('[');</span>
<span class="fc" id="L443">        sb.append(getZone().getID());</span>
        
<span class="fc bfc" id="L445" title="All 2 branches covered.">        if (iCutoverMillis != DEFAULT_CUTOVER.getMillis()) {</span>
<span class="fc" id="L446">            sb.append(&quot;,cutover=&quot;);</span>
            DateTimeFormatter printer;
<span class="fc bfc" id="L448" title="All 2 branches covered.">            if (withUTC().dayOfYear().remainder(iCutoverMillis) == 0) {</span>
<span class="fc" id="L449">                printer = ISODateTimeFormat.date();</span>
            } else {
<span class="fc" id="L451">                printer = ISODateTimeFormat.dateTime();</span>
            }
<span class="fc" id="L453">            printer.withChronology(withUTC()).printTo(sb, iCutoverMillis);</span>
        }
        
<span class="fc bfc" id="L456" title="All 2 branches covered.">        if (getMinimumDaysInFirstWeek() != 4) {</span>
<span class="fc" id="L457">            sb.append(&quot;,mdfw=&quot;);</span>
<span class="fc" id="L458">            sb.append(getMinimumDaysInFirstWeek());</span>
        }
<span class="fc" id="L460">        sb.append(']');</span>
        
<span class="fc" id="L462">        return sb.toString();</span>
    }

    protected void assemble(Fields fields) {
<span class="fc" id="L466">        Object[] params = (Object[])getParam();</span>

<span class="fc" id="L468">        JulianChronology julian = (JulianChronology)params[0];</span>
<span class="fc" id="L469">        GregorianChronology gregorian = (GregorianChronology)params[1];</span>
<span class="fc" id="L470">        Instant cutoverInstant = (Instant)params[2];</span>
<span class="fc" id="L471">        iCutoverMillis = cutoverInstant.getMillis();</span>

<span class="fc" id="L473">        iJulianChronology = julian;</span>
<span class="fc" id="L474">        iGregorianChronology = gregorian;</span>
<span class="fc" id="L475">        iCutoverInstant = cutoverInstant;</span>

<span class="fc bfc" id="L477" title="All 2 branches covered.">        if (getBase() != null) {</span>
<span class="fc" id="L478">            return;</span>
        }

<span class="pc bpc" id="L481" title="1 of 2 branches missed.">        if (julian.getMinimumDaysInFirstWeek() != gregorian.getMinimumDaysInFirstWeek()) {</span>
<span class="nc" id="L482">            throw new IllegalArgumentException();</span>
        }

        // Compute difference between the chronologies at the cutover instant
<span class="fc" id="L486">        iGapDuration = iCutoverMillis - julianToGregorianByYear(iCutoverMillis);</span>

        // Begin field definitions.

        // First just copy all the Gregorian fields and then override those
        // that need special attention.
<span class="fc" id="L492">        fields.copyFieldsFrom(gregorian);</span>
        
        // Assuming cutover is at midnight, all time of day fields can be
        // gregorian since they are unaffected by cutover.

        // Verify assumption.
<span class="fc bfc" id="L498" title="All 2 branches covered.">        if (gregorian.millisOfDay().get(iCutoverMillis) == 0) {</span>
            // Cutover is sometime in the day, so cutover fields are required
            // for time of day.

<span class="fc" id="L502">            fields.millisOfSecond = new CutoverField(julian.millisOfSecond(), fields.millisOfSecond, iCutoverMillis);</span>
<span class="fc" id="L503">            fields.millisOfDay = new CutoverField(julian.millisOfDay(), fields.millisOfDay, iCutoverMillis);</span>
<span class="fc" id="L504">            fields.secondOfMinute = new CutoverField(julian.secondOfMinute(), fields.secondOfMinute, iCutoverMillis);</span>
<span class="fc" id="L505">            fields.secondOfDay = new CutoverField(julian.secondOfDay(), fields.secondOfDay, iCutoverMillis);</span>
<span class="fc" id="L506">            fields.minuteOfHour = new CutoverField(julian.minuteOfHour(), fields.minuteOfHour, iCutoverMillis);</span>
<span class="fc" id="L507">            fields.minuteOfDay = new CutoverField(julian.minuteOfDay(), fields.minuteOfDay, iCutoverMillis);</span>
<span class="fc" id="L508">            fields.hourOfDay = new CutoverField(julian.hourOfDay(), fields.hourOfDay, iCutoverMillis);</span>
<span class="fc" id="L509">            fields.hourOfHalfday = new CutoverField(julian.hourOfHalfday(), fields.hourOfHalfday, iCutoverMillis);</span>
<span class="fc" id="L510">            fields.clockhourOfDay = new CutoverField(julian.clockhourOfDay(), fields.clockhourOfDay, iCutoverMillis);</span>
<span class="fc" id="L511">            fields.clockhourOfHalfday = new CutoverField(julian.clockhourOfHalfday(),</span>
                                                         fields.clockhourOfHalfday, iCutoverMillis);
<span class="fc" id="L513">            fields.halfdayOfDay = new CutoverField(julian.halfdayOfDay(), fields.halfdayOfDay, iCutoverMillis);</span>
        }

        // These fields just require basic cutover support.
        {
<span class="fc" id="L518">            fields.era = new CutoverField(julian.era(), fields.era, iCutoverMillis);</span>
        }

        // These fields are special because they have imprecise durations. The
        // family of addition methods need special attention. Override affected
        // duration fields as well.
        {
<span class="fc" id="L525">            fields.year = new ImpreciseCutoverField(</span>
<span class="fc" id="L526">                julian.year(), fields.year, iCutoverMillis);</span>
<span class="fc" id="L527">            fields.years = fields.year.getDurationField();</span>
<span class="fc" id="L528">            fields.yearOfEra = new ImpreciseCutoverField(</span>
<span class="fc" id="L529">                julian.yearOfEra(), fields.yearOfEra, fields.years, iCutoverMillis);</span>
            
<span class="fc" id="L531">            fields.centuryOfEra = new ImpreciseCutoverField(</span>
<span class="fc" id="L532">                julian.centuryOfEra(), fields.centuryOfEra, iCutoverMillis);</span>
<span class="fc" id="L533">            fields.centuries = fields.centuryOfEra.getDurationField();</span>
            
<span class="fc" id="L535">            fields.yearOfCentury = new ImpreciseCutoverField(</span>
<span class="fc" id="L536">                julian.yearOfCentury(), fields.yearOfCentury, fields.years, fields.centuries, iCutoverMillis);</span>
            
<span class="fc" id="L538">            fields.monthOfYear = new ImpreciseCutoverField(</span>
<span class="fc" id="L539">                julian.monthOfYear(), fields.monthOfYear, null, fields.years, iCutoverMillis);</span>
<span class="fc" id="L540">            fields.months = fields.monthOfYear.getDurationField();</span>
            
<span class="fc" id="L542">            fields.weekyear = new ImpreciseCutoverField(</span>
<span class="fc" id="L543">                julian.weekyear(), fields.weekyear, null, iCutoverMillis, true);</span>
<span class="fc" id="L544">            fields.weekyears = fields.weekyear.getDurationField();</span>
<span class="fc" id="L545">            fields.weekyearOfCentury = new ImpreciseCutoverField(</span>
<span class="fc" id="L546">                julian.weekyearOfCentury(), fields.weekyearOfCentury, fields.weekyears, fields.centuries, iCutoverMillis);</span>
        }

        // DayOfYear and weekOfWeekyear require special handling since cutover
        // year has fewer days and weeks. Extend the cutover to the start of
        // the next year or weekyear. This keeps the sequence unbroken during
        // the cutover year.

        {
<span class="fc" id="L555">            long cutover = gregorian.year().roundCeiling(iCutoverMillis);</span>
<span class="fc" id="L556">            fields.dayOfYear = new CutoverField(</span>
<span class="fc" id="L557">                julian.dayOfYear(), fields.dayOfYear, fields.years, cutover, false);</span>
        }

        {
<span class="fc" id="L561">            long cutover = gregorian.weekyear().roundCeiling(iCutoverMillis);</span>
<span class="fc" id="L562">            fields.weekOfWeekyear = new CutoverField(</span>
<span class="fc" id="L563">                julian.weekOfWeekyear(), fields.weekOfWeekyear, fields.weekyears, cutover, true);</span>
        }

        // These fields require basic cutover support, except they must link to
        // imprecise durations.
        {
<span class="fc" id="L569">            CutoverField cf = new CutoverField</span>
<span class="fc" id="L570">                (julian.dayOfMonth(), fields.dayOfMonth, iCutoverMillis);</span>
<span class="fc" id="L571">            cf.iRangeDurationField = fields.months;</span>
<span class="fc" id="L572">            fields.dayOfMonth = cf;</span>
        }
<span class="fc" id="L574">    }</span>

    long julianToGregorianByYear(long instant) {
<span class="fc" id="L577">        return convertByYear(instant, iJulianChronology, iGregorianChronology);</span>
    }

    long gregorianToJulianByYear(long instant) {
<span class="fc" id="L581">        return convertByYear(instant, iGregorianChronology, iJulianChronology);</span>
    }

    long julianToGregorianByWeekyear(long instant) {
<span class="fc" id="L585">        return convertByWeekyear(instant, iJulianChronology, iGregorianChronology);</span>
    }

    long gregorianToJulianByWeekyear(long instant) {
<span class="fc" id="L589">        return convertByWeekyear(instant, iGregorianChronology, iJulianChronology);</span>
    }

    //-----------------------------------------------------------------------
    /**
     * This basic cutover field adjusts calls to 'get' and 'set' methods, and
     * assumes that calls to add and addWrapField are unaffected by the cutover.
     */
    private class CutoverField extends BaseDateTimeField {
        @SuppressWarnings(&quot;unused&quot;)
        private static final long serialVersionUID = 3528501219481026402L;

        final DateTimeField iJulianField;
        final DateTimeField iGregorianField;
        final long iCutover;
        final boolean iConvertByWeekyear;

        protected DurationField iDurationField;
        protected DurationField iRangeDurationField;

        /**
         * @param julianField field from the chronology used before the cutover instant
         * @param gregorianField field from the chronology used at and after the cutover
         * @param cutoverMillis  the millis of the cutover
         */
        CutoverField(DateTimeField julianField, DateTimeField gregorianField, long cutoverMillis) {
<span class="fc" id="L615">            this(julianField, gregorianField, cutoverMillis, false);</span>
<span class="fc" id="L616">        }</span>

        /**
         * @param julianField field from the chronology used before the cutover instant
         * @param gregorianField field from the chronology used at and after the cutover
         * @param cutoverMillis  the millis of the cutover
         * @param convertByWeekyear
         */
        CutoverField(DateTimeField julianField, DateTimeField gregorianField,
                     long cutoverMillis, boolean convertByWeekyear) {
<span class="fc" id="L626">            this(julianField, gregorianField, null, cutoverMillis, convertByWeekyear);</span>
<span class="fc" id="L627">        }</span>

        /**
         * @param julianField field from the chronology used before the cutover instant
         * @param gregorianField field from the chronology used at and after the cutover
         * @param rangeField  the range field
         * @param cutoverMillis  the millis of the cutover
         * @param convertByWeekyear
         */
        CutoverField(DateTimeField julianField, DateTimeField gregorianField,
<span class="fc" id="L637">                     DurationField rangeField, long cutoverMillis, boolean convertByWeekyear) {</span>
<span class="fc" id="L638">            super(gregorianField.getType());</span>
<span class="fc" id="L639">            iJulianField = julianField;</span>
<span class="fc" id="L640">            iGregorianField = gregorianField;</span>
<span class="fc" id="L641">            iCutover = cutoverMillis;</span>
<span class="fc" id="L642">            iConvertByWeekyear = convertByWeekyear;</span>
            // Although average length of Julian and Gregorian years differ,
            // use the Gregorian duration field because it is more accurate.
<span class="fc" id="L645">            iDurationField = gregorianField.getDurationField();</span>
<span class="fc bfc" id="L646" title="All 2 branches covered.">            if (rangeField == null) {</span>
<span class="fc" id="L647">                rangeField = gregorianField.getRangeDurationField();</span>
<span class="fc bfc" id="L648" title="All 2 branches covered.">                if (rangeField == null) {</span>
<span class="fc" id="L649">                    rangeField = julianField.getRangeDurationField();</span>
                }
            }
<span class="fc" id="L652">            iRangeDurationField = rangeField;</span>
<span class="fc" id="L653">        }</span>

        public boolean isLenient() {
<span class="fc" id="L656">            return false;</span>
        }

        public int get(long instant) {
<span class="fc bfc" id="L660" title="All 2 branches covered.">            if (instant &gt;= iCutover) {</span>
<span class="fc" id="L661">                return iGregorianField.get(instant);</span>
            } else {
<span class="fc" id="L663">                return iJulianField.get(instant);</span>
            }
        }

        public String getAsText(long instant, Locale locale) {
<span class="nc bnc" id="L668" title="All 2 branches missed.">            if (instant &gt;= iCutover) {</span>
<span class="nc" id="L669">                return iGregorianField.getAsText(instant, locale);</span>
            } else {
<span class="nc" id="L671">                return iJulianField.getAsText(instant, locale);</span>
            }
        }

        public String getAsText(int fieldValue, Locale locale) {
<span class="fc" id="L676">            return iGregorianField.getAsText(fieldValue, locale);</span>
        }

        public String getAsShortText(long instant, Locale locale) {
<span class="nc bnc" id="L680" title="All 2 branches missed.">            if (instant &gt;= iCutover) {</span>
<span class="nc" id="L681">                return iGregorianField.getAsShortText(instant, locale);</span>
            } else {
<span class="nc" id="L683">                return iJulianField.getAsShortText(instant, locale);</span>
            }
        }

        public String getAsShortText(int fieldValue, Locale locale) {
<span class="fc" id="L688">            return iGregorianField.getAsShortText(fieldValue, locale);</span>
        }

        public long add(long instant, int value) {
<span class="fc" id="L692">            return iGregorianField.add(instant, value);</span>
        }

        public long add(long instant, long value) {
<span class="nc" id="L696">            return iGregorianField.add(instant, value);</span>
        }

        public int[] add(ReadablePartial partial, int fieldIndex, int[] values, int valueToAdd) {
            // overridden as superclass algorithm can't handle
            // 2004-02-29 + 48 months -&gt; 2008-02-29 type dates
<span class="fc bfc" id="L702" title="All 2 branches covered.">            if (valueToAdd == 0) {</span>
<span class="fc" id="L703">                return values;</span>
            }
<span class="pc bpc" id="L705" title="1 of 2 branches missed.">            if (DateTimeUtils.isContiguous(partial)) {</span>
<span class="fc" id="L706">                long instant = 0L;</span>
<span class="fc bfc" id="L707" title="All 2 branches covered.">                for (int i = 0, isize = partial.size(); i &lt; isize; i++) {</span>
<span class="fc" id="L708">                    instant = partial.getFieldType(i).getField(GJChronology.this).set(instant, values[i]);</span>
                }
<span class="fc" id="L710">                instant = add(instant, valueToAdd);</span>
<span class="fc" id="L711">                return GJChronology.this.get(partial, instant);</span>
            } else {
<span class="nc" id="L713">                return super.add(partial, fieldIndex, values, valueToAdd);</span>
            }
        }

        public int getDifference(long minuendInstant, long subtrahendInstant) {
<span class="nc" id="L718">            return iGregorianField.getDifference(minuendInstant, subtrahendInstant);</span>
        }

        public long getDifferenceAsLong(long minuendInstant, long subtrahendInstant) {
<span class="nc" id="L722">            return iGregorianField.getDifferenceAsLong(minuendInstant, subtrahendInstant);</span>
        }

        public long set(long instant, int value) {
<span class="fc bfc" id="L726" title="All 2 branches covered.">            if (instant &gt;= iCutover) {</span>
<span class="fc" id="L727">                instant = iGregorianField.set(instant, value);</span>
<span class="fc bfc" id="L728" title="All 2 branches covered.">                if (instant &lt; iCutover) {</span>
                    // Only adjust if gap fully crossed.
<span class="fc bfc" id="L730" title="All 2 branches covered.">                    if (instant + iGapDuration &lt; iCutover) {</span>
<span class="fc" id="L731">                        instant = gregorianToJulian(instant);</span>
                    }
                    // Verify that new value stuck.
<span class="fc bfc" id="L734" title="All 2 branches covered.">                    if (get(instant) != value) {</span>
<span class="fc" id="L735">                        throw new IllegalFieldValueException</span>
<span class="fc" id="L736">                            (iGregorianField.getType(), Integer.valueOf(value), null, null);</span>
                    }
                }
            } else {
<span class="fc" id="L740">                instant = iJulianField.set(instant, value);</span>
<span class="fc bfc" id="L741" title="All 2 branches covered.">                if (instant &gt;= iCutover) {</span>
                    // Only adjust if gap fully crossed.
<span class="fc bfc" id="L743" title="All 2 branches covered.">                    if (instant - iGapDuration &gt;= iCutover) {</span>
<span class="fc" id="L744">                        instant = julianToGregorian(instant);</span>
                    }
                    // Verify that new value stuck.
<span class="fc bfc" id="L747" title="All 2 branches covered.">                    if (get(instant) != value) {</span>
<span class="fc" id="L748">                       throw new IllegalFieldValueException</span>
<span class="fc" id="L749">                            (iJulianField.getType(), Integer.valueOf(value), null, null);</span>
                    }
                }
            }
<span class="fc" id="L753">            return instant;</span>
        }

        public long set(long instant, String text, Locale locale) {
<span class="fc bfc" id="L757" title="All 2 branches covered.">            if (instant &gt;= iCutover) {</span>
<span class="fc" id="L758">                instant = iGregorianField.set(instant, text, locale);</span>
<span class="fc bfc" id="L759" title="All 2 branches covered.">                if (instant &lt; iCutover) {</span>
                    // Only adjust if gap fully crossed.
<span class="pc bpc" id="L761" title="1 of 2 branches missed.">                    if (instant + iGapDuration &lt; iCutover) {</span>
<span class="fc" id="L762">                        instant = gregorianToJulian(instant);</span>
                    }
                    // Cannot verify that new value stuck because set may be lenient.
                }
            } else {
<span class="fc" id="L767">                instant = iJulianField.set(instant, text, locale);</span>
<span class="pc bpc" id="L768" title="1 of 2 branches missed.">                if (instant &gt;= iCutover) {</span>
                    // Only adjust if gap fully crossed.
<span class="nc bnc" id="L770" title="All 2 branches missed.">                    if (instant - iGapDuration &gt;= iCutover) {</span>
<span class="nc" id="L771">                        instant = julianToGregorian(instant);</span>
                    }
                    // Cannot verify that new value stuck because set may be lenient.
                }
            }
<span class="fc" id="L776">            return instant;</span>
        }

        public DurationField getDurationField() {
<span class="fc" id="L780">            return iDurationField;</span>
        }

        public DurationField getRangeDurationField() {
<span class="fc" id="L784">            return iRangeDurationField;</span>
        }

        public boolean isLeap(long instant) {
<span class="pc bpc" id="L788" title="1 of 2 branches missed.">            if (instant &gt;= iCutover) {</span>
<span class="fc" id="L789">                return iGregorianField.isLeap(instant);</span>
            } else {
<span class="nc" id="L791">                return iJulianField.isLeap(instant);</span>
            }
        }

        public int getLeapAmount(long instant) {
<span class="nc bnc" id="L796" title="All 2 branches missed.">            if (instant &gt;= iCutover) {</span>
<span class="nc" id="L797">                return iGregorianField.getLeapAmount(instant);</span>
            } else {
<span class="nc" id="L799">                return iJulianField.getLeapAmount(instant);</span>
            }
        }

        public DurationField getLeapDurationField() {
<span class="fc" id="L804">            return iGregorianField.getLeapDurationField();</span>
        }


        public int getMinimumValue() {
            // For all precise fields, the Julian and Gregorian limits are
            // identical. Choose Julian to tighten up the year limits.
<span class="fc" id="L811">            return iJulianField.getMinimumValue();</span>
        }

        public int getMinimumValue(ReadablePartial partial) {
<span class="nc" id="L815">            return iJulianField.getMinimumValue(partial);</span>
        }

        public int getMinimumValue(ReadablePartial partial, int[] values) {
<span class="fc" id="L819">            return iJulianField.getMinimumValue(partial, values);</span>
        }

        public int getMinimumValue(long instant) {
<span class="nc bnc" id="L823" title="All 2 branches missed.">            if (instant &lt; iCutover) {</span>
<span class="nc" id="L824">                return iJulianField.getMinimumValue(instant);</span>
            }

<span class="nc" id="L827">            int min = iGregorianField.getMinimumValue(instant);</span>

            // Because the cutover may reduce the length of this field, verify
            // the minimum by setting it.
<span class="nc" id="L831">            instant = iGregorianField.set(instant, min);</span>
<span class="nc bnc" id="L832" title="All 2 branches missed.">            if (instant &lt; iCutover) {</span>
<span class="nc" id="L833">                min = iGregorianField.get(iCutover);</span>
            }

<span class="nc" id="L836">            return min;</span>
        }

        public int getMaximumValue() {
            // For all precise fields, the Julian and Gregorian limits are
            // identical.
<span class="fc" id="L842">            return iGregorianField.getMaximumValue();</span>
        }

        public int getMaximumValue(long instant) {
<span class="fc bfc" id="L846" title="All 2 branches covered.">            if (instant &gt;= iCutover) {</span>
<span class="fc" id="L847">                return iGregorianField.getMaximumValue(instant);</span>
            }

<span class="fc" id="L850">            int max = iJulianField.getMaximumValue(instant);</span>

            // Because the cutover may reduce the length of this field, verify
            // the maximum by setting it.
<span class="fc" id="L854">            instant = iJulianField.set(instant, max);</span>
<span class="fc bfc" id="L855" title="All 2 branches covered.">            if (instant &gt;= iCutover) {</span>
<span class="fc" id="L856">                max = iJulianField.get(iJulianField.add(iCutover, -1));</span>
            }

<span class="fc" id="L859">            return max;</span>
        }

        public int getMaximumValue(ReadablePartial partial) {
<span class="fc" id="L863">            long instant = GJChronology.getInstanceUTC().set(partial, 0L);</span>
<span class="fc" id="L864">            return getMaximumValue(instant);</span>
        }

        public int getMaximumValue(ReadablePartial partial, int[] values) {
<span class="fc" id="L868">            Chronology chrono = GJChronology.getInstanceUTC();</span>
<span class="fc" id="L869">            long instant = 0L;</span>
<span class="fc bfc" id="L870" title="All 2 branches covered.">            for (int i = 0, isize = partial.size(); i &lt; isize; i++) {</span>
<span class="fc" id="L871">                DateTimeField field = partial.getFieldType(i).getField(chrono);</span>
<span class="pc bpc" id="L872" title="1 of 2 branches missed.">                if (values[i] &lt;= field.getMaximumValue(instant)) {</span>
<span class="fc" id="L873">                    instant = field.set(instant, values[i]);</span>
                }
            }
<span class="fc" id="L876">            return getMaximumValue(instant);</span>
        }

        public long roundFloor(long instant) {
<span class="fc bfc" id="L880" title="All 2 branches covered.">            if (instant &gt;= iCutover) {</span>
<span class="fc" id="L881">                instant = iGregorianField.roundFloor(instant);</span>
<span class="fc bfc" id="L882" title="All 2 branches covered.">                if (instant &lt; iCutover) {</span>
                    // Only adjust if gap fully crossed.
<span class="pc bpc" id="L884" title="1 of 2 branches missed.">                    if (instant + iGapDuration &lt; iCutover) {</span>
<span class="fc" id="L885">                        instant = gregorianToJulian(instant);</span>
                    }
                }
            } else {
<span class="fc" id="L889">                instant = iJulianField.roundFloor(instant);</span>
            }
<span class="fc" id="L891">            return instant;</span>
        }

        public long roundCeiling(long instant) {
<span class="nc bnc" id="L895" title="All 2 branches missed.">            if (instant &gt;= iCutover) {</span>
<span class="nc" id="L896">                instant = iGregorianField.roundCeiling(instant);</span>
            } else {
<span class="nc" id="L898">                instant = iJulianField.roundCeiling(instant);</span>
<span class="nc bnc" id="L899" title="All 2 branches missed.">                if (instant &gt;= iCutover) {</span>
                    // Only adjust if gap fully crossed.
<span class="nc bnc" id="L901" title="All 2 branches missed.">                    if (instant - iGapDuration &gt;= iCutover) {</span>
<span class="nc" id="L902">                        instant = julianToGregorian(instant);</span>
                    }
                }
            }
<span class="nc" id="L906">            return instant;</span>
        }

        public int getMaximumTextLength(Locale locale) {
<span class="nc" id="L910">            return Math.max(iJulianField.getMaximumTextLength(locale),</span>
<span class="nc" id="L911">                            iGregorianField.getMaximumTextLength(locale));</span>
        }

        public int getMaximumShortTextLength(Locale locale) {
<span class="nc" id="L915">            return Math.max(iJulianField.getMaximumShortTextLength(locale),</span>
<span class="nc" id="L916">                            iGregorianField.getMaximumShortTextLength(locale));</span>
        }

        protected long julianToGregorian(long instant) {
<span class="fc bfc" id="L920" title="All 2 branches covered.">            if (iConvertByWeekyear) {</span>
<span class="fc" id="L921">                return julianToGregorianByWeekyear(instant);</span>
            } else {
<span class="fc" id="L923">                return julianToGregorianByYear(instant);</span>
            }
        }

        protected long gregorianToJulian(long instant) {
<span class="fc bfc" id="L928" title="All 2 branches covered.">            if (iConvertByWeekyear) {</span>
<span class="fc" id="L929">                return gregorianToJulianByWeekyear(instant);</span>
            } else {
<span class="fc" id="L931">                return gregorianToJulianByYear(instant);</span>
            }
        }
    }

    //-----------------------------------------------------------------------
    /**
     * Cutover field for variable length fields. These fields internally call
     * set whenever add is called. As a result, the same correction applied to
     * set must be applied to add and addWrapField. Knowing when to use this
     * field requires specific knowledge of how the GJ fields are implemented.
     */
    private final class ImpreciseCutoverField extends CutoverField {
        @SuppressWarnings(&quot;unused&quot;)
        private static final long serialVersionUID = 3410248757173576441L;

        /**
         * Creates a duration field that links back to this.
         */
        ImpreciseCutoverField(DateTimeField julianField, DateTimeField gregorianField, long cutoverMillis) {
<span class="fc" id="L951">            this(julianField, gregorianField, null, cutoverMillis, false);</span>
<span class="fc" id="L952">        }</span>

        /**
         * Uses a shared duration field rather than creating a new one.
         *
         * @param durationField shared duration field
         */
        ImpreciseCutoverField(DateTimeField julianField, DateTimeField gregorianField,
                              DurationField durationField, long cutoverMillis)
        {
<span class="fc" id="L962">            this(julianField, gregorianField, durationField, cutoverMillis, false);</span>
<span class="fc" id="L963">        }</span>

        /**
         * Uses shared duration fields rather than creating a new one.
         *
         * @param durationField shared duration field
         */
        ImpreciseCutoverField(DateTimeField julianField, DateTimeField gregorianField,
                              DurationField durationField, DurationField rangeDurationField, long cutoverMillis)
        {
<span class="fc" id="L973">            this(julianField, gregorianField, durationField, cutoverMillis, false);</span>
<span class="fc" id="L974">            iRangeDurationField = rangeDurationField;</span>
<span class="fc" id="L975">        }</span>

        /**
         * Uses a shared duration field rather than creating a new one.
         *
         * @param durationField shared duration field
         */
        ImpreciseCutoverField(DateTimeField julianField, DateTimeField gregorianField,
                              DurationField durationField,
                              long cutoverMillis, boolean convertByWeekyear)
<span class="fc" id="L985">        {</span>
<span class="fc" id="L986">            super(julianField, gregorianField, cutoverMillis, convertByWeekyear);</span>
<span class="fc bfc" id="L987" title="All 2 branches covered.">            if (durationField == null) {</span>
<span class="fc" id="L988">                durationField = new LinkedDurationField(iDurationField, this);</span>
            }
<span class="fc" id="L990">            iDurationField = durationField;</span>
<span class="fc" id="L991">        }</span>

        public long add(long instant, int value) {
<span class="fc bfc" id="L994" title="All 2 branches covered.">            if (instant &gt;= iCutover) {</span>
<span class="fc" id="L995">                instant = iGregorianField.add(instant, value);</span>
<span class="fc bfc" id="L996" title="All 2 branches covered.">                if (instant &lt; iCutover) {</span>
                    // Only adjust if gap fully crossed.
<span class="pc bpc" id="L998" title="1 of 2 branches missed.">                    if (instant + iGapDuration &lt; iCutover) {</span>
<span class="fc bfc" id="L999" title="All 2 branches covered.">                        if (iConvertByWeekyear) {</span>
<span class="fc" id="L1000">                            int wyear = iGregorianChronology.weekyear().get(instant);</span>
<span class="fc bfc" id="L1001" title="All 2 branches covered.">                            if (wyear &lt;= 0) {</span>
<span class="fc" id="L1002">                                instant = iGregorianChronology.weekyear().add(instant, -1);</span>
                            }
<span class="fc" id="L1004">                        } else {</span>
<span class="fc" id="L1005">                            int year = iGregorianChronology.year().get(instant);</span>
<span class="fc bfc" id="L1006" title="All 2 branches covered.">                            if (year &lt;= 0) {</span>
<span class="fc" id="L1007">                                instant = iGregorianChronology.year().add(instant, -1);</span>
                            }
                        }
<span class="fc" id="L1010">                        instant = gregorianToJulian(instant);</span>
                    }
                }
            } else {
<span class="fc" id="L1014">                instant = iJulianField.add(instant, value);</span>
<span class="fc bfc" id="L1015" title="All 2 branches covered.">                if (instant &gt;= iCutover) {</span>
                    // Only adjust if gap fully crossed.
<span class="pc bpc" id="L1017" title="1 of 2 branches missed.">                    if (instant - iGapDuration &gt;= iCutover) {</span>
                        // no special handling for year zero as cutover always after year zero
<span class="fc" id="L1019">                        instant = julianToGregorian(instant);</span>
                    }
                }
            }
<span class="fc" id="L1023">            return instant;</span>
        }
        
        public long add(long instant, long value) {
<span class="fc bfc" id="L1027" title="All 2 branches covered.">            if (instant &gt;= iCutover) {</span>
<span class="fc" id="L1028">                instant = iGregorianField.add(instant, value);</span>
<span class="pc bpc" id="L1029" title="1 of 2 branches missed.">                if (instant &lt; iCutover) {</span>
                    // Only adjust if gap fully crossed.
<span class="nc bnc" id="L1031" title="All 2 branches missed.">                    if (instant + iGapDuration &lt; iCutover) {</span>
<span class="nc bnc" id="L1032" title="All 2 branches missed.">                        if (iConvertByWeekyear) {</span>
<span class="nc" id="L1033">                            int wyear = iGregorianChronology.weekyear().get(instant);</span>
<span class="nc bnc" id="L1034" title="All 2 branches missed.">                            if (wyear &lt;= 0) {</span>
<span class="nc" id="L1035">                                instant = iGregorianChronology.weekyear().add(instant, -1);</span>
                            }
<span class="nc" id="L1037">                        } else {</span>
<span class="nc" id="L1038">                            int year = iGregorianChronology.year().get(instant);</span>
<span class="nc bnc" id="L1039" title="All 2 branches missed.">                            if (year &lt;= 0) {</span>
<span class="nc" id="L1040">                                instant = iGregorianChronology.year().add(instant, -1);</span>
                            }
                        }
<span class="nc" id="L1043">                        instant = gregorianToJulian(instant);</span>
                    }
                }
            } else {
<span class="fc" id="L1047">                instant = iJulianField.add(instant, value);</span>
<span class="pc bpc" id="L1048" title="1 of 2 branches missed.">                if (instant &gt;= iCutover) {</span>
                    // Only adjust if gap fully crossed.
<span class="nc bnc" id="L1050" title="All 2 branches missed.">                    if (instant - iGapDuration &gt;= iCutover) {</span>
                        // no special handling for year zero as cutover always after year zero
<span class="nc" id="L1052">                        instant = julianToGregorian(instant);</span>
                    }
                }
            }
<span class="fc" id="L1056">            return instant;</span>
        }

        public int getDifference(long minuendInstant, long subtrahendInstant) {
<span class="fc bfc" id="L1060" title="All 2 branches covered.">            if (minuendInstant &gt;= iCutover) {</span>
<span class="fc bfc" id="L1061" title="All 2 branches covered.">                if (subtrahendInstant &gt;= iCutover) {</span>
<span class="fc" id="L1062">                    return iGregorianField.getDifference(minuendInstant, subtrahendInstant);</span>
                }
                // Remember, the add is being reversed. Since subtrahend is
                // Julian, convert minuend to Julian to match.
<span class="fc" id="L1066">                minuendInstant = gregorianToJulian(minuendInstant);</span>
<span class="fc" id="L1067">                return iJulianField.getDifference(minuendInstant, subtrahendInstant);</span>
            } else {
<span class="pc bpc" id="L1069" title="1 of 2 branches missed.">                if (subtrahendInstant &lt; iCutover) {</span>
<span class="fc" id="L1070">                    return iJulianField.getDifference(minuendInstant, subtrahendInstant);</span>
                }
                // Remember, the add is being reversed. Since subtrahend is
                // Gregorian, convert minuend to Gregorian to match.
<span class="nc" id="L1074">                minuendInstant = julianToGregorian(minuendInstant);</span>
<span class="nc" id="L1075">                return iGregorianField.getDifference(minuendInstant, subtrahendInstant);</span>
            }
        }

        public long getDifferenceAsLong(long minuendInstant, long subtrahendInstant) {
<span class="nc bnc" id="L1080" title="All 2 branches missed.">            if (minuendInstant &gt;= iCutover) {</span>
<span class="nc bnc" id="L1081" title="All 2 branches missed.">                if (subtrahendInstant &gt;= iCutover) {</span>
<span class="nc" id="L1082">                    return iGregorianField.getDifferenceAsLong(minuendInstant, subtrahendInstant);</span>
                }
                // Remember, the add is being reversed. Since subtrahend is
                // Julian, convert minuend to Julian to match.
<span class="nc" id="L1086">                minuendInstant = gregorianToJulian(minuendInstant);</span>
<span class="nc" id="L1087">                return iJulianField.getDifferenceAsLong(minuendInstant, subtrahendInstant);</span>
            } else {
<span class="nc bnc" id="L1089" title="All 2 branches missed.">                if (subtrahendInstant &lt; iCutover) {</span>
<span class="nc" id="L1090">                    return iJulianField.getDifferenceAsLong(minuendInstant, subtrahendInstant);</span>
                }
                // Remember, the add is being reversed. Since subtrahend is
                // Gregorian, convert minuend to Gregorian to match.
<span class="nc" id="L1094">                minuendInstant = julianToGregorian(minuendInstant);</span>
<span class="nc" id="L1095">                return iGregorianField.getDifferenceAsLong(minuendInstant, subtrahendInstant);</span>
            }
        }

        // Since the imprecise fields have durations longer than the gap
        // duration, keep these methods simple. The inherited implementations
        // produce incorrect results.
        //
        // Degenerate case: If this field is a month, and the cutover is set
        // far into the future, then the gap duration may be so large as to
        // reduce the number of months in a year. If the missing month(s) are
        // at the beginning or end of the year, then the minimum and maximum
        // values are not 1 and 12. I don't expect this case to ever occur.

        public int getMinimumValue(long instant) {
<span class="nc bnc" id="L1110" title="All 2 branches missed.">            if (instant &gt;= iCutover) {</span>
<span class="nc" id="L1111">                return iGregorianField.getMinimumValue(instant);</span>
            } else {
<span class="nc" id="L1113">                return iJulianField.getMinimumValue(instant);</span>
            }
        }

        public int getMaximumValue(long instant) {
<span class="fc bfc" id="L1118" title="All 2 branches covered.">            if (instant &gt;= iCutover) {</span>
<span class="fc" id="L1119">                return iGregorianField.getMaximumValue(instant);</span>
            } else {
<span class="fc" id="L1121">                return iJulianField.getMaximumValue(instant);</span>
            }
        }
    }

    //-----------------------------------------------------------------------
    /**
     * Links the duration back to a ImpreciseCutoverField.
     */
    private static class LinkedDurationField extends DecoratedDurationField {
        private static final long serialVersionUID = 4097975388007713084L;

        private final ImpreciseCutoverField iField;

        LinkedDurationField(DurationField durationField, ImpreciseCutoverField dateTimeField) {
<span class="fc" id="L1136">            super(durationField, durationField.getType());</span>
<span class="fc" id="L1137">            iField = dateTimeField;</span>
<span class="fc" id="L1138">        }</span>

        public long add(long instant, int value) {
<span class="fc" id="L1141">            return iField.add(instant, value);</span>
        }

        public long add(long instant, long value) {
<span class="fc" id="L1145">            return iField.add(instant, value);</span>
        }

        public int getDifference(long minuendInstant, long subtrahendInstant) {
<span class="fc" id="L1149">            return iField.getDifference(minuendInstant, subtrahendInstant);</span>
        }

        public long getDifferenceAsLong(long minuendInstant, long subtrahendInstant) {
<span class="nc" id="L1153">            return iField.getDifferenceAsLong(minuendInstant, subtrahendInstant);</span>
        }
    }

}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.2.201808211720</span></div></body></html>