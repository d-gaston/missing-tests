<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>DateTimeZoneBuilder.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">Joda-Time</a> &gt; <a href="index.source.html" class="el_package">org.joda.time.tz</a> &gt; <span class="el_source">DateTimeZoneBuilder.java</span></div><h1>DateTimeZoneBuilder.java</h1><pre class="source lang-java linenums">/*
 *  Copyright 2001-2013 Stephen Colebourne
 *
 *  Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
 *  you may not use this file except in compliance with the License.
 *  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the License for the specific language governing permissions and
 *  limitations under the License.
 */
package org.joda.time.tz;

import java.io.DataInput;
import java.io.DataInputStream;
import java.io.DataOutput;
import java.io.DataOutputStream;
import java.io.IOException;
import java.io.InputStream;
import java.io.OutputStream;
import java.text.DateFormatSymbols;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.HashSet;
import java.util.Iterator;
import java.util.Locale;
import java.util.Set;

import org.joda.time.Chronology;
import org.joda.time.DateTime;
import org.joda.time.DateTimeConstants;
import org.joda.time.DateTimeUtils;
import org.joda.time.DateTimeZone;
import org.joda.time.Period;
import org.joda.time.PeriodType;
import org.joda.time.chrono.ISOChronology;

/**
 * DateTimeZoneBuilder allows complex DateTimeZones to be constructed. Since
 * creating a new DateTimeZone this way is a relatively expensive operation,
 * built zones can be written to a file. Reading back the encoded data is a
 * quick operation.
 * &lt;p&gt;
 * DateTimeZoneBuilder itself is mutable and not thread-safe, but the
 * DateTimeZone objects that it builds are thread-safe and immutable.
 * &lt;p&gt;
 * It is intended that {@link ZoneInfoCompiler} be used to read time zone data
 * files, indirectly calling DateTimeZoneBuilder. The following complex
 * example defines the America/Los_Angeles time zone, with all historical
 * transitions:
 * 
 * &lt;pre&gt;
 * DateTimeZone America_Los_Angeles = new DateTimeZoneBuilder()
 *     .addCutover(-2147483648, 'w', 1, 1, 0, false, 0)
 *     .setStandardOffset(-28378000)
 *     .setFixedSavings(&quot;LMT&quot;, 0)
 *     .addCutover(1883, 'w', 11, 18, 0, false, 43200000)
 *     .setStandardOffset(-28800000)
 *     .addRecurringSavings(&quot;PDT&quot;, 3600000, 1918, 1919, 'w',  3, -1, 7, false, 7200000)
 *     .addRecurringSavings(&quot;PST&quot;,       0, 1918, 1919, 'w', 10, -1, 7, false, 7200000)
 *     .addRecurringSavings(&quot;PWT&quot;, 3600000, 1942, 1942, 'w',  2,  9, 0, false, 7200000)
 *     .addRecurringSavings(&quot;PPT&quot;, 3600000, 1945, 1945, 'u',  8, 14, 0, false, 82800000)
 *     .addRecurringSavings(&quot;PST&quot;,       0, 1945, 1945, 'w',  9, 30, 0, false, 7200000)
 *     .addRecurringSavings(&quot;PDT&quot;, 3600000, 1948, 1948, 'w',  3, 14, 0, false, 7200000)
 *     .addRecurringSavings(&quot;PST&quot;,       0, 1949, 1949, 'w',  1,  1, 0, false, 7200000)
 *     .addRecurringSavings(&quot;PDT&quot;, 3600000, 1950, 1966, 'w',  4, -1, 7, false, 7200000)
 *     .addRecurringSavings(&quot;PST&quot;,       0, 1950, 1961, 'w',  9, -1, 7, false, 7200000)
 *     .addRecurringSavings(&quot;PST&quot;,       0, 1962, 1966, 'w', 10, -1, 7, false, 7200000)
 *     .addRecurringSavings(&quot;PST&quot;,       0, 1967, 2147483647, 'w', 10, -1, 7, false, 7200000)
 *     .addRecurringSavings(&quot;PDT&quot;, 3600000, 1967, 1973, 'w', 4, -1,  7, false, 7200000)
 *     .addRecurringSavings(&quot;PDT&quot;, 3600000, 1974, 1974, 'w', 1,  6,  0, false, 7200000)
 *     .addRecurringSavings(&quot;PDT&quot;, 3600000, 1975, 1975, 'w', 2, 23,  0, false, 7200000)
 *     .addRecurringSavings(&quot;PDT&quot;, 3600000, 1976, 1986, 'w', 4, -1,  7, false, 7200000)
 *     .addRecurringSavings(&quot;PDT&quot;, 3600000, 1987, 2147483647, 'w', 4, 1, 7, true, 7200000)
 *     .toDateTimeZone(&quot;America/Los_Angeles&quot;, true);
 * &lt;/pre&gt;
 *
 * @author Brian S O'Neill
 * @see ZoneInfoCompiler
 * @see ZoneInfoProvider
 * @since 1.0
 */
public class DateTimeZoneBuilder {
    /**
     * Decodes a built DateTimeZone from the given stream, as encoded by
     * writeTo.
     *
     * @param in input stream to read encoded DateTimeZone from.
     * @param id time zone id to assign
     */
    public static DateTimeZone readFrom(InputStream in, String id) throws IOException {
<span class="pc bpc" id="L96" title="1 of 2 branches missed.">        if (in instanceof DataInput) {</span>
<span class="nc" id="L97">            return readFrom((DataInput)in, id);</span>
        } else {
<span class="fc" id="L99">            return readFrom((DataInput)new DataInputStream(in), id);</span>
        }
    }

    /**
     * Decodes a built DateTimeZone from the given stream, as encoded by
     * writeTo.
     *
     * @param in input stream to read encoded DateTimeZone from.
     * @param id time zone id to assign
     */
    public static DateTimeZone readFrom(DataInput in, String id) throws IOException {
<span class="pc bpc" id="L111" title="1 of 4 branches missed.">        switch (in.readUnsignedByte()) {</span>
        case 'F':
<span class="fc" id="L113">            DateTimeZone fixed = new FixedDateTimeZone</span>
<span class="fc" id="L114">                (id, in.readUTF(), (int)readMillis(in), (int)readMillis(in));</span>
<span class="pc bpc" id="L115" title="1 of 2 branches missed.">            if (fixed.equals(DateTimeZone.UTC)) {</span>
<span class="nc" id="L116">                fixed = DateTimeZone.UTC;</span>
            }
<span class="fc" id="L118">            return fixed;</span>
        case 'C':
<span class="fc" id="L120">            return CachedDateTimeZone.forZone(PrecalculatedZone.readFrom(in, id));</span>
        case 'P':
<span class="fc" id="L122">            return PrecalculatedZone.readFrom(in, id);</span>
        default:
<span class="nc" id="L124">            throw new IOException(&quot;Invalid encoding&quot;);</span>
        }
    }

    /**
     * Millisecond encoding formats:
     *
     * upper two bits  units       field length  approximate range
     * ---------------------------------------------------------------
     * 00              30 minutes  1 byte        +/- 16 hours
     * 01              minutes     4 bytes       +/- 1020 years
     * 10              seconds     5 bytes       +/- 4355 years
     * 11              millis      9 bytes       +/- 292,000,000 years
     *
     * Remaining bits in field form signed offset from 1970-01-01T00:00:00Z.
     */
    static void writeMillis(DataOutput out, long millis) throws IOException {
<span class="fc bfc" id="L141" title="All 2 branches covered.">        if (millis % (30 * 60000L) == 0) {</span>
            // Try to write in 30 minute units.
<span class="fc" id="L143">            long units = millis / (30 * 60000L);</span>
<span class="fc bfc" id="L144" title="All 2 branches covered.">            if (((units &lt;&lt; (64 - 6)) &gt;&gt; (64 - 6)) == units) {</span>
                // Form 00 (6 bits effective precision)
<span class="fc" id="L146">                out.writeByte((int)(units &amp; 0x3f));</span>
<span class="fc" id="L147">                return;</span>
            }
        }

<span class="fc bfc" id="L151" title="All 2 branches covered.">        if (millis % 60000L == 0) {</span>
            // Try to write minutes.
<span class="fc" id="L153">            long minutes = millis / 60000L;</span>
<span class="pc bpc" id="L154" title="1 of 2 branches missed.">            if (((minutes &lt;&lt; (64 - 30)) &gt;&gt; (64 - 30)) == minutes) {</span>
                // Form 01 (30 bits effective precision)
<span class="fc" id="L156">                out.writeInt(0x40000000 | (int)(minutes &amp; 0x3fffffff));</span>
<span class="fc" id="L157">                return;</span>
            }
        }
        
<span class="fc bfc" id="L161" title="All 2 branches covered.">        if (millis % 1000L == 0) {</span>
            // Try to write seconds.
<span class="fc" id="L163">            long seconds = millis / 1000L;</span>
<span class="pc bpc" id="L164" title="1 of 2 branches missed.">            if (((seconds &lt;&lt; (64 - 38)) &gt;&gt; (64 - 38)) == seconds) {</span>
                // Form 10 (38 bits effective precision)
<span class="fc" id="L166">                out.writeByte(0x80 | (int)((seconds &gt;&gt; 32) &amp; 0x3f));</span>
<span class="fc" id="L167">                out.writeInt((int)(seconds &amp; 0xffffffff));</span>
<span class="fc" id="L168">                return;</span>
            }
        }

        // Write milliseconds either because the additional precision is
        // required or the minutes didn't fit in the field.
        
        // Form 11 (64-bits effective precision, but write as if 70 bits)
<span class="pc bpc" id="L176" title="1 of 2 branches missed.">        out.writeByte(millis &lt; 0 ? 0xff : 0xc0);</span>
<span class="fc" id="L177">        out.writeLong(millis);</span>
<span class="fc" id="L178">    }</span>

    /**
     * Reads encoding generated by writeMillis.
     */
    static long readMillis(DataInput in) throws IOException {
<span class="fc" id="L184">        int v = in.readUnsignedByte();</span>
<span class="fc bfc" id="L185" title="All 4 branches covered.">        switch (v &gt;&gt; 6) {</span>
        case 0: default:
            // Form 00 (6 bits effective precision)
<span class="fc" id="L188">            v = (v &lt;&lt; (32 - 6)) &gt;&gt; (32 - 6);</span>
<span class="fc" id="L189">            return v * (30 * 60000L);</span>

        case 1:
            // Form 01 (30 bits effective precision)
<span class="fc" id="L193">            v = (v &lt;&lt; (32 - 6)) &gt;&gt; (32 - 30);</span>
<span class="fc" id="L194">            v |= (in.readUnsignedByte()) &lt;&lt; 16;</span>
<span class="fc" id="L195">            v |= (in.readUnsignedByte()) &lt;&lt; 8;</span>
<span class="fc" id="L196">            v |= (in.readUnsignedByte());</span>
<span class="fc" id="L197">            return v * 60000L;</span>

        case 2:
            // Form 10 (38 bits effective precision)
<span class="fc" id="L201">            long w = (((long)v) &lt;&lt; (64 - 6)) &gt;&gt; (64 - 38);</span>
<span class="fc" id="L202">            w |= (in.readUnsignedByte()) &lt;&lt; 24;</span>
<span class="fc" id="L203">            w |= (in.readUnsignedByte()) &lt;&lt; 16;</span>
<span class="fc" id="L204">            w |= (in.readUnsignedByte()) &lt;&lt; 8;</span>
<span class="fc" id="L205">            w |= (in.readUnsignedByte());</span>
<span class="fc" id="L206">            return w * 1000L;</span>

        case 3:
            // Form 11 (64-bits effective precision)
<span class="fc" id="L210">            return in.readLong();</span>
        }
    }

    private static DateTimeZone buildFixedZone(String id, String nameKey,
                                               int wallOffset, int standardOffset) {
<span class="pc bpc" id="L216" title="7 of 8 branches missed.">        if (&quot;UTC&quot;.equals(id) &amp;&amp; id.equals(nameKey) &amp;&amp;</span>
            wallOffset == 0 &amp;&amp; standardOffset == 0) {
<span class="nc" id="L218">            return DateTimeZone.UTC;</span>
        }
<span class="fc" id="L220">        return new FixedDateTimeZone(id, nameKey, wallOffset, standardOffset);</span>
    }

    // List of RuleSets.
    private final ArrayList&lt;RuleSet&gt; iRuleSets;

<span class="fc" id="L226">    public DateTimeZoneBuilder() {</span>
<span class="fc" id="L227">        iRuleSets = new ArrayList&lt;RuleSet&gt;(10);</span>
<span class="fc" id="L228">    }</span>

    /**
     * Adds a cutover for added rules. The standard offset at the cutover
     * defaults to 0. Call setStandardOffset afterwards to change it.
     *
     * @param year  the year of cutover
     * @param mode 'u' - cutover is measured against UTC, 'w' - against wall
     *  offset, 's' - against standard offset
     * @param monthOfYear  the month from 1 (January) to 12 (December)
     * @param dayOfMonth  if negative, set to ((last day of month) - ~dayOfMonth).
     *  For example, if -1, set to last day of month
     * @param dayOfWeek  from 1 (Monday) to 7 (Sunday), if 0 then ignore
     * @param advanceDayOfWeek  if dayOfMonth does not fall on dayOfWeek, advance to
     *  dayOfWeek when true, retreat when false.
     * @param millisOfDay  additional precision for specifying time of day of cutover
     */
    public DateTimeZoneBuilder addCutover(int year,
                                          char mode,
                                          int monthOfYear,
                                          int dayOfMonth,
                                          int dayOfWeek,
                                          boolean advanceDayOfWeek,
                                          int millisOfDay)
    {
<span class="fc bfc" id="L253" title="All 2 branches covered.">        if (iRuleSets.size() &gt; 0) {</span>
<span class="fc" id="L254">            OfYear ofYear = new OfYear</span>
                (mode, monthOfYear, dayOfMonth, dayOfWeek, advanceDayOfWeek, millisOfDay);
<span class="fc" id="L256">            RuleSet lastRuleSet = iRuleSets.get(iRuleSets.size() - 1);</span>
<span class="fc" id="L257">            lastRuleSet.setUpperLimit(year, ofYear);</span>
        }
<span class="fc" id="L259">        iRuleSets.add(new RuleSet());</span>
<span class="fc" id="L260">        return this;</span>
    }

    /**
     * Sets the standard offset to use for newly added rules until the next
     * cutover is added.
     * @param standardOffset  the standard offset in millis
     */
    public DateTimeZoneBuilder setStandardOffset(int standardOffset) {
<span class="fc" id="L269">        getLastRuleSet().setStandardOffset(standardOffset);</span>
<span class="fc" id="L270">        return this;</span>
    }

    /**
     * Set a fixed savings rule at the cutover.
     */
    public DateTimeZoneBuilder setFixedSavings(String nameKey, int saveMillis) {
<span class="fc" id="L277">        getLastRuleSet().setFixedSavings(nameKey, saveMillis);</span>
<span class="fc" id="L278">        return this;</span>
    }

    /**
     * Add a recurring daylight saving time rule.
     *
     * @param nameKey  the name key of new rule
     * @param saveMillis  the milliseconds to add to standard offset
     * @param fromYear  the first year that rule is in effect, MIN_VALUE indicates
     * beginning of time
     * @param toYear  the last year (inclusive) that rule is in effect, MAX_VALUE
     *  indicates end of time
     * @param mode  'u' - transitions are calculated against UTC, 'w' -
     *  transitions are calculated against wall offset, 's' - transitions are
     *  calculated against standard offset
     * @param monthOfYear  the month from 1 (January) to 12 (December)
     * @param dayOfMonth  if negative, set to ((last day of month) - ~dayOfMonth).
     *  For example, if -1, set to last day of month
     * @param dayOfWeek  from 1 (Monday) to 7 (Sunday), if 0 then ignore
     * @param advanceDayOfWeek  if dayOfMonth does not fall on dayOfWeek, advance to
     *  dayOfWeek when true, retreat when false.
     * @param millisOfDay  additional precision for specifying time of day of transitions
     */
    public DateTimeZoneBuilder addRecurringSavings(String nameKey, int saveMillis,
                                                   int fromYear, int toYear,
                                                   char mode,
                                                   int monthOfYear,
                                                   int dayOfMonth,
                                                   int dayOfWeek,
                                                   boolean advanceDayOfWeek,
                                                   int millisOfDay)
    {
<span class="pc bpc" id="L310" title="1 of 2 branches missed.">        if (fromYear &lt;= toYear) {</span>
<span class="fc" id="L311">            OfYear ofYear = new OfYear</span>
                (mode, monthOfYear, dayOfMonth, dayOfWeek, advanceDayOfWeek, millisOfDay);
<span class="fc" id="L313">            Recurrence recurrence = new Recurrence(ofYear, nameKey, saveMillis);</span>
<span class="fc" id="L314">            Rule rule = new Rule(recurrence, fromYear, toYear);</span>
<span class="fc" id="L315">            getLastRuleSet().addRule(rule);</span>
        }
<span class="fc" id="L317">        return this;</span>
    }

    private RuleSet getLastRuleSet() {
<span class="fc bfc" id="L321" title="All 2 branches covered.">        if (iRuleSets.size() == 0) {</span>
<span class="fc" id="L322">            addCutover(Integer.MIN_VALUE, 'w', 1, 1, 0, false, 0);</span>
        }
<span class="fc" id="L324">        return iRuleSets.get(iRuleSets.size() - 1);</span>
    }
    
    /**
     * Processes all the rules and builds a DateTimeZone.
     *
     * @param id  time zone id to assign
     * @param outputID  true if the zone id should be output
     */
    public DateTimeZone toDateTimeZone(String id, boolean outputID) {
<span class="pc bpc" id="L334" title="1 of 2 branches missed.">        if (id == null) {</span>
<span class="nc" id="L335">            throw new IllegalArgumentException();</span>
        }

        // Discover where all the transitions occur and store the results in
        // these lists.
<span class="fc" id="L340">        ArrayList&lt;Transition&gt; transitions = new ArrayList&lt;Transition&gt;();</span>

        // Tail zone picks up remaining transitions in the form of an endless
        // DST cycle.
<span class="fc" id="L344">        DSTZone tailZone = null;</span>

<span class="fc" id="L346">        long millis = Long.MIN_VALUE;</span>
<span class="fc" id="L347">        int saveMillis = 0;</span>
            
<span class="fc" id="L349">        int ruleSetCount = iRuleSets.size();</span>
<span class="fc bfc" id="L350" title="All 2 branches covered.">        for (int i=0; i&lt;ruleSetCount; i++) {</span>
<span class="fc" id="L351">            RuleSet rs = iRuleSets.get(i);</span>
<span class="fc" id="L352">            Transition next = rs.firstTransition(millis);</span>
<span class="pc bpc" id="L353" title="1 of 2 branches missed.">            if (next == null) {</span>
<span class="nc" id="L354">                continue;</span>
            }
<span class="fc" id="L356">            addTransition(transitions, next);</span>
<span class="fc" id="L357">            millis = next.getMillis();</span>
<span class="fc" id="L358">            saveMillis = next.getSaveMillis();</span>

            // Copy it since we're going to destroy it.
<span class="fc" id="L361">            rs = new RuleSet(rs);</span>

<span class="fc bfc" id="L363" title="All 2 branches covered.">            while ((next = rs.nextTransition(millis, saveMillis)) != null) {</span>
<span class="fc bfc" id="L364" title="All 4 branches covered.">                if (addTransition(transitions, next) &amp;&amp; tailZone != null) {</span>
                    // Got the extra transition before DSTZone.
<span class="fc" id="L366">                    break;</span>
                }
<span class="fc" id="L368">                millis = next.getMillis();</span>
<span class="fc" id="L369">                saveMillis = next.getSaveMillis();</span>
<span class="fc bfc" id="L370" title="All 4 branches covered.">                if (tailZone == null &amp;&amp; i == ruleSetCount - 1) {</span>
<span class="fc" id="L371">                    tailZone = rs.buildTailZone(id);</span>
                    // If tailZone is not null, don't break out of main loop until
                    // at least one more transition is calculated. This ensures a
                    // correct 'seam' to the DSTZone.
                }
            }

<span class="fc" id="L378">            millis = rs.getUpperLimit(saveMillis);</span>
        }

        // Check if a simpler zone implementation can be returned.
<span class="pc bpc" id="L382" title="1 of 2 branches missed.">        if (transitions.size() == 0) {</span>
<span class="nc bnc" id="L383" title="All 2 branches missed.">            if (tailZone != null) {</span>
                // This shouldn't happen, but handle just in case.
<span class="nc" id="L385">                return tailZone;</span>
            }
<span class="nc" id="L387">            return buildFixedZone(id, &quot;UTC&quot;, 0, 0);</span>
        }
<span class="pc bpc" id="L389" title="1 of 4 branches missed.">        if (transitions.size() == 1 &amp;&amp; tailZone == null) {</span>
<span class="fc" id="L390">            Transition tr = transitions.get(0);</span>
<span class="fc" id="L391">            return buildFixedZone(id, tr.getNameKey(),</span>
<span class="fc" id="L392">                                  tr.getWallOffset(), tr.getStandardOffset());</span>
        }

<span class="fc" id="L395">        PrecalculatedZone zone = PrecalculatedZone.create(id, outputID, transitions, tailZone);</span>
<span class="fc bfc" id="L396" title="All 2 branches covered.">        if (zone.isCachable()) {</span>
<span class="fc" id="L397">            return CachedDateTimeZone.forZone(zone);</span>
        }
<span class="fc" id="L399">        return zone;</span>
    }

    private boolean addTransition(ArrayList&lt;Transition&gt; transitions, Transition tr) {
<span class="fc" id="L403">        int size = transitions.size();</span>
<span class="fc bfc" id="L404" title="All 2 branches covered.">        if (size == 0) {</span>
//            System.out.println(&quot;Adding   &quot; + tr);
<span class="fc" id="L406">            transitions.add(tr);</span>
<span class="fc" id="L407">            return true;</span>
        }

<span class="fc" id="L410">        Transition last = transitions.get(size - 1);</span>
<span class="fc bfc" id="L411" title="All 2 branches covered.">        if (!tr.isTransitionFrom(last)) {</span>
//            System.out.println(&quot;Rejected &quot; + tr);
<span class="fc" id="L413">            return false;</span>
        }

        // If local time of new transition is same as last local time, just
        // replace last transition with new one.
<span class="fc" id="L418">        int offsetForLast = 0;</span>
<span class="fc bfc" id="L419" title="All 2 branches covered.">        if (size &gt;= 2) {</span>
<span class="fc" id="L420">            offsetForLast = transitions.get(size - 2).getWallOffset();</span>
        }
<span class="fc" id="L422">        int offsetForNew = last.getWallOffset();</span>

<span class="fc" id="L424">        long lastLocal = last.getMillis() + offsetForLast;</span>
<span class="fc" id="L425">        long newLocal = tr.getMillis() + offsetForNew;</span>

<span class="pc bpc" id="L427" title="1 of 2 branches missed.">        if (newLocal != lastLocal) {</span>
<span class="fc" id="L428">            transitions.add(tr);</span>
//            System.out.println(&quot;Adding   &quot; + tr);
<span class="fc" id="L430">            return true;</span>
        }
<span class="nc" id="L432">        Transition previous = transitions.remove(size - 1);</span>
<span class="nc" id="L433">        Transition adjusted = tr.withMillis(previous.getMillis());</span>
//        System.out.println(&quot;Current  &quot; + tr);
//        System.out.println(&quot;Previous &quot; + previous);
//        System.out.println(&quot;Adjusted &quot; + adjusted);
<span class="nc" id="L437">        return addTransition(transitions, adjusted);</span>
    }

    /**
     * Encodes a built DateTimeZone to the given stream. Call readFrom to
     * decode the data into a DateTimeZone object.
     *
     * @param out  the output stream to receive the encoded DateTimeZone
     * @since 1.5 (parameter added)
     */
    public void writeTo(String zoneID, OutputStream out) throws IOException {
<span class="pc bpc" id="L448" title="1 of 2 branches missed.">        if (out instanceof DataOutput) {</span>
<span class="nc" id="L449">            writeTo(zoneID, (DataOutput)out);</span>
        } else {
<span class="fc" id="L451">            DataOutputStream dout = new DataOutputStream(out);</span>
<span class="fc" id="L452">            writeTo(zoneID, (DataOutput)dout);</span>
<span class="fc" id="L453">            dout.flush();</span>
        }
<span class="fc" id="L455">    }</span>

    /**
     * Encodes a built DateTimeZone to the given stream. Call readFrom to
     * decode the data into a DateTimeZone object.
     *
     * @param out  the output stream to receive the encoded DateTimeZone
     * @since 1.5 (parameter added)
     */
    public void writeTo(String zoneID, DataOutput out) throws IOException {
        // pass false so zone id is not written out
<span class="fc" id="L466">        DateTimeZone zone = toDateTimeZone(zoneID, false);</span>

<span class="fc bfc" id="L468" title="All 2 branches covered.">        if (zone instanceof FixedDateTimeZone) {</span>
<span class="fc" id="L469">            out.writeByte('F'); // 'F' for fixed</span>
<span class="fc" id="L470">            out.writeUTF(zone.getNameKey(0));</span>
<span class="fc" id="L471">            writeMillis(out, zone.getOffset(0));</span>
<span class="fc" id="L472">            writeMillis(out, zone.getStandardOffset(0));</span>
        } else {
<span class="pc bpc" id="L474" title="1 of 2 branches missed.">            if (zone instanceof CachedDateTimeZone) {</span>
<span class="fc" id="L475">                out.writeByte('C'); // 'C' for cached, precalculated</span>
<span class="fc" id="L476">                zone = ((CachedDateTimeZone)zone).getUncachedZone();</span>
            } else {
<span class="nc" id="L478">                out.writeByte('P'); // 'P' for precalculated, uncached</span>
            }
<span class="fc" id="L480">            ((PrecalculatedZone)zone).writeTo(out);</span>
        }
<span class="fc" id="L482">    }</span>

    /**
     * Supports setting fields of year and moving between transitions.
     */
    private static final class OfYear {
        static OfYear readFrom(DataInput in) throws IOException {
<span class="fc" id="L489">            return new OfYear((char)in.readUnsignedByte(),</span>
<span class="fc" id="L490">                              (int)in.readUnsignedByte(),</span>
<span class="fc" id="L491">                              (int)in.readByte(),</span>
<span class="fc" id="L492">                              (int)in.readUnsignedByte(),</span>
<span class="fc" id="L493">                              in.readBoolean(),</span>
<span class="fc" id="L494">                              (int)readMillis(in));</span>
        }

        // Is 'u', 'w', or 's'.
        final char iMode;

        final int iMonthOfYear;
        final int iDayOfMonth;
        final int iDayOfWeek;
        final boolean iAdvance;
        final int iMillisOfDay;

        OfYear(char mode,
               int monthOfYear,
               int dayOfMonth,
               int dayOfWeek, boolean advanceDayOfWeek,
               int millisOfDay)
<span class="fc" id="L511">        {</span>
<span class="pc bpc" id="L512" title="1 of 6 branches missed.">            if (mode != 'u' &amp;&amp; mode != 'w' &amp;&amp; mode != 's') {</span>
<span class="nc" id="L513">                throw new IllegalArgumentException(&quot;Unknown mode: &quot; + mode);</span>
            }

<span class="fc" id="L516">            iMode = mode;</span>
<span class="fc" id="L517">            iMonthOfYear = monthOfYear;</span>
<span class="fc" id="L518">            iDayOfMonth = dayOfMonth;</span>
<span class="fc" id="L519">            iDayOfWeek = dayOfWeek;</span>
<span class="fc" id="L520">            iAdvance = advanceDayOfWeek;</span>
<span class="fc" id="L521">            iMillisOfDay = millisOfDay;</span>
<span class="fc" id="L522">        }</span>

        /**
         * @param standardOffset standard offset just before instant
         */
        public long setInstant(int year, int standardOffset, int saveMillis) {
            int offset;
<span class="pc bpc" id="L529" title="1 of 2 branches missed.">            if (iMode == 'w') {</span>
<span class="fc" id="L530">                offset = standardOffset + saveMillis;</span>
<span class="nc bnc" id="L531" title="All 2 branches missed.">            } else if (iMode == 's') {</span>
<span class="nc" id="L532">                offset = standardOffset;</span>
            } else {
<span class="nc" id="L534">                offset = 0;</span>
            }

<span class="fc" id="L537">            Chronology chrono = ISOChronology.getInstanceUTC();</span>
<span class="fc" id="L538">            long millis = chrono.year().set(0, year);</span>
<span class="fc" id="L539">            millis = chrono.monthOfYear().set(millis, iMonthOfYear);</span>
<span class="fc" id="L540">            millis = chrono.millisOfDay().set(millis, iMillisOfDay);</span>
<span class="fc" id="L541">            millis = setDayOfMonth(chrono, millis);</span>

<span class="pc bpc" id="L543" title="1 of 2 branches missed.">            if (iDayOfWeek != 0) {</span>
<span class="nc" id="L544">                millis = setDayOfWeek(chrono, millis);</span>
            }

            // Convert from local time to UTC.
<span class="fc" id="L548">            return millis - offset;</span>
        }

        /**
         * @param standardOffset standard offset just before next recurrence
         */
        public long next(long instant, int standardOffset, int saveMillis) {
            int offset;
<span class="fc bfc" id="L556" title="All 2 branches covered.">            if (iMode == 'w') {</span>
<span class="fc" id="L557">                offset = standardOffset + saveMillis;</span>
<span class="fc bfc" id="L558" title="All 2 branches covered.">            } else if (iMode == 's') {</span>
<span class="fc" id="L559">                offset = standardOffset;</span>
            } else {
<span class="fc" id="L561">                offset = 0;</span>
            }

            // Convert from UTC to local time.
<span class="fc" id="L565">            instant += offset;</span>

<span class="fc" id="L567">            Chronology chrono = ISOChronology.getInstanceUTC();</span>
<span class="fc" id="L568">            long next = chrono.monthOfYear().set(instant, iMonthOfYear);</span>
            // Be lenient with millisOfDay.
<span class="fc" id="L570">            next = chrono.millisOfDay().set(next, 0);</span>
<span class="fc" id="L571">            next = chrono.millisOfDay().add(next, iMillisOfDay);</span>
<span class="fc" id="L572">            next = setDayOfMonthNext(chrono, next);</span>

<span class="fc bfc" id="L574" title="All 2 branches covered.">            if (iDayOfWeek == 0) {</span>
<span class="fc bfc" id="L575" title="All 2 branches covered.">                if (next &lt;= instant) {</span>
<span class="fc" id="L576">                    next = chrono.year().add(next, 1);</span>
<span class="fc" id="L577">                    next = setDayOfMonthNext(chrono, next);</span>
                }
            } else {
<span class="fc" id="L580">                next = setDayOfWeek(chrono, next);</span>
<span class="fc bfc" id="L581" title="All 2 branches covered.">                if (next &lt;= instant) {</span>
<span class="fc" id="L582">                    next = chrono.year().add(next, 1);</span>
<span class="fc" id="L583">                    next = chrono.monthOfYear().set(next, iMonthOfYear);</span>
<span class="fc" id="L584">                    next = setDayOfMonthNext(chrono, next);</span>
<span class="fc" id="L585">                    next = setDayOfWeek(chrono, next);</span>
                }
            }
<span class="fc" id="L588">            next = chrono.millisOfDay().set(next, 0);</span>
<span class="fc" id="L589">            next = chrono.millisOfDay().add(next, iMillisOfDay);</span>

            // Convert from local time to UTC.
<span class="fc" id="L592">            return next - offset;</span>
        }

        /**
         * @param standardOffset standard offset just before previous recurrence
         */
        public long previous(long instant, int standardOffset, int saveMillis) {
            int offset;
<span class="fc bfc" id="L600" title="All 2 branches covered.">            if (iMode == 'w') {</span>
<span class="fc" id="L601">                offset = standardOffset + saveMillis;</span>
<span class="fc bfc" id="L602" title="All 2 branches covered.">            } else if (iMode == 's') {</span>
<span class="fc" id="L603">                offset = standardOffset;</span>
            } else {
<span class="fc" id="L605">                offset = 0;</span>
            }

            // Convert from UTC to local time.
<span class="fc" id="L609">            instant += offset;</span>

<span class="fc" id="L611">            Chronology chrono = ISOChronology.getInstanceUTC();</span>
<span class="fc" id="L612">            long prev = chrono.monthOfYear().set(instant, iMonthOfYear);</span>
            // Be lenient with millisOfDay.
<span class="fc" id="L614">            prev = chrono.millisOfDay().set(prev, 0);</span>
<span class="fc" id="L615">            prev = chrono.millisOfDay().add(prev, iMillisOfDay);</span>
<span class="fc" id="L616">            prev = setDayOfMonthPrevious(chrono, prev);</span>

<span class="pc bpc" id="L618" title="1 of 2 branches missed.">            if (iDayOfWeek == 0) {</span>
<span class="nc bnc" id="L619" title="All 2 branches missed.">                if (prev &gt;= instant) {</span>
<span class="nc" id="L620">                    prev = chrono.year().add(prev, -1);</span>
<span class="nc" id="L621">                    prev = setDayOfMonthPrevious(chrono, prev);</span>
                }
            } else {
<span class="fc" id="L624">                prev = setDayOfWeek(chrono, prev);</span>
<span class="fc bfc" id="L625" title="All 2 branches covered.">                if (prev &gt;= instant) {</span>
<span class="fc" id="L626">                    prev = chrono.year().add(prev, -1);</span>
<span class="fc" id="L627">                    prev = chrono.monthOfYear().set(prev, iMonthOfYear);</span>
<span class="fc" id="L628">                    prev = setDayOfMonthPrevious(chrono, prev);</span>
<span class="fc" id="L629">                    prev = setDayOfWeek(chrono, prev);</span>
                }
            }
<span class="fc" id="L632">            prev = chrono.millisOfDay().set(prev, 0);</span>
<span class="fc" id="L633">            prev = chrono.millisOfDay().add(prev, iMillisOfDay);</span>

            // Convert from local time to UTC.
<span class="fc" id="L636">            return prev - offset;</span>
        }

        public boolean equals(Object obj) {
<span class="pc bpc" id="L640" title="1 of 2 branches missed.">            if (this == obj) {</span>
<span class="nc" id="L641">                return true;</span>
            }
<span class="pc bpc" id="L643" title="1 of 2 branches missed.">            if (obj instanceof OfYear) {</span>
<span class="fc" id="L644">                OfYear other = (OfYear)obj;</span>
<span class="pc bpc" id="L645" title="6 of 12 branches missed.">                return</span>
                    iMode == other.iMode &amp;&amp;
                    iMonthOfYear == other.iMonthOfYear &amp;&amp;
                    iDayOfMonth == other.iDayOfMonth &amp;&amp;
                    iDayOfWeek == other.iDayOfWeek &amp;&amp;
                    iAdvance == other.iAdvance &amp;&amp;
                    iMillisOfDay == other.iMillisOfDay;
            }
<span class="nc" id="L653">            return false;</span>
        }

        public String toString() {
<span class="nc" id="L657">            return</span>
                &quot;[OfYear]\n&quot; + 
                &quot;Mode: &quot; + iMode + '\n' +
                &quot;MonthOfYear: &quot; + iMonthOfYear + '\n' +
                &quot;DayOfMonth: &quot; + iDayOfMonth + '\n' +
                &quot;DayOfWeek: &quot; + iDayOfWeek + '\n' +
                &quot;AdvanceDayOfWeek: &quot; + iAdvance + '\n' +
                &quot;MillisOfDay: &quot; + iMillisOfDay + '\n';
        }

        public void writeTo(DataOutput out) throws IOException {
<span class="fc" id="L668">            out.writeByte(iMode);</span>
<span class="fc" id="L669">            out.writeByte(iMonthOfYear);</span>
<span class="fc" id="L670">            out.writeByte(iDayOfMonth);</span>
<span class="fc" id="L671">            out.writeByte(iDayOfWeek);</span>
<span class="fc" id="L672">            out.writeBoolean(iAdvance);</span>
<span class="fc" id="L673">            writeMillis(out, iMillisOfDay);</span>
<span class="fc" id="L674">        }</span>

        /**
         * If month-day is 02-29 and year isn't leap, advances to next leap year.
         */
        private long setDayOfMonthNext(Chronology chrono, long next) {
            try {
<span class="fc" id="L681">                next = setDayOfMonth(chrono, next);</span>
<span class="nc" id="L682">            } catch (IllegalArgumentException e) {</span>
<span class="nc bnc" id="L683" title="All 4 branches missed.">                if (iMonthOfYear == 2 &amp;&amp; iDayOfMonth == 29) {</span>
<span class="nc bnc" id="L684" title="All 2 branches missed.">                    while (chrono.year().isLeap(next) == false) {</span>
<span class="nc" id="L685">                        next = chrono.year().add(next, 1);</span>
                    }
<span class="nc" id="L687">                    next = setDayOfMonth(chrono, next);</span>
                } else {
<span class="nc" id="L689">                    throw e;</span>
                }
<span class="fc" id="L691">            }</span>
<span class="fc" id="L692">            return next;</span>
        }

        /**
         * If month-day is 02-29 and year isn't leap, retreats to previous leap year.
         */
        private long setDayOfMonthPrevious(Chronology chrono, long prev) {
            try {
<span class="fc" id="L700">                prev = setDayOfMonth(chrono, prev);</span>
<span class="nc" id="L701">            } catch (IllegalArgumentException e) {</span>
<span class="nc bnc" id="L702" title="All 4 branches missed.">                if (iMonthOfYear == 2 &amp;&amp; iDayOfMonth == 29) {</span>
<span class="nc bnc" id="L703" title="All 2 branches missed.">                    while (chrono.year().isLeap(prev) == false) {</span>
<span class="nc" id="L704">                        prev = chrono.year().add(prev, -1);</span>
                    }
<span class="nc" id="L706">                    prev = setDayOfMonth(chrono, prev);</span>
                } else {
<span class="nc" id="L708">                    throw e;</span>
                }
<span class="fc" id="L710">            }</span>
<span class="fc" id="L711">            return prev;</span>
        }

        private long setDayOfMonth(Chronology chrono, long instant) {
<span class="fc bfc" id="L715" title="All 2 branches covered.">            if (iDayOfMonth &gt;= 0) {</span>
<span class="fc" id="L716">                instant = chrono.dayOfMonth().set(instant, iDayOfMonth);</span>
            } else {
<span class="fc" id="L718">                instant = chrono.dayOfMonth().set(instant, 1);</span>
<span class="fc" id="L719">                instant = chrono.monthOfYear().add(instant, 1);</span>
<span class="fc" id="L720">                instant = chrono.dayOfMonth().add(instant, iDayOfMonth);</span>
            }
<span class="fc" id="L722">            return instant;</span>
        }

        private long setDayOfWeek(Chronology chrono, long instant) {
<span class="fc" id="L726">            int dayOfWeek = chrono.dayOfWeek().get(instant);</span>
<span class="fc" id="L727">            int daysToAdd = iDayOfWeek - dayOfWeek;</span>
<span class="fc bfc" id="L728" title="All 2 branches covered.">            if (daysToAdd != 0) {</span>
<span class="fc bfc" id="L729" title="All 2 branches covered.">                if (iAdvance) {</span>
<span class="pc bpc" id="L730" title="1 of 2 branches missed.">                    if (daysToAdd &lt; 0) {</span>
<span class="nc" id="L731">                        daysToAdd += 7;</span>
                    }
                } else {
<span class="fc bfc" id="L734" title="All 2 branches covered.">                    if (daysToAdd &gt; 0) {</span>
<span class="fc" id="L735">                        daysToAdd -= 7;</span>
                    }
                }
<span class="fc" id="L738">                instant = chrono.dayOfWeek().add(instant, daysToAdd);</span>
            }
<span class="fc" id="L740">            return instant;</span>
        }
    }

    /**
     * Extends OfYear with a nameKey and savings.
     */
    private static final class Recurrence {
        static Recurrence readFrom(DataInput in) throws IOException {
<span class="fc" id="L749">            return new Recurrence(OfYear.readFrom(in), in.readUTF(), (int)readMillis(in));</span>
        }

        final OfYear iOfYear;
        final String iNameKey;
        final int iSaveMillis;

<span class="fc" id="L756">        Recurrence(OfYear ofYear, String nameKey, int saveMillis) {</span>
<span class="fc" id="L757">            iOfYear = ofYear;</span>
<span class="fc" id="L758">            iNameKey = nameKey;</span>
<span class="fc" id="L759">            iSaveMillis = saveMillis;</span>
<span class="fc" id="L760">        }</span>

        public OfYear getOfYear() {
<span class="nc" id="L763">            return iOfYear;</span>
        }

        /**
         * @param standardOffset standard offset just before next recurrence
         */
        public long next(long instant, int standardOffset, int saveMillis) {
<span class="fc" id="L770">            return iOfYear.next(instant, standardOffset, saveMillis);</span>
        }

        /**
         * @param standardOffset standard offset just before previous recurrence
         */
        public long previous(long instant, int standardOffset, int saveMillis) {
<span class="fc" id="L777">            return iOfYear.previous(instant, standardOffset, saveMillis);</span>
        }

        public String getNameKey() {
<span class="fc" id="L781">            return iNameKey;</span>
        }

        public int getSaveMillis() {
<span class="fc" id="L785">            return iSaveMillis;</span>
        }

        public boolean equals(Object obj) {
<span class="pc bpc" id="L789" title="1 of 2 branches missed.">            if (this == obj) {</span>
<span class="nc" id="L790">                return true;</span>
            }
<span class="pc bpc" id="L792" title="1 of 2 branches missed.">            if (obj instanceof Recurrence) {</span>
<span class="fc" id="L793">                Recurrence other = (Recurrence)obj;</span>
<span class="pc bpc" id="L794" title="1 of 2 branches missed.">                return</span>
                    iSaveMillis == other.iSaveMillis &amp;&amp;
<span class="pc bpc" id="L796" title="1 of 2 branches missed.">                    iNameKey.equals(other.iNameKey) &amp;&amp;</span>
<span class="pc bpc" id="L797" title="1 of 2 branches missed.">                    iOfYear.equals(other.iOfYear);</span>
            }
<span class="nc" id="L799">            return false;</span>
        }

        public void writeTo(DataOutput out) throws IOException {
<span class="fc" id="L803">            iOfYear.writeTo(out);</span>
<span class="fc" id="L804">            out.writeUTF(iNameKey);</span>
<span class="fc" id="L805">            writeMillis(out, iSaveMillis);</span>
<span class="fc" id="L806">        }</span>

        Recurrence rename(String nameKey) {
<span class="fc" id="L809">            return new Recurrence(iOfYear, nameKey, iSaveMillis);</span>
        }

        Recurrence renameAppend(String appendNameKey) {
<span class="fc" id="L813">            return rename((iNameKey + appendNameKey).intern());</span>
        }
        
        @Override
        public String toString() {
<span class="nc" id="L818">            return iOfYear + &quot; named &quot; + iNameKey + &quot; at &quot; + iSaveMillis;</span>
        }
    }

    /**
     * Extends Recurrence with inclusive year limits.
     */
    private static final class Rule {
        final Recurrence iRecurrence;
        final int iFromYear; // inclusive
        final int iToYear;   // inclusive

<span class="fc" id="L830">        Rule(Recurrence recurrence, int fromYear, int toYear) {</span>
<span class="fc" id="L831">            iRecurrence = recurrence;</span>
<span class="fc" id="L832">            iFromYear = fromYear;</span>
<span class="fc" id="L833">            iToYear = toYear;</span>
<span class="fc" id="L834">        }</span>

        @SuppressWarnings(&quot;unused&quot;)
        public int getFromYear() {
<span class="nc" id="L838">            return iFromYear;</span>
        }

        public int getToYear() {
<span class="fc" id="L842">            return iToYear;</span>
        }

        @SuppressWarnings(&quot;unused&quot;)
        public OfYear getOfYear() {
<span class="nc" id="L847">            return iRecurrence.getOfYear();</span>
        }

        public String getNameKey() {
<span class="fc" id="L851">            return iRecurrence.getNameKey();</span>
        }

        public int getSaveMillis() {
<span class="fc" id="L855">            return iRecurrence.getSaveMillis();</span>
        }

        public long next(final long instant, int standardOffset, int saveMillis) {
<span class="fc" id="L859">            Chronology chrono = ISOChronology.getInstanceUTC();</span>

<span class="fc" id="L861">            final int wallOffset = standardOffset + saveMillis;</span>
<span class="fc" id="L862">            long testInstant = instant;</span>

            int year;
<span class="fc bfc" id="L865" title="All 2 branches covered.">            if (instant == Long.MIN_VALUE) {</span>
<span class="fc" id="L866">                year = Integer.MIN_VALUE;</span>
            } else {
<span class="fc" id="L868">                year = chrono.year().get(instant + wallOffset);</span>
            }

<span class="fc bfc" id="L871" title="All 2 branches covered.">            if (year &lt; iFromYear) {</span>
                // First advance instant to start of from year.
<span class="fc" id="L873">                testInstant = chrono.year().set(0, iFromYear) - wallOffset;</span>
                // Back off one millisecond to account for next recurrence
                // being exactly at the beginning of the year.
<span class="fc" id="L876">                testInstant -= 1;</span>
            }

<span class="fc" id="L879">            long next = iRecurrence.next(testInstant, standardOffset, saveMillis);</span>

<span class="pc bpc" id="L881" title="1 of 2 branches missed.">            if (next &gt; instant) {</span>
<span class="fc" id="L882">                year = chrono.year().get(next + wallOffset);</span>
<span class="fc bfc" id="L883" title="All 2 branches covered.">                if (year &gt; iToYear) {</span>
                    // Out of range, return original value.
<span class="fc" id="L885">                    next = instant;</span>
                }
            }

<span class="fc" id="L889">            return next;</span>
        }
        
        @Override
        public String toString() {
<span class="nc" id="L894">            return iFromYear + &quot; to &quot; + iToYear + &quot; using &quot; + iRecurrence;</span>
        }
    }

    private static final class Transition {
        private final long iMillis;
        private final String iNameKey;
        private final int iWallOffset;
        private final int iStandardOffset;

<span class="fc" id="L904">        Transition(long millis, Transition tr) {</span>
<span class="fc" id="L905">            iMillis = millis;</span>
<span class="fc" id="L906">            iNameKey = tr.iNameKey;</span>
<span class="fc" id="L907">            iWallOffset = tr.iWallOffset;</span>
<span class="fc" id="L908">            iStandardOffset = tr.iStandardOffset;</span>
<span class="fc" id="L909">        }</span>

<span class="fc" id="L911">        Transition(long millis, Rule rule, int standardOffset) {</span>
<span class="fc" id="L912">            iMillis = millis;</span>
<span class="fc" id="L913">            iNameKey = rule.getNameKey();</span>
<span class="fc" id="L914">            iWallOffset = standardOffset + rule.getSaveMillis();</span>
<span class="fc" id="L915">            iStandardOffset = standardOffset;</span>
<span class="fc" id="L916">        }</span>

        Transition(long millis, String nameKey,
<span class="fc" id="L919">                   int wallOffset, int standardOffset) {</span>
<span class="fc" id="L920">            iMillis = millis;</span>
<span class="fc" id="L921">            iNameKey = nameKey;</span>
<span class="fc" id="L922">            iWallOffset = wallOffset;</span>
<span class="fc" id="L923">            iStandardOffset = standardOffset;</span>
<span class="fc" id="L924">        }</span>

        public long getMillis() {
<span class="fc" id="L927">            return iMillis;</span>
        }

        public String getNameKey() {
<span class="fc" id="L931">            return iNameKey;</span>
        }

        public int getWallOffset() {
<span class="fc" id="L935">            return iWallOffset;</span>
        }

        public int getStandardOffset() {
<span class="fc" id="L939">            return iStandardOffset;</span>
        }

        public int getSaveMillis() {
<span class="fc" id="L943">            return iWallOffset - iStandardOffset;</span>
        }

        public Transition withMillis(long millis) {
<span class="nc" id="L947">            return new Transition(millis, iNameKey, iWallOffset, iStandardOffset);</span>
        }

        /**
         * There must be a change in the millis, wall offsets or name keys.
         */
        public boolean isTransitionFrom(Transition other) {
<span class="fc bfc" id="L954" title="All 2 branches covered.">            if (other == null) {</span>
<span class="fc" id="L955">                return true;</span>
            }
<span class="pc bpc" id="L957" title="2 of 6 branches missed.">            return iMillis &gt; other.iMillis &amp;&amp;</span>
                (iWallOffset != other.iWallOffset ||
                 iStandardOffset != other.iStandardOffset ||
<span class="fc bfc" id="L960" title="All 2 branches covered.">                 !(iNameKey.equals(other.iNameKey)));</span>
        }
        
        @Override
        public String toString() {
<span class="nc" id="L965">            return new DateTime(iMillis, DateTimeZone.UTC) + &quot; &quot; + iStandardOffset + &quot; &quot; + iWallOffset;</span>
        }
    }

    private static final class RuleSet {
        private static final int YEAR_LIMIT;

        static {
            // Don't pre-calculate more than 100 years into the future. Almost
            // all zones will stop pre-calculating far sooner anyhow. Either a
            // simple DST cycle is detected or the last rule is a fixed
            // offset. If a zone has a fixed offset set more than 100 years
            // into the future, then it won't be observed.
<span class="fc" id="L978">            long now = DateTimeUtils.currentTimeMillis();</span>
<span class="fc" id="L979">            YEAR_LIMIT = ISOChronology.getInstanceUTC().year().get(now) + 100;</span>
<span class="fc" id="L980">        }</span>

        private int iStandardOffset;
        private ArrayList&lt;Rule&gt; iRules;

        // Optional.
        private String iInitialNameKey;
        private int iInitialSaveMillis;

        // Upper limit is exclusive.
        private int iUpperYear;
        private OfYear iUpperOfYear;

<span class="fc" id="L993">        RuleSet() {</span>
<span class="fc" id="L994">            iRules = new ArrayList&lt;Rule&gt;(10);</span>
<span class="fc" id="L995">            iUpperYear = Integer.MAX_VALUE;</span>
<span class="fc" id="L996">        }</span>

        /**
         * Copy constructor.
         */
<span class="fc" id="L1001">        RuleSet(RuleSet rs) {</span>
<span class="fc" id="L1002">            iStandardOffset = rs.iStandardOffset;</span>
<span class="fc" id="L1003">            iRules = new ArrayList&lt;Rule&gt;(rs.iRules);</span>
<span class="fc" id="L1004">            iInitialNameKey = rs.iInitialNameKey;</span>
<span class="fc" id="L1005">            iInitialSaveMillis = rs.iInitialSaveMillis;</span>
<span class="fc" id="L1006">            iUpperYear = rs.iUpperYear;</span>
<span class="fc" id="L1007">            iUpperOfYear = rs.iUpperOfYear;</span>
<span class="fc" id="L1008">        }</span>

        @SuppressWarnings(&quot;unused&quot;)
        public int getStandardOffset() {
<span class="nc" id="L1012">            return iStandardOffset;</span>
        }

        public void setStandardOffset(int standardOffset) {
<span class="fc" id="L1016">            iStandardOffset = standardOffset;</span>
<span class="fc" id="L1017">        }</span>

        public void setFixedSavings(String nameKey, int saveMillis) {
<span class="fc" id="L1020">            iInitialNameKey = nameKey;</span>
<span class="fc" id="L1021">            iInitialSaveMillis = saveMillis;</span>
<span class="fc" id="L1022">        }</span>

        public void addRule(Rule rule) {
<span class="pc bpc" id="L1025" title="1 of 2 branches missed.">            if (!iRules.contains(rule)) {</span>
<span class="fc" id="L1026">                iRules.add(rule);</span>
            }
<span class="fc" id="L1028">        }</span>

        public void setUpperLimit(int year, OfYear ofYear) {
<span class="fc" id="L1031">            iUpperYear = year;</span>
<span class="fc" id="L1032">            iUpperOfYear = ofYear;</span>
<span class="fc" id="L1033">        }</span>

        /**
         * Returns a transition at firstMillis with the first name key and
         * offsets for this rule set. This method may return null.
         *
         * @param firstMillis millis of first transition
         */
        public Transition firstTransition(final long firstMillis) {
<span class="fc bfc" id="L1042" title="All 2 branches covered.">            if (iInitialNameKey != null) {</span>
                // Initial zone info explicitly set, so don't search the rules.
<span class="fc" id="L1044">                return new Transition(firstMillis, iInitialNameKey,</span>
                                      iStandardOffset + iInitialSaveMillis, iStandardOffset);
            }

            // Make a copy before we destroy the rules.
<span class="fc" id="L1049">            ArrayList&lt;Rule&gt; copy = new ArrayList&lt;Rule&gt;(iRules);</span>

            // Iterate through all the transitions until firstMillis is
            // reached. Use the name key and savings for whatever rule reaches
            // the limit.

<span class="fc" id="L1055">            long millis = Long.MIN_VALUE;</span>
<span class="fc" id="L1056">            int saveMillis = 0;</span>
<span class="fc" id="L1057">            Transition first = null;</span>

            Transition next;
<span class="pc bpc" id="L1060" title="1 of 2 branches missed.">            while ((next = nextTransition(millis, saveMillis)) != null) {</span>
<span class="fc" id="L1061">                millis = next.getMillis();</span>

<span class="pc bpc" id="L1063" title="1 of 2 branches missed.">                if (millis == firstMillis) {</span>
<span class="nc" id="L1064">                    first = new Transition(firstMillis, next);</span>
<span class="nc" id="L1065">                    break;</span>
                }

<span class="fc bfc" id="L1068" title="All 2 branches covered.">                if (millis &gt; firstMillis) {</span>
<span class="fc bfc" id="L1069" title="All 2 branches covered.">                    if (first == null) {</span>
                        // Find first rule without savings. This way a more
                        // accurate nameKey is found even though no rule
                        // extends to the RuleSet's lower limit.
<span class="pc bpc" id="L1073" title="1 of 2 branches missed.">                        for (Rule rule : copy) {</span>
<span class="fc bfc" id="L1074" title="All 2 branches covered.">                            if (rule.getSaveMillis() == 0) {</span>
<span class="fc" id="L1075">                                first = new Transition(firstMillis, rule, iStandardOffset);</span>
<span class="fc" id="L1076">                                break;</span>
                            }
<span class="fc" id="L1078">                        }</span>
                    }
<span class="pc bpc" id="L1080" title="1 of 2 branches missed.">                    if (first == null) {</span>
                        // Found no rule without savings. Create a transition
                        // with no savings anyhow, and use the best available
                        // name key.
<span class="nc" id="L1084">                        first = new Transition(firstMillis, next.getNameKey(),</span>
                                               iStandardOffset, iStandardOffset);
                    }
                    break;
                }
                
                // Set first to the best transition found so far, but next
                // iteration may find something closer to lower limit.
<span class="fc" id="L1092">                first = new Transition(firstMillis, next);</span>

<span class="fc" id="L1094">                saveMillis = next.getSaveMillis();</span>
            }

<span class="fc" id="L1097">            iRules = copy;</span>
<span class="fc" id="L1098">            return first;</span>
        }

        /**
         * Returns null if RuleSet is exhausted or upper limit reached. Calling
         * this method will throw away rules as they each become
         * exhausted. Copy the RuleSet before using it to compute transitions.
         *
         * Returned transition may be a duplicate from previous
         * transition. Caller must call isTransitionFrom to filter out
         * duplicates.
         *
         * @param saveMillis savings before next transition
         */
        public Transition nextTransition(final long instant, final int saveMillis) {
<span class="fc" id="L1113">            Chronology chrono = ISOChronology.getInstanceUTC();</span>

            // Find next matching rule.
<span class="fc" id="L1116">            Rule nextRule = null;</span>
<span class="fc" id="L1117">            long nextMillis = Long.MAX_VALUE;</span>
            
<span class="fc" id="L1119">            Iterator&lt;Rule&gt; it = iRules.iterator();</span>
<span class="fc bfc" id="L1120" title="All 2 branches covered.">            while (it.hasNext()) {</span>
<span class="fc" id="L1121">                Rule rule = it.next();</span>
<span class="fc" id="L1122">                long next = rule.next(instant, iStandardOffset, saveMillis);</span>
<span class="fc bfc" id="L1123" title="All 2 branches covered.">                if (next &lt;= instant) {</span>
<span class="fc" id="L1124">                    it.remove();</span>
<span class="fc" id="L1125">                    continue;</span>
                }
                // Even if next is same as previous next, choose the rule
                // in order for more recently added rules to override.
<span class="fc bfc" id="L1129" title="All 2 branches covered.">                if (next &lt;= nextMillis) {</span>
                    // Found a better match.
<span class="fc" id="L1131">                    nextRule = rule;</span>
<span class="fc" id="L1132">                    nextMillis = next;</span>
                }
<span class="fc" id="L1134">            }</span>
            
<span class="fc bfc" id="L1136" title="All 2 branches covered.">            if (nextRule == null) {</span>
<span class="fc" id="L1137">                return null;</span>
            }
            
            // Stop precalculating if year reaches some arbitrary limit.
<span class="pc bpc" id="L1141" title="1 of 2 branches missed.">            if (chrono.year().get(nextMillis) &gt;= YEAR_LIMIT) {</span>
<span class="nc" id="L1142">                return null;</span>
            }
            
            // Check if upper limit reached or passed.
<span class="fc bfc" id="L1146" title="All 2 branches covered.">            if (iUpperYear &lt; Integer.MAX_VALUE) {</span>
<span class="fc" id="L1147">                long upperMillis =</span>
<span class="fc" id="L1148">                    iUpperOfYear.setInstant(iUpperYear, iStandardOffset, saveMillis);</span>
<span class="fc bfc" id="L1149" title="All 2 branches covered.">                if (nextMillis &gt;= upperMillis) {</span>
                    // At or after upper limit.
<span class="fc" id="L1151">                    return null;</span>
                }
            }
            
<span class="fc" id="L1155">            return new Transition(nextMillis, nextRule, iStandardOffset);</span>
        }

        /**
         * @param saveMillis savings before upper limit
         */
        public long getUpperLimit(int saveMillis) {
<span class="fc bfc" id="L1162" title="All 2 branches covered.">            if (iUpperYear == Integer.MAX_VALUE) {</span>
<span class="fc" id="L1163">                return Long.MAX_VALUE;</span>
            }
<span class="fc" id="L1165">            return iUpperOfYear.setInstant(iUpperYear, iStandardOffset, saveMillis);</span>
        }

        /**
         * Returns null if none can be built.
         */
        public DSTZone buildTailZone(String id) {
<span class="fc bfc" id="L1172" title="All 2 branches covered.">            if (iRules.size() == 2) {</span>
<span class="fc" id="L1173">                Rule startRule = iRules.get(0);</span>
<span class="fc" id="L1174">                Rule endRule = iRules.get(1);</span>
<span class="fc bfc" id="L1175" title="All 2 branches covered.">                if (startRule.getToYear() == Integer.MAX_VALUE &amp;&amp;</span>
<span class="pc bpc" id="L1176" title="1 of 2 branches missed.">                    endRule.getToYear() == Integer.MAX_VALUE) {</span>

                    // With exactly two infinitely recurring rules left, a
                    // simple DSTZone can be formed.

                    // The order of rules can come in any order, and it doesn't
                    // really matter which rule was chosen the 'start' and
                    // which is chosen the 'end'. DSTZone works properly either
                    // way.
<span class="fc" id="L1185">                    return new DSTZone(id, iStandardOffset,</span>
                                       startRule.iRecurrence, endRule.iRecurrence);
                }
            }
<span class="fc" id="L1189">            return null;</span>
        }
        
        @Override
        public String toString() {
<span class="nc" id="L1194">            return iInitialNameKey + &quot; initial: &quot; + iInitialSaveMillis + &quot; std: &quot; + iStandardOffset +</span>
                    &quot; upper: &quot; + iUpperYear + &quot; &quot; + iUpperOfYear + &quot; &quot; + iRules;
        }
    }

    private static final class DSTZone extends DateTimeZone {
        private static final long serialVersionUID = 6941492635554961361L;

        static DSTZone readFrom(DataInput in, String id) throws IOException {
<span class="fc" id="L1203">            return new DSTZone(id, (int)readMillis(in), </span>
<span class="fc" id="L1204">                               Recurrence.readFrom(in), Recurrence.readFrom(in));</span>
        }

        final int iStandardOffset;
        final Recurrence iStartRecurrence;
        final Recurrence iEndRecurrence;

        DSTZone(String id, int standardOffset,
                Recurrence startRecurrence, Recurrence endRecurrence) {
<span class="fc" id="L1213">            super(id);</span>
<span class="fc" id="L1214">            iStandardOffset = standardOffset;</span>
<span class="fc" id="L1215">            iStartRecurrence = startRecurrence;</span>
<span class="fc" id="L1216">            iEndRecurrence = endRecurrence;</span>
<span class="fc" id="L1217">        }</span>

        public String getNameKey(long instant) {
<span class="fc" id="L1220">            return findMatchingRecurrence(instant).getNameKey();</span>
        }

        public int getOffset(long instant) {
<span class="fc" id="L1224">            return iStandardOffset + findMatchingRecurrence(instant).getSaveMillis();</span>
        }

        public int getStandardOffset(long instant) {
<span class="fc" id="L1228">            return iStandardOffset;</span>
        }

        public boolean isFixed() {
<span class="nc" id="L1232">            return false;</span>
        }

        public long nextTransition(long instant) {
<span class="fc" id="L1236">            int standardOffset = iStandardOffset;</span>
<span class="fc" id="L1237">            Recurrence startRecurrence = iStartRecurrence;</span>
<span class="fc" id="L1238">            Recurrence endRecurrence = iEndRecurrence;</span>

            long start, end;

            try {
<span class="fc" id="L1243">                start = startRecurrence.next</span>
<span class="fc" id="L1244">                    (instant, standardOffset, endRecurrence.getSaveMillis());</span>
<span class="pc bpc" id="L1245" title="2 of 4 branches missed.">                if (instant &gt; 0 &amp;&amp; start &lt; 0) {</span>
                    // Overflowed.
<span class="nc" id="L1247">                    start = instant;</span>
                }
<span class="fc" id="L1249">            } catch (IllegalArgumentException e) {</span>
                // Overflowed.
<span class="fc" id="L1251">                start = instant;</span>
<span class="nc" id="L1252">            } catch (ArithmeticException e) {</span>
                // Overflowed.
<span class="nc" id="L1254">                start = instant;</span>
<span class="fc" id="L1255">            }</span>

            try {
<span class="fc" id="L1258">                end = endRecurrence.next</span>
<span class="fc" id="L1259">                    (instant, standardOffset, startRecurrence.getSaveMillis());</span>
<span class="pc bpc" id="L1260" title="1 of 4 branches missed.">                if (instant &gt; 0 &amp;&amp; end &lt; 0) {</span>
                    // Overflowed.
<span class="fc" id="L1262">                    end = instant;</span>
                }
<span class="fc" id="L1264">            } catch (IllegalArgumentException e) {</span>
                // Overflowed.
<span class="fc" id="L1266">                end = instant;</span>
<span class="nc" id="L1267">            } catch (ArithmeticException e) {</span>
                // Overflowed.
<span class="nc" id="L1269">                end = instant;</span>
<span class="fc" id="L1270">            }</span>

<span class="fc bfc" id="L1272" title="All 2 branches covered.">            return (start &gt; end) ? end : start;</span>
        }

        public long previousTransition(long instant) {
            // Increment in order to handle the case where instant is exactly at
            // a transition.
<span class="fc" id="L1278">            instant++;</span>

<span class="fc" id="L1280">            int standardOffset = iStandardOffset;</span>
<span class="fc" id="L1281">            Recurrence startRecurrence = iStartRecurrence;</span>
<span class="fc" id="L1282">            Recurrence endRecurrence = iEndRecurrence;</span>

            long start, end;

            try {
<span class="fc" id="L1287">                start = startRecurrence.previous</span>
<span class="fc" id="L1288">                    (instant, standardOffset, endRecurrence.getSaveMillis());</span>
<span class="pc bpc" id="L1289" title="3 of 4 branches missed.">                if (instant &lt; 0 &amp;&amp; start &gt; 0) {</span>
                    // Overflowed.
<span class="nc" id="L1291">                    start = instant;</span>
                }
<span class="nc" id="L1293">            } catch (IllegalArgumentException e) {</span>
                // Overflowed.
<span class="nc" id="L1295">                start = instant;</span>
<span class="nc" id="L1296">            } catch (ArithmeticException e) {</span>
                // Overflowed.
<span class="nc" id="L1298">                start = instant;</span>
<span class="pc" id="L1299">            }</span>

            try {
<span class="fc" id="L1302">                end = endRecurrence.previous</span>
<span class="fc" id="L1303">                    (instant, standardOffset, startRecurrence.getSaveMillis());</span>
<span class="pc bpc" id="L1304" title="3 of 4 branches missed.">                if (instant &lt; 0 &amp;&amp; end &gt; 0) {</span>
                    // Overflowed.
<span class="nc" id="L1306">                    end = instant;</span>
                }
<span class="nc" id="L1308">            } catch (IllegalArgumentException e) {</span>
                // Overflowed.
<span class="nc" id="L1310">                end = instant;</span>
<span class="nc" id="L1311">            } catch (ArithmeticException e) {</span>
                // Overflowed.
<span class="nc" id="L1313">                end = instant;</span>
<span class="pc" id="L1314">            }</span>

<span class="fc bfc" id="L1316" title="All 2 branches covered.">            return ((start &gt; end) ? start : end) - 1;</span>
        }

        public boolean equals(Object obj) {
<span class="pc bpc" id="L1320" title="1 of 2 branches missed.">            if (this == obj) {</span>
<span class="nc" id="L1321">                return true;</span>
            }
<span class="pc bpc" id="L1323" title="1 of 2 branches missed.">            if (obj instanceof DSTZone) {</span>
<span class="fc" id="L1324">                DSTZone other = (DSTZone)obj;</span>
<span class="fc" id="L1325">                return</span>
<span class="pc bpc" id="L1326" title="2 of 4 branches missed.">                    getID().equals(other.getID()) &amp;&amp;</span>
                    iStandardOffset == other.iStandardOffset &amp;&amp;
<span class="pc bpc" id="L1328" title="1 of 2 branches missed.">                    iStartRecurrence.equals(other.iStartRecurrence) &amp;&amp;</span>
<span class="pc bpc" id="L1329" title="1 of 2 branches missed.">                    iEndRecurrence.equals(other.iEndRecurrence);</span>
            }
<span class="nc" id="L1331">            return false;</span>
        }

        public void writeTo(DataOutput out) throws IOException {
<span class="fc" id="L1335">            writeMillis(out, iStandardOffset);</span>
<span class="fc" id="L1336">            iStartRecurrence.writeTo(out);</span>
<span class="fc" id="L1337">            iEndRecurrence.writeTo(out);</span>
<span class="fc" id="L1338">        }</span>

        private Recurrence findMatchingRecurrence(long instant) {
<span class="fc" id="L1341">            int standardOffset = iStandardOffset;</span>
<span class="fc" id="L1342">            Recurrence startRecurrence = iStartRecurrence;</span>
<span class="fc" id="L1343">            Recurrence endRecurrence = iEndRecurrence;</span>

            long start, end;

            try {
<span class="fc" id="L1348">                start = startRecurrence.next</span>
<span class="fc" id="L1349">                    (instant, standardOffset, endRecurrence.getSaveMillis());</span>
<span class="fc" id="L1350">            } catch (IllegalArgumentException e) {</span>
                // Overflowed.
<span class="fc" id="L1352">                start = instant;</span>
<span class="nc" id="L1353">            } catch (ArithmeticException e) {</span>
                // Overflowed.
<span class="nc" id="L1355">                start = instant;</span>
<span class="fc" id="L1356">            }</span>

            try {
<span class="fc" id="L1359">                end = endRecurrence.next</span>
<span class="fc" id="L1360">                    (instant, standardOffset, startRecurrence.getSaveMillis());</span>
<span class="fc" id="L1361">            } catch (IllegalArgumentException e) {</span>
                // Overflowed.
<span class="fc" id="L1363">                end = instant;</span>
<span class="nc" id="L1364">            } catch (ArithmeticException e) {</span>
                // Overflowed.
<span class="nc" id="L1366">                end = instant;</span>
<span class="fc" id="L1367">            }</span>

<span class="fc bfc" id="L1369" title="All 2 branches covered.">            return (start &gt; end) ? startRecurrence : endRecurrence;</span>
        }
    }

    private static final class PrecalculatedZone extends DateTimeZone {
        private static final long serialVersionUID = 7811976468055766265L;

        static PrecalculatedZone readFrom(DataInput in, String id) throws IOException {
            // Read string pool.
<span class="fc" id="L1378">            int poolSize = in.readUnsignedShort();</span>
<span class="fc" id="L1379">            String[] pool = new String[poolSize];</span>
<span class="fc bfc" id="L1380" title="All 2 branches covered.">            for (int i=0; i&lt;poolSize; i++) {</span>
<span class="fc" id="L1381">                pool[i] = in.readUTF();</span>
            }

<span class="fc" id="L1384">            int size = in.readInt();</span>
<span class="fc" id="L1385">            long[] transitions = new long[size];</span>
<span class="fc" id="L1386">            int[] wallOffsets = new int[size];</span>
<span class="fc" id="L1387">            int[] standardOffsets = new int[size];</span>
<span class="fc" id="L1388">            String[] nameKeys = new String[size];</span>
            
<span class="fc bfc" id="L1390" title="All 2 branches covered.">            for (int i=0; i&lt;size; i++) {</span>
<span class="fc" id="L1391">                transitions[i] = readMillis(in);</span>
<span class="fc" id="L1392">                wallOffsets[i] = (int)readMillis(in);</span>
<span class="fc" id="L1393">                standardOffsets[i] = (int)readMillis(in);</span>
                try {
                    int index;
<span class="pc bpc" id="L1396" title="1 of 2 branches missed.">                    if (poolSize &lt; 256) {</span>
<span class="fc" id="L1397">                        index = in.readUnsignedByte();</span>
                    } else {
<span class="nc" id="L1399">                        index = in.readUnsignedShort();</span>
                    }
<span class="fc" id="L1401">                    nameKeys[i] = pool[index];</span>
<span class="nc" id="L1402">                } catch (ArrayIndexOutOfBoundsException e) {</span>
<span class="nc" id="L1403">                    throw new IOException(&quot;Invalid encoding&quot;);</span>
<span class="fc" id="L1404">                }</span>
            }

<span class="fc" id="L1407">            DSTZone tailZone = null;</span>
<span class="fc bfc" id="L1408" title="All 2 branches covered.">            if (in.readBoolean()) {</span>
<span class="fc" id="L1409">                tailZone = DSTZone.readFrom(in, id);</span>
            }

<span class="fc" id="L1412">            return new PrecalculatedZone</span>
                (id, transitions, wallOffsets, standardOffsets, nameKeys, tailZone);
        }

        /**
         * Factory to create instance from builder.
         * 
         * @param id  the zone id
         * @param outputID  true if the zone id should be output
         * @param transitions  the list of Transition objects
         * @param tailZone  optional zone for getting info beyond precalculated tables
         */
        static PrecalculatedZone create(String id, boolean outputID, ArrayList&lt;Transition&gt; transitions,
                                        DSTZone tailZone) {
<span class="fc" id="L1426">            int size = transitions.size();</span>
<span class="pc bpc" id="L1427" title="1 of 2 branches missed.">            if (size == 0) {</span>
<span class="nc" id="L1428">                throw new IllegalArgumentException();</span>
            }

<span class="fc" id="L1431">            long[] trans = new long[size];</span>
<span class="fc" id="L1432">            int[] wallOffsets = new int[size];</span>
<span class="fc" id="L1433">            int[] standardOffsets = new int[size];</span>
<span class="fc" id="L1434">            String[] nameKeys = new String[size];</span>

<span class="fc" id="L1436">            Transition last = null;</span>
<span class="fc bfc" id="L1437" title="All 2 branches covered.">            for (int i=0; i&lt;size; i++) {</span>
<span class="fc" id="L1438">                Transition tr = transitions.get(i);</span>

<span class="pc bpc" id="L1440" title="1 of 2 branches missed.">                if (!tr.isTransitionFrom(last)) {</span>
<span class="nc" id="L1441">                    throw new IllegalArgumentException(id);</span>
                }

<span class="fc" id="L1444">                trans[i] = tr.getMillis();</span>
<span class="fc" id="L1445">                wallOffsets[i] = tr.getWallOffset();</span>
<span class="fc" id="L1446">                standardOffsets[i] = tr.getStandardOffset();</span>
<span class="fc" id="L1447">                nameKeys[i] = tr.getNameKey();</span>

<span class="fc" id="L1449">                last = tr;</span>
            }

            // Some timezones (Australia) have the same name key for
            // summer and winter which messes everything up. Fix it here.
<span class="fc" id="L1454">            String[] zoneNameData = new String[5];</span>
<span class="fc" id="L1455">            String[][] zoneStrings = new DateFormatSymbols(Locale.ENGLISH).getZoneStrings();</span>
<span class="fc bfc" id="L1456" title="All 2 branches covered.">            for (int j = 0; j &lt; zoneStrings.length; j++) {</span>
<span class="fc" id="L1457">                String[] set = zoneStrings[j];</span>
<span class="pc bpc" id="L1458" title="4 of 6 branches missed.">                if (set != null &amp;&amp; set.length == 5 &amp;&amp; id.equals(set[0])) {</span>
<span class="nc" id="L1459">                    zoneNameData = set;</span>
                }
            }

<span class="fc" id="L1463">            Chronology chrono = ISOChronology.getInstanceUTC();</span>

<span class="fc bfc" id="L1465" title="All 2 branches covered.">            for (int i = 0; i &lt; nameKeys.length - 1; i++) {</span>
<span class="fc" id="L1466">                String curNameKey = nameKeys[i];</span>
<span class="fc" id="L1467">                String nextNameKey = nameKeys[i + 1];</span>
<span class="fc" id="L1468">                long curOffset = wallOffsets[i];</span>
<span class="fc" id="L1469">                long nextOffset = wallOffsets[i + 1];</span>
<span class="fc" id="L1470">                long curStdOffset = standardOffsets[i];</span>
<span class="fc" id="L1471">                long nextStdOffset = standardOffsets[i + 1];</span>
<span class="fc" id="L1472">                Period p = new Period(trans[i], trans[i + 1], PeriodType.yearMonthDay(), chrono);</span>
<span class="fc bfc" id="L1473" title="All 4 branches covered.">                if (curOffset != nextOffset &amp;&amp;</span>
                        curStdOffset == nextStdOffset &amp;&amp;
<span class="fc bfc" id="L1475" title="All 2 branches covered.">                        curNameKey.equals(nextNameKey) &amp;&amp;</span>
<span class="pc bpc" id="L1476" title="2 of 6 branches missed.">                        p.getYears() == 0 &amp;&amp; p.getMonths() &gt; 4 &amp;&amp; p.getMonths() &lt; 8 &amp;&amp;</span>
<span class="pc bpc" id="L1477" title="1 of 2 branches missed.">                        curNameKey.equals(zoneNameData[2]) &amp;&amp;</span>
<span class="nc bnc" id="L1478" title="All 2 branches missed.">                        curNameKey.equals(zoneNameData[4])) {</span>
                    
<span class="nc bnc" id="L1480" title="All 2 branches missed.">                    if (ZoneInfoLogger.verbose()) {</span>
<span class="nc" id="L1481">                        System.out.println(&quot;Fixing duplicate name key - &quot; + nextNameKey);</span>
<span class="nc" id="L1482">                        System.out.println(&quot;     - &quot; + new DateTime(trans[i], chrono) +</span>
                                           &quot; - &quot; + new DateTime(trans[i + 1], chrono));
                    }
<span class="nc bnc" id="L1485" title="All 2 branches missed.">                    if (curOffset &gt; nextOffset) {</span>
<span class="nc" id="L1486">                        nameKeys[i] = (curNameKey + &quot;-Summer&quot;).intern();</span>
<span class="nc bnc" id="L1487" title="All 2 branches missed.">                    } else if (curOffset &lt; nextOffset) {</span>
<span class="nc" id="L1488">                        nameKeys[i + 1] = (nextNameKey + &quot;-Summer&quot;).intern();</span>
<span class="nc" id="L1489">                        i++;</span>
                    }
                }
            }

<span class="fc bfc" id="L1494" title="All 2 branches covered.">            if (tailZone != null) {</span>
<span class="fc" id="L1495">                if (tailZone.iStartRecurrence.getNameKey()</span>
<span class="fc bfc" id="L1496" title="All 2 branches covered.">                    .equals(tailZone.iEndRecurrence.getNameKey())) {</span>
<span class="pc bpc" id="L1497" title="1 of 2 branches missed.">                    if (ZoneInfoLogger.verbose()) {</span>
<span class="nc" id="L1498">                        System.out.println(&quot;Fixing duplicate recurrent name key - &quot; +</span>
<span class="nc" id="L1499">                                           tailZone.iStartRecurrence.getNameKey());</span>
                    }
<span class="pc bpc" id="L1501" title="1 of 2 branches missed.">                    if (tailZone.iStartRecurrence.getSaveMillis() &gt; 0) {</span>
<span class="fc" id="L1502">                        tailZone = new DSTZone(</span>
<span class="fc" id="L1503">                            tailZone.getID(),</span>
                            tailZone.iStandardOffset,
<span class="fc" id="L1505">                            tailZone.iStartRecurrence.renameAppend(&quot;-Summer&quot;),</span>
                            tailZone.iEndRecurrence);
                    } else {
<span class="nc" id="L1508">                        tailZone = new DSTZone(</span>
<span class="nc" id="L1509">                            tailZone.getID(),</span>
                            tailZone.iStandardOffset,
                            tailZone.iStartRecurrence,
<span class="nc" id="L1512">                            tailZone.iEndRecurrence.renameAppend(&quot;-Summer&quot;));</span>
                    }
                }
            }
            
<span class="fc bfc" id="L1517" title="All 2 branches covered.">            return new PrecalculatedZone</span>
                ((outputID ? id : &quot;&quot;), trans, wallOffsets, standardOffsets, nameKeys, tailZone);
        }

        // All array fields have the same length.

        private final long[] iTransitions;

        private final int[] iWallOffsets;
        private final int[] iStandardOffsets;
        private final String[] iNameKeys;

        private final DSTZone iTailZone;

        /**
         * Constructor used ONLY for valid input, loaded via static methods.
         */
        private PrecalculatedZone(String id, long[] transitions, int[] wallOffsets,
                          int[] standardOffsets, String[] nameKeys, DSTZone tailZone)
        {
<span class="fc" id="L1537">            super(id);</span>
<span class="fc" id="L1538">            iTransitions = transitions;</span>
<span class="fc" id="L1539">            iWallOffsets = wallOffsets;</span>
<span class="fc" id="L1540">            iStandardOffsets = standardOffsets;</span>
<span class="fc" id="L1541">            iNameKeys = nameKeys;</span>
<span class="fc" id="L1542">            iTailZone = tailZone;</span>
<span class="fc" id="L1543">        }</span>

        public String getNameKey(long instant) {
<span class="fc" id="L1546">            long[] transitions = iTransitions;</span>
<span class="fc" id="L1547">            int i = Arrays.binarySearch(transitions, instant);</span>
<span class="fc bfc" id="L1548" title="All 2 branches covered.">            if (i &gt;= 0) {</span>
<span class="fc" id="L1549">                return iNameKeys[i];</span>
            }
<span class="fc" id="L1551">            i = ~i;</span>
<span class="fc bfc" id="L1552" title="All 2 branches covered.">            if (i &lt; transitions.length) {</span>
<span class="pc bpc" id="L1553" title="1 of 2 branches missed.">                if (i &gt; 0) {</span>
<span class="fc" id="L1554">                    return iNameKeys[i - 1];</span>
                }
<span class="nc" id="L1556">                return &quot;UTC&quot;;</span>
            }
<span class="fc bfc" id="L1558" title="All 2 branches covered.">            if (iTailZone == null) {</span>
<span class="fc" id="L1559">                return iNameKeys[i - 1];</span>
            }
<span class="fc" id="L1561">            return iTailZone.getNameKey(instant);</span>
        }

        public int getOffset(long instant) {
<span class="fc" id="L1565">            long[] transitions = iTransitions;</span>
<span class="fc" id="L1566">            int i = Arrays.binarySearch(transitions, instant);</span>
<span class="fc bfc" id="L1567" title="All 2 branches covered.">            if (i &gt;= 0) {</span>
<span class="fc" id="L1568">                return iWallOffsets[i];</span>
            }
<span class="fc" id="L1570">            i = ~i;</span>
<span class="fc bfc" id="L1571" title="All 2 branches covered.">            if (i &lt; transitions.length) {</span>
<span class="pc bpc" id="L1572" title="1 of 2 branches missed.">                if (i &gt; 0) {</span>
<span class="fc" id="L1573">                    return iWallOffsets[i - 1];</span>
                }
<span class="nc" id="L1575">                return 0;</span>
            }
<span class="fc bfc" id="L1577" title="All 2 branches covered.">            if (iTailZone == null) {</span>
<span class="fc" id="L1578">                return iWallOffsets[i - 1];</span>
            }
<span class="fc" id="L1580">            return iTailZone.getOffset(instant);</span>
        }

        public int getStandardOffset(long instant) {
<span class="fc" id="L1584">            long[] transitions = iTransitions;</span>
<span class="fc" id="L1585">            int i = Arrays.binarySearch(transitions, instant);</span>
<span class="fc bfc" id="L1586" title="All 2 branches covered.">            if (i &gt;= 0) {</span>
<span class="fc" id="L1587">                return iStandardOffsets[i];</span>
            }
<span class="fc" id="L1589">            i = ~i;</span>
<span class="fc bfc" id="L1590" title="All 2 branches covered.">            if (i &lt; transitions.length) {</span>
<span class="pc bpc" id="L1591" title="1 of 2 branches missed.">                if (i &gt; 0) {</span>
<span class="fc" id="L1592">                    return iStandardOffsets[i - 1];</span>
                }
<span class="nc" id="L1594">                return 0;</span>
            }
<span class="fc bfc" id="L1596" title="All 2 branches covered.">            if (iTailZone == null) {</span>
<span class="fc" id="L1597">                return iStandardOffsets[i - 1];</span>
            }
<span class="fc" id="L1599">            return iTailZone.getStandardOffset(instant);</span>
        }

        public boolean isFixed() {
<span class="fc" id="L1603">            return false;</span>
        }

        public long nextTransition(long instant) {
<span class="fc" id="L1607">            long[] transitions = iTransitions;</span>
<span class="fc" id="L1608">            int i = Arrays.binarySearch(transitions, instant);</span>
<span class="fc bfc" id="L1609" title="All 2 branches covered.">            i = (i &gt;= 0) ? (i + 1) : ~i;</span>
<span class="fc bfc" id="L1610" title="All 2 branches covered.">            if (i &lt; transitions.length) {</span>
<span class="fc" id="L1611">                return transitions[i];</span>
            }
<span class="fc bfc" id="L1613" title="All 2 branches covered.">            if (iTailZone == null) {</span>
<span class="fc" id="L1614">                return instant;</span>
            }
<span class="fc" id="L1616">            long end = transitions[transitions.length - 1];</span>
<span class="pc bpc" id="L1617" title="1 of 2 branches missed.">            if (instant &lt; end) {</span>
<span class="nc" id="L1618">                instant = end;</span>
            }
<span class="fc" id="L1620">            return iTailZone.nextTransition(instant);</span>
        }

        public long previousTransition(long instant) {
<span class="fc" id="L1624">            long[] transitions = iTransitions;</span>
<span class="fc" id="L1625">            int i = Arrays.binarySearch(transitions, instant);</span>
<span class="fc bfc" id="L1626" title="All 2 branches covered.">            if (i &gt;= 0) {</span>
<span class="pc bpc" id="L1627" title="1 of 2 branches missed.">                if (instant &gt; Long.MIN_VALUE) {</span>
<span class="fc" id="L1628">                    return instant - 1;</span>
                }
<span class="nc" id="L1630">                return instant;</span>
            }
<span class="fc" id="L1632">            i = ~i;</span>
<span class="fc bfc" id="L1633" title="All 2 branches covered.">            if (i &lt; transitions.length) {</span>
<span class="pc bpc" id="L1634" title="1 of 2 branches missed.">                if (i &gt; 0) {</span>
<span class="fc" id="L1635">                    long prev = transitions[i - 1];</span>
<span class="pc bpc" id="L1636" title="1 of 2 branches missed.">                    if (prev &gt; Long.MIN_VALUE) {</span>
<span class="fc" id="L1637">                        return prev - 1;</span>
                    }
                }
<span class="nc" id="L1640">                return instant;</span>
            }
<span class="fc bfc" id="L1642" title="All 2 branches covered.">            if (iTailZone != null) {</span>
<span class="fc" id="L1643">                long prev = iTailZone.previousTransition(instant);</span>
<span class="pc bpc" id="L1644" title="1 of 2 branches missed.">                if (prev &lt; instant) {</span>
<span class="fc" id="L1645">                    return prev;</span>
                }
            }
<span class="fc" id="L1648">            long prev = transitions[i - 1];</span>
<span class="pc bpc" id="L1649" title="1 of 2 branches missed.">            if (prev &gt; Long.MIN_VALUE) {</span>
<span class="fc" id="L1650">                return prev - 1;</span>
            }
<span class="nc" id="L1652">            return instant;</span>
        }

        public boolean equals(Object obj) {
<span class="fc bfc" id="L1656" title="All 2 branches covered.">            if (this == obj) {</span>
<span class="fc" id="L1657">                return true;</span>
            }
<span class="pc bpc" id="L1659" title="1 of 2 branches missed.">            if (obj instanceof PrecalculatedZone) {</span>
<span class="fc" id="L1660">                PrecalculatedZone other = (PrecalculatedZone)obj;</span>
<span class="fc" id="L1661">                return</span>
<span class="fc bfc" id="L1662" title="All 2 branches covered.">                    getID().equals(other.getID()) &amp;&amp;</span>
<span class="pc bpc" id="L1663" title="1 of 2 branches missed.">                    Arrays.equals(iTransitions, other.iTransitions) &amp;&amp;</span>
<span class="pc bpc" id="L1664" title="1 of 2 branches missed.">                    Arrays.equals(iNameKeys, other.iNameKeys) &amp;&amp;</span>
<span class="pc bpc" id="L1665" title="1 of 2 branches missed.">                    Arrays.equals(iWallOffsets, other.iWallOffsets) &amp;&amp;</span>
<span class="pc bpc" id="L1666" title="2 of 6 branches missed.">                    Arrays.equals(iStandardOffsets, other.iStandardOffsets) &amp;&amp;</span>
                    ((iTailZone == null)
                     ? (null == other.iTailZone)
<span class="pc bpc" id="L1669" title="1 of 2 branches missed.">                     : (iTailZone.equals(other.iTailZone)));</span>
            }
<span class="nc" id="L1671">            return false;</span>
        }

        public void writeTo(DataOutput out) throws IOException {
<span class="fc" id="L1675">            int size = iTransitions.length;</span>

            // Create unique string pool.
<span class="fc" id="L1678">            Set&lt;String&gt; poolSet = new HashSet&lt;String&gt;();</span>
<span class="fc bfc" id="L1679" title="All 2 branches covered.">            for (int i=0; i&lt;size; i++) {</span>
<span class="fc" id="L1680">                poolSet.add(iNameKeys[i]);</span>
            }

<span class="fc" id="L1683">            int poolSize = poolSet.size();</span>
<span class="pc bpc" id="L1684" title="1 of 2 branches missed.">            if (poolSize &gt; 65535) {</span>
<span class="nc" id="L1685">                throw new UnsupportedOperationException(&quot;String pool is too large&quot;);</span>
            }
<span class="fc" id="L1687">            String[] pool = new String[poolSize];</span>
<span class="fc" id="L1688">            Iterator&lt;String&gt; it = poolSet.iterator();</span>
<span class="fc bfc" id="L1689" title="All 2 branches covered.">            for (int i=0; it.hasNext(); i++) {</span>
<span class="fc" id="L1690">                pool[i] = it.next();</span>
            }

            // Write out the pool.
<span class="fc" id="L1694">            out.writeShort(poolSize);</span>
<span class="fc bfc" id="L1695" title="All 2 branches covered.">            for (int i=0; i&lt;poolSize; i++) {</span>
<span class="fc" id="L1696">                out.writeUTF(pool[i]);</span>
            }

<span class="fc" id="L1699">            out.writeInt(size);</span>

<span class="fc bfc" id="L1701" title="All 2 branches covered.">            for (int i=0; i&lt;size; i++) {</span>
<span class="fc" id="L1702">                writeMillis(out, iTransitions[i]);</span>
<span class="fc" id="L1703">                writeMillis(out, iWallOffsets[i]);</span>
<span class="fc" id="L1704">                writeMillis(out, iStandardOffsets[i]);</span>
                
                // Find pool index and write it out.
<span class="fc" id="L1707">                String nameKey = iNameKeys[i];</span>
<span class="pc bpc" id="L1708" title="1 of 2 branches missed.">                for (int j=0; j&lt;poolSize; j++) {</span>
<span class="fc bfc" id="L1709" title="All 2 branches covered.">                    if (pool[j].equals(nameKey)) {</span>
<span class="pc bpc" id="L1710" title="1 of 2 branches missed.">                        if (poolSize &lt; 256) {</span>
<span class="fc" id="L1711">                            out.writeByte(j);</span>
                        } else {
<span class="nc" id="L1713">                            out.writeShort(j);</span>
                        }
<span class="nc" id="L1715">                        break;</span>
                    }
                }
            }

<span class="pc bpc" id="L1720" title="1 of 2 branches missed.">            out.writeBoolean(iTailZone != null);</span>
<span class="pc bpc" id="L1721" title="1 of 2 branches missed.">            if (iTailZone != null) {</span>
<span class="fc" id="L1722">                iTailZone.writeTo(out);</span>
            }
<span class="fc" id="L1724">        }</span>

        public boolean isCachable() {
<span class="fc bfc" id="L1727" title="All 2 branches covered.">            if (iTailZone != null) {</span>
<span class="fc" id="L1728">                return true;</span>
            }
<span class="fc" id="L1730">            long[] transitions = iTransitions;</span>
<span class="pc bpc" id="L1731" title="1 of 2 branches missed.">            if (transitions.length &lt;= 1) {</span>
<span class="nc" id="L1732">                return false;</span>
            }

            // Add up all the distances between transitions that are less than
            // about two years.
<span class="fc" id="L1737">            double distances = 0;</span>
<span class="fc" id="L1738">            int count = 0;</span>

<span class="fc bfc" id="L1740" title="All 2 branches covered.">            for (int i=1; i&lt;transitions.length; i++) {</span>
<span class="fc" id="L1741">                long diff = transitions[i] - transitions[i - 1];</span>
<span class="pc bpc" id="L1742" title="1 of 2 branches missed.">                if (diff &lt; ((366L + 365) * 24 * 60 * 60 * 1000)) {</span>
<span class="fc" id="L1743">                    distances += (double)diff;</span>
<span class="fc" id="L1744">                    count++;</span>
                }
            }

<span class="pc bpc" id="L1748" title="1 of 2 branches missed.">            if (count &gt; 0) {</span>
<span class="fc" id="L1749">                double avg = distances / count;</span>
<span class="fc" id="L1750">                avg /= 24 * 60 * 60 * 1000;</span>
<span class="pc bpc" id="L1751" title="1 of 2 branches missed.">                if (avg &gt;= 25) {</span>
                    // Only bother caching if average distance between
                    // transitions is at least 25 days. Why 25?
                    // CachedDateTimeZone is more efficient if the distance
                    // between transitions is large. With an average of 25, it
                    // will on average perform about 2 tests per cache
                    // hit. (49.7 / 25) is approximately 2.
<span class="nc" id="L1758">                    return true;</span>
                }
            }

<span class="fc" id="L1762">            return false;</span>
        }
    }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.2.201808211720</span></div></body></html>