<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>JavadocTagInfoTest.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">checkstyle$java_in_checkstyle.exec</a> &gt; <a href="index.source.html" class="el_package">com.puppycrawl.tools.checkstyle.checks.javadoc</a> &gt; <span class="el_source">JavadocTagInfoTest.java</span></div><h1>JavadocTagInfoTest.java</h1><pre class="source lang-java linenums">////////////////////////////////////////////////////////////////////////////////
// checkstyle: Checks Java source code for adherence to a set of rules.
// Copyright (C) 2001-2019 the original author or authors.
//
// This library is free software; you can redistribute it and/or
// modify it under the terms of the GNU Lesser General Public
// License as published by the Free Software Foundation; either
// version 2.1 of the License, or (at your option) any later version.
//
// This library is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
// Lesser General Public License for more details.
//
// You should have received a copy of the GNU Lesser General Public
// License along with this library; if not, write to the Free Software
// Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
////////////////////////////////////////////////////////////////////////////////

package com.puppycrawl.tools.checkstyle.checks.javadoc;

import static org.junit.Assert.assertArrayEquals;
import static org.junit.Assert.assertEquals;
import static org.junit.Assert.assertFalse;
import static org.junit.Assert.assertTrue;
import static org.junit.Assert.fail;

import java.lang.reflect.Method;

import org.junit.Test;

import com.puppycrawl.tools.checkstyle.DetailAstImpl;
import com.puppycrawl.tools.checkstyle.api.DetailAST;
import com.puppycrawl.tools.checkstyle.api.TokenTypes;

<span class="fc" id="L36">public class JavadocTagInfoTest {</span>

    /* Additional test for jacoco, since valueOf()
     * is generated by javac and jacoco reports that
     * valueOf() is uncovered.
     */
    @Test
    public void testJavadocTagInfoValueOf() {
<span class="fc" id="L44">        final JavadocTagInfo tag = JavadocTagInfo.valueOf(&quot;AUTHOR&quot;);</span>
<span class="fc" id="L45">        assertEquals(&quot;Invalid valueOf result&quot;, JavadocTagInfo.AUTHOR, tag);</span>
<span class="fc" id="L46">    }</span>

    /* Additional test for jacoco, since valueOf()
     * is generated by javac and jacoco reports that
     * valueOf() is uncovered.
     */
    @Test
    public void testTypeValueOf() {
<span class="fc" id="L54">        final JavadocTagInfo.Type type = JavadocTagInfo.Type.valueOf(&quot;BLOCK&quot;);</span>
<span class="fc" id="L55">        assertEquals(&quot;Invalid valueOf result&quot;, JavadocTagInfo.Type.BLOCK, type);</span>
<span class="fc" id="L56">    }</span>

    /* Additional test for jacoco, since values()
     * is generated by javac and jacoco reports that
     * values() is uncovered.
     */
    @Test
    public void testTypeValues() {
<span class="fc" id="L64">        final JavadocTagInfo.Type[] expected = {</span>
            JavadocTagInfo.Type.BLOCK,
            JavadocTagInfo.Type.INLINE,
        };
<span class="fc" id="L68">        final JavadocTagInfo.Type[] actual = JavadocTagInfo.Type.values();</span>
<span class="fc" id="L69">        assertArrayEquals(&quot;Invalid Type values&quot;, expected, actual);</span>
<span class="fc" id="L70">    }</span>

    @Test
    public void testAuthor() {
<span class="fc" id="L74">        final DetailAST ast = new DetailAstImpl();</span>

<span class="fc" id="L76">        final int[] validTypes = {</span>
            TokenTypes.PACKAGE_DEF,
            TokenTypes.CLASS_DEF,
            TokenTypes.INTERFACE_DEF,
            TokenTypes.ENUM_DEF,
            TokenTypes.ANNOTATION_DEF,
        };
<span class="fc bfc" id="L83" title="All 2 branches covered.">        for (int type: validTypes) {</span>
<span class="fc" id="L84">            ast.setType(type);</span>
<span class="fc" id="L85">            assertTrue(&quot;Invalid ast type for current tag: &quot; + ast.getType(),</span>
<span class="fc" id="L86">                    JavadocTagInfo.AUTHOR.isValidOn(ast));</span>
        }

<span class="fc" id="L89">        ast.setType(TokenTypes.LAMBDA);</span>
<span class="fc" id="L90">        assertFalse(&quot;Should return false when ast type is invalid for current tag&quot;,</span>
<span class="fc" id="L91">                JavadocTagInfo.AUTHOR.isValidOn(ast));</span>
<span class="fc" id="L92">    }</span>

    @Test
    public void testOthers() throws ReflectiveOperationException {
<span class="fc" id="L96">        final JavadocTagInfo[] tags = {</span>
            JavadocTagInfo.CODE,
            JavadocTagInfo.DOC_ROOT,
            JavadocTagInfo.LINK,
            JavadocTagInfo.LINKPLAIN,
            JavadocTagInfo.LITERAL,
            JavadocTagInfo.SEE,
            JavadocTagInfo.SINCE,
            JavadocTagInfo.VALUE,
        };
<span class="fc bfc" id="L106" title="All 2 branches covered.">        for (JavadocTagInfo tagInfo : tags) {</span>
<span class="fc" id="L107">            final DetailAstImpl astParent = new DetailAstImpl();</span>
<span class="fc" id="L108">            astParent.setType(TokenTypes.LITERAL_CATCH);</span>

<span class="fc" id="L110">            final DetailAST ast = new DetailAstImpl();</span>
<span class="fc" id="L111">            final Method setParent = ast.getClass().getDeclaredMethod(&quot;setParent&quot;,</span>
                    DetailAstImpl.class);
<span class="fc" id="L113">            setParent.setAccessible(true);</span>
<span class="fc" id="L114">            setParent.invoke(ast, astParent);</span>

<span class="fc" id="L116">            final int[] validTypes = {</span>
                TokenTypes.PACKAGE_DEF,
                TokenTypes.CLASS_DEF,
                TokenTypes.INTERFACE_DEF,
                TokenTypes.ENUM_DEF,
                TokenTypes.ANNOTATION_DEF,
                TokenTypes.METHOD_DEF,
                TokenTypes.CTOR_DEF,
                TokenTypes.VARIABLE_DEF,
            };
<span class="fc bfc" id="L126" title="All 2 branches covered.">            for (int type: validTypes) {</span>
<span class="fc" id="L127">                ast.setType(type);</span>
<span class="fc" id="L128">                assertTrue(&quot;Invalid ast type for current tag: &quot; + ast.getType(),</span>
<span class="fc" id="L129">                        tagInfo.isValidOn(ast));</span>
            }

<span class="fc" id="L132">            astParent.setType(TokenTypes.SLIST);</span>
<span class="fc" id="L133">            ast.setType(TokenTypes.VARIABLE_DEF);</span>
<span class="fc" id="L134">            assertFalse(&quot;Should return false when ast type is invalid for current tag&quot;,</span>
<span class="fc" id="L135">                    tagInfo.isValidOn(ast));</span>

<span class="fc" id="L137">            ast.setType(TokenTypes.PARAMETER_DEF);</span>
<span class="fc" id="L138">            assertFalse(&quot;Should return false when ast type is invalid for current tag&quot;,</span>
<span class="fc" id="L139">                    tagInfo.isValidOn(ast));</span>
        }
<span class="fc" id="L141">    }</span>

    @Test
    public void testDeprecated() throws ReflectiveOperationException {
<span class="fc" id="L145">        final DetailAST ast = new DetailAstImpl();</span>
<span class="fc" id="L146">        final DetailAstImpl astParent = new DetailAstImpl();</span>
<span class="fc" id="L147">        astParent.setType(TokenTypes.LITERAL_CATCH);</span>
<span class="fc" id="L148">        final Method setParent = ast.getClass().getDeclaredMethod(&quot;setParent&quot;, DetailAstImpl.class);</span>
<span class="fc" id="L149">        setParent.setAccessible(true);</span>
<span class="fc" id="L150">        setParent.invoke(ast, astParent);</span>

<span class="fc" id="L152">        final int[] validTypes = {</span>
            TokenTypes.CLASS_DEF,
            TokenTypes.INTERFACE_DEF,
            TokenTypes.ENUM_DEF,
            TokenTypes.ANNOTATION_DEF,
            TokenTypes.METHOD_DEF,
            TokenTypes.CTOR_DEF,
            TokenTypes.ENUM_CONSTANT_DEF,
            TokenTypes.ANNOTATION_FIELD_DEF,
            TokenTypes.VARIABLE_DEF,
        };
<span class="fc bfc" id="L163" title="All 2 branches covered.">        for (int type: validTypes) {</span>
<span class="fc" id="L164">            ast.setType(type);</span>
<span class="fc" id="L165">            assertTrue(&quot;Invalid ast type for current tag: &quot; + ast.getType(),</span>
<span class="fc" id="L166">                    JavadocTagInfo.DEPRECATED.isValidOn(ast));</span>
        }

<span class="fc" id="L169">        astParent.setType(TokenTypes.SLIST);</span>
<span class="fc" id="L170">        ast.setType(TokenTypes.VARIABLE_DEF);</span>
<span class="fc" id="L171">        assertFalse(&quot;Should return false when ast type is invalid for current tag&quot;,</span>
<span class="fc" id="L172">                JavadocTagInfo.DEPRECATED.isValidOn(ast));</span>

<span class="fc" id="L174">        ast.setType(TokenTypes.PARAMETER_DEF);</span>
<span class="fc" id="L175">        assertFalse(&quot;Should return false when ast type is invalid for current tag&quot;,</span>
<span class="fc" id="L176">                JavadocTagInfo.DEPRECATED.isValidOn(ast));</span>
<span class="fc" id="L177">    }</span>

    @Test
    public void testSerial() throws ReflectiveOperationException {
<span class="fc" id="L181">        final DetailAST ast = new DetailAstImpl();</span>
<span class="fc" id="L182">        final DetailAstImpl astParent = new DetailAstImpl();</span>
<span class="fc" id="L183">        astParent.setType(TokenTypes.LITERAL_CATCH);</span>
<span class="fc" id="L184">        final Method setParent = ast.getClass().getDeclaredMethod(&quot;setParent&quot;, DetailAstImpl.class);</span>
<span class="fc" id="L185">        setParent.setAccessible(true);</span>
<span class="fc" id="L186">        setParent.invoke(ast, astParent);</span>

<span class="fc" id="L188">        final int[] validTypes = {</span>
            TokenTypes.VARIABLE_DEF,
        };
<span class="fc bfc" id="L191" title="All 2 branches covered.">        for (int type: validTypes) {</span>
<span class="fc" id="L192">            ast.setType(type);</span>
<span class="fc" id="L193">            assertTrue(&quot;Invalid ast type for current tag: &quot; + ast.getType(),</span>
<span class="fc" id="L194">                    JavadocTagInfo.SERIAL.isValidOn(ast));</span>
        }

<span class="fc" id="L197">        astParent.setType(TokenTypes.SLIST);</span>
<span class="fc" id="L198">        ast.setType(TokenTypes.VARIABLE_DEF);</span>
<span class="fc" id="L199">        assertFalse(&quot;Should return false when ast type is invalid for current tag&quot;,</span>
<span class="fc" id="L200">                JavadocTagInfo.SERIAL.isValidOn(ast));</span>

<span class="fc" id="L202">        ast.setType(TokenTypes.PARAMETER_DEF);</span>
<span class="fc" id="L203">        assertFalse(&quot;Should return false when ast type is invalid for current tag&quot;,</span>
<span class="fc" id="L204">                JavadocTagInfo.SERIAL.isValidOn(ast));</span>
<span class="fc" id="L205">    }</span>

    @Test
    public void testException() {
<span class="fc" id="L209">        final DetailAST ast = new DetailAstImpl();</span>

<span class="fc" id="L211">        final int[] validTypes = {</span>
            TokenTypes.METHOD_DEF,
            TokenTypes.CTOR_DEF,
        };
<span class="fc bfc" id="L215" title="All 2 branches covered.">        for (int type: validTypes) {</span>
<span class="fc" id="L216">            ast.setType(type);</span>
<span class="fc" id="L217">            assertTrue(&quot;Invalid ast type for current tag: &quot; + ast.getType(),</span>
<span class="fc" id="L218">                    JavadocTagInfo.EXCEPTION.isValidOn(ast));</span>
        }

<span class="fc" id="L221">        ast.setType(TokenTypes.LAMBDA);</span>
<span class="fc" id="L222">        assertFalse(&quot;Should return false when ast type is invalid for current tag&quot;,</span>
<span class="fc" id="L223">                JavadocTagInfo.EXCEPTION.isValidOn(ast));</span>
<span class="fc" id="L224">    }</span>

    @Test
    public void testThrows() {
<span class="fc" id="L228">        final DetailAST ast = new DetailAstImpl();</span>

<span class="fc" id="L230">        final int[] validTypes = {</span>
            TokenTypes.METHOD_DEF,
            TokenTypes.CTOR_DEF,
        };
<span class="fc bfc" id="L234" title="All 2 branches covered.">        for (int type: validTypes) {</span>
<span class="fc" id="L235">            ast.setType(type);</span>
<span class="fc" id="L236">            assertTrue(&quot;Invalid ast type for current tag: &quot; + ast.getType(),</span>
<span class="fc" id="L237">                    JavadocTagInfo.THROWS.isValidOn(ast));</span>
        }

<span class="fc" id="L240">        ast.setType(TokenTypes.LAMBDA);</span>
<span class="fc" id="L241">        assertFalse(&quot;Should return false when ast type is invalid for current tag&quot;,</span>
<span class="fc" id="L242">                JavadocTagInfo.THROWS.isValidOn(ast));</span>
<span class="fc" id="L243">    }</span>

    @Test
    public void testVersions() {
<span class="fc" id="L247">        final DetailAST ast = new DetailAstImpl();</span>

<span class="fc" id="L249">        final int[] validTypes = {</span>
            TokenTypes.PACKAGE_DEF,
            TokenTypes.CLASS_DEF,
            TokenTypes.INTERFACE_DEF,
            TokenTypes.ENUM_DEF,
            TokenTypes.ANNOTATION_DEF,
        };
<span class="fc bfc" id="L256" title="All 2 branches covered.">        for (int type: validTypes) {</span>
<span class="fc" id="L257">            ast.setType(type);</span>
<span class="fc" id="L258">            assertTrue(&quot;Invalid ast type for current tag: &quot; + ast.getType(),</span>
<span class="fc" id="L259">                    JavadocTagInfo.VERSION.isValidOn(ast));</span>
        }

<span class="fc" id="L262">        ast.setType(TokenTypes.LAMBDA);</span>
<span class="fc" id="L263">        assertFalse(&quot;Should return false when ast type is invalid for current tag&quot;,</span>
<span class="fc" id="L264">                JavadocTagInfo.VERSION.isValidOn(ast));</span>
<span class="fc" id="L265">    }</span>

    @Test
    public void testParam() {
<span class="fc" id="L269">        final DetailAST ast = new DetailAstImpl();</span>

<span class="fc" id="L271">        final int[] validTypes = {</span>
            TokenTypes.CLASS_DEF,
            TokenTypes.INTERFACE_DEF,
            TokenTypes.METHOD_DEF,
            TokenTypes.CTOR_DEF,
        };
<span class="fc bfc" id="L277" title="All 2 branches covered.">        for (int type: validTypes) {</span>
<span class="fc" id="L278">            ast.setType(type);</span>
<span class="fc" id="L279">            assertTrue(&quot;Invalid ast type for current tag: &quot; + ast.getType(),</span>
<span class="fc" id="L280">                    JavadocTagInfo.PARAM.isValidOn(ast));</span>
        }

<span class="fc" id="L283">        ast.setType(TokenTypes.LAMBDA);</span>
<span class="fc" id="L284">        assertFalse(&quot;Should return false when ast type is invalid for current tag&quot;,</span>
<span class="fc" id="L285">                JavadocTagInfo.PARAM.isValidOn(ast));</span>
<span class="fc" id="L286">    }</span>

    @Test
    public void testReturn() {
<span class="fc" id="L290">        final DetailAstImpl ast = new DetailAstImpl();</span>
<span class="fc" id="L291">        final DetailAstImpl astChild = new DetailAstImpl();</span>
<span class="fc" id="L292">        astChild.setType(TokenTypes.TYPE);</span>
<span class="fc" id="L293">        ast.setFirstChild(astChild);</span>
<span class="fc" id="L294">        final DetailAstImpl astChild2 = new DetailAstImpl();</span>
<span class="fc" id="L295">        astChild2.setType(TokenTypes.LITERAL_INT);</span>
<span class="fc" id="L296">        astChild.setFirstChild(astChild2);</span>

<span class="fc" id="L298">        final int[] validTypes = {</span>
            TokenTypes.METHOD_DEF,
        };
<span class="fc bfc" id="L301" title="All 2 branches covered.">        for (int type: validTypes) {</span>
<span class="fc" id="L302">            ast.setType(type);</span>
<span class="fc" id="L303">            assertTrue(&quot;Invalid ast type for current tag: &quot; + ast.getType(),</span>
<span class="fc" id="L304">                    JavadocTagInfo.RETURN.isValidOn(ast));</span>
        }

<span class="fc" id="L307">        astChild2.setType(TokenTypes.LITERAL_VOID);</span>
<span class="fc" id="L308">        assertFalse(&quot;Should return false when ast type is invalid for current tag&quot;,</span>
<span class="fc" id="L309">                JavadocTagInfo.RETURN.isValidOn(ast));</span>

<span class="fc" id="L311">        ast.setType(TokenTypes.LAMBDA);</span>
<span class="fc" id="L312">        assertFalse(&quot;Should return false when ast type is invalid for current tag&quot;,</span>
<span class="fc" id="L313">                JavadocTagInfo.RETURN.isValidOn(ast));</span>
<span class="fc" id="L314">    }</span>

    @Test
    public void testSerialField() {
<span class="fc" id="L318">        final DetailAstImpl ast = new DetailAstImpl();</span>
<span class="fc" id="L319">        final DetailAstImpl astChild = new DetailAstImpl();</span>
<span class="fc" id="L320">        astChild.setType(TokenTypes.TYPE);</span>
<span class="fc" id="L321">        ast.setFirstChild(astChild);</span>
<span class="fc" id="L322">        final DetailAstImpl astChild2 = new DetailAstImpl();</span>
<span class="fc" id="L323">        astChild2.setType(TokenTypes.ARRAY_DECLARATOR);</span>
<span class="fc" id="L324">        astChild2.setText(&quot;ObjectStreamField&quot;);</span>
<span class="fc" id="L325">        astChild.setFirstChild(astChild2);</span>

<span class="fc" id="L327">        final int[] validTypes = {</span>
            TokenTypes.VARIABLE_DEF,
        };
<span class="fc bfc" id="L330" title="All 2 branches covered.">        for (int type: validTypes) {</span>
<span class="fc" id="L331">            ast.setType(type);</span>
<span class="fc" id="L332">            assertTrue(&quot;Invalid ast type for current tag: &quot; + ast.getType(),</span>
<span class="fc" id="L333">                    JavadocTagInfo.SERIAL_FIELD.isValidOn(ast));</span>
        }

<span class="fc" id="L336">        astChild2.setText(&quot;1111&quot;);</span>
<span class="fc" id="L337">        assertFalse(&quot;Should return false when ast type is invalid for current tag&quot;,</span>
<span class="fc" id="L338">                JavadocTagInfo.SERIAL_FIELD.isValidOn(ast));</span>

<span class="fc" id="L340">        astChild2.setType(TokenTypes.LITERAL_VOID);</span>
<span class="fc" id="L341">        assertFalse(&quot;Should return false when ast type is invalid for current tag&quot;,</span>
<span class="fc" id="L342">                JavadocTagInfo.SERIAL_FIELD.isValidOn(ast));</span>

<span class="fc" id="L344">        ast.setType(TokenTypes.LAMBDA);</span>
<span class="fc" id="L345">        assertFalse(&quot;Should return false when ast type is invalid for current tag&quot;,</span>
<span class="fc" id="L346">                JavadocTagInfo.SERIAL_FIELD.isValidOn(ast));</span>
<span class="fc" id="L347">    }</span>

    @Test
    public void testSerialData() {
<span class="fc" id="L351">        final DetailAstImpl ast = new DetailAstImpl();</span>
<span class="fc" id="L352">        ast.setType(TokenTypes.METHOD_DEF);</span>
<span class="fc" id="L353">        final DetailAstImpl astChild = new DetailAstImpl();</span>
<span class="fc" id="L354">        astChild.setType(TokenTypes.IDENT);</span>
<span class="fc" id="L355">        astChild.setText(&quot;writeObject&quot;);</span>
<span class="fc" id="L356">        ast.setFirstChild(astChild);</span>

<span class="fc" id="L358">        final String[] validNames = {</span>
            &quot;writeObject&quot;,
            &quot;readObject&quot;,
            &quot;writeExternal&quot;,
            &quot;readExternal&quot;,
            &quot;writeReplace&quot;,
            &quot;readResolve&quot;,
        };
<span class="fc bfc" id="L366" title="All 2 branches covered.">        for (String name: validNames) {</span>
<span class="fc" id="L367">            astChild.setText(name);</span>
<span class="fc" id="L368">            assertTrue(&quot;Invalid ast type for current tag: &quot; + ast.getType(),</span>
<span class="fc" id="L369">                    JavadocTagInfo.SERIAL_DATA.isValidOn(ast));</span>
        }

<span class="fc" id="L372">        astChild.setText(&quot;1111&quot;);</span>
<span class="fc" id="L373">        assertFalse(&quot;Should return false when ast type is invalid for current tag&quot;,</span>
<span class="fc" id="L374">                JavadocTagInfo.SERIAL_DATA.isValidOn(ast));</span>

<span class="fc" id="L376">        ast.setType(TokenTypes.LAMBDA);</span>
<span class="fc" id="L377">        assertFalse(&quot;Should return false when ast type is invalid for current tag&quot;,</span>
<span class="fc" id="L378">                JavadocTagInfo.SERIAL_DATA.isValidOn(ast));</span>
<span class="fc" id="L379">    }</span>

    @Test
    public void testCoverage() {
<span class="fc" id="L383">        assertEquals(&quot;Invalid type&quot;, JavadocTagInfo.Type.BLOCK, JavadocTagInfo.VERSION.getType());</span>

<span class="fc" id="L385">        assertEquals(&quot;Invalid toString result&quot;, &quot;text [@version] name [version] type [BLOCK]&quot;,</span>
<span class="fc" id="L386">            JavadocTagInfo.VERSION.toString());</span>

        try {
<span class="nc" id="L389">            JavadocTagInfo.fromName(null);</span>
<span class="nc" id="L390">            fail(&quot;IllegalArgumentException is expected&quot;);</span>
        }
<span class="fc" id="L392">        catch (IllegalArgumentException ex) {</span>
<span class="fc" id="L393">            assertEquals(&quot;Invalid exception message&quot;,</span>
<span class="fc" id="L394">                    &quot;the name is null&quot;, ex.getMessage());</span>
<span class="nc" id="L395">        }</span>

        try {
<span class="nc" id="L398">            JavadocTagInfo.fromName(&quot;myname&quot;);</span>
<span class="nc" id="L399">            fail(&quot;IllegalArgumentException is expected&quot;);</span>
        }
<span class="fc" id="L401">        catch (IllegalArgumentException ex) {</span>
<span class="fc" id="L402">            assertEquals(&quot;Invalid exception message&quot;,</span>
<span class="fc" id="L403">                    &quot;the name [myname] is not a valid Javadoc tag name&quot;, ex.getMessage());</span>
<span class="nc" id="L404">        }</span>

        try {
<span class="nc" id="L407">            JavadocTagInfo.fromText(null);</span>
<span class="nc" id="L408">            fail(&quot;IllegalArgumentException is expected&quot;);</span>
        }
<span class="fc" id="L410">        catch (IllegalArgumentException ex) {</span>
<span class="fc" id="L411">            assertEquals(&quot;Invalid exception message&quot;, &quot;the text is null&quot;, ex.getMessage());</span>
<span class="nc" id="L412">        }</span>

        try {
<span class="nc" id="L415">            JavadocTagInfo.fromText(&quot;myname&quot;);</span>
<span class="nc" id="L416">            fail(&quot;IllegalArgumentException is expected&quot;);</span>
        }
<span class="fc" id="L418">        catch (IllegalArgumentException ex) {</span>
<span class="fc" id="L419">            assertEquals(&quot;Invalid exception message&quot;,</span>
<span class="fc" id="L420">                    &quot;the text [myname] is not a valid Javadoc tag text&quot;, ex.getMessage());</span>
<span class="nc" id="L421">        }</span>

<span class="fc" id="L423">        assertEquals(&quot;Invalid fromText result&quot;,</span>
<span class="fc" id="L424">                JavadocTagInfo.VERSION, JavadocTagInfo.fromText(&quot;@version&quot;));</span>
<span class="fc" id="L425">    }</span>

}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.1.201803210924</span></div></body></html>