<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>CheckerTest.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">checkstyle$java_in_checkstyle.exec</a> &gt; <a href="index.source.html" class="el_package">com.puppycrawl.tools.checkstyle</a> &gt; <span class="el_source">CheckerTest.java</span></div><h1>CheckerTest.java</h1><pre class="source lang-java linenums">////////////////////////////////////////////////////////////////////////////////
// checkstyle: Checks Java source code for adherence to a set of rules.
// Copyright (C) 2001-2019 the original author or authors.
//
// This library is free software; you can redistribute it and/or
// modify it under the terms of the GNU Lesser General Public
// License as published by the Free Software Foundation; either
// version 2.1 of the License, or (at your option) any later version.
//
// This library is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
// Lesser General Public License for more details.
//
// You should have received a copy of the GNU Lesser General Public
// License along with this library; if not, write to the Free Software
// Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
////////////////////////////////////////////////////////////////////////////////

package com.puppycrawl.tools.checkstyle;

import static com.puppycrawl.tools.checkstyle.Checker.EXCEPTION_MSG;
import static com.puppycrawl.tools.checkstyle.DefaultLogger.AUDIT_FINISHED_MESSAGE;
import static com.puppycrawl.tools.checkstyle.DefaultLogger.AUDIT_STARTED_MESSAGE;
import static com.puppycrawl.tools.checkstyle.checks.NewlineAtEndOfFileCheck.MSG_KEY_NO_NEWLINE_EOF;
import static org.hamcrest.CoreMatchers.instanceOf;
import static org.junit.Assert.assertArrayEquals;
import static org.junit.Assert.assertEquals;
import static org.junit.Assert.assertFalse;
import static org.junit.Assert.assertNotNull;
import static org.junit.Assert.assertNull;
import static org.junit.Assert.assertThat;
import static org.junit.Assert.assertTrue;
import static org.junit.Assert.fail;

import java.io.ByteArrayInputStream;
import java.io.ByteArrayOutputStream;
import java.io.File;
import java.io.IOError;
import java.io.IOException;
import java.io.InputStream;
import java.io.InputStreamReader;
import java.io.LineNumberReader;
import java.io.UnsupportedEncodingException;
import java.lang.reflect.Field;
import java.lang.reflect.Method;
import java.nio.charset.StandardCharsets;
import java.nio.file.Files;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Collections;
import java.util.HashSet;
import java.util.List;
import java.util.Locale;
import java.util.Properties;
import java.util.Set;
import java.util.SortedSet;
import java.util.TreeSet;
import java.util.stream.Collectors;

import org.junit.Rule;
import org.junit.Test;
import org.junit.rules.TemporaryFolder;
import org.powermock.reflect.Whitebox;

import com.puppycrawl.tools.checkstyle.api.AbstractCheck;
import com.puppycrawl.tools.checkstyle.api.AbstractFileSetCheck;
import com.puppycrawl.tools.checkstyle.api.AuditEvent;
import com.puppycrawl.tools.checkstyle.api.AuditListener;
import com.puppycrawl.tools.checkstyle.api.CheckstyleException;
import com.puppycrawl.tools.checkstyle.api.Configuration;
import com.puppycrawl.tools.checkstyle.api.Context;
import com.puppycrawl.tools.checkstyle.api.DetailAST;
import com.puppycrawl.tools.checkstyle.api.ExternalResourceHolder;
import com.puppycrawl.tools.checkstyle.api.FileText;
import com.puppycrawl.tools.checkstyle.api.Filter;
import com.puppycrawl.tools.checkstyle.api.FilterSet;
import com.puppycrawl.tools.checkstyle.api.LocalizedMessage;
import com.puppycrawl.tools.checkstyle.api.MessageDispatcher;
import com.puppycrawl.tools.checkstyle.api.TokenTypes;
import com.puppycrawl.tools.checkstyle.checks.NewlineAtEndOfFileCheck;
import com.puppycrawl.tools.checkstyle.checks.TranslationCheck;
import com.puppycrawl.tools.checkstyle.checks.coding.HiddenFieldCheck;
import com.puppycrawl.tools.checkstyle.filters.SuppressionFilter;
import com.puppycrawl.tools.checkstyle.internal.testmodules.DebugAuditAdapter;
import com.puppycrawl.tools.checkstyle.internal.testmodules.DebugFilter;
import com.puppycrawl.tools.checkstyle.internal.testmodules.TestBeforeExecutionFileFilter;
import com.puppycrawl.tools.checkstyle.internal.testmodules.TestFileSetCheck;
import com.puppycrawl.tools.checkstyle.internal.utils.CloseAndFlushTestByteArrayOutputStream;
import com.puppycrawl.tools.checkstyle.utils.CommonUtil;

<span class="fc" id="L92">public class CheckerTest extends AbstractModuleTestSupport {</span>

<span class="fc" id="L94">    @Rule</span>
    public final TemporaryFolder temporaryFolder = new TemporaryFolder();

    private static Method getFireAuditFinished() throws NoSuchMethodException {
<span class="fc" id="L98">        final Class&lt;Checker&gt; checkerClass = Checker.class;</span>
<span class="fc" id="L99">        final Method fireAuditFinished = checkerClass.getDeclaredMethod(&quot;fireAuditFinished&quot;);</span>
<span class="fc" id="L100">        fireAuditFinished.setAccessible(true);</span>
<span class="fc" id="L101">        return fireAuditFinished;</span>
    }

    private static Method getFireAuditStartedMethod() throws NoSuchMethodException {
<span class="fc" id="L105">        final Class&lt;Checker&gt; checkerClass = Checker.class;</span>
<span class="fc" id="L106">        final Method fireAuditStarted = checkerClass.getDeclaredMethod(&quot;fireAuditStarted&quot;);</span>
<span class="fc" id="L107">        fireAuditStarted.setAccessible(true);</span>
<span class="fc" id="L108">        return fireAuditStarted;</span>
    }

    @Override
    protected String getPackageLocation() {
<span class="fc" id="L113">        return &quot;com/puppycrawl/tools/checkstyle/checker&quot;;</span>
    }

    @Test
    public void testDestroy() throws Exception {
<span class="fc" id="L118">        final Checker checker = new Checker();</span>
<span class="fc" id="L119">        final DebugAuditAdapter auditAdapter = new DebugAuditAdapter();</span>
<span class="fc" id="L120">        checker.addListener(auditAdapter);</span>
<span class="fc" id="L121">        final TestFileSetCheck fileSet = new TestFileSetCheck();</span>
<span class="fc" id="L122">        checker.addFileSetCheck(fileSet);</span>
<span class="fc" id="L123">        final DebugFilter filter = new DebugFilter();</span>
<span class="fc" id="L124">        checker.addFilter(filter);</span>
<span class="fc" id="L125">        final TestBeforeExecutionFileFilter fileFilter = new TestBeforeExecutionFileFilter();</span>
<span class="fc" id="L126">        checker.addBeforeExecutionFileFilter(fileFilter);</span>

        // should remove all listeners, file sets, and filters
<span class="fc" id="L129">        checker.destroy();</span>

<span class="fc" id="L131">        checker.process(Collections.singletonList(temporaryFolder.newFile()));</span>
<span class="fc" id="L132">        final SortedSet&lt;LocalizedMessage&gt; messages = new TreeSet&lt;&gt;();</span>
<span class="fc" id="L133">        messages.add(new LocalizedMessage(1, 0, &quot;a Bundle&quot;, &quot;message.key&quot;,</span>
<span class="fc" id="L134">                new Object[] {&quot;arg&quot;}, null, getClass(), null));</span>
<span class="fc" id="L135">        checker.fireErrors(&quot;Some File Name&quot;, messages);</span>

<span class="fc" id="L137">        assertFalse(&quot;Checker.destroy() doesn't remove listeners.&quot;, auditAdapter.wasCalled());</span>
<span class="fc" id="L138">        assertFalse(&quot;Checker.destroy() doesn't remove file sets.&quot;, fileSet.wasCalled());</span>
<span class="fc" id="L139">        assertFalse(&quot;Checker.destroy() doesn't remove filters.&quot;, filter.wasCalled());</span>
<span class="fc" id="L140">        assertFalse(&quot;Checker.destroy() doesn't remove file filters.&quot;, fileFilter.wasCalled());</span>
<span class="fc" id="L141">    }</span>

    @Test
    public void testAddListener() throws Exception {
<span class="fc" id="L145">        final Checker checker = new Checker();</span>
<span class="fc" id="L146">        final DebugAuditAdapter auditAdapter = new DebugAuditAdapter();</span>
<span class="fc" id="L147">        checker.addListener(auditAdapter);</span>

        // Let's try fire some events
<span class="fc" id="L150">        getFireAuditStartedMethod().invoke(checker);</span>
<span class="fc" id="L151">        assertTrue(&quot;Checker.fireAuditStarted() doesn't call listener&quot;, auditAdapter.wasCalled());</span>
<span class="fc" id="L152">        assertTrue(&quot;Checker.fireAuditStarted() doesn't pass event&quot;, auditAdapter.wasEventPassed());</span>

<span class="fc" id="L154">        auditAdapter.resetListener();</span>
<span class="fc" id="L155">        getFireAuditFinished().invoke(checker);</span>
<span class="fc" id="L156">        assertTrue(&quot;Checker.fireAuditFinished() doesn't call listener&quot;, auditAdapter.wasCalled());</span>
<span class="fc" id="L157">        assertTrue(&quot;Checker.fireAuditFinished() doesn't pass event&quot;, auditAdapter.wasEventPassed());</span>

<span class="fc" id="L159">        auditAdapter.resetListener();</span>
<span class="fc" id="L160">        checker.fireFileStarted(&quot;Some File Name&quot;);</span>
<span class="fc" id="L161">        assertTrue(&quot;Checker.fireFileStarted() doesn't call listener&quot;, auditAdapter.wasCalled());</span>
<span class="fc" id="L162">        assertTrue(&quot;Checker.fireFileStarted() doesn't pass event&quot;, auditAdapter.wasEventPassed());</span>

<span class="fc" id="L164">        auditAdapter.resetListener();</span>
<span class="fc" id="L165">        checker.fireFileFinished(&quot;Some File Name&quot;);</span>
<span class="fc" id="L166">        assertTrue(&quot;Checker.fireFileFinished() doesn't call listener&quot;, auditAdapter.wasCalled());</span>
<span class="fc" id="L167">        assertTrue(&quot;Checker.fireFileFinished() doesn't pass event&quot;, auditAdapter.wasEventPassed());</span>

<span class="fc" id="L169">        auditAdapter.resetListener();</span>
<span class="fc" id="L170">        final SortedSet&lt;LocalizedMessage&gt; messages = new TreeSet&lt;&gt;();</span>
<span class="fc" id="L171">        messages.add(new LocalizedMessage(1, 0, &quot;a Bundle&quot;, &quot;message.key&quot;,</span>
<span class="fc" id="L172">                new Object[] {&quot;arg&quot;}, null, getClass(), null));</span>
<span class="fc" id="L173">        checker.fireErrors(&quot;Some File Name&quot;, messages);</span>
<span class="fc" id="L174">        assertTrue(&quot;Checker.fireErrors() doesn't call listener&quot;, auditAdapter.wasCalled());</span>
<span class="fc" id="L175">        assertTrue(&quot;Checker.fireErrors() doesn't pass event&quot;, auditAdapter.wasEventPassed());</span>
<span class="fc" id="L176">    }</span>

    @Test
    public void testRemoveListener() throws Exception {
<span class="fc" id="L180">        final Checker checker = new Checker();</span>
<span class="fc" id="L181">        final DebugAuditAdapter auditAdapter = new DebugAuditAdapter();</span>
<span class="fc" id="L182">        final DebugAuditAdapter aa2 = new DebugAuditAdapter();</span>
<span class="fc" id="L183">        checker.addListener(auditAdapter);</span>
<span class="fc" id="L184">        checker.addListener(aa2);</span>
<span class="fc" id="L185">        checker.removeListener(auditAdapter);</span>

        // Let's try fire some events
<span class="fc" id="L188">        getFireAuditStartedMethod().invoke(checker);</span>
<span class="fc" id="L189">        assertTrue(&quot;Checker.fireAuditStarted() doesn't call listener&quot;, aa2.wasCalled());</span>
<span class="fc" id="L190">        assertFalse(&quot;Checker.fireAuditStarted() does call removed listener&quot;,</span>
<span class="fc" id="L191">                auditAdapter.wasCalled());</span>

<span class="fc" id="L193">        aa2.resetListener();</span>
<span class="fc" id="L194">        getFireAuditFinished().invoke(checker);</span>
<span class="fc" id="L195">        assertTrue(&quot;Checker.fireAuditFinished() doesn't call listener&quot;, aa2.wasCalled());</span>
<span class="fc" id="L196">        assertFalse(&quot;Checker.fireAuditFinished() does call removed listener&quot;,</span>
<span class="fc" id="L197">                auditAdapter.wasCalled());</span>

<span class="fc" id="L199">        aa2.resetListener();</span>
<span class="fc" id="L200">        checker.fireFileStarted(&quot;Some File Name&quot;);</span>
<span class="fc" id="L201">        assertTrue(&quot;Checker.fireFileStarted() doesn't call listener&quot;, aa2.wasCalled());</span>
<span class="fc" id="L202">        assertFalse(&quot;Checker.fireFileStarted() does call removed listener&quot;,</span>
<span class="fc" id="L203">                auditAdapter.wasCalled());</span>

<span class="fc" id="L205">        aa2.resetListener();</span>
<span class="fc" id="L206">        checker.fireFileFinished(&quot;Some File Name&quot;);</span>
<span class="fc" id="L207">        assertTrue(&quot;Checker.fireFileFinished() doesn't call listener&quot;, aa2.wasCalled());</span>
<span class="fc" id="L208">        assertFalse(&quot;Checker.fireFileFinished() does call removed listener&quot;,</span>
<span class="fc" id="L209">                auditAdapter.wasCalled());</span>

<span class="fc" id="L211">        aa2.resetListener();</span>
<span class="fc" id="L212">        final SortedSet&lt;LocalizedMessage&gt; messages = new TreeSet&lt;&gt;();</span>
<span class="fc" id="L213">        messages.add(new LocalizedMessage(1, 0, &quot;a Bundle&quot;, &quot;message.key&quot;,</span>
<span class="fc" id="L214">                new Object[] {&quot;arg&quot;}, null, getClass(), null));</span>
<span class="fc" id="L215">        checker.fireErrors(&quot;Some File Name&quot;, messages);</span>
<span class="fc" id="L216">        assertTrue(&quot;Checker.fireErrors() doesn't call listener&quot;, aa2.wasCalled());</span>
<span class="fc" id="L217">        assertFalse(&quot;Checker.fireErrors() does call removed listener&quot;, auditAdapter.wasCalled());</span>
<span class="fc" id="L218">    }</span>

    @Test
    public void testAddBeforeExecutionFileFilter() throws Exception {
<span class="fc" id="L222">        final Checker checker = new Checker();</span>
<span class="fc" id="L223">        final TestBeforeExecutionFileFilter filter = new TestBeforeExecutionFileFilter();</span>

<span class="fc" id="L225">        checker.addBeforeExecutionFileFilter(filter);</span>

<span class="fc" id="L227">        filter.resetFilter();</span>
<span class="fc" id="L228">        checker.process(Collections.singletonList(new File(&quot;dummy.java&quot;)));</span>
<span class="fc" id="L229">        assertTrue(&quot;Checker.acceptFileStarted() doesn't call filter&quot;, filter.wasCalled());</span>
<span class="fc" id="L230">    }</span>

    @Test
    public void testRemoveBeforeExecutionFileFilter() throws Exception {
<span class="fc" id="L234">        final Checker checker = new Checker();</span>
<span class="fc" id="L235">        final TestBeforeExecutionFileFilter filter = new TestBeforeExecutionFileFilter();</span>
<span class="fc" id="L236">        final TestBeforeExecutionFileFilter f2 = new TestBeforeExecutionFileFilter();</span>
<span class="fc" id="L237">        checker.addBeforeExecutionFileFilter(filter);</span>
<span class="fc" id="L238">        checker.addBeforeExecutionFileFilter(f2);</span>
<span class="fc" id="L239">        checker.removeBeforeExecutionFileFilter(filter);</span>

<span class="fc" id="L241">        f2.resetFilter();</span>
<span class="fc" id="L242">        checker.process(Collections.singletonList(new File(&quot;dummy.java&quot;)));</span>
<span class="fc" id="L243">        assertTrue(&quot;Checker.acceptFileStarted() doesn't call filter&quot;, f2.wasCalled());</span>
<span class="fc" id="L244">        assertFalse(&quot;Checker.acceptFileStarted() does call removed filter&quot;, filter.wasCalled());</span>
<span class="fc" id="L245">    }</span>

    @Test
    public void testAddFilter() {
<span class="fc" id="L249">        final Checker checker = new Checker();</span>
<span class="fc" id="L250">        final DebugFilter filter = new DebugFilter();</span>

<span class="fc" id="L252">        checker.addFilter(filter);</span>

<span class="fc" id="L254">        filter.resetFilter();</span>
<span class="fc" id="L255">        final SortedSet&lt;LocalizedMessage&gt; messages = new TreeSet&lt;&gt;();</span>
<span class="fc" id="L256">        messages.add(new LocalizedMessage(1, 0, &quot;a Bundle&quot;, &quot;message.key&quot;,</span>
<span class="fc" id="L257">                new Object[] {&quot;arg&quot;}, null, getClass(), null));</span>
<span class="fc" id="L258">        checker.fireErrors(&quot;Some File Name&quot;, messages);</span>
<span class="fc" id="L259">        assertTrue(&quot;Checker.fireErrors() doesn't call filter&quot;, filter.wasCalled());</span>
<span class="fc" id="L260">    }</span>

    @Test
    public void testRemoveFilter() {
<span class="fc" id="L264">        final Checker checker = new Checker();</span>
<span class="fc" id="L265">        final DebugFilter filter = new DebugFilter();</span>
<span class="fc" id="L266">        final DebugFilter f2 = new DebugFilter();</span>
<span class="fc" id="L267">        checker.addFilter(filter);</span>
<span class="fc" id="L268">        checker.addFilter(f2);</span>
<span class="fc" id="L269">        checker.removeFilter(filter);</span>

<span class="fc" id="L271">        f2.resetFilter();</span>
<span class="fc" id="L272">        final SortedSet&lt;LocalizedMessage&gt; messages = new TreeSet&lt;&gt;();</span>
<span class="fc" id="L273">        messages.add(new LocalizedMessage(1, 0, &quot;a Bundle&quot;, &quot;message.key&quot;,</span>
<span class="fc" id="L274">                new Object[] {&quot;arg&quot;}, null, getClass(), null));</span>
<span class="fc" id="L275">        checker.fireErrors(&quot;Some File Name&quot;, messages);</span>
<span class="fc" id="L276">        assertTrue(&quot;Checker.fireErrors() doesn't call filter&quot;, f2.wasCalled());</span>
<span class="fc" id="L277">        assertFalse(&quot;Checker.fireErrors() does call removed filter&quot;, filter.wasCalled());</span>
<span class="fc" id="L278">    }</span>

    @Test
    public void testFileExtensions() throws Exception {
<span class="fc" id="L282">        final DefaultConfiguration checkerConfig = new DefaultConfiguration(&quot;configuration&quot;);</span>
<span class="fc" id="L283">        checkerConfig.addAttribute(&quot;charset&quot;, StandardCharsets.UTF_8.name());</span>
<span class="fc" id="L284">        checkerConfig.addAttribute(&quot;cacheFile&quot;, temporaryFolder.newFile().getPath());</span>

<span class="fc" id="L286">        final Checker checker = new Checker();</span>
<span class="fc" id="L287">        checker.setModuleClassLoader(Thread.currentThread().getContextClassLoader());</span>
<span class="fc" id="L288">        checker.configure(checkerConfig);</span>

<span class="fc" id="L290">        final DebugAuditAdapter auditAdapter = new DebugAuditAdapter();</span>
<span class="fc" id="L291">        checker.addListener(auditAdapter);</span>

<span class="fc" id="L293">        final List&lt;File&gt; files = new ArrayList&lt;&gt;();</span>
<span class="fc" id="L294">        final File file = new File(&quot;file.pdf&quot;);</span>
<span class="fc" id="L295">        files.add(file);</span>
<span class="fc" id="L296">        final File otherFile = new File(&quot;file.java&quot;);</span>
<span class="fc" id="L297">        files.add(otherFile);</span>
<span class="fc" id="L298">        final String[] fileExtensions = {&quot;java&quot;, &quot;xml&quot;, &quot;properties&quot;};</span>
<span class="fc" id="L299">        checker.setFileExtensions(fileExtensions);</span>
<span class="fc" id="L300">        checker.setCacheFile(temporaryFolder.newFile().getPath());</span>
<span class="fc" id="L301">        final int counter = checker.process(files);</span>

        // comparing to 1 as there is only one legal file in input
<span class="fc" id="L304">        final int numLegalFiles = 1;</span>
<span class="fc" id="L305">        final PropertyCacheFile cache = Whitebox.getInternalState(checker, &quot;cacheFile&quot;);</span>
<span class="fc" id="L306">        assertEquals(&quot;There were more legal files than expected&quot;,</span>
                numLegalFiles, counter);
<span class="fc" id="L308">        assertEquals(&quot;Audit was started on larger amount of files than expected&quot;,</span>
<span class="fc" id="L309">                numLegalFiles, auditAdapter.getNumFilesStarted());</span>
<span class="fc" id="L310">        assertEquals(&quot;Audit was finished on larger amount of files than expected&quot;,</span>
<span class="fc" id="L311">                numLegalFiles, auditAdapter.getNumFilesFinished());</span>
<span class="fc" id="L312">        assertNull(&quot;Cache shout not contain any file&quot;,</span>
<span class="fc" id="L313">                cache.get(new File(&quot;file.java&quot;).getCanonicalPath()));</span>
<span class="fc" id="L314">    }</span>

    @Test
    public void testIgnoredFileExtensions() throws Exception {
<span class="fc" id="L318">        final DefaultConfiguration checkerConfig = new DefaultConfiguration(&quot;configuration&quot;);</span>
<span class="fc" id="L319">        checkerConfig.addAttribute(&quot;charset&quot;, StandardCharsets.UTF_8.name());</span>
<span class="fc" id="L320">        checkerConfig.addAttribute(&quot;cacheFile&quot;, temporaryFolder.newFile().getPath());</span>

<span class="fc" id="L322">        final Checker checker = new Checker();</span>
<span class="fc" id="L323">        checker.setModuleClassLoader(Thread.currentThread().getContextClassLoader());</span>
<span class="fc" id="L324">        checker.configure(checkerConfig);</span>

<span class="fc" id="L326">        final DebugAuditAdapter auditAdapter = new DebugAuditAdapter();</span>
<span class="fc" id="L327">        checker.addListener(auditAdapter);</span>

<span class="fc" id="L329">        final List&lt;File&gt; allIgnoredFiles = new ArrayList&lt;&gt;();</span>
<span class="fc" id="L330">        final File ignoredFile = new File(&quot;file.pdf&quot;);</span>
<span class="fc" id="L331">        allIgnoredFiles.add(ignoredFile);</span>
<span class="fc" id="L332">        final String[] fileExtensions = {&quot;java&quot;, &quot;xml&quot;, &quot;properties&quot;};</span>
<span class="fc" id="L333">        checker.setFileExtensions(fileExtensions);</span>
<span class="fc" id="L334">        checker.setCacheFile(temporaryFolder.newFile().getPath());</span>
<span class="fc" id="L335">        final int counter = checker.process(allIgnoredFiles);</span>

        // comparing to 0 as there is no legal file in input
<span class="fc" id="L338">        final int numLegalFiles = 0;</span>
<span class="fc" id="L339">        assertEquals(&quot;There were more legal files than expected&quot;,</span>
                numLegalFiles, counter);
<span class="fc" id="L341">        assertEquals(&quot;Audit was started on larger amount of files than expected&quot;,</span>
<span class="fc" id="L342">                numLegalFiles, auditAdapter.getNumFilesStarted());</span>
<span class="fc" id="L343">        assertEquals(&quot;Audit was finished on larger amount of files than expected&quot;,</span>
<span class="fc" id="L344">                numLegalFiles, auditAdapter.getNumFilesFinished());</span>
<span class="fc" id="L345">    }</span>

    @Test
    public void testSetters() {
        // all  that is set by reflection, so just make code coverage be happy
<span class="fc" id="L350">        final Checker checker = new Checker();</span>
<span class="fc" id="L351">        checker.setClassLoader(getClass().getClassLoader());</span>
<span class="fc" id="L352">        checker.setBasedir(&quot;some&quot;);</span>
<span class="fc" id="L353">        checker.setSeverity(&quot;ignore&quot;);</span>

<span class="fc" id="L355">        final PackageObjectFactory factory = new PackageObjectFactory(</span>
<span class="fc" id="L356">            new HashSet&lt;&gt;(), Thread.currentThread().getContextClassLoader());</span>
<span class="fc" id="L357">        checker.setModuleFactory(factory);</span>

<span class="fc" id="L359">        checker.setFileExtensions((String[]) null);</span>
<span class="fc" id="L360">        checker.setFileExtensions(&quot;.java&quot;, &quot;xml&quot;);</span>

        try {
<span class="nc" id="L363">            checker.setCharset(&quot;UNKNOWN-CHARSET&quot;);</span>
<span class="nc" id="L364">            fail(&quot;Exception is expected&quot;);</span>
        }
<span class="fc" id="L366">        catch (UnsupportedEncodingException ex) {</span>
<span class="fc" id="L367">            assertEquals(&quot;Error message is not expected&quot;,</span>
<span class="fc" id="L368">                    &quot;unsupported charset: 'UNKNOWN-CHARSET'&quot;, ex.getMessage());</span>
<span class="nc" id="L369">        }</span>
<span class="fc" id="L370">    }</span>

    @Test
    public void testNoClassLoaderNoModuleFactory() {
<span class="fc" id="L374">        final Checker checker = new Checker();</span>

        try {
<span class="nc" id="L377">            checker.finishLocalSetup();</span>
<span class="nc" id="L378">            fail(&quot;Exception is expected&quot;);</span>
        }
<span class="fc" id="L380">        catch (CheckstyleException ex) {</span>
<span class="fc" id="L381">            assertEquals(&quot;Error message is not expected&quot;,</span>
                    &quot;if no custom moduleFactory is set, moduleClassLoader must be specified&quot;,
<span class="fc" id="L383">                    ex.getMessage());</span>
<span class="nc" id="L384">        }</span>
<span class="fc" id="L385">    }</span>

    @Test
    public void testNoModuleFactory() throws Exception {
<span class="fc" id="L389">        final Checker checker = new Checker();</span>
<span class="fc" id="L390">        final ClassLoader classLoader = Thread.currentThread().getContextClassLoader();</span>

<span class="fc" id="L392">        checker.setModuleClassLoader(classLoader);</span>
<span class="fc" id="L393">        checker.finishLocalSetup();</span>
<span class="fc" id="L394">        final Context actualCtx = Whitebox.getInternalState(checker, &quot;childContext&quot;);</span>

<span class="fc" id="L396">        assertNotNull(&quot;Default module factory should be created when it is not specified&quot;,</span>
<span class="fc" id="L397">            actualCtx.get(&quot;moduleFactory&quot;));</span>
<span class="fc" id="L398">        assertEquals(&quot;Invalid classLoader&quot;, classLoader, actualCtx.get(&quot;classLoader&quot;));</span>
<span class="fc" id="L399">    }</span>

    @Test
    public void testFinishLocalSetupFullyInitialized() throws Exception {
<span class="fc" id="L403">        final Checker checker = new Checker();</span>
<span class="fc" id="L404">        final ClassLoader contextClassLoader = Thread.currentThread().getContextClassLoader();</span>
<span class="fc" id="L405">        checker.setModuleClassLoader(contextClassLoader);</span>
<span class="fc" id="L406">        final PackageObjectFactory factory = new PackageObjectFactory(</span>
            new HashSet&lt;&gt;(), contextClassLoader);
<span class="fc" id="L408">        checker.setModuleFactory(factory);</span>
<span class="fc" id="L409">        checker.setBasedir(&quot;testBaseDir&quot;);</span>
<span class="fc" id="L410">        checker.setLocaleLanguage(&quot;it&quot;);</span>
<span class="fc" id="L411">        checker.setLocaleCountry(&quot;IT&quot;);</span>
<span class="fc" id="L412">        checker.finishLocalSetup();</span>

<span class="fc" id="L414">        final Context context = Whitebox.getInternalState(checker, &quot;childContext&quot;);</span>
<span class="fc" id="L415">        assertEquals(&quot;Charset was different than expected&quot;,</span>
<span class="fc" id="L416">                System.getProperty(&quot;file.encoding&quot;, StandardCharsets.UTF_8.name()),</span>
<span class="fc" id="L417">                context.get(&quot;charset&quot;));</span>
<span class="fc" id="L418">        assertEquals(&quot;Was used insufficient classloader&quot;,</span>
<span class="fc" id="L419">                contextClassLoader, context.get(&quot;classLoader&quot;));</span>
<span class="fc" id="L420">        assertEquals(&quot;Severity is set to unexpected value&quot;,</span>
<span class="fc" id="L421">                &quot;error&quot;, context.get(&quot;severity&quot;));</span>
<span class="fc" id="L422">        assertEquals(&quot;Basedir is set to unexpected value&quot;,</span>
<span class="fc" id="L423">                &quot;testBaseDir&quot;, context.get(&quot;basedir&quot;));</span>

<span class="fc" id="L425">        final Field sLocale = LocalizedMessage.class.getDeclaredField(&quot;sLocale&quot;);</span>
<span class="fc" id="L426">        sLocale.setAccessible(true);</span>
<span class="fc" id="L427">        final Locale locale = (Locale) sLocale.get(null);</span>
<span class="fc" id="L428">        assertEquals(&quot;Locale is set to unexpected value&quot;, Locale.ITALY, locale);</span>
<span class="fc" id="L429">    }</span>

    @Test
    public void testSetupChildExceptions() {
<span class="fc" id="L433">        final Checker checker = new Checker();</span>
<span class="fc" id="L434">        final PackageObjectFactory factory = new PackageObjectFactory(</span>
<span class="fc" id="L435">            new HashSet&lt;&gt;(), Thread.currentThread().getContextClassLoader());</span>
<span class="fc" id="L436">        checker.setModuleFactory(factory);</span>

<span class="fc" id="L438">        final Configuration config = new DefaultConfiguration(&quot;java.lang.String&quot;);</span>
        try {
<span class="nc" id="L440">            checker.setupChild(config);</span>
<span class="nc" id="L441">            fail(&quot;Exception is expected&quot;);</span>
        }
<span class="fc" id="L443">        catch (CheckstyleException ex) {</span>
<span class="fc" id="L444">            assertEquals(&quot;Error message is not expected&quot;,</span>
<span class="fc" id="L445">                    &quot;java.lang.String is not allowed as a child in Checker&quot;, ex.getMessage());</span>
<span class="nc" id="L446">        }</span>
<span class="fc" id="L447">    }</span>

    @Test
    public void testSetupChildInvalidProperty() throws Exception {
<span class="fc" id="L451">        final DefaultConfiguration checkConfig = createModuleConfig(HiddenFieldCheck.class);</span>
<span class="fc" id="L452">        checkConfig.addAttribute(&quot;$$No such property&quot;, null);</span>
        try {
<span class="nc" id="L454">            createChecker(checkConfig);</span>
<span class="nc" id="L455">            fail(&quot;Exception is expected&quot;);</span>
        }
<span class="fc" id="L457">        catch (CheckstyleException ex) {</span>
<span class="fc" id="L458">            assertEquals(&quot;Error message is not expected&quot;,</span>
                    &quot;cannot initialize module com.puppycrawl.tools.checkstyle.TreeWalker&quot;
<span class="fc" id="L460">                        + &quot; - cannot initialize module &quot; + checkConfig.getName()</span>
                        + &quot; - Property '$$No such property'&quot;
<span class="fc" id="L462">                        + &quot; does not exist, please check the documentation&quot;, ex.getMessage());</span>
<span class="nc" id="L463">        }</span>
<span class="fc" id="L464">    }</span>

    @Test
    public void testSetupChildListener() throws Exception {
<span class="fc" id="L468">        final Checker checker = new Checker();</span>
<span class="fc" id="L469">        final PackageObjectFactory factory = new PackageObjectFactory(</span>
<span class="fc" id="L470">            new HashSet&lt;&gt;(), Thread.currentThread().getContextClassLoader());</span>
<span class="fc" id="L471">        checker.setModuleFactory(factory);</span>

<span class="fc" id="L473">        final Configuration config = new DefaultConfiguration(</span>
<span class="fc" id="L474">            DebugAuditAdapter.class.getCanonicalName());</span>
<span class="fc" id="L475">        checker.setupChild(config);</span>

<span class="fc" id="L477">        final List&lt;AuditListener&gt; listeners = Whitebox.getInternalState(checker, &quot;listeners&quot;);</span>
<span class="fc" id="L478">        assertTrue(&quot;Invalid child listener class&quot;,</span>
<span class="fc" id="L479">            listeners.get(listeners.size() - 1) instanceof DebugAuditAdapter);</span>
<span class="fc" id="L480">    }</span>

    @Test
    public void testDestroyCheckerWithWrongCacheFileNameLength() throws Exception {
<span class="fc" id="L484">        final Checker checker = new Checker();</span>
<span class="fc" id="L485">        final PackageObjectFactory factory = new PackageObjectFactory(</span>
<span class="fc" id="L486">            new HashSet&lt;&gt;(), Thread.currentThread().getContextClassLoader());</span>
<span class="fc" id="L487">        checker.setModuleFactory(factory);</span>
<span class="fc" id="L488">        checker.configure(new DefaultConfiguration(&quot;default config&quot;));</span>
        // We set wrong file name length in order to reproduce IOException on OS Linux, OS Windows.
        // The maximum file name length which is allowed in most UNIX, Windows file systems is 255.
        // See https://en.wikipedia.org/wiki/Filename;
<span class="fc" id="L492">        checker.setCacheFile(String.format(Locale.ENGLISH, &quot;%0300d&quot;, 0));</span>
        try {
<span class="nc" id="L494">            checker.destroy();</span>
<span class="nc" id="L495">            fail(&quot;Exception did not happen&quot;);</span>
        }
<span class="fc" id="L497">        catch (IllegalStateException ex) {</span>
<span class="fc" id="L498">            assertTrue(&quot;Cause of exception differs from IOException&quot;,</span>
<span class="fc" id="L499">                    ex.getCause() instanceof IOException);</span>
<span class="nc" id="L500">        }</span>
<span class="fc" id="L501">    }</span>

    /**
     * It is OK to have long test method name here as it describes the test purpose.
     */
    @Test
    public void testCacheAndCheckWhichDoesNotImplementExternalResourceHolderInterface()
            throws Exception {
<span class="fc" id="L509">        assertFalse(&quot;ExternalResourceHolder has changed his parent&quot;,</span>
<span class="fc" id="L510">                ExternalResourceHolder.class.isAssignableFrom(HiddenFieldCheck.class));</span>
<span class="fc" id="L511">        final DefaultConfiguration checkConfig = createModuleConfig(HiddenFieldCheck.class);</span>

<span class="fc" id="L513">        final DefaultConfiguration treeWalkerConfig = createModuleConfig(TreeWalker.class);</span>
<span class="fc" id="L514">        treeWalkerConfig.addChild(checkConfig);</span>

<span class="fc" id="L516">        final DefaultConfiguration checkerConfig = createRootConfig(treeWalkerConfig);</span>
<span class="fc" id="L517">        checkerConfig.addAttribute(&quot;charset&quot;, StandardCharsets.UTF_8.name());</span>

<span class="fc" id="L519">        final File cacheFile = temporaryFolder.newFile();</span>
<span class="fc" id="L520">        checkerConfig.addAttribute(&quot;cacheFile&quot;, cacheFile.getPath());</span>

<span class="fc" id="L522">        final File tmpFile = temporaryFolder.newFile(&quot;file.java&quot;);</span>
<span class="fc" id="L523">        final String[] expected = CommonUtil.EMPTY_STRING_ARRAY;</span>

<span class="fc" id="L525">        verify(checkerConfig, tmpFile.getPath(), expected);</span>
<span class="fc" id="L526">        final Properties cacheAfterFirstRun = new Properties();</span>
<span class="fc" id="L527">        cacheAfterFirstRun.load(Files.newBufferedReader(cacheFile.toPath()));</span>

        // one more time to reuse cache
<span class="fc" id="L530">        verify(checkerConfig, tmpFile.getPath(), expected);</span>
<span class="fc" id="L531">        final Properties cacheAfterSecondRun = new Properties();</span>
<span class="fc" id="L532">        cacheAfterSecondRun.load(Files.newBufferedReader(cacheFile.toPath()));</span>

<span class="fc" id="L534">        assertEquals(&quot;Cache from first run differs from second run cache&quot;,</span>
                cacheAfterFirstRun, cacheAfterSecondRun);
<span class="fc" id="L536">    }</span>

    @Test
    public void testWithCacheWithNoViolation() throws Exception {
<span class="fc" id="L540">        final Checker checker = new Checker();</span>
<span class="fc" id="L541">        final PackageObjectFactory factory = new PackageObjectFactory(</span>
<span class="fc" id="L542">            new HashSet&lt;&gt;(), Thread.currentThread().getContextClassLoader());</span>
<span class="fc" id="L543">        checker.setModuleFactory(factory);</span>
<span class="fc" id="L544">        checker.configure(createModuleConfig(TranslationCheck.class));</span>

<span class="fc" id="L546">        final File cacheFile = temporaryFolder.newFile();</span>
<span class="fc" id="L547">        checker.setCacheFile(cacheFile.getPath());</span>

<span class="fc" id="L549">        checker.setupChild(createModuleConfig(TranslationCheck.class));</span>
<span class="fc" id="L550">        final File tmpFile = temporaryFolder.newFile(&quot;file.java&quot;);</span>
<span class="fc" id="L551">        final List&lt;File&gt; files = new ArrayList&lt;&gt;(1);</span>
<span class="fc" id="L552">        files.add(tmpFile);</span>
<span class="fc" id="L553">        checker.process(files);</span>

        // invoke destroy to persist cache
<span class="fc" id="L556">        checker.destroy();</span>

<span class="fc" id="L558">        final Properties cache = new Properties();</span>
<span class="fc" id="L559">        cache.load(Files.newBufferedReader(cacheFile.toPath()));</span>

        // There should 2 objects in cache: processed file (file.java) and checker configuration.
<span class="fc" id="L562">        final int expectedNumberOfObjectsInCache = 2;</span>
<span class="fc" id="L563">        assertEquals(&quot;Cache has unexpected size&quot;,</span>
<span class="fc" id="L564">                expectedNumberOfObjectsInCache, cache.size());</span>

<span class="fc" id="L566">        final String expectedConfigHash = &quot;B8535A811CA90BE8B7A14D40BCA62B4FC2447B46&quot;;</span>
<span class="fc" id="L567">        assertEquals(&quot;Cache has unexpected hash&quot;,</span>
<span class="fc" id="L568">                expectedConfigHash, cache.getProperty(PropertyCacheFile.CONFIG_HASH_KEY));</span>

<span class="fc" id="L570">        assertNotNull(&quot;Cache file has null path&quot;,</span>
<span class="fc" id="L571">                cache.getProperty(tmpFile.getPath()));</span>
<span class="fc" id="L572">    }</span>

    @Test
    public void testClearExistingCache() throws Exception {
<span class="fc" id="L576">        final DefaultConfiguration checkerConfig = createRootConfig(null);</span>
<span class="fc" id="L577">        checkerConfig.addAttribute(&quot;charset&quot;, StandardCharsets.UTF_8.name());</span>
<span class="fc" id="L578">        final File cacheFile = temporaryFolder.newFile();</span>
<span class="fc" id="L579">        checkerConfig.addAttribute(&quot;cacheFile&quot;, cacheFile.getPath());</span>

<span class="fc" id="L581">        final Checker checker = new Checker();</span>
<span class="fc" id="L582">        checker.setModuleClassLoader(Thread.currentThread().getContextClassLoader());</span>
<span class="fc" id="L583">        checker.configure(checkerConfig);</span>
<span class="fc" id="L584">        checker.addListener(getBriefUtLogger());</span>

<span class="fc" id="L586">        checker.clearCache();</span>
        // invoke destroy to persist cache
<span class="fc" id="L588">        checker.destroy();</span>

<span class="fc" id="L590">        final Properties cacheAfterClear = new Properties();</span>
<span class="fc" id="L591">        cacheAfterClear.load(Files.newBufferedReader(cacheFile.toPath()));</span>

<span class="fc" id="L593">        assertEquals(&quot;Cache has unexpected size&quot;,</span>
<span class="fc" id="L594">                1, cacheAfterClear.size());</span>
<span class="fc" id="L595">        assertNotNull(&quot;Cache has null hash&quot;,</span>
<span class="fc" id="L596">                cacheAfterClear.getProperty(PropertyCacheFile.CONFIG_HASH_KEY));</span>

<span class="fc" id="L598">        final String pathToEmptyFile = temporaryFolder.newFile(&quot;file.java&quot;).getPath();</span>
<span class="fc" id="L599">        final String[] expected = CommonUtil.EMPTY_STRING_ARRAY;</span>

        // file that should be audited is not in cache
<span class="fc" id="L602">        verify(checker, pathToEmptyFile, pathToEmptyFile, expected);</span>
<span class="fc" id="L603">        final Properties cacheAfterSecondRun = new Properties();</span>
<span class="fc" id="L604">        cacheAfterSecondRun.load(Files.newBufferedReader(cacheFile.toPath()));</span>

<span class="fc" id="L606">        assertNotNull(&quot;Cache has null path&quot;,</span>
<span class="fc" id="L607">                cacheAfterSecondRun.getProperty(pathToEmptyFile));</span>
<span class="fc" id="L608">        assertEquals(&quot;Cash have changed it hash&quot;,</span>
<span class="fc" id="L609">            cacheAfterClear.getProperty(PropertyCacheFile.CONFIG_HASH_KEY),</span>
<span class="fc" id="L610">            cacheAfterSecondRun.getProperty(PropertyCacheFile.CONFIG_HASH_KEY)</span>
        );
<span class="fc" id="L612">        final int expectedNumberOfObjectsInCacheAfterSecondRun = 2;</span>
<span class="fc" id="L613">        assertEquals(&quot;Cache has changed number of items&quot;,</span>
<span class="fc" id="L614">                expectedNumberOfObjectsInCacheAfterSecondRun, cacheAfterSecondRun.size());</span>
<span class="fc" id="L615">    }</span>

    @Test
    public void testClearCache() throws Exception {
<span class="fc" id="L619">        final DefaultConfiguration violationCheck =</span>
<span class="fc" id="L620">                createModuleConfig(DummyFileSetViolationCheck.class);</span>
<span class="fc" id="L621">        final DefaultConfiguration checkerConfig = new DefaultConfiguration(&quot;myConfig&quot;);</span>
<span class="fc" id="L622">        checkerConfig.addAttribute(&quot;charset&quot;, &quot;UTF-8&quot;);</span>
<span class="fc" id="L623">        final File cacheFile = temporaryFolder.newFile();</span>
<span class="fc" id="L624">        checkerConfig.addAttribute(&quot;cacheFile&quot;, cacheFile.getPath());</span>
<span class="fc" id="L625">        checkerConfig.addChild(violationCheck);</span>
<span class="fc" id="L626">        final Checker checker = new Checker();</span>
<span class="fc" id="L627">        checker.setModuleClassLoader(Thread.currentThread().getContextClassLoader());</span>
<span class="fc" id="L628">        checker.configure(checkerConfig);</span>
<span class="fc" id="L629">        checker.addListener(getBriefUtLogger());</span>

<span class="fc" id="L631">        checker.process(Collections.singletonList(new File(&quot;dummy.java&quot;)));</span>
<span class="fc" id="L632">        checker.clearCache();</span>
        // invoke destroy to persist cache
<span class="fc" id="L634">        final PropertyCacheFile cache = Whitebox.getInternalState(checker, &quot;cacheFile&quot;);</span>
<span class="fc" id="L635">        cache.persist();</span>

<span class="fc" id="L637">        final Properties cacheAfterClear = new Properties();</span>
<span class="fc" id="L638">        cacheAfterClear.load(Files.newBufferedReader(cacheFile.toPath()));</span>

<span class="fc" id="L640">        assertEquals(&quot;Cache has unexpected size&quot;,</span>
<span class="fc" id="L641">                1, cacheAfterClear.size());</span>
<span class="fc" id="L642">    }</span>

    @Test
    public void setFileExtension() {
<span class="fc" id="L646">        final Checker checker = new Checker();</span>
<span class="fc" id="L647">        checker.setFileExtensions(&quot;.test1&quot;, &quot;test2&quot;);</span>
<span class="fc" id="L648">        final String[] actual = Whitebox.getInternalState(checker, &quot;fileExtensions&quot;);</span>
<span class="fc" id="L649">        assertArrayEquals(&quot;Extensions are not expected&quot;,</span>
                new String[] {&quot;.test1&quot;, &quot;.test2&quot;}, actual);
<span class="fc" id="L651">    }</span>

    @Test
    public void testClearCacheWhenCacheFileIsNotSet() {
        // The idea of the test is to check that when cache file is not set,
        // the invocation of clearCache method does not throw an exception.
<span class="fc" id="L657">        final Checker checker = new Checker();</span>
<span class="fc" id="L658">        checker.clearCache();</span>
<span class="fc" id="L659">        assertNull(&quot;If cache file is not set the cache should default to null&quot;,</span>
<span class="fc" id="L660">            Whitebox.getInternalState(checker, &quot;cacheFile&quot;));</span>
<span class="fc" id="L661">    }</span>

    /**
     * Test doesn't need to be serialized.
     * @noinspection SerializableInnerClassWithNonSerializableOuterClass
     */
    @Test
    public void testCatchErrorInProcessFilesMethod() throws Exception {
        // Assume that I/O error is happened when we try to invoke 'lastModified()' method.
<span class="fc" id="L670">        final String errorMessage = &quot;Java Virtual Machine is broken&quot;</span>
            + &quot; or has run out of resources necessary for it to continue operating.&quot;;
<span class="fc" id="L672">        final Error expectedError = new IOError(new InternalError(errorMessage));</span>

<span class="fc" id="L674">        final File mock = new File(&quot;testFile&quot;) {</span>
            private static final long serialVersionUID = 1L;

            /**
             * Test is checking catch clause when exception is thrown.
             * @noinspection ProhibitedExceptionThrown
             */
            @Override
            public long lastModified() {
<span class="fc" id="L683">                throw expectedError;</span>
            }
        };

<span class="fc" id="L687">        final Checker checker = new Checker();</span>
<span class="fc" id="L688">        final List&lt;File&gt; filesToProcess = new ArrayList&lt;&gt;();</span>
<span class="fc" id="L689">        filesToProcess.add(mock);</span>
        try {
<span class="nc" id="L691">            checker.process(filesToProcess);</span>
<span class="nc" id="L692">            fail(&quot;IOError is expected!&quot;);</span>
        }
        // -@cs[IllegalCatchExtended] Testing for catch Error is part of 100% coverage.
<span class="fc" id="L695">        catch (Error error) {</span>
<span class="fc" id="L696">            assertThat(&quot;Error cause differs from IOError&quot;,</span>
<span class="fc" id="L697">                    error.getCause(), instanceOf(IOError.class));</span>
<span class="fc" id="L698">            assertThat(&quot;Error cause is not InternalError&quot;,</span>
<span class="fc" id="L699">                    error.getCause().getCause(), instanceOf(InternalError.class));</span>
<span class="fc" id="L700">            assertEquals(&quot;Error message is not expected&quot;,</span>
<span class="fc" id="L701">                    errorMessage, error.getCause().getCause().getMessage());</span>
<span class="nc" id="L702">        }</span>
<span class="fc" id="L703">    }</span>

    /**
     * Test doesn't need to be serialized.
     * @noinspection SerializableInnerClassWithNonSerializableOuterClass
     */
    @Test
    public void testCatchErrorWithNoFileName() throws Exception {
        // Assume that I/O error is happened when we try to invoke 'lastModified()' method.
<span class="fc" id="L712">        final String errorMessage = &quot;Java Virtual Machine is broken&quot;</span>
            + &quot; or has run out of resources necessary for it to continue operating.&quot;;
<span class="fc" id="L714">        final Error expectedError = new IOError(new InternalError(errorMessage));</span>

<span class="fc" id="L716">        final File mock = new File(&quot;testFile&quot;) {</span>
            private static final long serialVersionUID = 1L;

            /**
             * Test is checking catch clause when exception is thrown.
             * @noinspection ProhibitedExceptionThrown
             */
            @Override
            public long lastModified() {
<span class="fc" id="L725">                throw expectedError;</span>
            }

            @Override
            public String getAbsolutePath() {
<span class="fc" id="L730">                return null;</span>
            }
        };

<span class="fc" id="L734">        final Checker checker = new Checker();</span>
<span class="fc" id="L735">        final List&lt;File&gt; filesToProcess = new ArrayList&lt;&gt;();</span>
<span class="fc" id="L736">        filesToProcess.add(mock);</span>
        try {
<span class="nc" id="L738">            checker.process(filesToProcess);</span>
<span class="nc" id="L739">            fail(&quot;IOError is expected!&quot;);</span>
        }
        // -@cs[IllegalCatchExtended] Testing for catch Error is part of 100% coverage.
<span class="fc" id="L742">        catch (Error error) {</span>
<span class="fc" id="L743">            assertThat(&quot;Error cause differs from IOError&quot;,</span>
<span class="fc" id="L744">                    error.getCause(), instanceOf(IOError.class));</span>
<span class="fc" id="L745">            assertThat(&quot;Error cause is not InternalError&quot;,</span>
<span class="fc" id="L746">                    error.getCause().getCause(), instanceOf(InternalError.class));</span>
<span class="fc" id="L747">            assertEquals(&quot;Error message is not expected&quot;,</span>
<span class="fc" id="L748">                    errorMessage, error.getCause().getCause().getMessage());</span>
<span class="nc" id="L749">        }</span>
<span class="fc" id="L750">    }</span>

    /**
     * It is OK to have long test method name here as it describes the test purpose.
     */
    @Test
    public void testCacheAndFilterWhichDoesNotImplementExternalResourceHolderInterface()
            throws Exception {
<span class="fc" id="L758">        assertFalse(&quot;ExternalResourceHolder has changed its parent&quot;,</span>
<span class="fc" id="L759">                ExternalResourceHolder.class.isAssignableFrom(DummyFilter.class));</span>
<span class="fc" id="L760">        final DefaultConfiguration filterConfig = createModuleConfig(DummyFilter.class);</span>

<span class="fc" id="L762">        final DefaultConfiguration checkerConfig = createRootConfig(filterConfig);</span>
<span class="fc" id="L763">        final File cacheFile = temporaryFolder.newFile();</span>
<span class="fc" id="L764">        checkerConfig.addAttribute(&quot;cacheFile&quot;, cacheFile.getPath());</span>

<span class="fc" id="L766">        final String[] expected = CommonUtil.EMPTY_STRING_ARRAY;</span>
<span class="fc" id="L767">        final String pathToEmptyFile = temporaryFolder.newFile(&quot;file.java&quot;).getPath();</span>

<span class="fc" id="L769">        verify(checkerConfig, pathToEmptyFile, expected);</span>
<span class="fc" id="L770">        final Properties cacheAfterFirstRun = new Properties();</span>
<span class="fc" id="L771">        cacheAfterFirstRun.load(Files.newBufferedReader(cacheFile.toPath()));</span>

        // One more time to use cache.
<span class="fc" id="L774">        verify(checkerConfig, pathToEmptyFile, expected);</span>
<span class="fc" id="L775">        final Properties cacheAfterSecondRun = new Properties();</span>
<span class="fc" id="L776">        cacheAfterSecondRun.load(Files.newBufferedReader(cacheFile.toPath()));</span>

<span class="fc" id="L778">        assertEquals(</span>
                &quot;Cache file has changed its path&quot;,
<span class="fc" id="L780">            cacheAfterFirstRun.getProperty(pathToEmptyFile),</span>
<span class="fc" id="L781">            cacheAfterSecondRun.getProperty(pathToEmptyFile)</span>
        );
<span class="fc" id="L783">        assertEquals(</span>
                &quot;Cache has changed its hash&quot;,
<span class="fc" id="L785">            cacheAfterFirstRun.getProperty(PropertyCacheFile.CONFIG_HASH_KEY),</span>
<span class="fc" id="L786">            cacheAfterSecondRun.getProperty(PropertyCacheFile.CONFIG_HASH_KEY)</span>
        );
<span class="fc" id="L788">        final int expectedNumberOfObjectsInCache = 2;</span>
<span class="fc" id="L789">        assertEquals(&quot;Number of items in cache differs from expected&quot;,</span>
<span class="fc" id="L790">                expectedNumberOfObjectsInCache, cacheAfterFirstRun.size());</span>
<span class="fc" id="L791">        assertEquals(&quot;Number of items in cache differs from expected&quot;,</span>
<span class="fc" id="L792">                expectedNumberOfObjectsInCache, cacheAfterSecondRun.size());</span>
<span class="fc" id="L793">    }</span>

    /**
     * It is OK to have long test method name here as it describes the test purpose.
     */
    // -@cs[ExecutableStatementCount] This test needs to verify many things.
    @Test
    public void testCacheAndCheckWhichAddsNewResourceLocationButKeepsSameCheckerInstance()
            throws Exception {
        // Use case (https://github.com/checkstyle/checkstyle/pull/3092#issuecomment-218162436):
        // Imagine that cache exists in a file. New version of Checkstyle appear.
        // New release contains update to a some check to have additional external resource.
        // User update his configuration and run validation as usually.
        // Cache should not be reused.

<span class="fc" id="L808">        final DynamicalResourceHolderCheck check = new DynamicalResourceHolderCheck();</span>
<span class="fc" id="L809">        final String firstExternalResourceLocation = getPath(&quot;InputCheckerImportControlOne.xml&quot;);</span>
<span class="fc" id="L810">        final String firstExternalResourceKey = PropertyCacheFile.EXTERNAL_RESOURCE_KEY_PREFIX</span>
                + firstExternalResourceLocation;
<span class="fc" id="L812">        check.setFirstExternalResourceLocation(firstExternalResourceLocation);</span>

<span class="fc" id="L814">        final DefaultConfiguration checkerConfig = createRootConfig(null);</span>
<span class="fc" id="L815">        final File cacheFile = temporaryFolder.newFile();</span>
<span class="fc" id="L816">        checkerConfig.addAttribute(&quot;cacheFile&quot;, cacheFile.getPath());</span>

<span class="fc" id="L818">        final Checker checker = new Checker();</span>
<span class="fc" id="L819">        checker.setModuleClassLoader(Thread.currentThread().getContextClassLoader());</span>
<span class="fc" id="L820">        checker.addFileSetCheck(check);</span>
<span class="fc" id="L821">        checker.addFilter(new DummyFilterSet());</span>
<span class="fc" id="L822">        checker.configure(checkerConfig);</span>
<span class="fc" id="L823">        checker.addListener(getBriefUtLogger());</span>

<span class="fc" id="L825">        final String pathToEmptyFile = temporaryFolder.newFile(&quot;file.java&quot;).getPath();</span>
<span class="fc" id="L826">        final String[] expected = CommonUtil.EMPTY_STRING_ARRAY;</span>

<span class="fc" id="L828">        verify(checker, pathToEmptyFile, expected);</span>
<span class="fc" id="L829">        final Properties cacheAfterFirstRun = new Properties();</span>
<span class="fc" id="L830">        cacheAfterFirstRun.load(Files.newBufferedReader(cacheFile.toPath()));</span>

<span class="fc" id="L832">        final int expectedNumberOfObjectsInCacheAfterFirstRun = 4;</span>
<span class="fc" id="L833">        assertEquals(&quot;Number of items in cache differs from expected&quot;,</span>
<span class="fc" id="L834">                expectedNumberOfObjectsInCacheAfterFirstRun, cacheAfterFirstRun.size());</span>

        // Change a list of external resources which are used by the check
<span class="fc" id="L837">        final String secondExternalResourceLocation = &quot;InputCheckerImportControlTwo.xml&quot;;</span>
<span class="fc" id="L838">        final String secondExternalResourceKey = PropertyCacheFile.EXTERNAL_RESOURCE_KEY_PREFIX</span>
                + secondExternalResourceLocation;
<span class="fc" id="L840">        check.setSecondExternalResourceLocation(secondExternalResourceLocation);</span>

<span class="fc" id="L842">        checker.addFileSetCheck(check);</span>
<span class="fc" id="L843">        checker.configure(checkerConfig);</span>

<span class="fc" id="L845">        verify(checker, pathToEmptyFile, expected);</span>
<span class="fc" id="L846">        final Properties cacheAfterSecondRun = new Properties();</span>
<span class="fc" id="L847">        cacheAfterSecondRun.load(Files.newBufferedReader(cacheFile.toPath()));</span>

<span class="fc" id="L849">        assertEquals(&quot;Cache file has changed its path&quot;,</span>
<span class="fc" id="L850">            cacheAfterFirstRun.getProperty(pathToEmptyFile),</span>
<span class="fc" id="L851">            cacheAfterSecondRun.getProperty(pathToEmptyFile)</span>
        );
<span class="fc" id="L853">        assertEquals(</span>
                &quot;Cache has changed its hash&quot;,
<span class="fc" id="L855">            cacheAfterFirstRun.getProperty(PropertyCacheFile.CONFIG_HASH_KEY),</span>
<span class="fc" id="L856">            cacheAfterSecondRun.getProperty(PropertyCacheFile.CONFIG_HASH_KEY)</span>
        );
<span class="fc" id="L858">        assertEquals(&quot;Cache has changed its resource key&quot;,</span>
<span class="fc" id="L859">            cacheAfterFirstRun.getProperty(firstExternalResourceKey),</span>
<span class="fc" id="L860">            cacheAfterSecondRun.getProperty(firstExternalResourceKey)</span>
        );
<span class="fc" id="L862">        assertNotNull(&quot;Cache has null as a resource key&quot;,</span>
<span class="fc" id="L863">                cacheAfterFirstRun.getProperty(firstExternalResourceKey));</span>
<span class="fc" id="L864">        final int expectedNumberOfObjectsInCacheAfterSecondRun = 4;</span>
<span class="fc" id="L865">        assertEquals(&quot;Number of items in cache differs from expected&quot;,</span>
<span class="fc" id="L866">                expectedNumberOfObjectsInCacheAfterSecondRun, cacheAfterSecondRun.size());</span>
<span class="fc" id="L867">        assertNull(&quot;Cache has not null as a resource key&quot;,</span>
<span class="fc" id="L868">                cacheAfterFirstRun.getProperty(secondExternalResourceKey));</span>
<span class="fc" id="L869">        assertNotNull(&quot;Cache has null as a resource key&quot;,</span>
<span class="fc" id="L870">                cacheAfterSecondRun.getProperty(secondExternalResourceKey));</span>
<span class="fc" id="L871">    }</span>

    @Test
    public void testClearLazyLoadCacheInDetailAST() throws Exception {
<span class="fc" id="L875">        final DefaultConfiguration checkConfig1 =</span>
<span class="fc" id="L876">            createModuleConfig(CheckWhichDoesNotRequireCommentNodes.class);</span>
<span class="fc" id="L877">        final DefaultConfiguration checkConfig2 =</span>
<span class="fc" id="L878">            createModuleConfig(CheckWhichRequiresCommentNodes.class);</span>

<span class="fc" id="L880">        final DefaultConfiguration treeWalkerConfig = createModuleConfig(TreeWalker.class);</span>
<span class="fc" id="L881">        treeWalkerConfig.addChild(checkConfig1);</span>
<span class="fc" id="L882">        treeWalkerConfig.addChild(checkConfig2);</span>

<span class="fc" id="L884">        final DefaultConfiguration checkerConfig = createRootConfig(treeWalkerConfig);</span>

<span class="fc" id="L886">        final String filePath = getPath(&quot;InputCheckerClearDetailAstLazyLoadCache.java&quot;);</span>
<span class="fc" id="L887">        final String[] expected = CommonUtil.EMPTY_STRING_ARRAY;</span>

<span class="fc" id="L889">        verify(checkerConfig, filePath, expected);</span>
<span class="fc" id="L890">    }</span>

    @Test
    public void testCacheOnViolationSuppression() throws Exception {
<span class="fc" id="L894">        final File cacheFile = temporaryFolder.newFile();</span>
<span class="fc" id="L895">        final DefaultConfiguration violationCheck =</span>
<span class="fc" id="L896">                createModuleConfig(DummyFileSetViolationCheck.class);</span>

<span class="fc" id="L898">        final DefaultConfiguration filterConfig = createModuleConfig(SuppressionFilter.class);</span>
<span class="fc" id="L899">        filterConfig.addAttribute(&quot;file&quot;, getPath(&quot;InputCheckerSuppressAll.xml&quot;));</span>

<span class="fc" id="L901">        final DefaultConfiguration checkerConfig = createRootConfig(violationCheck);</span>
<span class="fc" id="L902">        checkerConfig.addAttribute(&quot;cacheFile&quot;, cacheFile.getPath());</span>
<span class="fc" id="L903">        checkerConfig.addChild(filterConfig);</span>

<span class="fc" id="L905">        final String fileViolationPath = temporaryFolder.newFile(&quot;ViolationFile.java&quot;).getPath();</span>
<span class="fc" id="L906">        final String[] expected = CommonUtil.EMPTY_STRING_ARRAY;</span>

<span class="fc" id="L908">        verify(checkerConfig, fileViolationPath, expected);</span>

<span class="fc" id="L910">        try (InputStream input = Files.newInputStream(cacheFile.toPath())) {</span>
<span class="fc" id="L911">            final Properties details = new Properties();</span>
<span class="fc" id="L912">            details.load(input);</span>

<span class="fc" id="L914">            assertNotNull(&quot;suppressed violation file saved in cache&quot;,</span>
<span class="fc" id="L915">                    details.getProperty(fileViolationPath));</span>
        }
<span class="fc" id="L917">    }</span>

    @Test
    public void testHaltOnException() throws Exception {
<span class="fc" id="L921">        final DefaultConfiguration checkConfig =</span>
<span class="fc" id="L922">            createModuleConfig(CheckWhichThrowsError.class);</span>
<span class="fc" id="L923">        final String filePath = getPath(&quot;InputChecker.java&quot;);</span>
        try {
<span class="nc" id="L925">            verify(checkConfig, filePath);</span>
<span class="nc" id="L926">            fail(&quot;Exception is expected&quot;);</span>
        }
<span class="fc" id="L928">        catch (CheckstyleException ex) {</span>
<span class="fc" id="L929">            assertEquals(&quot;Error message is not expected&quot;,</span>
<span class="fc" id="L930">                    &quot;Exception was thrown while processing &quot; + filePath, ex.getMessage());</span>
<span class="nc" id="L931">        }</span>
<span class="fc" id="L932">    }</span>

    @Test
    public void testExceptionWithCache() throws Exception {
<span class="fc" id="L936">        final File cacheFile = temporaryFolder.newFile();</span>

<span class="fc" id="L938">        final DefaultConfiguration checkConfig =</span>
<span class="fc" id="L939">                createModuleConfig(CheckWhichThrowsError.class);</span>

<span class="fc" id="L941">        final DefaultConfiguration treewalkerConfig =</span>
<span class="fc" id="L942">                createModuleConfig(TreeWalker.class);</span>
<span class="fc" id="L943">        treewalkerConfig.addChild(checkConfig);</span>

<span class="fc" id="L945">        final DefaultConfiguration checkerConfig = createRootConfig(treewalkerConfig);</span>
<span class="fc" id="L946">        checkerConfig.addAttribute(&quot;charset&quot;, StandardCharsets.UTF_8.name());</span>
<span class="fc" id="L947">        checkerConfig.addAttribute(&quot;cacheFile&quot;, cacheFile.getPath());</span>
<span class="fc" id="L948">        checkerConfig.addChild(treewalkerConfig);</span>

<span class="fc" id="L950">        final Checker checker = createChecker(checkerConfig);</span>

<span class="fc" id="L952">        final String filePath = getPath(&quot;InputChecker.java&quot;);</span>
        try {
<span class="nc" id="L954">            checker.process(Collections.singletonList(new File(filePath)));</span>
<span class="nc" id="L955">            fail(&quot;Exception is expected&quot;);</span>
        }
<span class="fc" id="L957">        catch (CheckstyleException ex) {</span>
<span class="fc" id="L958">            assertEquals(&quot;Error message is not expected&quot;,</span>
<span class="fc" id="L959">                    &quot;Exception was thrown while processing &quot; + filePath, ex.getMessage());</span>

            // destroy is called by Main
<span class="fc" id="L962">            checker.destroy();</span>

<span class="fc" id="L964">            final Properties cache = new Properties();</span>
<span class="fc" id="L965">            cache.load(Files.newBufferedReader(cacheFile.toPath()));</span>

<span class="fc" id="L967">            assertEquals(&quot;Cache has unexpected size&quot;,</span>
<span class="fc" id="L968">                    1, cache.size());</span>
<span class="fc" id="L969">            assertNull(&quot;testFile is not in cache&quot;,</span>
<span class="fc" id="L970">                    cache.getProperty(filePath));</span>
<span class="nc" id="L971">        }</span>
<span class="fc" id="L972">    }</span>

    /**
     * Test doesn't need to be serialized.
     * @noinspection SerializableInnerClassWithNonSerializableOuterClass
     */
    @Test
    public void testCatchErrorWithCache() throws Exception {
<span class="fc" id="L980">        final File cacheFile = temporaryFolder.newFile();</span>

<span class="fc" id="L982">        final DefaultConfiguration checkerConfig = new DefaultConfiguration(&quot;configuration&quot;);</span>
<span class="fc" id="L983">        checkerConfig.addAttribute(&quot;charset&quot;, StandardCharsets.UTF_8.name());</span>
<span class="fc" id="L984">        checkerConfig.addAttribute(&quot;cacheFile&quot;, cacheFile.getPath());</span>

<span class="fc" id="L986">        final String errorMessage = &quot;Java Virtual Machine is broken&quot;</span>
            + &quot; or has run out of resources necessary for it to continue operating.&quot;;
<span class="fc" id="L988">        final Error expectedError = new IOError(new InternalError(errorMessage));</span>

<span class="fc" id="L990">        final File mock = new File(&quot;testFile&quot;) {</span>
            private static final long serialVersionUID = 1L;

            @Override
            public String getAbsolutePath() {
<span class="fc" id="L995">                return &quot;testFile&quot;;</span>
            }

            /**
             * Test is checking catch clause when exception is thrown.
             * @noinspection ProhibitedExceptionThrown
             */
            @Override
            public File getAbsoluteFile() {
<span class="fc" id="L1004">                throw expectedError;</span>
            }
        };

<span class="fc" id="L1008">        final Checker checker = new Checker();</span>
<span class="fc" id="L1009">        checker.setModuleClassLoader(Thread.currentThread().getContextClassLoader());</span>
<span class="fc" id="L1010">        checker.configure(checkerConfig);</span>
<span class="fc" id="L1011">        final List&lt;File&gt; filesToProcess = new ArrayList&lt;&gt;();</span>
<span class="fc" id="L1012">        filesToProcess.add(mock);</span>
        try {
<span class="nc" id="L1014">            checker.process(filesToProcess);</span>
<span class="nc" id="L1015">            fail(&quot;IOError is expected!&quot;);</span>
        }
        // -@cs[IllegalCatchExtended] Testing for catch Error is part of 100% coverage.
<span class="fc" id="L1018">        catch (Error error) {</span>
<span class="fc" id="L1019">            assertThat(&quot;Error cause differs from IOError&quot;,</span>
<span class="fc" id="L1020">                    error.getCause(), instanceOf(IOError.class));</span>
<span class="fc" id="L1021">            assertEquals(&quot;Error message is not expected&quot;,</span>
<span class="fc" id="L1022">                    errorMessage, error.getCause().getCause().getMessage());</span>

            // destroy is called by Main
<span class="fc" id="L1025">            checker.destroy();</span>

<span class="fc" id="L1027">            final Properties cache = new Properties();</span>
<span class="fc" id="L1028">            cache.load(Files.newBufferedReader(cacheFile.toPath()));</span>

<span class="fc" id="L1030">            assertEquals(&quot;Cache has unexpected size&quot;,</span>
<span class="fc" id="L1031">                    1, cache.size());</span>
<span class="fc" id="L1032">            assertNull(&quot;testFile is not in cache&quot;,</span>
<span class="fc" id="L1033">                    cache.getProperty(&quot;testFile&quot;));</span>
<span class="nc" id="L1034">        }</span>
<span class="fc" id="L1035">    }</span>

    /**
     * Test doesn't need to be serialized.
     * @noinspection SerializableInnerClassWithNonSerializableOuterClass
     */
    @Test
    public void testCatchErrorWithCacheWithNoFileName() throws Exception {
<span class="fc" id="L1043">        final File cacheFile = temporaryFolder.newFile();</span>

<span class="fc" id="L1045">        final DefaultConfiguration checkerConfig = new DefaultConfiguration(&quot;configuration&quot;);</span>
<span class="fc" id="L1046">        checkerConfig.addAttribute(&quot;charset&quot;, StandardCharsets.UTF_8.name());</span>
<span class="fc" id="L1047">        checkerConfig.addAttribute(&quot;cacheFile&quot;, cacheFile.getPath());</span>

<span class="fc" id="L1049">        final String errorMessage = &quot;Java Virtual Machine is broken&quot;</span>
            + &quot; or has run out of resources necessary for it to continue operating.&quot;;
<span class="fc" id="L1051">        final Error expectedError = new IOError(new InternalError(errorMessage));</span>

<span class="fc" id="L1053">        final File mock = new File(&quot;testFile&quot;) {</span>
            private static final long serialVersionUID = 1L;

            /**
             * Test is checking catch clause when exception is thrown.
             * @noinspection ProhibitedExceptionThrown
             */
            @Override
            public String getAbsolutePath() {
<span class="fc" id="L1062">                throw expectedError;</span>
            }
        };

<span class="fc" id="L1066">        final Checker checker = new Checker();</span>
<span class="fc" id="L1067">        checker.setModuleClassLoader(Thread.currentThread().getContextClassLoader());</span>
<span class="fc" id="L1068">        checker.configure(checkerConfig);</span>
<span class="fc" id="L1069">        final List&lt;File&gt; filesToProcess = new ArrayList&lt;&gt;();</span>
<span class="fc" id="L1070">        filesToProcess.add(mock);</span>
        try {
<span class="nc" id="L1072">            checker.process(filesToProcess);</span>
<span class="nc" id="L1073">            fail(&quot;IOError is expected!&quot;);</span>
        }
        // -@cs[IllegalCatchExtended] Testing for catch Error is part of 100% coverage.
<span class="fc" id="L1076">        catch (Error error) {</span>
<span class="fc" id="L1077">            assertThat(&quot;Error cause differs from IOError&quot;,</span>
<span class="fc" id="L1078">                    error.getCause(), instanceOf(IOError.class));</span>
<span class="fc" id="L1079">            assertEquals(&quot;Error message is not expected&quot;,</span>
<span class="fc" id="L1080">                    errorMessage, error.getCause().getCause().getMessage());</span>

            // destroy is called by Main
<span class="fc" id="L1083">            checker.destroy();</span>

<span class="fc" id="L1085">            final Properties cache = new Properties();</span>
<span class="fc" id="L1086">            cache.load(Files.newBufferedReader(cacheFile.toPath()));</span>

<span class="fc" id="L1088">            assertEquals(&quot;Cache has unexpected size&quot;,</span>
<span class="fc" id="L1089">                    1, cache.size());</span>
<span class="nc" id="L1090">        }</span>
<span class="fc" id="L1091">    }</span>

    /**
     * Test doesn't need to be serialized.
     * @noinspection SerializableInnerClassWithNonSerializableOuterClass
     */
    @Test
    public void testExceptionWithNoFileName() {
<span class="fc" id="L1099">        final String errorMessage = &quot;Security Exception&quot;;</span>
<span class="fc" id="L1100">        final RuntimeException expectedError = new SecurityException(errorMessage);</span>

<span class="fc" id="L1102">        final File mock = new File(&quot;testFile&quot;) {</span>
            private static final long serialVersionUID = 1L;

            /**
             * Test is checking catch clause when exception is thrown.
             * @noinspection ProhibitedExceptionThrown
             */
            @Override
            public String getAbsolutePath() {
<span class="fc" id="L1111">                throw expectedError;</span>
            }
        };

<span class="fc" id="L1115">        final Checker checker = new Checker();</span>
<span class="fc" id="L1116">        final List&lt;File&gt; filesToProcess = new ArrayList&lt;&gt;();</span>
<span class="fc" id="L1117">        filesToProcess.add(mock);</span>
        try {
<span class="nc" id="L1119">            checker.process(filesToProcess);</span>
<span class="nc" id="L1120">            fail(&quot;SecurityException is expected!&quot;);</span>
        }
<span class="fc" id="L1122">        catch (CheckstyleException ex) {</span>
<span class="fc" id="L1123">            assertThat(&quot;Error cause differs from SecurityException&quot;,</span>
<span class="fc" id="L1124">                    ex.getCause(), instanceOf(SecurityException.class));</span>
<span class="fc" id="L1125">            assertEquals(&quot;Error message is not expected&quot;,</span>
<span class="fc" id="L1126">                    errorMessage, ex.getCause().getMessage());</span>
<span class="nc" id="L1127">        }</span>
<span class="fc" id="L1128">    }</span>

    /**
     * Test doesn't need to be serialized.
     * @noinspection SerializableInnerClassWithNonSerializableOuterClass
     */
    @Test
    public void testExceptionWithCacheAndNoFileName() throws Exception {
<span class="fc" id="L1136">        final File cacheFile = temporaryFolder.newFile();</span>

<span class="fc" id="L1138">        final DefaultConfiguration checkerConfig = new DefaultConfiguration(&quot;configuration&quot;);</span>
<span class="fc" id="L1139">        checkerConfig.addAttribute(&quot;charset&quot;, StandardCharsets.UTF_8.name());</span>
<span class="fc" id="L1140">        checkerConfig.addAttribute(&quot;cacheFile&quot;, cacheFile.getPath());</span>

<span class="fc" id="L1142">        final String errorMessage = &quot;Security Exception&quot;;</span>
<span class="fc" id="L1143">        final RuntimeException expectedError = new SecurityException(errorMessage);</span>

<span class="fc" id="L1145">        final File mock = new File(&quot;testFile&quot;) {</span>
            private static final long serialVersionUID = 1L;

            /**
             * Test is checking catch clause when exception is thrown.
             * @noinspection ProhibitedExceptionThrown
             */
            @Override
            public String getAbsolutePath() {
<span class="fc" id="L1154">                throw expectedError;</span>
            }
        };

<span class="fc" id="L1158">        final Checker checker = new Checker();</span>
<span class="fc" id="L1159">        checker.setModuleClassLoader(Thread.currentThread().getContextClassLoader());</span>
<span class="fc" id="L1160">        checker.configure(checkerConfig);</span>
<span class="fc" id="L1161">        final List&lt;File&gt; filesToProcess = new ArrayList&lt;&gt;();</span>
<span class="fc" id="L1162">        filesToProcess.add(mock);</span>
        try {
<span class="nc" id="L1164">            checker.process(filesToProcess);</span>
<span class="nc" id="L1165">            fail(&quot;SecurityException is expected!&quot;);</span>
        }
<span class="fc" id="L1167">        catch (CheckstyleException ex) {</span>
<span class="fc" id="L1168">            assertThat(&quot;Error cause differs from SecurityException&quot;,</span>
<span class="fc" id="L1169">                    ex.getCause(), instanceOf(SecurityException.class));</span>
<span class="fc" id="L1170">            assertEquals(&quot;Error message is not expected&quot;,</span>
<span class="fc" id="L1171">                    errorMessage, ex.getCause().getMessage());</span>

            // destroy is called by Main
<span class="fc" id="L1174">            checker.destroy();</span>

<span class="fc" id="L1176">            final Properties cache = new Properties();</span>
<span class="fc" id="L1177">            cache.load(Files.newBufferedReader(cacheFile.toPath()));</span>

<span class="fc" id="L1179">            assertEquals(&quot;Cache has unexpected size&quot;,</span>
<span class="fc" id="L1180">                    1, cache.size());</span>
<span class="nc" id="L1181">        }</span>
<span class="fc" id="L1182">    }</span>

    @Test
    public void testHaltOnExceptionOff() throws Exception {
<span class="fc" id="L1186">        final DefaultConfiguration checkConfig =</span>
<span class="fc" id="L1187">            createModuleConfig(CheckWhichThrowsError.class);</span>

<span class="fc" id="L1189">        final DefaultConfiguration treeWalkerConfig = createModuleConfig(TreeWalker.class);</span>
<span class="fc" id="L1190">        treeWalkerConfig.addChild(checkConfig);</span>

<span class="fc" id="L1192">        final DefaultConfiguration checkerConfig = createRootConfig(treeWalkerConfig);</span>
<span class="fc" id="L1193">        checkerConfig.addChild(treeWalkerConfig);</span>

<span class="fc" id="L1195">        checkerConfig.addAttribute(&quot;haltOnException&quot;, &quot;false&quot;);</span>

<span class="fc" id="L1197">        final String filePath = getPath(&quot;InputChecker.java&quot;);</span>
<span class="fc" id="L1198">        final String[] expected = {</span>
<span class="fc" id="L1199">            &quot;1: &quot; + getCheckMessage(EXCEPTION_MSG, &quot;java.lang.IndexOutOfBoundsException: test&quot;),</span>
        };

<span class="fc" id="L1202">        verify(checkerConfig, filePath, expected);</span>
<span class="fc" id="L1203">    }</span>

    @Test
    public void testTabViolationDefault() throws Exception {
<span class="fc" id="L1207">        final DefaultConfiguration checkConfig =</span>
<span class="fc" id="L1208">            createModuleConfig(VerifyPositionAfterTabFileSet.class);</span>
<span class="fc" id="L1209">        final String[] expected = {</span>
            &quot;2:9: violation&quot;,
            &quot;3:17: violation&quot;,
        };
<span class="fc" id="L1213">        verify(checkConfig, getPath(&quot;InputCheckerTabCharacter.txt&quot;),</span>
            expected);
<span class="fc" id="L1215">    }</span>

    @Test
    public void testTabViolation() throws Exception {
<span class="fc" id="L1219">        final DefaultConfiguration checkConfig =</span>
<span class="fc" id="L1220">            createModuleConfig(VerifyPositionAfterTabFileSet.class);</span>
<span class="fc" id="L1221">        final DefaultConfiguration checkerConfig = createRootConfig(checkConfig);</span>
<span class="fc" id="L1222">        checkerConfig.addAttribute(&quot;tabWidth&quot;, &quot;4&quot;);</span>
<span class="fc" id="L1223">        final String[] expected = {</span>
            &quot;2:5: violation&quot;,
            &quot;3:9: violation&quot;,
        };
<span class="fc" id="L1227">        verify(checkerConfig, getPath(&quot;InputCheckerTabCharacter.txt&quot;),</span>
            expected);
<span class="fc" id="L1229">    }</span>

    @Test
    public void testCheckerProcessCallAllNeededMethodsOfFileSets() throws Exception {
<span class="fc" id="L1233">        final DummyFileSet fileSet = new DummyFileSet();</span>
<span class="fc" id="L1234">        final Checker checker = new Checker();</span>
<span class="fc" id="L1235">        checker.addFileSetCheck(fileSet);</span>
<span class="fc" id="L1236">        checker.process(Collections.singletonList(new File(&quot;dummy.java&quot;)));</span>
<span class="fc" id="L1237">        final List&lt;String&gt; expected =</span>
<span class="fc" id="L1238">            Arrays.asList(&quot;beginProcessing&quot;, &quot;finishProcessing&quot;, &quot;destroy&quot;);</span>
<span class="fc" id="L1239">        assertArrayEquals(&quot;Method calls were not expected&quot;,</span>
<span class="fc" id="L1240">                expected.toArray(), fileSet.getMethodCalls().toArray());</span>
<span class="fc" id="L1241">    }</span>

    @Test
    public void testSetFileSetCheckSetsMessageDispatcher() {
<span class="fc" id="L1245">        final DummyFileSet fileSet = new DummyFileSet();</span>
<span class="fc" id="L1246">        final Checker checker = new Checker();</span>
<span class="fc" id="L1247">        checker.addFileSetCheck(fileSet);</span>
<span class="fc" id="L1248">        assertEquals(&quot;Message dispatcher was not expected&quot;,</span>
<span class="fc" id="L1249">                checker, fileSet.getInternalMessageDispatcher());</span>
<span class="fc" id="L1250">    }</span>

    @Test
    public void testAddAuditListenerAsChild() throws Exception {
<span class="fc" id="L1254">        final Checker checker = new Checker();</span>
<span class="fc" id="L1255">        final DebugAuditAdapter auditAdapter = new DebugAuditAdapter();</span>
<span class="fc" id="L1256">        final PackageObjectFactory factory = new PackageObjectFactory(</span>
<span class="fc" id="L1257">                new HashSet&lt;&gt;(), Thread.currentThread().getContextClassLoader()) {</span>
            @Override
            public Object createModule(String name) throws CheckstyleException {
<span class="fc" id="L1260">                Object adapter = auditAdapter;</span>
<span class="pc bpc" id="L1261" title="1 of 2 branches missed.">                if (!name.equals(DebugAuditAdapter.class.getName())) {</span>
<span class="nc" id="L1262">                    adapter = super.createModule(name);</span>
                }
<span class="fc" id="L1264">                return adapter;</span>
            }
        };
<span class="fc" id="L1267">        checker.setModuleFactory(factory);</span>
<span class="fc" id="L1268">        checker.setupChild(createModuleConfig(DebugAuditAdapter.class));</span>
        // Let's try fire some events
<span class="fc" id="L1270">        checker.process(Collections.singletonList(new File(&quot;dummy.java&quot;)));</span>
<span class="fc" id="L1271">        assertTrue(&quot;Checker.fireAuditStarted() doesn't call listener&quot;, auditAdapter.wasCalled());</span>
<span class="fc" id="L1272">    }</span>

    @Test
    public void testAddBeforeExecutionFileFilterAsChild() throws Exception {
<span class="fc" id="L1276">        final Checker checker = new Checker();</span>
<span class="fc" id="L1277">        final TestBeforeExecutionFileFilter fileFilter = new TestBeforeExecutionFileFilter();</span>
<span class="fc" id="L1278">        final PackageObjectFactory factory = new PackageObjectFactory(</span>
<span class="fc" id="L1279">                new HashSet&lt;&gt;(), Thread.currentThread().getContextClassLoader()) {</span>
            @Override
            public Object createModule(String name) throws CheckstyleException {
<span class="fc" id="L1282">                Object filter = fileFilter;</span>
<span class="pc bpc" id="L1283" title="1 of 2 branches missed.">                if (!name.equals(TestBeforeExecutionFileFilter.class.getName())) {</span>
<span class="nc" id="L1284">                    filter = super.createModule(name);</span>
                }
<span class="fc" id="L1286">                return filter;</span>
            }
        };
<span class="fc" id="L1289">        checker.setModuleFactory(factory);</span>
<span class="fc" id="L1290">        checker.setupChild(createModuleConfig(TestBeforeExecutionFileFilter.class));</span>
<span class="fc" id="L1291">        checker.process(Collections.singletonList(new File(&quot;dummy.java&quot;)));</span>
<span class="fc" id="L1292">        assertTrue(&quot;Checker.acceptFileStarted() doesn't call listener&quot;, fileFilter.wasCalled());</span>
<span class="fc" id="L1293">    }</span>

    @Test
    public void testFileSetCheckInitWhenAddedAsChild() throws Exception {
<span class="fc" id="L1297">        final Checker checker = new Checker();</span>
<span class="fc" id="L1298">        final DummyFileSet fileSet = new DummyFileSet();</span>
<span class="fc" id="L1299">        final PackageObjectFactory factory = new PackageObjectFactory(</span>
<span class="fc" id="L1300">                new HashSet&lt;&gt;(), Thread.currentThread().getContextClassLoader()) {</span>
            @Override
            public Object createModule(String name) throws CheckstyleException {
<span class="fc" id="L1303">                Object check = fileSet;</span>
<span class="pc bpc" id="L1304" title="1 of 2 branches missed.">                if (!name.equals(DummyFileSet.class.getName())) {</span>
<span class="nc" id="L1305">                    check = super.createModule(name);</span>
                }
<span class="fc" id="L1307">                return check;</span>
            }
        };
<span class="fc" id="L1310">        checker.setModuleFactory(factory);</span>
<span class="fc" id="L1311">        checker.finishLocalSetup();</span>
<span class="fc" id="L1312">        checker.setupChild(createModuleConfig(DummyFileSet.class));</span>
<span class="fc" id="L1313">        assertTrue(&quot;FileSetCheck.init() wasn't called&quot;, fileSet.isInitCalled());</span>
<span class="fc" id="L1314">    }</span>

    // -@cs[CheckstyleTestMakeup] must use raw class to directly initialize DefaultLogger
    @Test
    public void testDefaultLoggerClosesItStreams() throws Exception {
<span class="fc" id="L1319">        final Checker checker = new Checker();</span>
<span class="fc" id="L1320">        try (CloseAndFlushTestByteArrayOutputStream testInfoOutputStream =</span>
                new CloseAndFlushTestByteArrayOutputStream();
<span class="fc" id="L1322">            CloseAndFlushTestByteArrayOutputStream testErrorOutputStream =</span>
                new CloseAndFlushTestByteArrayOutputStream()) {
<span class="fc" id="L1324">            checker.setModuleClassLoader(Thread.currentThread().getContextClassLoader());</span>
<span class="fc" id="L1325">            checker.addListener(new DefaultLogger(testInfoOutputStream,</span>
                true, testErrorOutputStream, true));

<span class="fc" id="L1328">            final File tmpFile = temporaryFolder.newFile(&quot;file.java&quot;);</span>
<span class="fc" id="L1329">            final String[] expected = CommonUtil.EMPTY_STRING_ARRAY;</span>

<span class="fc" id="L1331">            verify(checker, tmpFile.getPath(), expected);</span>

<span class="fc" id="L1333">            assertEquals(&quot;Close count was not expected&quot;,</span>
<span class="fc" id="L1334">                    1, testInfoOutputStream.getCloseCount());</span>
<span class="fc" id="L1335">            assertEquals(&quot;Flush count was not expected&quot;,</span>
<span class="fc" id="L1336">                    3, testInfoOutputStream.getFlushCount());</span>
<span class="fc" id="L1337">            assertEquals(&quot;Close count was not expected&quot;,</span>
<span class="fc" id="L1338">                    1, testErrorOutputStream.getCloseCount());</span>
<span class="fc" id="L1339">            assertEquals(&quot;Flush count was not expected&quot;,</span>
<span class="fc" id="L1340">                    1, testErrorOutputStream.getFlushCount());</span>
        }
<span class="fc" id="L1342">    }</span>

    // -@cs[CheckstyleTestMakeup] must use raw class to directly initialize DefaultLogger
    @Test
    public void testXmlLoggerClosesItStreams() throws Exception {
<span class="fc" id="L1347">        final Checker checker = new Checker();</span>
<span class="fc" id="L1348">        try (CloseAndFlushTestByteArrayOutputStream testInfoOutputStream =</span>
                new CloseAndFlushTestByteArrayOutputStream()) {
<span class="fc" id="L1350">            checker.setModuleClassLoader(Thread.currentThread().getContextClassLoader());</span>
<span class="fc" id="L1351">            checker.addListener(new XMLLogger(testInfoOutputStream, true));</span>

<span class="fc" id="L1353">            final File tmpFile = temporaryFolder.newFile(&quot;file.java&quot;);</span>
<span class="fc" id="L1354">            final String[] expected = CommonUtil.EMPTY_STRING_ARRAY;</span>

<span class="fc" id="L1356">            verify(checker, tmpFile.getPath(), tmpFile.getPath(), expected);</span>

<span class="fc" id="L1358">            assertEquals(&quot;Close count was not expected&quot;,</span>
<span class="fc" id="L1359">                    1, testInfoOutputStream.getCloseCount());</span>
<span class="fc" id="L1360">            assertEquals(&quot;Flush count was not expected&quot;,</span>
<span class="fc" id="L1361">                    0, testInfoOutputStream.getFlushCount());</span>
        }
<span class="fc" id="L1363">    }</span>

    @Test
    public void testDuplicatedModule() throws Exception {
        // we need to test a module with two instances, one with id and the other not
<span class="fc" id="L1368">        final DefaultConfiguration moduleConfig1 =</span>
<span class="fc" id="L1369">                createModuleConfig(NewlineAtEndOfFileCheck.class);</span>
<span class="fc" id="L1370">        final DefaultConfiguration moduleConfig2 =</span>
<span class="fc" id="L1371">                createModuleConfig(NewlineAtEndOfFileCheck.class);</span>
<span class="fc" id="L1372">        moduleConfig2.addAttribute(&quot;id&quot;, &quot;ModuleId&quot;);</span>
<span class="fc" id="L1373">        final DefaultConfiguration root = new DefaultConfiguration(&quot;root&quot;);</span>
<span class="fc" id="L1374">        root.addChild(moduleConfig1);</span>
<span class="fc" id="L1375">        root.addChild(moduleConfig2);</span>
<span class="fc" id="L1376">        final Checker checker = new Checker();</span>
<span class="fc" id="L1377">        checker.setModuleClassLoader(Thread.currentThread().getContextClassLoader());</span>
<span class="fc" id="L1378">        checker.configure(root);</span>
        // BriefUtLogger does not print the module name or id postfix,
        // so we need to set logger manually
<span class="fc" id="L1381">        final ByteArrayOutputStream out = Whitebox.getInternalState(this, &quot;stream&quot;);</span>
<span class="fc" id="L1382">        final DefaultLogger logger =</span>
                new DefaultLogger(out, true, out, false, new AuditEventDefaultFormatter());
<span class="fc" id="L1384">        checker.addListener(logger);</span>

<span class="fc" id="L1386">        final String path = temporaryFolder.newFile(&quot;file.java&quot;).getPath();</span>
<span class="fc" id="L1387">        final String errorMessage =</span>
<span class="fc" id="L1388">                getCheckMessage(NewlineAtEndOfFileCheck.class, MSG_KEY_NO_NEWLINE_EOF);</span>
<span class="fc" id="L1389">        final String[] expected = {</span>
            &quot;1: &quot; + errorMessage + &quot; [NewlineAtEndOfFile]&quot;,
            &quot;1: &quot; + errorMessage + &quot; [ModuleId]&quot;,
        };

        // super.verify does not work here, for we change the logger
<span class="fc" id="L1395">        out.flush();</span>
<span class="fc" id="L1396">        final int errs = checker.process(Collections.singletonList(new File(path)));</span>
<span class="fc" id="L1397">        try (ByteArrayInputStream inputStream =</span>
<span class="fc" id="L1398">                new ByteArrayInputStream(out.toByteArray());</span>
<span class="fc" id="L1399">            LineNumberReader lnr = new LineNumberReader(</span>
                new InputStreamReader(inputStream, StandardCharsets.UTF_8))) {
            // we need to ignore the unrelated lines
<span class="fc" id="L1402">            final List&lt;String&gt; actual = lnr.lines()</span>
<span class="fc bfc" id="L1403" title="All 2 branches covered.">                    .filter(line -&gt; !getCheckMessage(AUDIT_STARTED_MESSAGE).equals(line))</span>
<span class="pc bpc" id="L1404" title="1 of 2 branches missed.">                    .filter(line -&gt; !getCheckMessage(AUDIT_FINISHED_MESSAGE).equals(line))</span>
<span class="fc" id="L1405">                    .limit(expected.length)</span>
<span class="fc" id="L1406">                    .sorted()</span>
<span class="fc" id="L1407">                    .collect(Collectors.toList());</span>
<span class="fc" id="L1408">            Arrays.sort(expected);</span>

<span class="fc bfc" id="L1410" title="All 2 branches covered.">            for (int i = 0; i &lt; expected.length; i++) {</span>
<span class="fc" id="L1411">                final String expectedResult = &quot;[ERROR] &quot; + path + &quot;:&quot; + expected[i];</span>
<span class="fc" id="L1412">                assertEquals(&quot;error message &quot; + i, expectedResult, actual.get(i));</span>
            }

<span class="fc" id="L1415">            assertEquals(&quot;unexpected output: &quot; + lnr.readLine(), expected.length, errs);</span>
        }

<span class="fc" id="L1418">        checker.destroy();</span>
<span class="fc" id="L1419">    }</span>

    private static class DummyFilter implements Filter {

        @Override
        public boolean accept(AuditEvent event) {
<span class="nc" id="L1425">            return false;</span>
        }

    }

    private static class DummyFileSetViolationCheck extends AbstractFileSetCheck
        implements ExternalResourceHolder {

        @Override
        protected void processFiltered(File file, FileText fileText) {
<span class="fc" id="L1435">            log(1, &quot;test&quot;);</span>
<span class="fc" id="L1436">        }</span>

        @Override
        public Set&lt;String&gt; getExternalResourceLocations() {
<span class="fc" id="L1440">            final Set&lt;String&gt; externalResourceLocation = new HashSet&lt;&gt;(1);</span>
<span class="fc" id="L1441">            externalResourceLocation.add(&quot;non_existent_external_resource.xml&quot;);</span>
<span class="fc" id="L1442">            return externalResourceLocation;</span>
        }

    }

    private static class DummyFilterSet extends FilterSet implements ExternalResourceHolder {

        @Override
        public Set&lt;String&gt; getExternalResourceLocations() {
<span class="fc" id="L1451">            final Set&lt;String&gt; strings = new HashSet&lt;&gt;();</span>
<span class="fc" id="L1452">            strings.add(&quot;test&quot;);</span>
<span class="fc" id="L1453">            return strings;</span>
        }

    }

    private static class DynamicalResourceHolderCheck extends AbstractFileSetCheck
        implements ExternalResourceHolder {

        private String firstExternalResourceLocation;
        private String secondExternalResourceLocation;

        public void setFirstExternalResourceLocation(String firstExternalResourceLocation) {
<span class="fc" id="L1465">            this.firstExternalResourceLocation = firstExternalResourceLocation;</span>
<span class="fc" id="L1466">        }</span>

        public void setSecondExternalResourceLocation(String secondExternalResourceLocation) {
<span class="fc" id="L1469">            this.secondExternalResourceLocation = secondExternalResourceLocation;</span>
<span class="fc" id="L1470">        }</span>

        @Override
        protected void processFiltered(File file, FileText fileText) {
            // there is no need in implementation of the method
<span class="fc" id="L1475">        }</span>

        @Override
        public Set&lt;String&gt; getExternalResourceLocations() {
<span class="fc" id="L1479">            final Set&lt;String&gt; locations = new HashSet&lt;&gt;();</span>
<span class="fc" id="L1480">            locations.add(firstExternalResourceLocation);</span>
            // Attempt to change the behaviour of the check dynamically
<span class="fc bfc" id="L1482" title="All 2 branches covered.">            if (secondExternalResourceLocation != null) {</span>
<span class="fc" id="L1483">                locations.add(secondExternalResourceLocation);</span>
            }
<span class="fc" id="L1485">            return locations;</span>
        }

    }

    private static class CheckWhichDoesNotRequireCommentNodes extends AbstractCheck {

        /** Number of children of method definition token. */
        private static final int METHOD_DEF_CHILD_COUNT = 7;

        @Override
        public int[] getDefaultTokens() {
<span class="fc" id="L1497">            return new int[] {TokenTypes.METHOD_DEF};</span>
        }

        @Override
        public int[] getAcceptableTokens() {
<span class="nc" id="L1502">            return new int[] {TokenTypes.METHOD_DEF};</span>
        }

        @Override
        public int[] getRequiredTokens() {
<span class="nc" id="L1507">            return new int[] {TokenTypes.METHOD_DEF};</span>
        }

        @Override
        public void visitToken(DetailAST ast) {
<span class="pc bpc" id="L1512" title="1 of 2 branches missed.">            if (ast.findFirstToken(TokenTypes.MODIFIERS).findFirstToken(</span>
                    TokenTypes.BLOCK_COMMENT_BEGIN) != null) {
<span class="nc" id="L1514">                log(ast, &quot;AST has incorrect structure structure.&quot;</span>
                    + &quot; The check does not require comment nodes but there were comment nodes&quot;
                    + &quot; in the AST.&quot;);
            }
<span class="fc" id="L1518">            final int childCount = ast.getChildCount();</span>
<span class="pc bpc" id="L1519" title="1 of 2 branches missed.">            if (childCount != METHOD_DEF_CHILD_COUNT) {</span>
<span class="nc" id="L1520">                final String msg = String.format(Locale.getDefault(),</span>
                    &quot;AST node in no comment tree has wrong number of children. &quot;
                            + &quot;Expected is %d but was %d&quot;,
<span class="nc" id="L1523">                    METHOD_DEF_CHILD_COUNT, childCount);</span>
<span class="nc" id="L1524">                log(ast, msg);</span>
            }
            // count children where comment lives
<span class="fc" id="L1527">            int actualChildCount = 0;</span>
<span class="fc bfc" id="L1528" title="All 2 branches covered.">            for (DetailAST child = ast.getFirstChild().getFirstChild(); child != null; child =</span>
<span class="fc" id="L1529">                    child.getNextSibling()) {</span>
<span class="fc" id="L1530">                actualChildCount++;</span>
            }
<span class="fc" id="L1532">            final int cacheChildCount = ast.getFirstChild().getChildCount();</span>
<span class="pc bpc" id="L1533" title="1 of 2 branches missed.">            if (cacheChildCount != actualChildCount) {</span>
<span class="nc" id="L1534">                final String msg = String.format(Locale.getDefault(),</span>
                        &quot;AST node with no comment has wrong number of children. &quot;
                                + &quot;Expected is %d but was %d&quot;,
<span class="nc" id="L1537">                        cacheChildCount, actualChildCount);</span>
<span class="nc" id="L1538">                log(ast, msg);</span>
            }
<span class="fc" id="L1540">        }</span>

    }

    private static class CheckWhichRequiresCommentNodes extends AbstractCheck {

        /** Number of children of method definition token. */
        private static final int METHOD_DEF_CHILD_COUNT = 7;

        @Override
        public boolean isCommentNodesRequired() {
<span class="fc" id="L1551">            return true;</span>
        }

        @Override
        public int[] getDefaultTokens() {
<span class="fc" id="L1556">            return new int[] {TokenTypes.METHOD_DEF};</span>
        }

        @Override
        public int[] getAcceptableTokens() {
<span class="nc" id="L1561">            return new int[] {TokenTypes.METHOD_DEF};</span>
        }

        @Override
        public int[] getRequiredTokens() {
<span class="nc" id="L1566">            return new int[] {TokenTypes.METHOD_DEF};</span>
        }

        @Override
        public void visitToken(DetailAST ast) {
<span class="pc bpc" id="L1571" title="1 of 2 branches missed.">            if (ast.findFirstToken(TokenTypes.MODIFIERS).findFirstToken(</span>
                    TokenTypes.BLOCK_COMMENT_BEGIN) == null) {
<span class="nc" id="L1573">                log(ast, &quot;Incorrect AST structure.&quot;);</span>
            }
<span class="fc" id="L1575">            final int childCount = ast.getChildCount();</span>
<span class="pc bpc" id="L1576" title="1 of 2 branches missed.">            if (childCount != METHOD_DEF_CHILD_COUNT) {</span>
<span class="nc" id="L1577">                final String msg = String.format(Locale.getDefault(),</span>
                    &quot;AST node in comment tree has wrong number of children. &quot;
                            + &quot;Expected is %d but was %d&quot;,
<span class="nc" id="L1580">                    METHOD_DEF_CHILD_COUNT, childCount);</span>
<span class="nc" id="L1581">                log(ast, msg);</span>
            }
            // count children where comment lives
<span class="fc" id="L1584">            int actualChildCount = 0;</span>
<span class="fc bfc" id="L1585" title="All 2 branches covered.">            for (DetailAST child = ast.getFirstChild().getFirstChild(); child != null; child =</span>
<span class="fc" id="L1586">                    child.getNextSibling()) {</span>
<span class="fc" id="L1587">                actualChildCount++;</span>
            }
<span class="fc" id="L1589">            final int cacheChildCount = ast.getFirstChild().getChildCount();</span>
<span class="pc bpc" id="L1590" title="1 of 2 branches missed.">            if (cacheChildCount != actualChildCount) {</span>
<span class="nc" id="L1591">                final String msg = String.format(Locale.getDefault(),</span>
                        &quot;AST node with comment has wrong number of children. &quot;
                                + &quot;Expected is %d but was %d&quot;,
<span class="nc" id="L1594">                        cacheChildCount, actualChildCount);</span>
<span class="nc" id="L1595">                log(ast, msg);</span>
            }
<span class="fc" id="L1597">        }</span>

    }

    private static class CheckWhichThrowsError extends AbstractCheck {

        @Override
        public int[] getDefaultTokens() {
<span class="fc" id="L1605">            return new int[] {TokenTypes.CLASS_DEF};</span>
        }

        @Override
        public int[] getAcceptableTokens() {
<span class="nc" id="L1610">            return new int[] {TokenTypes.CLASS_DEF};</span>
        }

        @Override
        public int[] getRequiredTokens() {
<span class="nc" id="L1615">            return new int[] {TokenTypes.CLASS_DEF};</span>
        }

        @Override
        public void visitToken(DetailAST ast) {
<span class="fc" id="L1620">            throw new IndexOutOfBoundsException(&quot;test&quot;);</span>
        }

    }

<span class="fc" id="L1625">    private static class DummyFileSet extends AbstractFileSetCheck {</span>

<span class="fc" id="L1627">        private final List&lt;String&gt; methodCalls = new ArrayList&lt;&gt;();</span>

        private boolean initCalled;

        @Override
        public void init() {
<span class="fc" id="L1633">            super.init();</span>
<span class="fc" id="L1634">            initCalled = true;</span>
<span class="fc" id="L1635">        }</span>

        @Override
        public void beginProcessing(String charset) {
<span class="fc" id="L1639">            methodCalls.add(&quot;beginProcessing&quot;);</span>
<span class="fc" id="L1640">            super.beginProcessing(charset);</span>
<span class="fc" id="L1641">        }</span>

        @Override
        public void finishProcessing() {
<span class="fc" id="L1645">            methodCalls.add(&quot;finishProcessing&quot;);</span>
<span class="fc" id="L1646">            super.finishProcessing();</span>
<span class="fc" id="L1647">        }</span>

        @Override
        protected void processFiltered(File file, FileText fileText) {
<span class="nc" id="L1651">            methodCalls.add(&quot;processFiltered&quot;);</span>
<span class="nc" id="L1652">        }</span>

        @Override
        public void destroy() {
<span class="fc" id="L1656">            methodCalls.add(&quot;destroy&quot;);</span>
<span class="fc" id="L1657">            super.destroy();</span>
<span class="fc" id="L1658">        }</span>

        public List&lt;String&gt; getMethodCalls() {
<span class="fc" id="L1661">            return Collections.unmodifiableList(methodCalls);</span>
        }

        public boolean isInitCalled() {
<span class="fc" id="L1665">            return initCalled;</span>
        }

        public MessageDispatcher getInternalMessageDispatcher() {
<span class="fc" id="L1669">            return getMessageDispatcher();</span>
        }

    }

    private static class VerifyPositionAfterTabFileSet extends AbstractFileSetCheck {

        @Override
        protected void processFiltered(File file, FileText fileText) {
<span class="fc" id="L1678">            int lineNumber = 0;</span>
<span class="fc bfc" id="L1679" title="All 2 branches covered.">            for (String line : getFileContents().getLines()) {</span>
<span class="fc" id="L1680">                final int position = line.lastIndexOf('\t');</span>
<span class="fc" id="L1681">                lineNumber++;</span>

<span class="fc bfc" id="L1683" title="All 2 branches covered.">                if (position != -1) {</span>
<span class="fc" id="L1684">                    log(lineNumber, position + 1, &quot;violation&quot;);</span>
                }
            }
<span class="fc" id="L1687">        }</span>

    }

}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.1.201803210924</span></div></body></html>