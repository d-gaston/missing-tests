<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>AbstractListTest.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">commons_collections4$All_in_commons_collections4.exec</a> &gt; <a href="index.source.html" class="el_package">org.apache.commons.collections4.list</a> &gt; <span class="el_source">AbstractListTest.java</span></div><h1>AbstractListTest.java</h1><pre class="source lang-java linenums">/*
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the &quot;License&quot;); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.commons.collections4.list;

import java.io.IOException;
import java.io.Serializable;
import java.lang.reflect.InvocationTargetException;
import java.lang.reflect.Method;
import java.util.AbstractCollection;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Collection;
import java.util.Collections;
import java.util.ConcurrentModificationException;
import java.util.Iterator;
import java.util.List;
import java.util.ListIterator;
import java.util.NoSuchElementException;

import org.apache.commons.collections4.BulkTest;
import org.apache.commons.collections4.collection.AbstractCollectionTest;
import org.apache.commons.collections4.iterators.AbstractListIteratorTest;

/**
 * Abstract test class for {@link java.util.List} methods and contracts.
 * &lt;p&gt;
 * To use, simply extend this class, and implement
 * the {@link #makeObject} method.
 * &lt;p&gt;
 * If your {@link List} fails one of these tests by design,
 * you may still use this base set of cases.  Simply override the
 * test case (method) your {@link List} fails or override one of the
 * protected methods from AbstractCollectionTest.
 *
 */
public abstract class AbstractListTest&lt;E&gt; extends AbstractCollectionTest&lt;E&gt; {

    /**
     * JUnit constructor.
     *
     * @param testName  the test class name
     */
    public AbstractListTest(final String testName) {
<span class="fc" id="L58">        super(testName);</span>
<span class="fc" id="L59">    }</span>

    //-----------------------------------------------------------------------
    /**
     *  Returns true if the collections produced by
     *  {@link #makeObject()} and {@link #makeFullCollection()}
     *  support the &lt;code&gt;set operation.&lt;p&gt;
     *  Default implementation returns true.  Override if your collection
     *  class does not support set.
     */
    public boolean isSetSupported() {
<span class="fc" id="L70">        return true;</span>
    }

    //-----------------------------------------------------------------------
    /**
     *  Verifies that the test list implementation matches the confirmed list
     *  implementation.
     */
    @Override
    @SuppressWarnings(&quot;unchecked&quot;)
    public void verify() {
<span class="fc" id="L81">        super.verify();</span>

<span class="fc" id="L83">        final List&lt;E&gt; list1 = getCollection();</span>
<span class="fc" id="L84">        final List&lt;E&gt; list2 = getConfirmed();</span>

<span class="fc" id="L86">        assertEquals(&quot;List should equal confirmed&quot;, list1, list2);</span>
<span class="fc" id="L87">        assertEquals(&quot;Confirmed should equal list&quot;, list2, list1);</span>

<span class="fc" id="L89">        assertEquals(&quot;Hash codes should be equal&quot;, list1.hashCode(), list2.hashCode());</span>

<span class="fc" id="L91">        int i = 0;</span>
<span class="fc" id="L92">        final Iterator&lt;E&gt; iterator1 = list1.iterator();</span>
<span class="fc" id="L93">        final Iterator&lt;E&gt; iterator2 = list2.iterator();</span>
<span class="fc" id="L94">        final E[] array = (E[]) list1.toArray();</span>
<span class="fc bfc" id="L95" title="All 2 branches covered.">        while (iterator2.hasNext()) {</span>
<span class="fc" id="L96">            assertTrue(&quot;List iterator should have next&quot;, iterator1.hasNext());</span>
<span class="fc" id="L97">            final Object o1 = iterator1.next();</span>
<span class="fc" id="L98">            Object o2 = iterator2.next();</span>
<span class="fc" id="L99">            assertEquals(&quot;Iterator elements should be equal&quot;, o1, o2);</span>
<span class="fc" id="L100">            o2 = list1.get(i);</span>
<span class="fc" id="L101">            assertEquals(&quot;get should return correct element&quot;, o1, o2);</span>
<span class="fc" id="L102">            o2 = array[i];</span>
<span class="fc" id="L103">            assertEquals(&quot;toArray should have correct element&quot;, o1, o2);</span>
<span class="fc" id="L104">            i++;</span>
<span class="fc" id="L105">        }</span>
<span class="fc" id="L106">    }</span>

    //-----------------------------------------------------------------------
    /**
     * List equals method is defined.
     */
    @Override
    public boolean isEqualsCheckable() {
<span class="fc" id="L114">        return true;</span>
    }

    /**
     * Returns an empty {@link ArrayList}.
     */
    @Override
    public Collection&lt;E&gt; makeConfirmedCollection() {
<span class="fc" id="L122">        final ArrayList&lt;E&gt; list = new ArrayList&lt;&gt;();</span>
<span class="fc" id="L123">        return list;</span>
    }

    /**
     * Returns a full {@link ArrayList}.
     */
    @Override
    public Collection&lt;E&gt; makeConfirmedFullCollection() {
<span class="fc" id="L131">        final ArrayList&lt;E&gt; list = new ArrayList&lt;&gt;();</span>
<span class="fc" id="L132">        list.addAll(Arrays.asList(getFullElements()));</span>
<span class="fc" id="L133">        return list;</span>
    }

    /**
     * Returns {@link #makeObject()}.
     *
     * @return an empty list to be used for testing
     */
    @Override
    public abstract List&lt;E&gt; makeObject();

    /**
     * {@inheritDoc}
     */
    @Override
    public List&lt;E&gt; makeFullCollection() {
        // only works if list supports optional &quot;addAll(Collection)&quot;
<span class="fc" id="L150">        final List&lt;E&gt; list = makeObject();</span>
<span class="fc" id="L151">        list.addAll(Arrays.asList(getFullElements()));</span>
<span class="fc" id="L152">        return list;</span>
    }

    //-----------------------------------------------------------------------
    /**
     * Returns the {@link #collection} field cast to a {@link List}.
     *
     * @return the collection field as a List
     */
    @Override
    public List&lt;E&gt; getCollection() {
<span class="fc" id="L163">        return (List&lt;E&gt;) super.getCollection();</span>
    }

    /**
     * Returns the {@link #confirmed} field cast to a {@link List}.
     *
     * @return the confirmed field as a List
     */
    @Override
    public List&lt;E&gt; getConfirmed() {
<span class="fc" id="L173">        return (List&lt;E&gt;) super.getConfirmed();</span>
    }

    //-----------------------------------------------------------------------
    /**
     *  Tests bounds checking for {@link List#add(int, Object)} on an
     *  empty list.
     */
    public void testListAddByIndexBoundsChecking() {
<span class="fc bfc" id="L182" title="All 2 branches covered.">        if (!isAddSupported()) {</span>
<span class="fc" id="L183">            return;</span>
        }

        List&lt;E&gt; list;
<span class="fc" id="L187">        final E element = getOtherElements()[0];</span>

        try {
<span class="fc" id="L190">            list = makeObject();</span>
<span class="nc" id="L191">            list.add(Integer.MIN_VALUE, element);</span>
<span class="nc" id="L192">            fail(&quot;List.add should throw IndexOutOfBoundsException [Integer.MIN_VALUE]&quot;);</span>
<span class="fc" id="L193">        } catch (final IndexOutOfBoundsException e) {</span>
            // expected
<span class="nc" id="L195">        }</span>

        try {
<span class="fc" id="L198">            list = makeObject();</span>
<span class="nc" id="L199">            list.add(-1, element);</span>
<span class="nc" id="L200">            fail(&quot;List.add should throw IndexOutOfBoundsException [-1]&quot;);</span>
<span class="fc" id="L201">        } catch (final IndexOutOfBoundsException e) {</span>
            // expected
<span class="nc" id="L203">        }</span>

        try {
<span class="fc" id="L206">            list = makeObject();</span>
<span class="nc" id="L207">            list.add(1, element);</span>
<span class="nc" id="L208">            fail(&quot;List.add should throw IndexOutOfBoundsException [1]&quot;);</span>
<span class="fc" id="L209">        } catch (final IndexOutOfBoundsException e) {</span>
            // expected
<span class="nc" id="L211">        }</span>

        try {
<span class="fc" id="L214">            list = makeObject();</span>
<span class="nc" id="L215">            list.add(Integer.MAX_VALUE, element);</span>
<span class="nc" id="L216">            fail(&quot;List.add should throw IndexOutOfBoundsException [Integer.MAX_VALUE]&quot;);</span>
<span class="fc" id="L217">        } catch (final IndexOutOfBoundsException e) {</span>
            // expected
<span class="nc" id="L219">        }</span>
<span class="fc" id="L220">    }</span>

    /**
     *  Tests bounds checking for {@link List#add(int, Object)} on a
     *  full list.
     */
    public void testListAddByIndexBoundsChecking2() {
<span class="fc bfc" id="L227" title="All 2 branches covered.">        if (!isAddSupported()) {</span>
<span class="fc" id="L228">            return;</span>
        }

        List&lt;E&gt; list;
<span class="fc" id="L232">        final E element = getOtherElements()[0];</span>

        try {
<span class="fc" id="L235">            list = makeFullCollection();</span>
<span class="nc" id="L236">            list.add(Integer.MIN_VALUE, element);</span>
<span class="nc" id="L237">            fail(&quot;List.add should throw IndexOutOfBoundsException [Integer.MIN_VALUE]&quot;);</span>
<span class="fc" id="L238">        } catch (final IndexOutOfBoundsException e) {</span>
            // expected
<span class="nc" id="L240">        }</span>

        try {
<span class="fc" id="L243">            list = makeFullCollection();</span>
<span class="nc" id="L244">            list.add(-1, element);</span>
<span class="nc" id="L245">            fail(&quot;List.add should throw IndexOutOfBoundsException [-1]&quot;);</span>
<span class="fc" id="L246">        } catch (final IndexOutOfBoundsException e) {</span>
            // expected
<span class="nc" id="L248">        }</span>

        try {
<span class="fc" id="L251">            list = makeFullCollection();</span>
<span class="nc" id="L252">            list.add(list.size() + 1, element);</span>
<span class="nc" id="L253">            fail(&quot;List.add should throw IndexOutOfBoundsException [size + 1]&quot;);</span>
<span class="fc" id="L254">        } catch (final IndexOutOfBoundsException e) {</span>
            // expected
<span class="nc" id="L256">        }</span>

        try {
<span class="fc" id="L259">            list = makeFullCollection();</span>
<span class="nc" id="L260">            list.add(Integer.MAX_VALUE, element);</span>
<span class="nc" id="L261">            fail(&quot;List.add should throw IndexOutOfBoundsException [Integer.MAX_VALUE]&quot;);</span>
<span class="fc" id="L262">        } catch (final IndexOutOfBoundsException e) {</span>
            // expected
<span class="nc" id="L264">        }</span>
<span class="fc" id="L265">    }</span>

    /**
     *  Tests {@link List#add(int,Object)}.
     */
    public void testListAddByIndex() {
<span class="fc bfc" id="L271" title="All 2 branches covered.">        if (!isAddSupported()) {</span>
<span class="fc" id="L272">            return;</span>
        }

<span class="fc" id="L275">        final E element = getOtherElements()[0];</span>
<span class="fc" id="L276">        final int max = getFullElements().length;</span>

<span class="fc bfc" id="L278" title="All 2 branches covered.">        for (int i = 0; i &lt;= max; i++) {</span>
<span class="fc" id="L279">            resetFull();</span>
<span class="fc" id="L280">            getCollection().add(i, element);</span>
<span class="fc" id="L281">            getConfirmed().add(i, element);</span>
<span class="fc" id="L282">            verify();</span>
        }
<span class="fc" id="L284">    }</span>

    /**
     *  Tests {@link List#equals(Object)}.
     */
    public void testListEquals() {
<span class="fc" id="L290">        resetEmpty();</span>
<span class="fc" id="L291">        List&lt;E&gt; list = getCollection();</span>
<span class="fc" id="L292">        assertEquals(&quot;Empty lists should be equal&quot;, true, list.equals(getConfirmed()));</span>
<span class="fc" id="L293">        verify();</span>
<span class="fc" id="L294">        assertEquals(&quot;Empty list should equal self&quot;, true, list.equals(list));</span>
<span class="fc" id="L295">        verify();</span>

<span class="fc" id="L297">        List&lt;E&gt; list2 = Arrays.asList(getFullElements());</span>
<span class="fc" id="L298">        assertEquals(&quot;Empty list shouldn't equal full&quot;, false, list.equals(list2));</span>
<span class="fc" id="L299">        verify();</span>

<span class="fc" id="L301">        list2 = Arrays.asList(getOtherElements());</span>
<span class="fc" id="L302">        assertEquals(&quot;Empty list shouldn't equal other&quot;, false, list.equals(list2));</span>
<span class="fc" id="L303">        verify();</span>

<span class="fc" id="L305">        resetFull();</span>
<span class="fc" id="L306">        list = getCollection();</span>
<span class="fc" id="L307">        assertEquals(&quot;Full lists should be equal&quot;, true, list.equals(getConfirmed()));</span>
<span class="fc" id="L308">        verify();</span>
<span class="fc" id="L309">        assertEquals(&quot;Full list should equal self&quot;, true, list.equals(list));</span>
<span class="fc" id="L310">        verify();</span>

<span class="fc" id="L312">        list2 = makeObject();</span>
<span class="fc" id="L313">        assertEquals(&quot;Full list shouldn't equal empty&quot;, false, list.equals(list2));</span>
<span class="fc" id="L314">        verify();</span>

<span class="fc" id="L316">        list2 = Arrays.asList(getOtherElements());</span>
<span class="fc" id="L317">        assertEquals(&quot;Full list shouldn't equal other&quot;, false, list.equals(list2));</span>
<span class="fc" id="L318">        verify();</span>

<span class="fc" id="L320">        list2 = Arrays.asList(getFullElements());</span>
<span class="pc bpc" id="L321" title="3 of 4 branches missed.">        if (list2.size() &lt; 2 &amp;&amp; isAddSupported()) {</span>
            // main list is only size 1, so lets add other elements to get a better list
<span class="nc" id="L323">            list.addAll(Arrays.asList(getOtherElements()));</span>
<span class="nc" id="L324">            getConfirmed().addAll(Arrays.asList(getOtherElements()));</span>
<span class="nc" id="L325">            list2 = new ArrayList&lt;&gt;(list2);</span>
<span class="nc" id="L326">            list2.addAll(Arrays.asList(getOtherElements()));</span>
        }
<span class="pc bpc" id="L328" title="1 of 2 branches missed.">        if (list2.size() &gt; 1) {</span>
<span class="fc" id="L329">            Collections.reverse(list2);</span>
<span class="fc" id="L330">            assertEquals(</span>
                &quot;Full list shouldn't equal full list with same elements but different order&quot;,
<span class="fc" id="L332">                false, list.equals(list2));</span>
<span class="fc" id="L333">            verify();</span>
        }

<span class="fc" id="L336">        resetFull();</span>
<span class="fc" id="L337">        list = getCollection();</span>
<span class="fc" id="L338">        assertEquals(&quot;List shouldn't equal String&quot;, false, list.equals(&quot;&quot;));</span>
<span class="fc" id="L339">        verify();</span>

<span class="fc" id="L341">        final List&lt;E&gt; listForC = Arrays.asList(getFullElements());</span>
<span class="fc" id="L342">        final Collection&lt;E&gt; c = new AbstractCollection&lt;E&gt;() {</span>
            @Override
            public int size() {
<span class="nc" id="L345">                return listForC.size();</span>
            }

            @Override
            public Iterator&lt;E&gt; iterator() {
<span class="nc" id="L350">                return listForC.iterator();</span>
            }
        };

<span class="fc" id="L354">        assertEquals(&quot;List shouldn't equal nonlist with same elements in same order&quot;, false, list.equals(c));</span>
<span class="fc" id="L355">        verify();</span>
<span class="fc" id="L356">    }</span>

    /**
     *  Tests {@link List#hashCode()}.
     */
    public void testListHashCode() {
<span class="fc" id="L362">        resetEmpty();</span>
<span class="fc" id="L363">        int hash1 = getCollection().hashCode();</span>
<span class="fc" id="L364">        int hash2 = getConfirmed().hashCode();</span>
<span class="fc" id="L365">        assertEquals(&quot;Empty lists should have equal hashCodes&quot;, hash1, hash2);</span>
<span class="fc" id="L366">        verify();</span>

<span class="fc" id="L368">        resetFull();</span>
<span class="fc" id="L369">        hash1 = getCollection().hashCode();</span>
<span class="fc" id="L370">        hash2 = getConfirmed().hashCode();</span>
<span class="fc" id="L371">        assertEquals(&quot;Full lists should have equal hashCodes&quot;, hash1, hash2);</span>
<span class="fc" id="L372">        verify();</span>
<span class="fc" id="L373">    }</span>

    /**
     *  Tests {@link List#get(int)}.
     */
    public void testListGetByIndex() {
<span class="fc" id="L379">        resetFull();</span>
<span class="fc" id="L380">        final List&lt;E&gt; list = getCollection();</span>
<span class="fc" id="L381">        final E[] elements = getFullElements();</span>
<span class="fc bfc" id="L382" title="All 2 branches covered.">        for (int i = 0; i &lt; elements.length; i++) {</span>
<span class="fc" id="L383">            assertEquals(&quot;List should contain correct elements&quot;, elements[i], list.get(i));</span>
<span class="fc" id="L384">            verify();</span>
        }
<span class="fc" id="L386">    }</span>

    /**
     *  Tests bounds checking for {@link List#get(int)} on an
     *  empty list.
     */
    public void testListGetByIndexBoundsChecking() {
<span class="fc" id="L393">        final List&lt;E&gt; list = makeObject();</span>

        try {
<span class="nc" id="L396">            list.get(Integer.MIN_VALUE);</span>
<span class="nc" id="L397">            fail(&quot;List.get should throw IndexOutOfBoundsException [Integer.MIN_VALUE]&quot;);</span>
<span class="fc" id="L398">        } catch (final IndexOutOfBoundsException e) {</span>
            // expected
<span class="nc" id="L400">        }</span>

        try {
<span class="nc" id="L403">            list.get(-1);</span>
<span class="nc" id="L404">            fail(&quot;List.get should throw IndexOutOfBoundsException [-1]&quot;);</span>
<span class="fc" id="L405">        } catch (final IndexOutOfBoundsException e) {</span>
            // expected
<span class="nc" id="L407">        }</span>

        try {
<span class="nc" id="L410">            list.get(0);</span>
<span class="nc" id="L411">            fail(&quot;List.get should throw IndexOutOfBoundsException [0]&quot;);</span>
<span class="fc" id="L412">        } catch (final IndexOutOfBoundsException e) {</span>
            // expected
<span class="nc" id="L414">        }</span>

        try {
<span class="nc" id="L417">            list.get(1);</span>
<span class="nc" id="L418">            fail(&quot;List.get should throw IndexOutOfBoundsException [1]&quot;);</span>
<span class="fc" id="L419">        } catch (final IndexOutOfBoundsException e) {</span>
            // expected
<span class="nc" id="L421">        }</span>

        try {
<span class="nc" id="L424">            list.get(Integer.MAX_VALUE);</span>
<span class="nc" id="L425">            fail(&quot;List.get should throw IndexOutOfBoundsException [Integer.MAX_VALUE]&quot;);</span>
<span class="fc" id="L426">        } catch (final IndexOutOfBoundsException e) {</span>
            // expected
<span class="nc" id="L428">        }</span>
<span class="fc" id="L429">    }</span>

    /**
     *  Tests bounds checking for {@link List#get(int)} on a
     *  full list.
     */
    public void testListGetByIndexBoundsChecking2() {
<span class="fc" id="L436">        final List&lt;E&gt; list = makeFullCollection();</span>

        try {
<span class="nc" id="L439">            list.get(Integer.MIN_VALUE);</span>
<span class="nc" id="L440">            fail(&quot;List.get should throw IndexOutOfBoundsException [Integer.MIN_VALUE]&quot;);</span>
<span class="fc" id="L441">        } catch (final IndexOutOfBoundsException e) {</span>
            // expected
<span class="nc" id="L443">        }</span>

        try {
<span class="nc" id="L446">            list.get(-1);</span>
<span class="nc" id="L447">            fail(&quot;List.get should throw IndexOutOfBoundsException [-1]&quot;);</span>
<span class="fc" id="L448">        } catch (final IndexOutOfBoundsException e) {</span>
            // expected
<span class="nc" id="L450">        }</span>

        try {
<span class="nc" id="L453">            list.get(getFullElements().length);</span>
<span class="nc" id="L454">            fail(&quot;List.get should throw IndexOutOfBoundsException [size]&quot;);</span>
<span class="fc" id="L455">        } catch (final IndexOutOfBoundsException e) {</span>
            // expected
<span class="nc" id="L457">        }</span>

        try {
<span class="nc" id="L460">            list.get(Integer.MAX_VALUE);</span>
<span class="nc" id="L461">            fail(&quot;List.get should throw IndexOutOfBoundsException [Integer.MAX_VALUE]&quot;);</span>
<span class="fc" id="L462">        } catch (final IndexOutOfBoundsException e) {</span>
            // expected
<span class="nc" id="L464">        }</span>
<span class="fc" id="L465">    }</span>

    /**
     *  Tests {@link List#indexOf}.
     */
    public void testListIndexOf() {
<span class="fc" id="L471">        resetFull();</span>
<span class="fc" id="L472">        final List&lt;E&gt; list1 = getCollection();</span>
<span class="fc" id="L473">        final List&lt;E&gt; list2 = getConfirmed();</span>

<span class="fc bfc" id="L475" title="All 2 branches covered.">        for (final E element : list2) {</span>
<span class="fc" id="L476">            assertEquals(&quot;indexOf should return correct result&quot;,</span>
<span class="fc" id="L477">                    list1.indexOf(element), list2.indexOf(element));</span>
<span class="fc" id="L478">            verify();</span>
<span class="fc" id="L479">        }</span>

<span class="fc" id="L481">        final E[] other = getOtherElements();</span>
<span class="fc bfc" id="L482" title="All 2 branches covered.">        for (final E element : other) {</span>
<span class="fc" id="L483">            assertEquals(&quot;indexOf should return -1 for nonexistent element&quot;,</span>
<span class="fc" id="L484">                -1, list1.indexOf(element));</span>
<span class="fc" id="L485">            verify();</span>
        }
<span class="fc" id="L487">    }</span>

    /**
     *  Tests {@link List#lastIndexOf}.
     */
    public void testListLastIndexOf() {
<span class="fc" id="L493">        resetFull();</span>
<span class="fc" id="L494">        final List&lt;E&gt; list1 = getCollection();</span>
<span class="fc" id="L495">        final List&lt;E&gt; list2 = getConfirmed();</span>

<span class="fc" id="L497">        final Iterator&lt;E&gt; iterator = list2.iterator();</span>
<span class="fc bfc" id="L498" title="All 2 branches covered.">        while (iterator.hasNext()) {</span>
<span class="fc" id="L499">            final E element = iterator.next();</span>
<span class="fc" id="L500">            assertEquals(&quot;lastIndexOf should return correct result&quot;,</span>
<span class="fc" id="L501">              list1.lastIndexOf(element), list2.lastIndexOf(element));</span>
<span class="fc" id="L502">            verify();</span>
<span class="fc" id="L503">        }</span>

<span class="fc" id="L505">        final E[] other = getOtherElements();</span>
<span class="fc bfc" id="L506" title="All 2 branches covered.">        for (final E element : other) {</span>
<span class="fc" id="L507">            assertEquals(&quot;lastIndexOf should return -1 for nonexistent &quot; +</span>
<span class="fc" id="L508">                &quot;element&quot;, -1, list1.lastIndexOf(element));</span>
<span class="fc" id="L509">            verify();</span>
        }
<span class="fc" id="L511">    }</span>

    /**
     *  Tests bounds checking for {@link List#set(int,Object)} on an
     *  empty list.
     */
    public void testListSetByIndexBoundsChecking() {
<span class="fc bfc" id="L518" title="All 2 branches covered.">        if (!isSetSupported()) {</span>
<span class="fc" id="L519">            return;</span>
        }

<span class="fc" id="L522">        final List&lt;E&gt; list = makeObject();</span>
<span class="fc" id="L523">        final E element = getOtherElements()[0];</span>

        try {
<span class="nc" id="L526">            list.set(Integer.MIN_VALUE, element);</span>
<span class="nc" id="L527">            fail(&quot;List.set should throw IndexOutOfBoundsException [Integer.MIN_VALUE]&quot;);</span>
<span class="fc" id="L528">        } catch (final IndexOutOfBoundsException e) {</span>
            // expected
<span class="nc" id="L530">        }</span>

        try {
<span class="nc" id="L533">            list.set(-1, element);</span>
<span class="nc" id="L534">            fail(&quot;List.set should throw IndexOutOfBoundsException [-1]&quot;);</span>
<span class="fc" id="L535">        } catch (final IndexOutOfBoundsException e) {</span>
            // expected
<span class="nc" id="L537">        }</span>

        try {
<span class="nc" id="L540">            list.set(0, element);</span>
<span class="nc" id="L541">            fail(&quot;List.set should throw IndexOutOfBoundsException [0]&quot;);</span>
<span class="fc" id="L542">        } catch (final IndexOutOfBoundsException e) {</span>
            // expected
<span class="nc" id="L544">        }</span>

        try {
<span class="nc" id="L547">            list.set(1, element);</span>
<span class="nc" id="L548">            fail(&quot;List.set should throw IndexOutOfBoundsException [1]&quot;);</span>
<span class="fc" id="L549">        } catch (final IndexOutOfBoundsException e) {</span>
            // expected
<span class="nc" id="L551">        }</span>

        try {
<span class="nc" id="L554">            list.set(Integer.MAX_VALUE, element);</span>
<span class="nc" id="L555">            fail(&quot;List.set should throw IndexOutOfBoundsException [Integer.MAX_VALUE]&quot;);</span>
<span class="fc" id="L556">        } catch (final IndexOutOfBoundsException e) {</span>
            // expected
<span class="nc" id="L558">        }</span>
<span class="fc" id="L559">    }</span>


    /**
     *  Tests bounds checking for {@link List#set(int,Object)} on a
     *  full list.
     */
    public void testListSetByIndexBoundsChecking2() {
<span class="fc bfc" id="L567" title="All 2 branches covered.">        if (!isSetSupported()) {</span>
<span class="fc" id="L568">            return;</span>
        }

<span class="fc" id="L571">        final List&lt;E&gt; list = makeFullCollection();</span>
<span class="fc" id="L572">        final E element = getOtherElements()[0];</span>

        try {
<span class="nc" id="L575">            list.set(Integer.MIN_VALUE, element);</span>
<span class="nc" id="L576">            fail(&quot;List.set should throw IndexOutOfBoundsException &quot; +</span>
              &quot;[Integer.MIN_VALUE]&quot;);
<span class="fc" id="L578">        } catch(final IndexOutOfBoundsException e) {</span>
            // expected
<span class="nc" id="L580">        }</span>

        try {
<span class="nc" id="L583">            list.set(-1, element);</span>
<span class="nc" id="L584">            fail(&quot;List.set should throw IndexOutOfBoundsException [-1]&quot;);</span>
<span class="fc" id="L585">        } catch(final IndexOutOfBoundsException e) {</span>
            // expected
<span class="nc" id="L587">        }</span>

        try {
<span class="nc" id="L590">            list.set(getFullElements().length, element);</span>
<span class="nc" id="L591">            fail(&quot;List.set should throw IndexOutOfBoundsException [size]&quot;);</span>
<span class="fc" id="L592">        } catch(final IndexOutOfBoundsException e) {</span>
            // expected
<span class="nc" id="L594">        }</span>

        try {
<span class="nc" id="L597">            list.set(Integer.MAX_VALUE, element);</span>
<span class="nc" id="L598">            fail(&quot;List.set should throw IndexOutOfBoundsException &quot; +</span>
              &quot;[Integer.MAX_VALUE]&quot;);
<span class="fc" id="L600">        } catch(final IndexOutOfBoundsException e) {</span>
            // expected
<span class="nc" id="L602">        }</span>
<span class="fc" id="L603">    }</span>


    /**
     *  Test {@link List#set(int,Object)}.
     */
    public void testListSetByIndex() {
<span class="fc bfc" id="L610" title="All 2 branches covered.">        if (!isSetSupported()) {</span>
<span class="fc" id="L611">            return;</span>
        }

<span class="fc" id="L614">        resetFull();</span>
<span class="fc" id="L615">        final E[] elements = getFullElements();</span>
<span class="fc" id="L616">        final E[] other = getOtherElements();</span>

<span class="fc bfc" id="L618" title="All 2 branches covered.">        for (int i = 0; i &lt; elements.length; i++) {</span>
<span class="fc" id="L619">            final E n = other[i % other.length];</span>
<span class="fc" id="L620">            final E v = getCollection().set(i, n);</span>
<span class="fc" id="L621">            assertEquals(&quot;Set should return correct element&quot;, elements[i], v);</span>
<span class="fc" id="L622">            getConfirmed().set(i, n);</span>
<span class="fc" id="L623">            verify();</span>
        }
<span class="fc" id="L625">    }</span>

    /**
     *  If {@link #isSetSupported()} returns false, tests that set operation
     *  raises &lt;Code&gt;UnsupportedOperationException.
     */
    public void testUnsupportedSet() {
<span class="fc bfc" id="L632" title="All 2 branches covered.">        if (isSetSupported()) {</span>
<span class="fc" id="L633">            return;</span>
        }

<span class="fc" id="L636">        resetFull();</span>
        try {
<span class="nc" id="L638">            getCollection().set(0, getFullElements()[0]);</span>
<span class="nc" id="L639">            fail(&quot;Emtpy collection should not support set.&quot;);</span>
<span class="fc" id="L640">        } catch (final UnsupportedOperationException e) {</span>
            // expected
<span class="nc" id="L642">        }</span>
        // make sure things didn't change even if the expected exception was
        // thrown.
<span class="fc" id="L645">        verify();</span>
<span class="fc" id="L646">    }</span>

    /**
     *  Tests bounds checking for {@link List#remove(int)} on an
     *  empty list.
     */
    public void testListRemoveByIndexBoundsChecking() {
<span class="fc bfc" id="L653" title="All 2 branches covered.">        if (!isRemoveSupported()) {</span>
<span class="fc" id="L654">            return;</span>
        }

<span class="fc" id="L657">        final List&lt;E&gt; list = makeObject();</span>

        try {
<span class="nc" id="L660">            list.remove(Integer.MIN_VALUE);</span>
<span class="nc" id="L661">            fail(&quot;List.remove should throw IndexOutOfBoundsException [Integer.MIN_VALUE]&quot;);</span>
<span class="fc" id="L662">        } catch(final IndexOutOfBoundsException e) {</span>
            // expected
<span class="nc" id="L664">        }</span>

        try {
<span class="nc" id="L667">            list.remove(-1);</span>
<span class="nc" id="L668">            fail(&quot;List.remove should throw IndexOutOfBoundsException [-1]&quot;);</span>
<span class="fc" id="L669">        } catch(final IndexOutOfBoundsException e) {</span>
            // expected
<span class="nc" id="L671">        }</span>

        try {
<span class="nc" id="L674">            list.remove(0);</span>
<span class="nc" id="L675">            fail(&quot;List.remove should throw IndexOutOfBoundsException [0]&quot;);</span>
<span class="fc" id="L676">        } catch(final IndexOutOfBoundsException e) {</span>
            // expected
<span class="nc" id="L678">        }</span>

        try {
<span class="nc" id="L681">            list.remove(1);</span>
<span class="nc" id="L682">            fail(&quot;List.remove should throw IndexOutOfBoundsException [1]&quot;);</span>
<span class="fc" id="L683">        } catch(final IndexOutOfBoundsException e) {</span>
            // expected
<span class="nc" id="L685">        }</span>

        try {
<span class="nc" id="L688">            list.remove(Integer.MAX_VALUE);</span>
<span class="nc" id="L689">            fail(&quot;List.remove should throw IndexOutOfBoundsException [Integer.MAX_VALUE]&quot;);</span>
<span class="fc" id="L690">        } catch(final IndexOutOfBoundsException e) {</span>
            // expected
<span class="nc" id="L692">        }</span>
<span class="fc" id="L693">    }</span>

    /**
     *  Tests bounds checking for {@link List#remove(int)} on a
     *  full list.
     */
    public void testListRemoveByIndexBoundsChecking2() {
<span class="fc bfc" id="L700" title="All 2 branches covered.">        if (!isRemoveSupported()) {</span>
<span class="fc" id="L701">            return;</span>
        }

<span class="fc" id="L704">        final List&lt;E&gt; list = makeFullCollection();</span>

        try {
<span class="nc" id="L707">            list.remove(Integer.MIN_VALUE);</span>
<span class="nc" id="L708">            fail(&quot;List.remove should throw IndexOutOfBoundsException &quot; +</span>
              &quot;[Integer.MIN_VALUE]&quot;);
<span class="fc" id="L710">        } catch(final IndexOutOfBoundsException e) {</span>
            // expected
<span class="nc" id="L712">        }</span>

        try {
<span class="nc" id="L715">            list.remove(-1);</span>
<span class="nc" id="L716">            fail(&quot;List.remove should throw IndexOutOfBoundsException [-1]&quot;);</span>
<span class="fc" id="L717">        } catch(final IndexOutOfBoundsException e) {</span>
            // expected
<span class="nc" id="L719">        }</span>

        try {
<span class="nc" id="L722">            list.remove(getFullElements().length);</span>
<span class="nc" id="L723">            fail(&quot;List.remove should throw IndexOutOfBoundsException [size]&quot;);</span>
<span class="fc" id="L724">        } catch(final IndexOutOfBoundsException e) {</span>
            // expected
<span class="nc" id="L726">        }</span>

        try {
<span class="nc" id="L729">            list.remove(Integer.MAX_VALUE);</span>
<span class="nc" id="L730">            fail(&quot;List.remove should throw IndexOutOfBoundsException &quot; +</span>
              &quot;[Integer.MAX_VALUE]&quot;);
<span class="fc" id="L732">        } catch(final IndexOutOfBoundsException e) {</span>
            // expected
<span class="nc" id="L734">        }</span>
<span class="fc" id="L735">    }</span>


    /**
     *  Tests {@link List#remove(int)}.
     */
    public void testListRemoveByIndex() {
<span class="fc bfc" id="L742" title="All 2 branches covered.">        if (!isRemoveSupported()) {</span>
<span class="fc" id="L743">            return;</span>
        }

<span class="fc" id="L746">        final int max = getFullElements().length;</span>
<span class="fc bfc" id="L747" title="All 2 branches covered.">        for (int i = 0; i &lt; max; i++) {</span>
<span class="fc" id="L748">            resetFull();</span>
<span class="fc" id="L749">            final E o1 = getCollection().remove(i);</span>
<span class="fc" id="L750">            final E o2 = getConfirmed().remove(i);</span>
<span class="fc" id="L751">            assertEquals(&quot;remove should return correct element&quot;, o1, o2);</span>
<span class="fc" id="L752">            verify();</span>
        }
<span class="fc" id="L754">    }</span>

    /**
     *  Tests the read-only bits of {@link List#listIterator()}.
     */
    public void testListListIterator() {
<span class="fc" id="L760">        resetFull();</span>
<span class="fc" id="L761">        forwardTest(getCollection().listIterator(), 0);</span>
<span class="fc" id="L762">        backwardTest(getCollection().listIterator(), 0);</span>
<span class="fc" id="L763">    }</span>

    /**
     *  Tests the read-only bits of {@link List#listIterator(int)}.
     */
    public void testListListIteratorByIndex() {
<span class="fc" id="L769">        resetFull();</span>
        try {
<span class="nc" id="L771">            getCollection().listIterator(-1);</span>
<span class="pc" id="L772">        } catch (final IndexOutOfBoundsException ex) {}</span>
<span class="fc" id="L773">        resetFull();</span>
        try {
<span class="nc" id="L775">            getCollection().listIterator(getCollection().size() + 1);</span>
<span class="pc" id="L776">        } catch (final IndexOutOfBoundsException ex) {}</span>
<span class="fc" id="L777">        resetFull();</span>
<span class="fc bfc" id="L778" title="All 2 branches covered.">        for (int i = 0; i &lt;= getConfirmed().size(); i++) {</span>
<span class="fc" id="L779">            forwardTest(getCollection().listIterator(i), i);</span>
<span class="fc" id="L780">            backwardTest(getCollection().listIterator(i), i);</span>
        }
<span class="fc" id="L782">        resetFull();</span>
<span class="fc bfc" id="L783" title="All 2 branches covered.">        for (int i = 0; i &lt;= getConfirmed().size(); i++) {</span>
<span class="fc" id="L784">            backwardTest(getCollection().listIterator(i), i);</span>
        }
<span class="fc" id="L786">    }</span>

    //-----------------------------------------------------------------------
    /**
     * Tests remove on list iterator is correct.
     */
    public void testListListIteratorPreviousRemoveNext() {
<span class="fc bfc" id="L793" title="All 2 branches covered.">        if (!isRemoveSupported()) {</span>
<span class="fc" id="L794">            return;</span>
        }
<span class="fc" id="L796">        resetFull();</span>
<span class="pc bpc" id="L797" title="1 of 2 branches missed.">        if (getCollection().size() &lt; 4) {</span>
<span class="nc" id="L798">            return;</span>
        }
<span class="fc" id="L800">        final ListIterator&lt;E&gt; it = getCollection().listIterator();</span>
<span class="fc" id="L801">        final E zero = it.next();</span>
<span class="fc" id="L802">        final E one = it.next();</span>
<span class="fc" id="L803">        final E two = it.next();</span>
<span class="fc" id="L804">        final E two2 = it.previous();</span>
<span class="fc" id="L805">        final E one2 = it.previous();</span>
<span class="fc" id="L806">        assertEquals(one, one2);</span>
<span class="fc" id="L807">        assertEquals(two, two2);</span>
<span class="fc" id="L808">        assertEquals(zero, getCollection().get(0));</span>
<span class="fc" id="L809">        assertEquals(one, getCollection().get(1));</span>
<span class="fc" id="L810">        assertEquals(two, getCollection().get(2));</span>

<span class="fc" id="L812">        it.remove(); // removed element at index 1 (one)</span>
<span class="fc" id="L813">        assertEquals(zero, getCollection().get(0));</span>
<span class="fc" id="L814">        assertEquals(two, getCollection().get(1));</span>
<span class="fc" id="L815">        final E two3 = it.next();  // do next after remove</span>
<span class="fc" id="L816">        assertEquals(two, two3);</span>
<span class="pc bpc" id="L817" title="1 of 2 branches missed.">        assertEquals(getCollection().size() &gt; 2, it.hasNext());</span>
<span class="fc" id="L818">        assertEquals(true, it.hasPrevious());</span>
<span class="fc" id="L819">    }</span>

    /**
     * Tests remove on list iterator is correct.
     */
    public void testListListIteratorPreviousRemovePrevious() {
<span class="fc bfc" id="L825" title="All 2 branches covered.">        if (!isRemoveSupported()) {</span>
<span class="fc" id="L826">            return;</span>
        }
<span class="fc" id="L828">        resetFull();</span>
<span class="pc bpc" id="L829" title="1 of 2 branches missed.">        if (getCollection().size() &lt; 4) {</span>
<span class="nc" id="L830">            return;</span>
        }
<span class="fc" id="L832">        final ListIterator&lt;E&gt; it = getCollection().listIterator();</span>
<span class="fc" id="L833">        final E zero = it.next();</span>
<span class="fc" id="L834">        final E one = it.next();</span>
<span class="fc" id="L835">        final E two = it.next();</span>
<span class="fc" id="L836">        final E two2 = it.previous();</span>
<span class="fc" id="L837">        final E one2 = it.previous();</span>
<span class="fc" id="L838">        assertEquals(one, one2);</span>
<span class="fc" id="L839">        assertEquals(two, two2);</span>
<span class="fc" id="L840">        assertEquals(zero, getCollection().get(0));</span>
<span class="fc" id="L841">        assertEquals(one, getCollection().get(1));</span>
<span class="fc" id="L842">        assertEquals(two, getCollection().get(2));</span>

<span class="fc" id="L844">        it.remove(); // removed element at index 1 (one)</span>
<span class="fc" id="L845">        assertEquals(zero, getCollection().get(0));</span>
<span class="fc" id="L846">        assertEquals(two, getCollection().get(1));</span>
<span class="fc" id="L847">        final E zero3 = it.previous();  // do previous after remove</span>
<span class="fc" id="L848">        assertEquals(zero, zero3);</span>
<span class="fc" id="L849">        assertEquals(false, it.hasPrevious());</span>
<span class="pc bpc" id="L850" title="1 of 2 branches missed.">        assertEquals(getCollection().size() &gt; 2, it.hasNext());</span>
<span class="fc" id="L851">    }</span>

    /**
     * Tests remove on list iterator is correct.
     */
    public void testListListIteratorNextRemoveNext() {
<span class="fc bfc" id="L857" title="All 2 branches covered.">        if (!isRemoveSupported()) {</span>
<span class="fc" id="L858">            return;</span>
        }
<span class="fc" id="L860">        resetFull();</span>
<span class="pc bpc" id="L861" title="1 of 2 branches missed.">        if (getCollection().size() &lt; 4) {</span>
<span class="nc" id="L862">            return;</span>
        }
<span class="fc" id="L864">        final ListIterator&lt;E&gt; it = getCollection().listIterator();</span>
<span class="fc" id="L865">        final E zero = it.next();</span>
<span class="fc" id="L866">        final E one = it.next();</span>
<span class="fc" id="L867">        final E two = it.next();</span>
<span class="fc" id="L868">        assertEquals(zero, getCollection().get(0));</span>
<span class="fc" id="L869">        assertEquals(one, getCollection().get(1));</span>
<span class="fc" id="L870">        assertEquals(two, getCollection().get(2));</span>
<span class="fc" id="L871">        final E three = getCollection().get(3);</span>

<span class="fc" id="L873">        it.remove(); // removed element at index 2 (two)</span>
<span class="fc" id="L874">        assertEquals(zero, getCollection().get(0));</span>
<span class="fc" id="L875">        assertEquals(one, getCollection().get(1));</span>
<span class="fc" id="L876">        final E three2 = it.next();  // do next after remove</span>
<span class="fc" id="L877">        assertEquals(three, three2);</span>
<span class="pc bpc" id="L878" title="1 of 2 branches missed.">        assertEquals(getCollection().size() &gt; 3, it.hasNext());</span>
<span class="fc" id="L879">        assertEquals(true, it.hasPrevious());</span>
<span class="fc" id="L880">    }</span>

    /**
     * Tests remove on list iterator is correct.
     */
    public void testListListIteratorNextRemovePrevious() {
<span class="fc bfc" id="L886" title="All 2 branches covered.">        if (!isRemoveSupported()) {</span>
<span class="fc" id="L887">            return;</span>
        }
<span class="fc" id="L889">        resetFull();</span>
<span class="pc bpc" id="L890" title="1 of 2 branches missed.">        if (getCollection().size() &lt; 4) {</span>
<span class="nc" id="L891">            return;</span>
        }
<span class="fc" id="L893">        final ListIterator&lt;E&gt; it = getCollection().listIterator();</span>
<span class="fc" id="L894">        final E zero = it.next();</span>
<span class="fc" id="L895">        final E one = it.next();</span>
<span class="fc" id="L896">        final E two = it.next();</span>
<span class="fc" id="L897">        assertEquals(zero, getCollection().get(0));</span>
<span class="fc" id="L898">        assertEquals(one, getCollection().get(1));</span>
<span class="fc" id="L899">        assertEquals(two, getCollection().get(2));</span>

<span class="fc" id="L901">        it.remove(); // removed element at index 2 (two)</span>
<span class="fc" id="L902">        assertEquals(zero, getCollection().get(0));</span>
<span class="fc" id="L903">        assertEquals(one, getCollection().get(1));</span>
<span class="fc" id="L904">        final E one2 = it.previous();  // do previous after remove</span>
<span class="fc" id="L905">        assertEquals(one, one2);</span>
<span class="fc" id="L906">        assertEquals(true, it.hasNext());</span>
<span class="fc" id="L907">        assertEquals(true, it.hasPrevious());</span>
<span class="fc" id="L908">    }</span>

    //-----------------------------------------------------------------------
    /**
     *  Traverses to the end of the given iterator.
     *
     *  @param iter  the iterator to traverse
     *  @param i     the starting index
     */
    private void forwardTest(final ListIterator&lt;E&gt; iter, int i) {
<span class="fc" id="L918">        final List&lt;E&gt; list = getCollection();</span>
<span class="fc" id="L919">        final int max = getFullElements().length;</span>

<span class="fc bfc" id="L921" title="All 2 branches covered.">        while (i &lt; max) {</span>
<span class="fc" id="L922">            assertTrue(&quot;Iterator should have next&quot;, iter.hasNext());</span>
<span class="fc" id="L923">            assertEquals(&quot;Iterator.nextIndex should work&quot;,</span>
<span class="fc" id="L924">                i, iter.nextIndex());</span>
<span class="fc" id="L925">            assertEquals(&quot;Iterator.previousIndex should work&quot;,</span>
<span class="fc" id="L926">                i - 1, iter.previousIndex());</span>
<span class="fc" id="L927">            final Object o = iter.next();</span>
<span class="fc" id="L928">            assertEquals(&quot;Iterator returned correct element&quot;, list.get(i), o);</span>
<span class="fc" id="L929">            i++;</span>
<span class="fc" id="L930">        }</span>

<span class="pc bpc" id="L932" title="1 of 2 branches missed.">        assertTrue(&quot;Iterator shouldn't have next&quot;, !iter.hasNext());</span>
<span class="fc" id="L933">        assertEquals(&quot;nextIndex should be size&quot;, max, iter.nextIndex());</span>
<span class="fc" id="L934">        assertEquals(&quot;previousIndex should be size - 1&quot;, max - 1, iter.previousIndex());</span>

        try {
<span class="nc" id="L937">            iter.next();</span>
<span class="nc" id="L938">            fail(&quot;Exhausted iterator should raise NoSuchElement&quot;);</span>
<span class="fc" id="L939">        } catch (final NoSuchElementException e) {</span>
            // expected
<span class="nc" id="L941">        }</span>
<span class="fc" id="L942">    }</span>

    /**
     *  Traverses to the beginning of the given iterator.
     *
     *  @param iter  the iterator to traverse
     *  @param i     the starting index
     */
    private void backwardTest(final ListIterator&lt;E&gt; iter, int i) {
<span class="fc" id="L951">        final List&lt;E&gt; list = getCollection();</span>

<span class="fc bfc" id="L953" title="All 2 branches covered.">        while (i &gt; 0) {</span>
<span class="fc" id="L954">            assertTrue(&quot;Iterator should have previous, i:&quot; + i,</span>
<span class="fc" id="L955">                iter.hasPrevious());</span>
<span class="fc" id="L956">            assertEquals(&quot;Iterator.nextIndex should work, i:&quot; + i,</span>
<span class="fc" id="L957">                i, iter.nextIndex());</span>
<span class="fc" id="L958">            assertEquals(&quot;Iterator.previousIndex should work, i:&quot; + i,</span>
<span class="fc" id="L959">                i - 1, iter.previousIndex());</span>
<span class="fc" id="L960">            final E o = iter.previous();</span>
<span class="fc" id="L961">            assertEquals(&quot;Iterator returned correct element&quot;,</span>
<span class="fc" id="L962">                list.get(i - 1), o);</span>
<span class="fc" id="L963">            i--;</span>
<span class="fc" id="L964">        }</span>

<span class="pc bpc" id="L966" title="1 of 2 branches missed.">        assertTrue(&quot;Iterator shouldn't have previous&quot;, !iter.hasPrevious());</span>
<span class="fc" id="L967">        final int nextIndex = iter.nextIndex();</span>
<span class="fc" id="L968">        assertEquals(&quot;nextIndex should be 0&quot;, 0, nextIndex);</span>
<span class="fc" id="L969">        final int prevIndex = iter.previousIndex();</span>
<span class="fc" id="L970">        assertEquals(&quot;previousIndex should be -1&quot;, -1, prevIndex);</span>

        try {
<span class="nc" id="L973">            iter.previous();</span>
<span class="nc" id="L974">            fail(&quot;Exhausted iterator should raise NoSuchElement&quot;);</span>
<span class="fc" id="L975">        } catch (final NoSuchElementException e) {</span>
            // expected
<span class="nc" id="L977">        }</span>

<span class="fc" id="L979">    }</span>


    /**
     *  Tests the {@link ListIterator#add(Object)} method of the list
     *  iterator.
     */
    public void testListIteratorAdd() {
<span class="fc bfc" id="L987" title="All 2 branches covered.">        if (!isAddSupported()) {</span>
<span class="fc" id="L988">            return;</span>
        }

<span class="fc" id="L991">        resetEmpty();</span>
<span class="fc" id="L992">        final List&lt;E&gt; list1 = getCollection();</span>
<span class="fc" id="L993">        final List&lt;E&gt; list2 = getConfirmed();</span>

<span class="fc" id="L995">        final E[] elements = getFullElements();</span>
<span class="fc" id="L996">        ListIterator&lt;E&gt; iter1 = list1.listIterator();</span>
<span class="fc" id="L997">        ListIterator&lt;E&gt; iter2 = list2.listIterator();</span>

<span class="fc bfc" id="L999" title="All 2 branches covered.">        for (final E element : elements) {</span>
<span class="fc" id="L1000">            iter1.add(element);</span>
<span class="fc" id="L1001">            iter2.add(element);</span>
<span class="fc" id="L1002">            verify();</span>
        }

<span class="fc" id="L1005">        resetFull();</span>
<span class="fc" id="L1006">        iter1 = getCollection().listIterator();</span>
<span class="fc" id="L1007">        iter2 = getConfirmed().listIterator();</span>
<span class="fc bfc" id="L1008" title="All 2 branches covered.">        for (final E element : elements) {</span>
<span class="fc" id="L1009">            iter1.next();</span>
<span class="fc" id="L1010">            iter2.next();</span>
<span class="fc" id="L1011">            iter1.add(element);</span>
<span class="fc" id="L1012">            iter2.add(element);</span>
<span class="fc" id="L1013">            verify();</span>
        }
<span class="fc" id="L1015">    }</span>

    /**
     *  Tests the {@link ListIterator#set(Object)} method of the list
     *  iterator.
     */
    public void testListIteratorSet() {
<span class="fc bfc" id="L1022" title="All 2 branches covered.">        if (!isSetSupported()) {</span>
<span class="fc" id="L1023">            return;</span>
        }

<span class="fc" id="L1026">        final E[] elements = getFullElements();</span>

<span class="fc" id="L1028">        resetFull();</span>
<span class="fc" id="L1029">        final ListIterator&lt;E&gt; iter1 = getCollection().listIterator();</span>
<span class="fc" id="L1030">        final ListIterator&lt;E&gt; iter2 = getConfirmed().listIterator();</span>
<span class="fc bfc" id="L1031" title="All 2 branches covered.">        for (final E element : elements) {</span>
<span class="fc" id="L1032">            iter1.next();</span>
<span class="fc" id="L1033">            iter2.next();</span>
<span class="fc" id="L1034">            iter1.set(element);</span>
<span class="fc" id="L1035">            iter2.set(element);</span>
<span class="fc" id="L1036">            verify();</span>
        }
<span class="fc" id="L1038">    }</span>

    @SuppressWarnings(&quot;unchecked&quot;)
    public void testEmptyListSerialization() throws IOException, ClassNotFoundException {
<span class="fc" id="L1042">        final List&lt;E&gt; list = makeObject();</span>
<span class="fc bfc" id="L1043" title="All 4 branches covered.">        if (!(list instanceof Serializable &amp;&amp; isTestSerialization())) {</span>
<span class="fc" id="L1044">            return;</span>
        }

<span class="fc" id="L1047">        final byte[] objekt = writeExternalFormToBytes((Serializable) list);</span>
<span class="fc" id="L1048">        final List&lt;E&gt; list2 = (List&lt;E&gt;) readExternalFormFromBytes(objekt);</span>

<span class="fc" id="L1050">        assertEquals(&quot;Both lists are empty&quot;, 0, list.size());</span>
<span class="fc" id="L1051">        assertEquals(&quot;Both lists are empty&quot;, 0, list2.size());</span>
<span class="fc" id="L1052">    }</span>

    @SuppressWarnings(&quot;unchecked&quot;)
    public void testFullListSerialization() throws IOException, ClassNotFoundException {
<span class="fc" id="L1056">        final List&lt;E&gt; list = makeFullCollection();</span>
<span class="fc" id="L1057">        final int size = getFullElements().length;</span>
<span class="fc bfc" id="L1058" title="All 4 branches covered.">        if (!(list instanceof Serializable &amp;&amp; isTestSerialization())) {</span>
<span class="fc" id="L1059">            return;</span>
        }

<span class="fc" id="L1062">        final byte[] objekt = writeExternalFormToBytes((Serializable) list);</span>
<span class="fc" id="L1063">        final List&lt;E&gt; list2 = (List&lt;E&gt;) readExternalFormFromBytes(objekt);</span>

<span class="fc" id="L1065">        assertEquals(&quot;Both lists are same size&quot;, size, list.size());</span>
<span class="fc" id="L1066">        assertEquals(&quot;Both lists are same size&quot;, size, list2.size());</span>
<span class="fc" id="L1067">    }</span>

    /**
     * Compare the current serialized form of the List
     * against the canonical version in SVN.
     */
    @SuppressWarnings(&quot;unchecked&quot;)
    public void testEmptyListCompatibility() throws IOException, ClassNotFoundException {
        /**
         * Create canonical objects with this code
        List list = makeEmptyList();
        if (!(list instanceof Serializable)) return;

        writeExternalFormToDisk((Serializable) list, getCanonicalEmptyCollectionName(list));
        */

        // test to make sure the canonical form has been preserved
<span class="fc" id="L1084">        final List&lt;E&gt; list = makeObject();</span>
<span class="pc bpc" id="L1085" title="1 of 4 branches missed.">        if (list instanceof Serializable &amp;&amp; !skipSerializedCanonicalTests()</span>
<span class="fc bfc" id="L1086" title="All 2 branches covered.">                &amp;&amp; isTestSerialization()) {</span>
<span class="fc" id="L1087">            final List&lt;E&gt; list2 = (List&lt;E&gt;) readExternalFormFromDisk(getCanonicalEmptyCollectionName(list));</span>
<span class="fc" id="L1088">            assertEquals(&quot;List is empty&quot;, 0, list2.size());</span>
<span class="fc" id="L1089">            assertEquals(list, list2);</span>
        }
<span class="fc" id="L1091">    }</span>

    /**
     * Compare the current serialized form of the List
     * against the canonical version in SVN.
     */
    @SuppressWarnings(&quot;unchecked&quot;)
    public void testFullListCompatibility() throws IOException, ClassNotFoundException {
        /**
         * Create canonical objects with this code
        List list = makeFullList();
        if (!(list instanceof Serializable)) return;

        writeExternalFormToDisk((Serializable) list, getCanonicalFullCollectionName(list));
        */

        // test to make sure the canonical form has been preserved
<span class="fc" id="L1108">        final List&lt;E&gt; list = makeFullCollection();</span>
<span class="pc bpc" id="L1109" title="1 of 6 branches missed.">        if(list instanceof Serializable &amp;&amp; !skipSerializedCanonicalTests() &amp;&amp; isTestSerialization()) {</span>
<span class="fc" id="L1110">            final List&lt;E&gt; list2 = (List&lt;E&gt;) readExternalFormFromDisk(getCanonicalFullCollectionName(list));</span>
<span class="pc bpc" id="L1111" title="1 of 2 branches missed.">            if (list2.size() == 4) {</span>
                // old serialized tests
<span class="nc" id="L1113">                return;</span>
            }
<span class="fc" id="L1115">            assertEquals(&quot;List is the right size&quot;,list.size(), list2.size());</span>
<span class="fc" id="L1116">            assertEquals(list, list2);</span>
        }
<span class="fc" id="L1118">    }</span>

    //-----------------------------------------------------------------------
    /**
     *  Returns a {@link BulkTest} for testing {@link List#subList(int,int)}.
     *  The returned bulk test will run through every &lt;code&gt;TestList&lt;/code&gt;
     *  method, &lt;i&gt;including&lt;/i&gt; another &lt;code&gt;bulkTestSubList&lt;/code&gt;.
     *  Sublists are tested until the size of the sublist is less than 10.
     *  Each sublist is 6 elements smaller than its parent list.
     *  (By default this means that two rounds of sublists will be tested).
     *  The verify() method is overloaded to test that the original list is
     *  modified when the sublist is.
     */
    public BulkTest bulkTestSubList() {
<span class="fc bfc" id="L1132" title="All 2 branches covered.">        if (getFullElements().length - 6 &lt; 10) {</span>
<span class="fc" id="L1133">            return null;</span>
        }
<span class="fc" id="L1135">        return new BulkTestSubList&lt;&gt;(this);</span>
    }

   public static class BulkTestSubList&lt;E&gt; extends AbstractListTest&lt;E&gt; {

       private final AbstractListTest&lt;E&gt; outer;

       public BulkTestSubList(final AbstractListTest&lt;E&gt; outer) {
<span class="fc" id="L1143">           super(&quot;&quot;);</span>
<span class="fc" id="L1144">           this.outer = outer;</span>
<span class="fc" id="L1145">       }</span>

       @Override
       @SuppressWarnings(&quot;unchecked&quot;)
       public E[] getFullElements() {
<span class="fc" id="L1150">           final List&lt;E&gt; l = Arrays.asList(outer.getFullElements());</span>
<span class="fc" id="L1151">           return (E[]) l.subList(3, l.size() - 3).toArray();</span>
       }

       @Override
       public E[] getOtherElements() {
<span class="fc" id="L1156">           return outer.getOtherElements();</span>
       }

       @Override
       public boolean isAddSupported() {
<span class="fc" id="L1161">           return outer.isAddSupported();</span>
       }

       @Override
       public boolean isSetSupported() {
<span class="fc" id="L1166">           return outer.isSetSupported();</span>
       }

       @Override
       public boolean isRemoveSupported() {
<span class="fc" id="L1171">           return outer.isRemoveSupported();</span>
       }

       @Override
       public List&lt;E&gt; makeObject() {
<span class="fc" id="L1176">           return outer.makeFullCollection().subList(4, 4);</span>
       }

       @Override
       public List&lt;E&gt; makeFullCollection() {
<span class="fc" id="L1181">           final int size = getFullElements().length;</span>
<span class="fc" id="L1182">           return outer.makeFullCollection().subList(3, size - 3);</span>
       }

       @Override
       public void resetEmpty() {
<span class="fc" id="L1187">           outer.resetFull();</span>
<span class="fc" id="L1188">           this.setCollection(outer.getCollection().subList(4, 4));</span>
<span class="fc" id="L1189">           this.setConfirmed(outer.getConfirmed().subList(4, 4));</span>
<span class="fc" id="L1190">       }</span>

       @Override
       public void resetFull() {
<span class="fc" id="L1194">           outer.resetFull();</span>
<span class="fc" id="L1195">           final int size = outer.getConfirmed().size();</span>
<span class="fc" id="L1196">           this.setCollection(outer.getCollection().subList(3, size - 3));</span>
<span class="fc" id="L1197">           this.setConfirmed(outer.getConfirmed().subList(3, size - 3));</span>
<span class="fc" id="L1198">       }</span>

       @Override
       public void verify() {
<span class="fc" id="L1202">           super.verify();</span>
<span class="fc" id="L1203">           outer.verify();</span>
<span class="fc" id="L1204">       }</span>

       @Override
       public boolean isTestSerialization() {
<span class="fc" id="L1208">           return false;</span>
       }
   }

   /**
    *  Tests that a sublist raises a {@link java.util.ConcurrentModificationException ConcurrentModificationException}
    *  if elements are added to the original list.
    */
   public void testListSubListFailFastOnAdd() {
<span class="pc bpc" id="L1217" title="1 of 2 branches missed.">       if (!isFailFastSupported()) {</span>
<span class="fc" id="L1218">        return;</span>
    }
<span class="nc bnc" id="L1220" title="All 2 branches missed.">       if (!isAddSupported()) {</span>
<span class="nc" id="L1221">        return;</span>
    }

<span class="nc" id="L1224">       resetFull();</span>
<span class="nc" id="L1225">       final int size = getCollection().size();</span>
<span class="nc" id="L1226">       List&lt;E&gt; sub = getCollection().subList(1, size);</span>
<span class="nc" id="L1227">       getCollection().add(getOtherElements()[0]);</span>
<span class="nc" id="L1228">       failFastAll(sub);</span>

<span class="nc" id="L1230">       resetFull();</span>
<span class="nc" id="L1231">       sub = getCollection().subList(1, size);</span>
<span class="nc" id="L1232">       getCollection().add(0, getOtherElements()[0]);</span>
<span class="nc" id="L1233">       failFastAll(sub);</span>

<span class="nc" id="L1235">       resetFull();</span>
<span class="nc" id="L1236">       sub = getCollection().subList(1, size);</span>
<span class="nc" id="L1237">       getCollection().addAll(Arrays.asList(getOtherElements()));</span>
<span class="nc" id="L1238">       failFastAll(sub);</span>

<span class="nc" id="L1240">       resetFull();</span>
<span class="nc" id="L1241">       sub = getCollection().subList(1, size);</span>
<span class="nc" id="L1242">       getCollection().addAll(0, Arrays.asList(getOtherElements()));</span>
<span class="nc" id="L1243">       failFastAll(sub);</span>
<span class="nc" id="L1244">   }</span>

   /**
    *  Tests that a sublist raises a {@link java.util.ConcurrentModificationException ConcurrentModificationException}
    *  if elements are removed from the original list.
    */
   public void testListSubListFailFastOnRemove() {
<span class="pc bpc" id="L1251" title="1 of 2 branches missed.">       if (!isFailFastSupported()) {</span>
<span class="fc" id="L1252">        return;</span>
    }
<span class="nc bnc" id="L1254" title="All 2 branches missed.">       if (!isRemoveSupported()) {</span>
<span class="nc" id="L1255">        return;</span>
    }

<span class="nc" id="L1258">       resetFull();</span>
<span class="nc" id="L1259">       final int size = getCollection().size();</span>
<span class="nc" id="L1260">       List&lt;E&gt; sub = getCollection().subList(1, size);</span>
<span class="nc" id="L1261">       getCollection().remove(0);</span>
<span class="nc" id="L1262">       failFastAll(sub);</span>

<span class="nc" id="L1264">       resetFull();</span>
<span class="nc" id="L1265">       sub = getCollection().subList(1, size);</span>
<span class="nc" id="L1266">       getCollection().remove(getFullElements()[2]);</span>
<span class="nc" id="L1267">       failFastAll(sub);</span>

<span class="nc" id="L1269">       resetFull();</span>
<span class="nc" id="L1270">       sub = getCollection().subList(1, size);</span>
<span class="nc" id="L1271">       getCollection().removeAll(Arrays.asList(getFullElements()));</span>
<span class="nc" id="L1272">       failFastAll(sub);</span>

<span class="nc" id="L1274">       resetFull();</span>
<span class="nc" id="L1275">       sub = getCollection().subList(1, size);</span>
<span class="nc" id="L1276">       getCollection().retainAll(Arrays.asList(getOtherElements()));</span>
<span class="nc" id="L1277">       failFastAll(sub);</span>

<span class="nc" id="L1279">       resetFull();</span>
<span class="nc" id="L1280">       sub = getCollection().subList(1, size);</span>
<span class="nc" id="L1281">       getCollection().clear();</span>
<span class="nc" id="L1282">       failFastAll(sub);</span>
<span class="nc" id="L1283">   }</span>

   /**
    *  Invokes all the methods on the given sublist to make sure they raise
    *  a {@link java.util.ConcurrentModificationException ConcurrentModificationException}.
    */
   protected void failFastAll(final List&lt;E&gt; list) {
<span class="nc" id="L1290">       final Method[] methods = List.class.getMethods();</span>
<span class="nc bnc" id="L1291" title="All 2 branches missed.">       for (final Method method : methods) {</span>
<span class="nc" id="L1292">           failFastMethod(list, method);</span>
       }
<span class="nc" id="L1294">   }</span>

   /**
    *  Invokes the given method on the given sublist to make sure it raises
    *  a {@link java.util.ConcurrentModificationException ConcurrentModificationException}.
    *
    *  Unless the method happens to be the equals() method, in which case
    *  the test is skipped.  There seems to be a bug in
    *  java.util.AbstractList.subList(int,int).equals(Object) -- it never
    *  raises a ConcurrentModificationException.
    *
    *  @param list  the sublist to test
    *  @param m     the method to invoke
    */
   protected void failFastMethod(final List&lt;E&gt; list, final Method m) {
<span class="nc bnc" id="L1309" title="All 2 branches missed.">       if (m.getName().equals(&quot;equals&quot;)) {</span>
<span class="nc" id="L1310">        return;</span>
    }

<span class="nc" id="L1313">       final E element = getOtherElements()[0];</span>
<span class="nc" id="L1314">       final Collection&lt;E&gt; c = Collections.singleton(element);</span>

<span class="nc" id="L1316">       final Class&lt;?&gt;[] types = m.getParameterTypes();</span>
<span class="nc" id="L1317">       final Object[] params = new Object[types.length];</span>
<span class="nc bnc" id="L1318" title="All 2 branches missed.">       for (int i = 0; i &lt; params.length; i++) {</span>
<span class="nc bnc" id="L1319" title="All 2 branches missed.">           if (types[i] == Integer.TYPE) {</span>
<span class="nc" id="L1320">            params[i] = Integer.valueOf(0);</span>
<span class="nc bnc" id="L1321" title="All 2 branches missed.">        } else if (types[i] == Collection.class) {</span>
<span class="nc" id="L1322">            params[i] = c;</span>
<span class="nc bnc" id="L1323" title="All 2 branches missed.">        } else if (types[i] == Object.class) {</span>
<span class="nc" id="L1324">            params[i] = element;</span>
<span class="nc bnc" id="L1325" title="All 2 branches missed.">        } else if (types[i] == Object[].class) {</span>
<span class="nc" id="L1326">            params[i] = new Object[0];</span>
        }
       }

       try {
<span class="nc" id="L1331">           m.invoke(list, params);</span>
<span class="nc" id="L1332">           fail(m.getName() + &quot; should raise ConcurrentModification&quot;);</span>
<span class="nc" id="L1333">       } catch (final IllegalAccessException e) {</span>
           // impossible
<span class="nc" id="L1335">       } catch (final InvocationTargetException e) {</span>
<span class="nc" id="L1336">           final Throwable t = e.getTargetException();</span>
<span class="nc bnc" id="L1337" title="All 2 branches missed.">           if (t instanceof ConcurrentModificationException) {</span>
               // expected
<span class="nc" id="L1339">               return;</span>
           }
<span class="nc" id="L1341">        fail(m.getName() + &quot; raised unexpected &quot; + e);</span>
<span class="nc" id="L1342">       }</span>
<span class="nc" id="L1343">   }</span>

   //-----------------------------------------------------------------------
   public BulkTest bulkTestListIterator() {
<span class="fc" id="L1347">       return new TestListIterator();</span>
   }

   public class TestListIterator extends AbstractListIteratorTest&lt;E&gt; {
<span class="fc" id="L1351">       public TestListIterator() {</span>
<span class="fc" id="L1352">           super(&quot;TestListIterator&quot;);</span>
<span class="fc" id="L1353">       }</span>

       @Override
       public E addSetValue() {
<span class="fc" id="L1357">           return AbstractListTest.this.getOtherElements()[0];</span>
       }

       @Override
       public boolean supportsRemove() {
<span class="fc" id="L1362">           return AbstractListTest.this.isRemoveSupported();</span>
       }

       @Override
       public boolean supportsAdd() {
<span class="fc" id="L1367">           return AbstractListTest.this.isAddSupported();</span>
       }

       @Override
       public boolean supportsSet() {
<span class="fc" id="L1372">           return AbstractListTest.this.isSetSupported();</span>
       }

       @Override
       public ListIterator&lt;E&gt; makeEmptyIterator() {
<span class="fc" id="L1377">           resetEmpty();</span>
<span class="fc" id="L1378">           return AbstractListTest.this.getCollection().listIterator();</span>
       }

       @Override
       public ListIterator&lt;E&gt; makeObject() {
<span class="fc" id="L1383">           resetFull();</span>
<span class="fc" id="L1384">           return AbstractListTest.this.getCollection().listIterator();</span>
       }
   }

}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.1.201803210924</span></div></body></html>