<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>AbstractMapTest.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">commons_collections4$All_in_commons_collections4.exec</a> &gt; <a href="index.source.html" class="el_package">org.apache.commons.collections4.map</a> &gt; <span class="el_source">AbstractMapTest.java</span></div><h1>AbstractMapTest.java</h1><pre class="source lang-java linenums">/*
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the &quot;License&quot;); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.commons.collections4.map;

import java.io.Serializable;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Collection;
import java.util.Collections;
import java.util.HashMap;
import java.util.HashSet;
import java.util.Iterator;
import java.util.List;
import java.util.Map;
import java.util.Map.Entry;
import java.util.Set;

import org.apache.commons.collections4.AbstractObjectTest;
import org.apache.commons.collections4.BulkTest;
import org.apache.commons.collections4.CollectionUtils;
import org.apache.commons.collections4.collection.AbstractCollectionTest;
import org.apache.commons.collections4.keyvalue.DefaultMapEntry;
import org.apache.commons.collections4.set.AbstractSetTest;

/**
 * Abstract test class for {@link java.util.Map} methods and contracts.
 * &lt;p&gt;
 * The forces at work here are similar to those in {@link AbstractCollectionTest}.
 * If your class implements the full Map interface, including optional
 * operations, simply extend this class, and implement the
 * {@link #makeObject()} method.
 * &lt;p&gt;
 * On the other hand, if your map implementation is weird, you may have to
 * override one or more of the other protected methods.  They're described
 * below.
 * &lt;p&gt;
 * &lt;b&gt;Entry Population Methods&lt;/b&gt;
 * &lt;p&gt;
 * Override these methods if your map requires special entries:
 *
 * &lt;ul&gt;
 * &lt;li&gt;{@link #getSampleKeys()}
 * &lt;li&gt;{@link #getSampleValues()}
 * &lt;li&gt;{@link #getNewSampleValues()}
 * &lt;li&gt;{@link #getOtherKeys()}
 * &lt;li&gt;{@link #getOtherValues()}
 * &lt;/ul&gt;
 *
 * &lt;b&gt;Supported Operation Methods&lt;/b&gt;
 * &lt;p&gt;
 * Override these methods if your map doesn't support certain operations:
 *
 * &lt;ul&gt;
 * &lt;li&gt; {@link #isPutAddSupported()}
 * &lt;li&gt; {@link #isPutChangeSupported()}
 * &lt;li&gt; {@link #isSetValueSupported()}
 * &lt;li&gt; {@link #isRemoveSupported()}
 * &lt;li&gt; {@link #isGetStructuralModify()}
 * &lt;li&gt; {@link #isAllowDuplicateValues()}
 * &lt;li&gt; {@link #isAllowNullKey()}
 * &lt;li&gt; {@link #isAllowNullValue()}
 * &lt;/ul&gt;
 *
 * &lt;b&gt;Fixture Methods&lt;/b&gt;
 * &lt;p&gt;
 * For tests on modification operations (puts and removes), fixtures are used
 * to verify that that operation results in correct state for the map and its
 * collection views.  Basically, the modification is performed against your
 * map implementation, and an identical modification is performed against
 * a &lt;I&gt;confirmed&lt;/I&gt; map implementation.  A confirmed map implementation is
 * something like &lt;Code&gt;java.util.HashMap&lt;/Code&gt;, which is known to conform
 * exactly to the {@link Map} contract.  After the modification takes place
 * on both your map implementation and the confirmed map implementation, the
 * two maps are compared to see if their state is identical.  The comparison
 * also compares the collection views to make sure they're still the same.&lt;P&gt;
 *
 * The upshot of all that is that &lt;I&gt;any&lt;/I&gt; test that modifies the map in
 * &lt;I&gt;any&lt;/I&gt; way will verify that &lt;I&gt;all&lt;/I&gt; of the map's state is still
 * correct, including the state of its collection views.  So for instance
 * if a key is removed by the map's key set's iterator, then the entry set
 * is checked to make sure the key/value pair no longer appears.&lt;P&gt;
 *
 * The {@link #map} field holds an instance of your collection implementation.
 * The {@link #entrySet}, {@link #keySet} and {@link #values} fields hold
 * that map's collection views.  And the {@link #confirmed} field holds
 * an instance of the confirmed collection implementation.  The
 * {@link #resetEmpty()} and {@link #resetFull()} methods set these fields to
 * empty or full maps, so that tests can proceed from a known state.&lt;P&gt;
 *
 * After a modification operation to both {@link #map} and {@link #confirmed},
 * the {@link #verify()} method is invoked to compare the results.  The
 * {@link #verify} method calls separate methods to verify the map and its three
 * collection views ({@link #verifyMap}, {@link #verifyEntrySet},
 * {@link #verifyKeySet}, and {@link #verifyValues}).  You may want to override
 * one of the verification methods to perform additional verifications.  For
 * instance, TestDoubleOrderedMap would want override its
 * {@link #verifyValues()} method to verify that the values are unique and in
 * ascending order.&lt;P&gt;
 *
 * &lt;b&gt;Other Notes&lt;/b&gt;
 * &lt;p&gt;
 * If your {@link Map} fails one of these tests by design, you may still use
 * this base set of cases.  Simply override the test case (method) your map
 * fails and/or the methods that define the assumptions used by the test
 * cases.  For example, if your map does not allow duplicate values, override
 * {@link #isAllowDuplicateValues()} and have it return &lt;code&gt;false&lt;/code&gt;
 *
 */
public abstract class AbstractMapTest&lt;K, V&gt; extends AbstractObjectTest {

    /**
     * JDK1.2 has bugs in null handling of Maps, especially HashMap.Entry.toString
     * This avoids nulls for JDK1.2
     */
    private static final boolean JDK12;
    static {
<span class="fc" id="L131">        final String str = System.getProperty(&quot;java.version&quot;);</span>
<span class="fc" id="L132">        JDK12 = str.startsWith(&quot;1.2&quot;);</span>
<span class="fc" id="L133">    }</span>

    // These instance variables are initialized with the reset method.
    // Tests for map methods that alter the map (put, putAll, remove)
    // first call reset() to create the map and its views; then perform
    // the modification on the map; perform the same modification on the
    // confirmed; and then call verify() to ensure that the map is equal
    // to the confirmed, that the already-constructed collection views
    // are still equal to the confirmed's collection views.

    /** Map created by reset(). */
    protected Map&lt;K, V&gt; map;

    /** Entry set of map created by reset(). */
    protected Set&lt;Map.Entry&lt;K, V&gt;&gt; entrySet;

    /** Key set of map created by reset(). */
    protected Set&lt;K&gt; keySet;

    /** Values collection of map created by reset(). */
    protected Collection&lt;V&gt; values;

    /** HashMap created by reset(). */
    protected Map&lt;K, V&gt; confirmed;

    /**
     * JUnit constructor.
     *
     * @param testName  the test name
     */
    public AbstractMapTest(final String testName) {
<span class="fc" id="L164">        super(testName);</span>
<span class="fc" id="L165">    }</span>

    /**
     * Returns true if the maps produced by
     * {@link #makeObject()} and {@link #makeFullMap()}
     * support the &lt;code&gt;put&lt;/code&gt; and &lt;code&gt;putAll&lt;/code&gt; operations
     * adding new mappings.
     * &lt;p&gt;
     * Default implementation returns true.
     * Override if your collection class does not support put adding.
     */
    public boolean isPutAddSupported() {
<span class="fc" id="L177">        return true;</span>
    }

    /**
     * Returns true if the maps produced by
     * {@link #makeObject()} and {@link #makeFullMap()}
     * support the &lt;code&gt;put&lt;/code&gt; and &lt;code&gt;putAll&lt;/code&gt; operations
     * changing existing mappings.
     * &lt;p&gt;
     * Default implementation returns true.
     * Override if your collection class does not support put changing.
     */
    public boolean isPutChangeSupported() {
<span class="fc" id="L190">        return true;</span>
    }

    /**
     * Returns true if the maps produced by
     * {@link #makeObject()} and {@link #makeFullMap()}
     * support the &lt;code&gt;setValue&lt;/code&gt; operation on entrySet entries.
     * &lt;p&gt;
     * Default implementation returns isPutChangeSupported().
     * Override if your collection class does not support setValue but does
     * support put changing.
     */
    public boolean isSetValueSupported() {
<span class="fc" id="L203">        return isPutChangeSupported();</span>
    }

    /**
     * Returns true if the maps produced by
     * {@link #makeObject()} and {@link #makeFullMap()}
     * support the &lt;code&gt;remove&lt;/code&gt; and &lt;code&gt;clear&lt;/code&gt; operations.
     * &lt;p&gt;
     * Default implementation returns true.
     * Override if your collection class does not support removal operations.
     */
    public boolean isRemoveSupported() {
<span class="fc" id="L215">        return true;</span>
    }

    /**
     * Returns true if the maps produced by
     * {@link #makeObject()} and {@link #makeFullMap()}
     * can cause structural modification on a get(). The example is LRUMap.
     * &lt;p&gt;
     * Default implementation returns false.
     * Override if your map class structurally modifies on get.
     */
    public boolean isGetStructuralModify() {
<span class="fc" id="L227">        return false;</span>
    }

    /**
     * Returns whether the sub map views of SortedMap are serializable.
     * If the class being tested is based around a TreeMap then you should
     * override and return false as TreeMap has a bug in deserialization.
     *
     * @return false
     */
    public boolean isSubMapViewsSerializable() {
<span class="nc" id="L238">        return true;</span>
    }

    /**
     * Returns true if the maps produced by
     * {@link #makeObject()} and {@link #makeFullMap()}
     * supports null keys.
     * &lt;p&gt;
     * Default implementation returns true.
     * Override if your collection class does not support null keys.
     */
    public boolean isAllowNullKey() {
<span class="fc" id="L250">        return true;</span>
    }

    /**
     * Returns true if the maps produced by
     * {@link #makeObject()} and {@link #makeFullMap()}
     * supports null values.
     * &lt;p&gt;
     * Default implementation returns true.
     * Override if your collection class does not support null values.
     */
    public boolean isAllowNullValue() {
<span class="fc" id="L262">        return true;</span>
    }

    /**
     * Returns true if the maps produced by
     * {@link #makeObject()} and {@link #makeFullMap()}
     * supports duplicate values.
     * &lt;p&gt;
     * Default implementation returns true.
     * Override if your collection class does not support duplicate values.
     */
    public boolean isAllowDuplicateValues() {
<span class="fc" id="L274">        return true;</span>
    }

    /**
     * Returns true if the maps produced by
     * {@link #makeObject()} and {@link #makeFullMap()}
     * provide fail-fast behavior on their various iterators.
     * &lt;p&gt;
     * Default implementation returns true.
     * Override if your collection class does not support fast failure.
     */
    public boolean isFailFastExpected() {
<span class="fc" id="L286">        return true;</span>
    }

    public boolean areEqualElementsDistinguishable() {
<span class="fc" id="L290">        return false;</span>
    }

    /**
     *  Returns the set of keys in the mappings used to test the map.  This
     *  method must return an array with the same length as {@link
     *  #getSampleValues()} and all array elements must be different. The
     *  default implementation constructs a set of String keys, and includes a
     *  single null key if {@link #isAllowNullKey()} returns &lt;code&gt;true&lt;/code&gt;.
     */
    @SuppressWarnings(&quot;unchecked&quot;)
    public K[] getSampleKeys() {
<span class="fc" id="L302">        final Object[] result = new Object[] {</span>
            &quot;blah&quot;, &quot;foo&quot;, &quot;bar&quot;, &quot;baz&quot;, &quot;tmp&quot;, &quot;gosh&quot;, &quot;golly&quot;, &quot;gee&quot;,
            &quot;hello&quot;, &quot;goodbye&quot;, &quot;we'll&quot;, &quot;see&quot;, &quot;you&quot;, &quot;all&quot;, &quot;again&quot;,
            &quot;key&quot;,
            &quot;key2&quot;,
<span class="pc bpc" id="L307" title="1 of 4 branches missed.">            isAllowNullKey() &amp;&amp; !JDK12 ? null : &quot;nonnullkey&quot;</span>
        };
<span class="fc" id="L309">        return (K[]) result;</span>
    }

    @SuppressWarnings(&quot;unchecked&quot;)
    public K[] getOtherKeys() {
<span class="fc" id="L314">        return (K[]) getOtherNonNullStringElements();</span>
    }

    @SuppressWarnings(&quot;unchecked&quot;)
    public V[] getOtherValues() {
<span class="fc" id="L319">        return (V[]) getOtherNonNullStringElements();</span>
    }

    @SuppressWarnings(&quot;unchecked&quot;)
    protected &lt;E&gt; List&lt;E&gt; getAsList(final Object[] o) {
<span class="fc" id="L324">        final ArrayList&lt;E&gt; result = new ArrayList&lt;&gt;();</span>
<span class="fc bfc" id="L325" title="All 2 branches covered.">        for (final Object element : o) {</span>
<span class="fc" id="L326">            result.add((E) element);</span>
        }
<span class="fc" id="L328">        return result;</span>
    }

    /**
     * Returns a list of string elements suitable for return by
     * {@link #getOtherKeys()} or {@link #getOtherValues}.
     *
     * &lt;p&gt;Override getOtherElements to return the results of this method if your
     * collection does not support heterogenous elements or the null element.
     * &lt;/p&gt;
     */
    public Object[] getOtherNonNullStringElements() {
<span class="fc" id="L340">        return new Object[] {</span>
            &quot;For&quot;,&quot;then&quot;,&quot;despite&quot;,/* of */&quot;space&quot;,&quot;I&quot;,&quot;would&quot;,&quot;be&quot;,&quot;brought&quot;,
            &quot;From&quot;,&quot;limits&quot;,&quot;far&quot;,&quot;remote&quot;,&quot;where&quot;,&quot;thou&quot;,&quot;dost&quot;,&quot;stay&quot;
        };
    }

    /**
     * Returns the set of values in the mappings used to test the map.  This
     * method must return an array with the same length as
     * {@link #getSampleKeys()}.  The default implementation constructs a set of
     * String values and includes a single null value if
     * {@link #isAllowNullValue()} returns &lt;code&gt;true&lt;/code&gt;, and includes
     * two values that are the same if {@link #isAllowDuplicateValues()} returns
     * &lt;code&gt;true&lt;/code&gt;.
     */
    @SuppressWarnings(&quot;unchecked&quot;)
    public V[] getSampleValues() {
<span class="fc" id="L357">        final Object[] result = new Object[] {</span>
            &quot;blahv&quot;, &quot;foov&quot;, &quot;barv&quot;, &quot;bazv&quot;, &quot;tmpv&quot;, &quot;goshv&quot;, &quot;gollyv&quot;, &quot;geev&quot;,
            &quot;hellov&quot;, &quot;goodbyev&quot;, &quot;we'llv&quot;, &quot;seev&quot;, &quot;youv&quot;, &quot;allv&quot;, &quot;againv&quot;,
<span class="pc bpc" id="L360" title="1 of 4 branches missed.">            isAllowNullValue() &amp;&amp; !JDK12 ? null : &quot;nonnullvalue&quot;,</span>
            &quot;value&quot;,
<span class="fc bfc" id="L362" title="All 2 branches covered.">            isAllowDuplicateValues() ? &quot;value&quot; : &quot;value2&quot;,</span>
        };
<span class="fc" id="L364">        return (V[]) result;</span>
    }

    /**
     * Returns a the set of values that can be used to replace the values
     * returned from {@link #getSampleValues()}.  This method must return an
     * array with the same length as {@link #getSampleValues()}.  The values
     * returned from this method should not be the same as those returned from
     * {@link #getSampleValues()}.  The default implementation constructs a
     * set of String values and includes a single null value if
     * {@link #isAllowNullValue()} returns &lt;code&gt;true&lt;/code&gt;, and includes two values
     * that are the same if {@link #isAllowDuplicateValues()} returns
     * &lt;code&gt;true&lt;/code&gt;.
     */
    @SuppressWarnings(&quot;unchecked&quot;)
    public V[] getNewSampleValues() {
<span class="fc" id="L380">        final Object[] result = new Object[] {</span>
<span class="pc bpc" id="L381" title="1 of 6 branches missed.">            isAllowNullValue() &amp;&amp; !JDK12 &amp;&amp; isAllowDuplicateValues() ? null : &quot;newnonnullvalue&quot;,</span>
            &quot;newvalue&quot;,
<span class="fc bfc" id="L383" title="All 2 branches covered.">            isAllowDuplicateValues() ? &quot;newvalue&quot; : &quot;newvalue2&quot;,</span>
            &quot;newblahv&quot;, &quot;newfoov&quot;, &quot;newbarv&quot;, &quot;newbazv&quot;, &quot;newtmpv&quot;, &quot;newgoshv&quot;,
            &quot;newgollyv&quot;, &quot;newgeev&quot;, &quot;newhellov&quot;, &quot;newgoodbyev&quot;, &quot;newwe'llv&quot;,
            &quot;newseev&quot;, &quot;newyouv&quot;, &quot;newallv&quot;, &quot;newagainv&quot;,
        };
<span class="fc" id="L388">        return (V[]) result;</span>
    }

    /**
     *  Helper method to add all the mappings described by
     * {@link #getSampleKeys()} and {@link #getSampleValues()}.
     */
    public void addSampleMappings(final Map&lt;? super K, ? super V&gt; m) {

<span class="fc" id="L397">        final K[] keys = getSampleKeys();</span>
<span class="fc" id="L398">        final V[] values = getSampleValues();</span>

<span class="fc bfc" id="L400" title="All 2 branches covered.">        for (int i = 0; i &lt; keys.length; i++) {</span>
            try {
<span class="fc" id="L402">                m.put(keys[i], values[i]);</span>
<span class="nc" id="L403">            } catch (final NullPointerException exception) {</span>
<span class="nc bnc" id="L404" title="All 4 branches missed.">                assertTrue(&quot;NullPointerException only allowed to be thrown &quot; +</span>
                           &quot;if either the key or value is null.&quot;,
                           keys[i] == null || values[i] == null);

<span class="nc bnc" id="L408" title="All 2 branches missed.">                assertTrue(&quot;NullPointerException on null key, but &quot; +</span>
                           &quot;isAllowNullKey is not overridden to return false.&quot;,
<span class="nc bnc" id="L410" title="All 2 branches missed.">                           keys[i] == null || !isAllowNullKey());</span>

<span class="nc bnc" id="L412" title="All 2 branches missed.">                assertTrue(&quot;NullPointerException on null value, but &quot; +</span>
                           &quot;isAllowNullValue is not overridden to return false.&quot;,
<span class="nc bnc" id="L414" title="All 2 branches missed.">                           values[i] == null || !isAllowNullValue());</span>

<span class="nc" id="L416">                assertTrue(&quot;Unknown reason for NullPointer.&quot;, false);</span>
<span class="fc" id="L417">            }</span>
        }
<span class="fc" id="L419">        assertEquals(&quot;size must reflect number of mappings added.&quot;,</span>
<span class="fc" id="L420">                     keys.length, m.size());</span>
<span class="fc" id="L421">    }</span>

    //-----------------------------------------------------------------------
    /**
     * Return a new, empty {@link Map} to be used for testing.
     *
     * @return the map to be tested
     */
    @Override
    public abstract Map&lt;K,V&gt; makeObject();

    /**
     * Return a new, populated map.  The mappings in the map should match the
     * keys and values returned from {@link #getSampleKeys()} and
     * {@link #getSampleValues()}.  The default implementation uses makeEmptyMap()
     * and calls {@link #addSampleMappings} to add all the mappings to the
     * map.
     *
     * @return the map to be tested
     */
    public Map&lt;K, V&gt; makeFullMap() {
<span class="fc" id="L442">        final Map&lt;K, V&gt; m = makeObject();</span>
<span class="fc" id="L443">        addSampleMappings(m);</span>
<span class="fc" id="L444">        return m;</span>
    }

    /**
     * Override to return a map other than HashMap as the confirmed map.
     *
     * @return a map that is known to be valid
     */
    public Map&lt;K, V&gt; makeConfirmedMap() {
<span class="fc" id="L453">        return new HashMap&lt;&gt;();</span>
    }

    /**
     * Creates a new Map Entry that is independent of the first and the map.
     */
    public static &lt;K, V&gt; Map.Entry&lt;K, V&gt; cloneMapEntry(final Map.Entry&lt;K, V&gt; entry) {
<span class="fc" id="L460">        final HashMap&lt;K, V&gt; map = new HashMap&lt;&gt;();</span>
<span class="fc" id="L461">        map.put(entry.getKey(), entry.getValue());</span>
<span class="fc" id="L462">        return map.entrySet().iterator().next();</span>
    }

    /**
     * Gets the compatability version, needed for package access.
     */
    @Override
    public String getCompatibilityVersion() {
<span class="nc" id="L470">        return super.getCompatibilityVersion();</span>
    }

    //-----------------------------------------------------------------------
    /**
     * Test to ensure the test setup is working properly.  This method checks
     * to ensure that the getSampleKeys and getSampleValues methods are
     * returning results that look appropriate.  That is, they both return a
     * non-null array of equal length.  The keys array must not have any
     * duplicate values, and may only contain a (single) null key if
     * isNullKeySupported() returns true.  The values array must only have a null
     * value if useNullValue() is true and may only have duplicate values if
     * isAllowDuplicateValues() returns true.
     */
    public void testSampleMappings() {
<span class="fc" id="L485">        final Object[] keys = getSampleKeys();</span>
<span class="fc" id="L486">        final Object[] values = getSampleValues();</span>
<span class="fc" id="L487">        final Object[] newValues = getNewSampleValues();</span>

<span class="fc" id="L489">        assertNotNull(&quot;failure in test: Must have keys returned from &quot; +</span>
                 &quot;getSampleKeys.&quot;, keys);

<span class="fc" id="L492">        assertNotNull(&quot;failure in test: Must have values returned from &quot; +</span>
                 &quot;getSampleValues.&quot;, values);

        // verify keys and values have equivalent lengths (in case getSampleX are
        // overridden)
<span class="fc" id="L497">        assertEquals(&quot;failure in test: not the same number of sample &quot; +</span>
                   &quot;keys and values.&quot;,  keys.length, values.length);

<span class="fc" id="L500">        assertEquals(&quot;failure in test: not the same number of values and new values.&quot;,</span>
                   values.length, newValues.length);

        // verify there aren't duplicate keys, and check values
<span class="fc bfc" id="L504" title="All 2 branches covered.">        for (int i = 0; i &lt; keys.length - 1; i++) {</span>
<span class="fc bfc" id="L505" title="All 2 branches covered.">            for (int j = i + 1; j &lt; keys.length; j++) {</span>
<span class="pc bpc" id="L506" title="1 of 4 branches missed.">                assertTrue(&quot;failure in test: duplicate null keys.&quot;,</span>
                        keys[i] != null || keys[j] != null);
<span class="fc bfc" id="L508" title="All 4 branches covered.">                assertTrue(</span>
                        &quot;failure in test: duplicate non-null key.&quot;,
<span class="pc bpc" id="L510" title="1 of 2 branches missed.">                        keys[i] == null || keys[j] == null || !keys[i].equals(keys[j]) &amp;&amp; !keys[j]</span>
<span class="pc bpc" id="L511" title="1 of 2 branches missed.">                                .equals(keys[i]));</span>
            }
<span class="fc bfc" id="L513" title="All 2 branches covered.">            assertTrue(&quot;failure in test: found null key, but isNullKeySupported &quot; + &quot;is false.&quot;,</span>
<span class="pc bpc" id="L514" title="1 of 2 branches missed.">                    keys[i] != null || isAllowNullKey());</span>
<span class="fc bfc" id="L515" title="All 2 branches covered.">            assertTrue(</span>
                    &quot;failure in test: found null value, but isNullValueSupported &quot; + &quot;is false.&quot;,
<span class="pc bpc" id="L517" title="1 of 2 branches missed.">                    values[i] != null || isAllowNullValue());</span>
<span class="fc bfc" id="L518" title="All 2 branches covered.">            assertTrue(&quot;failure in test: found null new value, but isNullValueSupported &quot;</span>
<span class="pc bpc" id="L519" title="1 of 2 branches missed.">                    + &quot;is false.&quot;, newValues[i] != null || isAllowNullValue());</span>
<span class="pc bpc" id="L520" title="1 of 4 branches missed.">            assertTrue(&quot;failure in test: values should not be the same as new value&quot;,</span>
                    values[i] != newValues[i]
<span class="pc bpc" id="L522" title="1 of 2 branches missed.">                            &amp;&amp; (values[i] == null || !values[i].equals(newValues[i])));</span>
        }
<span class="fc" id="L524">    }</span>

    // tests begin here.  Each test adds a little bit of tested functionality.
    // Many methods assume previous methods passed.  That is, they do not
    // exhaustively recheck things that have already been checked in a previous
    // test methods.

    /**
     * Test to ensure that makeEmptyMap and makeFull returns a new non-null
     * map with each invocation.
     */
    public void testMakeMap() {
<span class="fc" id="L536">        final Map&lt;K, V&gt; em = makeObject();</span>
<span class="pc bpc" id="L537" title="1 of 2 branches missed.">        assertTrue(&quot;failure in test: makeEmptyMap must return a non-null map.&quot;,</span>
                   em != null);

<span class="fc" id="L540">        final Map&lt;K, V&gt; em2 = makeObject();</span>
<span class="pc bpc" id="L541" title="1 of 2 branches missed.">        assertTrue(&quot;failure in test: makeEmptyMap must return a non-null map.&quot;,</span>
                   em != null);

<span class="pc bpc" id="L544" title="1 of 2 branches missed.">        assertTrue(&quot;failure in test: makeEmptyMap must return a new map &quot; +</span>
                   &quot;with each invocation.&quot;, em != em2);

<span class="fc" id="L547">        final Map&lt;K, V&gt; fm = makeFullMap();</span>
<span class="pc bpc" id="L548" title="1 of 2 branches missed.">        assertTrue(&quot;failure in test: makeFullMap must return a non-null map.&quot;,</span>
                   fm != null);

<span class="fc" id="L551">        final Map&lt;K, V&gt; fm2 = makeFullMap();</span>
<span class="pc bpc" id="L552" title="1 of 2 branches missed.">        assertTrue(&quot;failure in test: makeFullMap must return a non-null map.&quot;,</span>
                   fm != null);

<span class="pc bpc" id="L555" title="1 of 2 branches missed.">        assertTrue(&quot;failure in test: makeFullMap must return a new map &quot; +</span>
                   &quot;with each invocation.&quot;, fm != fm2);
<span class="fc" id="L557">    }</span>

    /**
     * Tests Map.isEmpty()
     */
    public void testMapIsEmpty() {
<span class="fc" id="L563">        resetEmpty();</span>
<span class="fc" id="L564">        assertEquals(&quot;Map.isEmpty() should return true with an empty map&quot;,</span>
<span class="fc" id="L565">                     true, getMap().isEmpty());</span>
<span class="fc" id="L566">        verify();</span>

<span class="fc" id="L568">        resetFull();</span>
<span class="fc" id="L569">        assertEquals(&quot;Map.isEmpty() should return false with a non-empty map&quot;,</span>
<span class="fc" id="L570">                     false, getMap().isEmpty());</span>
<span class="fc" id="L571">        verify();</span>
<span class="fc" id="L572">    }</span>

    /**
     * Tests Map.size()
     */
    public void testMapSize() {
<span class="fc" id="L578">        resetEmpty();</span>
<span class="fc" id="L579">        assertEquals(&quot;Map.size() should be 0 with an empty map&quot;,</span>
<span class="fc" id="L580">                     0, getMap().size());</span>
<span class="fc" id="L581">        verify();</span>

<span class="fc" id="L583">        resetFull();</span>
<span class="fc" id="L584">        assertEquals(&quot;Map.size() should equal the number of entries &quot; +</span>
<span class="fc" id="L585">                     &quot;in the map&quot;, getSampleKeys().length, getMap().size());</span>
<span class="fc" id="L586">        verify();</span>
<span class="fc" id="L587">    }</span>

    /**
     * Tests {@link Map#clear()}.  If the map {@link #isRemoveSupported()}
     * can add and remove elements}, then {@link Map#size()} and
     * {@link Map#isEmpty()} are used to ensure that map has no elements after
     * a call to clear.  If the map does not support adding and removing
     * elements, this method checks to ensure clear throws an
     * UnsupportedOperationException.
     */
    public void testMapClear() {
<span class="fc bfc" id="L598" title="All 2 branches covered.">        if (!isRemoveSupported()) {</span>
            try {
<span class="fc" id="L600">                resetFull();</span>
<span class="nc" id="L601">                getMap().clear();</span>
<span class="nc" id="L602">                fail(&quot;Expected UnsupportedOperationException on clear&quot;);</span>
<span class="pc" id="L603">            } catch (final UnsupportedOperationException ex) {}</span>
<span class="fc" id="L604">            return;</span>
        }

<span class="fc" id="L607">        resetEmpty();</span>
<span class="fc" id="L608">        getMap().clear();</span>
<span class="fc" id="L609">        getConfirmed().clear();</span>
<span class="fc" id="L610">        verify();</span>

<span class="fc" id="L612">        resetFull();</span>
<span class="fc" id="L613">        getMap().clear();</span>
<span class="fc" id="L614">        getConfirmed().clear();</span>
<span class="fc" id="L615">        verify();</span>
<span class="fc" id="L616">    }</span>

    /**
     * Tests Map.containsKey(Object) by verifying it returns false for all
     * sample keys on a map created using an empty map and returns true for
     * all sample keys returned on a full map.
     */
    public void testMapContainsKey() {
<span class="fc" id="L624">        final Object[] keys = getSampleKeys();</span>

<span class="fc" id="L626">        resetEmpty();</span>
<span class="fc bfc" id="L627" title="All 2 branches covered.">        for (final Object key : keys) {</span>
<span class="fc" id="L628">            assertTrue(&quot;Map must not contain key when map is empty&quot;,</span>
<span class="pc bpc" id="L629" title="1 of 2 branches missed.">                    !getMap().containsKey(key));</span>
        }
<span class="fc" id="L631">        verify();</span>

<span class="fc" id="L633">        resetFull();</span>
<span class="fc bfc" id="L634" title="All 2 branches covered.">        for (final Object key : keys) {</span>
<span class="fc" id="L635">            assertTrue(&quot;Map must contain key for a mapping in the map. &quot; +</span>
<span class="fc" id="L636">                       &quot;Missing: &quot; + key, getMap().containsKey(key));</span>
        }
<span class="fc" id="L638">        verify();</span>
<span class="fc" id="L639">    }</span>

    /**
     * Tests Map.containsValue(Object) by verifying it returns false for all
     * sample values on an empty map and returns true for all sample values on
     * a full map.
     */
    public void testMapContainsValue() {
<span class="fc" id="L647">        final Object[] values = getSampleValues();</span>

<span class="fc" id="L649">        resetEmpty();</span>
<span class="fc bfc" id="L650" title="All 2 branches covered.">        for (final Object value : values) {</span>
<span class="fc" id="L651">            assertTrue(&quot;Empty map must not contain value&quot;,</span>
<span class="pc bpc" id="L652" title="1 of 2 branches missed.">                       !getMap().containsValue(value));</span>
        }
<span class="fc" id="L654">        verify();</span>

<span class="fc" id="L656">        resetFull();</span>
<span class="fc bfc" id="L657" title="All 2 branches covered.">        for (final Object value : values) {</span>
<span class="fc" id="L658">            assertTrue(&quot;Map must contain value for a mapping in the map.&quot;,</span>
<span class="fc" id="L659">                    getMap().containsValue(value));</span>
        }
<span class="fc" id="L661">        verify();</span>
<span class="fc" id="L662">    }</span>


    /**
     * Tests Map.equals(Object)
     */
    public void testMapEquals() {
<span class="fc" id="L669">        resetEmpty();</span>
<span class="fc" id="L670">        assertTrue(&quot;Empty maps unequal.&quot;, getMap().equals(confirmed));</span>
<span class="fc" id="L671">        verify();</span>

<span class="fc" id="L673">        resetFull();</span>
<span class="fc" id="L674">        assertTrue(&quot;Full maps unequal.&quot;, getMap().equals(confirmed));</span>
<span class="fc" id="L675">        verify();</span>

<span class="fc" id="L677">        resetFull();</span>
        // modify the HashMap created from the full map and make sure this
        // change results in map.equals() to return false.
<span class="fc" id="L680">        final Iterator&lt;K&gt; iter = confirmed.keySet().iterator();</span>
<span class="fc" id="L681">        iter.next();</span>
<span class="fc" id="L682">        iter.remove();</span>
<span class="pc bpc" id="L683" title="1 of 2 branches missed.">        assertTrue(&quot;Different maps equal.&quot;, !getMap().equals(confirmed));</span>

<span class="fc" id="L685">        resetFull();</span>
<span class="pc bpc" id="L686" title="1 of 2 branches missed.">        assertTrue(&quot;equals(null) returned true.&quot;, !getMap().equals(null));</span>
<span class="fc" id="L687">        assertTrue(&quot;equals(new Object()) returned true.&quot;,</span>
<span class="pc bpc" id="L688" title="1 of 2 branches missed.">                   !getMap().equals(new Object()));</span>
<span class="fc" id="L689">        verify();</span>
<span class="fc" id="L690">    }</span>

    /**
     * Tests Map.get(Object)
     */
    public void testMapGet() {
<span class="fc" id="L696">        resetEmpty();</span>

<span class="fc" id="L698">        final Object[] keys = getSampleKeys();</span>
<span class="fc" id="L699">        final Object[] values = getSampleValues();</span>

<span class="fc bfc" id="L701" title="All 2 branches covered.">        for (final Object key : keys) {</span>
<span class="fc" id="L702">            assertTrue(&quot;Empty map.get() should return null.&quot;,</span>
<span class="pc bpc" id="L703" title="1 of 2 branches missed.">                    getMap().get(key) == null);</span>
        }
<span class="fc" id="L705">        verify();</span>

<span class="fc" id="L707">        resetFull();</span>
<span class="fc bfc" id="L708" title="All 2 branches covered.">        for (int i = 0; i &lt; keys.length; i++) {</span>
<span class="fc" id="L709">            assertEquals(&quot;Full map.get() should return value from mapping.&quot;,</span>
<span class="fc" id="L710">                         values[i], getMap().get(keys[i]));</span>
        }
<span class="fc" id="L712">    }</span>

    /**
     * Tests Map.hashCode()
     */
    public void testMapHashCode() {
<span class="fc" id="L718">        resetEmpty();</span>
<span class="fc" id="L719">        assertTrue(&quot;Empty maps have different hashCodes.&quot;,</span>
<span class="pc bpc" id="L720" title="1 of 2 branches missed.">                getMap().hashCode() == confirmed.hashCode());</span>

<span class="fc" id="L722">        resetFull();</span>
<span class="fc" id="L723">        assertTrue(&quot;Equal maps have different hashCodes.&quot;,</span>
<span class="pc bpc" id="L724" title="1 of 2 branches missed.">                getMap().hashCode() == confirmed.hashCode());</span>
<span class="fc" id="L725">    }</span>

    /**
     * Tests Map.toString().  Since the format of the string returned by the
     * toString() method is not defined in the Map interface, there is no
     * common way to test the results of the toString() method.  Therefore,
     * it is encouraged that Map implementations override this test with one
     * that checks the format matches any format defined in its API.  This
     * default implementation just verifies that the toString() method does
     * not return null.
     */
    public void testMapToString() {
<span class="fc" id="L737">        resetEmpty();</span>
<span class="fc" id="L738">        assertTrue(&quot;Empty map toString() should not return null&quot;,</span>
<span class="pc bpc" id="L739" title="1 of 2 branches missed.">                getMap().toString() != null);</span>
<span class="fc" id="L740">        verify();</span>

<span class="fc" id="L742">        resetFull();</span>
<span class="fc" id="L743">        assertTrue(&quot;Empty map toString() should not return null&quot;,</span>
<span class="pc bpc" id="L744" title="1 of 2 branches missed.">                getMap().toString() != null);</span>
<span class="fc" id="L745">        verify();</span>
<span class="fc" id="L746">    }</span>

    /**
     * Compare the current serialized form of the Map
     * against the canonical version in SVN.
     */
    public void testEmptyMapCompatibility() throws Exception {
        /**
         * Create canonical objects with this code
        Map map = makeEmptyMap();
        if (!(map instanceof Serializable)) return;

        writeExternalFormToDisk((Serializable) map, getCanonicalEmptyCollectionName(map));
        */

        // test to make sure the canonical form has been preserved
<span class="fc" id="L762">        final Map&lt;K, V&gt; map = makeObject();</span>
<span class="pc bpc" id="L763" title="1 of 6 branches missed.">        if (map instanceof Serializable &amp;&amp; !skipSerializedCanonicalTests() &amp;&amp; isTestSerialization()) {</span>
            @SuppressWarnings(&quot;unchecked&quot;)
<span class="fc" id="L765">            final Map&lt;K, V&gt; map2 = (Map&lt;K, V&gt;) readExternalFormFromDisk(getCanonicalEmptyCollectionName(map));</span>
<span class="fc" id="L766">            assertEquals(&quot;Map is empty&quot;, 0, map2.size());</span>
        }
<span class="fc" id="L768">    }</span>

    /**
     * Compare the current serialized form of the Map
     * against the canonical version in SVN.
     */
    public void testFullMapCompatibility() throws Exception {
        /**
         * Create canonical objects with this code
        Map map = makeFullMap();
        if (!(map instanceof Serializable)) return;

        writeExternalFormToDisk((Serializable) map, getCanonicalFullCollectionName(map));
        */

        // test to make sure the canonical form has been preserved
<span class="fc" id="L784">        final Map&lt;K, V&gt; map = makeFullMap();</span>
<span class="pc bpc" id="L785" title="1 of 6 branches missed.">        if (map instanceof Serializable &amp;&amp; !skipSerializedCanonicalTests() &amp;&amp; isTestSerialization()) {</span>
            @SuppressWarnings(&quot;unchecked&quot;)
<span class="fc" id="L787">            final Map&lt;K, V&gt; map2 = (Map&lt;K, V&gt;) readExternalFormFromDisk(getCanonicalFullCollectionName(map));</span>
<span class="fc" id="L788">            assertEquals(&quot;Map is the right size&quot;, getSampleKeys().length, map2.size());</span>
        }
<span class="fc" id="L790">    }</span>

    /**
     * Tests Map.put(Object, Object)
     */
    public void testMapPut() {
<span class="fc" id="L796">        resetEmpty();</span>
<span class="fc" id="L797">        final K[] keys = getSampleKeys();</span>
<span class="fc" id="L798">        final V[] values = getSampleValues();</span>
<span class="fc" id="L799">        final V[] newValues = getNewSampleValues();</span>

<span class="fc bfc" id="L801" title="All 2 branches covered.">        if (isPutAddSupported()) {</span>
<span class="fc bfc" id="L802" title="All 2 branches covered.">            for (int i = 0; i &lt; keys.length; i++) {</span>
<span class="fc" id="L803">                final Object o = getMap().put(keys[i], values[i]);</span>
<span class="fc" id="L804">                getConfirmed().put(keys[i], values[i]);</span>
<span class="fc" id="L805">                verify();</span>
<span class="pc bpc" id="L806" title="1 of 2 branches missed.">                assertTrue(&quot;First map.put should return null&quot;, o == null);</span>
<span class="fc" id="L807">                assertTrue(&quot;Map should contain key after put&quot;,</span>
<span class="fc" id="L808">                        getMap().containsKey(keys[i]));</span>
<span class="fc" id="L809">                assertTrue(&quot;Map should contain value after put&quot;,</span>
<span class="fc" id="L810">                        getMap().containsValue(values[i]));</span>
            }
<span class="pc bpc" id="L812" title="1 of 2 branches missed.">            if (isPutChangeSupported()) {</span>
<span class="fc bfc" id="L813" title="All 2 branches covered.">                for (int i = 0; i &lt; keys.length; i++) {</span>
<span class="fc" id="L814">                    final Object o = getMap().put(keys[i], newValues[i]);</span>
<span class="fc" id="L815">                    getConfirmed().put(keys[i], newValues[i]);</span>
<span class="fc" id="L816">                    verify();</span>
<span class="fc" id="L817">                    assertEquals(&quot;Map.put should return previous value when changed&quot;, values[i], o);</span>
<span class="fc" id="L818">                    assertTrue(&quot;Map should still contain key after put when changed&quot;,</span>
<span class="fc" id="L819">                            getMap().containsKey(keys[i]));</span>
<span class="fc" id="L820">                    assertTrue(&quot;Map should contain new value after put when changed&quot;,</span>
<span class="fc" id="L821">                            getMap().containsValue(newValues[i]));</span>

                    // if duplicates are allowed, we're not guaranteed that the value
                    // no longer exists, so don't try checking that.
<span class="fc bfc" id="L825" title="All 2 branches covered.">                    if (!isAllowDuplicateValues()) {</span>
<span class="fc" id="L826">                        assertTrue(&quot;Map should not contain old value after put when changed&quot;,</span>
<span class="pc bpc" id="L827" title="1 of 2 branches missed.">                                !getMap().containsValue(values[i]));</span>
                    }
                }
            } else {
                try {
                    // two possible exception here, either valid
<span class="nc" id="L833">                    getMap().put(keys[0], newValues[0]);</span>
<span class="nc" id="L834">                    fail(&quot;Expected IllegalArgumentException or UnsupportedOperationException on put (change)&quot;);</span>
<span class="nc" id="L835">                } catch (final IllegalArgumentException ex) {</span>
<span class="nc" id="L836">                } catch (final UnsupportedOperationException ex) {}</span>
            }

<span class="fc bfc" id="L839" title="All 2 branches covered.">        } else if (isPutChangeSupported()) {</span>
<span class="fc" id="L840">            resetEmpty();</span>
            try {
<span class="nc" id="L842">                getMap().put(keys[0], values[0]);</span>
<span class="nc" id="L843">                fail(&quot;Expected UnsupportedOperationException or IllegalArgumentException on put (add) when fixed size&quot;);</span>
<span class="fc" id="L844">            } catch (final IllegalArgumentException ex) {</span>
<span class="fc" id="L845">            } catch (final UnsupportedOperationException ex) {</span>
<span class="pc" id="L846">            }</span>

<span class="fc" id="L848">            resetFull();</span>
<span class="fc" id="L849">            int i = 0;</span>
<span class="pc bpc" id="L850" title="1 of 4 branches missed.">            for (final Iterator&lt;K&gt; it = getMap().keySet().iterator(); it.hasNext() &amp;&amp; i &lt; newValues.length; i++) {</span>
<span class="fc" id="L851">                final K  key = it.next();</span>
<span class="fc" id="L852">                final V o = getMap().put(key, newValues[i]);</span>
<span class="fc" id="L853">                final V value = getConfirmed().put(key, newValues[i]);</span>
<span class="fc" id="L854">                verify();</span>
<span class="fc" id="L855">                assertEquals(&quot;Map.put should return previous value when changed&quot;, value, o);</span>
<span class="fc" id="L856">                assertTrue(&quot;Map should still contain key after put when changed&quot;, getMap()</span>
<span class="fc" id="L857">                        .containsKey(key));</span>
<span class="fc" id="L858">                assertTrue(&quot;Map should contain new value after put when changed&quot;, getMap()</span>
<span class="fc" id="L859">                        .containsValue(newValues[i]));</span>

                // if duplicates are allowed, we're not guaranteed that the value
                // no longer exists, so don't try checking that.
<span class="pc bpc" id="L863" title="1 of 2 branches missed.">                if (!isAllowDuplicateValues()) {</span>
<span class="nc" id="L864">                    assertTrue(&quot;Map should not contain old value after put when changed&quot;,</span>
<span class="nc bnc" id="L865" title="All 2 branches missed.">                        !getMap().containsValue(values[i]));</span>
                }
            }
<span class="fc" id="L868">        } else {</span>
            try {
<span class="nc" id="L870">                getMap().put(keys[0], values[0]);</span>
<span class="nc" id="L871">                fail(&quot;Expected UnsupportedOperationException on put (add)&quot;);</span>
<span class="pc" id="L872">            } catch (final UnsupportedOperationException ex) {}</span>
        }
<span class="fc" id="L874">    }</span>

    /**
     * Tests Map.put(null, value)
     */
    public void testMapPutNullKey() {
<span class="fc" id="L880">        resetFull();</span>
<span class="fc" id="L881">        final V[] values = getSampleValues();</span>

<span class="fc bfc" id="L883" title="All 2 branches covered.">        if (isPutAddSupported()) {</span>
<span class="fc bfc" id="L884" title="All 2 branches covered.">            if (isAllowNullKey()) {</span>
<span class="fc" id="L885">                getMap().put(null, values[0]);</span>
            } else {
                try {
<span class="nc" id="L888">                    getMap().put(null, values[0]);</span>
<span class="nc" id="L889">                    fail(&quot;put(null, value) should throw NPE/IAE&quot;);</span>
<span class="fc" id="L890">                } catch (final NullPointerException ex) {</span>
<span class="pc" id="L891">                } catch (final IllegalArgumentException ex) {}</span>
            }
        }
<span class="fc" id="L894">    }</span>

    /**
     * Tests Map.put(null, value)
     */
    public void testMapPutNullValue() {
<span class="fc" id="L900">        resetFull();</span>
<span class="fc" id="L901">        final K[] keys = getSampleKeys();</span>

<span class="fc bfc" id="L903" title="All 2 branches covered.">        if (isPutAddSupported()) {</span>
<span class="fc bfc" id="L904" title="All 2 branches covered.">            if (isAllowNullValue()) {</span>
<span class="fc" id="L905">                getMap().put(keys[0], null);</span>
            } else {
                try {
<span class="nc" id="L908">                    getMap().put(keys[0], null);</span>
<span class="nc" id="L909">                    fail(&quot;put(key, null) should throw NPE/IAE&quot;);</span>
<span class="fc" id="L910">                } catch (final NullPointerException ex) {</span>
<span class="pc" id="L911">                } catch (final IllegalArgumentException ex) {}</span>
            }
        }
<span class="fc" id="L914">    }</span>

    /**
     * Tests Map.putAll(map)
     */
    public void testMapPutAll() {
<span class="fc bfc" id="L920" title="All 2 branches covered.">        if (!isPutAddSupported()) {</span>
<span class="fc bfc" id="L921" title="All 2 branches covered.">            if (!isPutChangeSupported()) {</span>
<span class="fc" id="L922">                final Map&lt;K, V&gt; temp = makeFullMap();</span>
<span class="fc" id="L923">                resetEmpty();</span>
                try {
<span class="nc" id="L925">                    getMap().putAll(temp);</span>
<span class="nc" id="L926">                    fail(&quot;Expected UnsupportedOperationException on putAll&quot;);</span>
<span class="pc" id="L927">                } catch (final UnsupportedOperationException ex) {}</span>
            }
<span class="fc" id="L929">            return;</span>
        }

        // check putAll OK adding empty map to empty map
<span class="fc" id="L933">        resetEmpty();</span>
<span class="fc" id="L934">        assertEquals(0, getMap().size());</span>
<span class="fc" id="L935">        getMap().putAll(new HashMap&lt;K, V&gt;());</span>
<span class="fc" id="L936">        assertEquals(0, getMap().size());</span>

        // check putAll OK adding empty map to non-empty map
<span class="fc" id="L939">        resetFull();</span>
<span class="fc" id="L940">        final int size = getMap().size();</span>
<span class="fc" id="L941">        getMap().putAll(new HashMap&lt;K, V&gt;());</span>
<span class="fc" id="L942">        assertEquals(size, getMap().size());</span>

        // check putAll OK adding non-empty map to empty map
<span class="fc" id="L945">        resetEmpty();</span>
<span class="fc" id="L946">        Map&lt;K, V&gt; m2 = makeFullMap();</span>
<span class="fc" id="L947">        getMap().putAll(m2);</span>
<span class="fc" id="L948">        getConfirmed().putAll(m2);</span>
<span class="fc" id="L949">        verify();</span>

        // check putAll OK adding non-empty JDK map to empty map
<span class="fc" id="L952">        resetEmpty();</span>
<span class="fc" id="L953">        m2 = makeConfirmedMap();</span>
<span class="fc" id="L954">        final K[] keys = getSampleKeys();</span>
<span class="fc" id="L955">        final V[] values = getSampleValues();</span>
<span class="fc bfc" id="L956" title="All 2 branches covered.">        for(int i = 0; i &lt; keys.length; i++) {</span>
<span class="fc" id="L957">            m2.put(keys[i], values[i]);</span>
        }
<span class="fc" id="L959">        getMap().putAll(m2);</span>
<span class="fc" id="L960">        getConfirmed().putAll(m2);</span>
<span class="fc" id="L961">        verify();</span>

        // check putAll OK adding non-empty JDK map to non-empty map
<span class="fc" id="L964">        resetEmpty();</span>
<span class="fc" id="L965">        m2 = makeConfirmedMap();</span>
<span class="fc" id="L966">        getMap().put(keys[0], values[0]);</span>
<span class="fc" id="L967">        getConfirmed().put(keys[0], values[0]);</span>
<span class="fc" id="L968">        verify();</span>
<span class="fc bfc" id="L969" title="All 2 branches covered.">        for(int i = 1; i &lt; keys.length; i++) {</span>
<span class="fc" id="L970">            m2.put(keys[i], values[i]);</span>
        }
<span class="fc" id="L972">        getMap().putAll(m2);</span>
<span class="fc" id="L973">        getConfirmed().putAll(m2);</span>
<span class="fc" id="L974">        verify();</span>
<span class="fc" id="L975">    }</span>

    /**
     * Tests Map.remove(Object)
     */
    public void testMapRemove() {
<span class="fc bfc" id="L981" title="All 2 branches covered.">        if (!isRemoveSupported()) {</span>
            try {
<span class="fc" id="L983">                resetFull();</span>
<span class="nc" id="L984">                getMap().remove(getMap().keySet().iterator().next());</span>
<span class="nc" id="L985">                fail(&quot;Expected UnsupportedOperationException on remove&quot;);</span>
<span class="pc" id="L986">            } catch (final UnsupportedOperationException ex) {}</span>
<span class="fc" id="L987">            return;</span>
        }

<span class="fc" id="L990">        resetEmpty();</span>

<span class="fc" id="L992">        final Object[] keys = getSampleKeys();</span>
<span class="fc" id="L993">        final Object[] values = getSampleValues();</span>
<span class="fc bfc" id="L994" title="All 2 branches covered.">        for (final Object key : keys) {</span>
<span class="fc" id="L995">            final Object o = getMap().remove(key);</span>
<span class="pc bpc" id="L996" title="1 of 2 branches missed.">            assertTrue(&quot;First map.remove should return null&quot;, o == null);</span>
        }
<span class="fc" id="L998">        verify();</span>

<span class="fc" id="L1000">        resetFull();</span>

<span class="fc bfc" id="L1002" title="All 2 branches covered.">        for (int i = 0; i &lt; keys.length; i++) {</span>
<span class="fc" id="L1003">            final Object o = getMap().remove(keys[i]);</span>
<span class="fc" id="L1004">            getConfirmed().remove(keys[i]);</span>
<span class="fc" id="L1005">            verify();</span>

<span class="fc" id="L1007">            assertEquals(&quot;map.remove with valid key should return value&quot;,</span>
                         values[i], o);
        }

<span class="fc" id="L1011">        final Object[] other = getOtherKeys();</span>

<span class="fc" id="L1013">        resetFull();</span>
<span class="fc" id="L1014">        final int size = getMap().size();</span>
<span class="fc bfc" id="L1015" title="All 2 branches covered.">        for (final Object element : other) {</span>
<span class="fc" id="L1016">            final Object o = getMap().remove(element);</span>
<span class="fc" id="L1017">            assertNull(&quot;map.remove for nonexistent key should return null&quot;, o);</span>
<span class="fc" id="L1018">            assertEquals(&quot;map.remove for nonexistent key should not &quot; +</span>
<span class="fc" id="L1019">                         &quot;shrink map&quot;, size, getMap().size());</span>
        }
<span class="fc" id="L1021">        verify();</span>
<span class="fc" id="L1022">    }</span>

    //-----------------------------------------------------------------------
    /**
     * Tests that the {@link Map#values} collection is backed by
     * the underlying map for clear().
     */
    public void testValuesClearChangesMap() {
<span class="fc bfc" id="L1030" title="All 2 branches covered.">        if (!isRemoveSupported()) {</span>
<span class="fc" id="L1031">            return;</span>
        }

        // clear values, reflected in map
<span class="fc" id="L1035">        resetFull();</span>
<span class="fc" id="L1036">        Collection&lt;V&gt; values = getMap().values();</span>
<span class="pc bpc" id="L1037" title="1 of 2 branches missed.">        assertTrue(getMap().size() &gt; 0);</span>
<span class="pc bpc" id="L1038" title="1 of 2 branches missed.">        assertTrue(values.size() &gt; 0);</span>
<span class="fc" id="L1039">        values.clear();</span>
<span class="pc bpc" id="L1040" title="1 of 2 branches missed.">        assertTrue(getMap().size() == 0);</span>
<span class="pc bpc" id="L1041" title="1 of 2 branches missed.">        assertTrue(values.size() == 0);</span>

        // clear map, reflected in values
<span class="fc" id="L1044">        resetFull();</span>
<span class="fc" id="L1045">        values = getMap().values();</span>
<span class="pc bpc" id="L1046" title="1 of 2 branches missed.">        assertTrue(getMap().size() &gt; 0);</span>
<span class="pc bpc" id="L1047" title="1 of 2 branches missed.">        assertTrue(values.size() &gt; 0);</span>
<span class="fc" id="L1048">        getMap().clear();</span>
<span class="pc bpc" id="L1049" title="1 of 2 branches missed.">        assertTrue(getMap().size() == 0);</span>
<span class="pc bpc" id="L1050" title="1 of 2 branches missed.">        assertTrue(values.size() == 0);</span>
<span class="fc" id="L1051">    }</span>

    /**
     * Tests that the {@link Map#keySet} collection is backed by
     * the underlying map for clear().
     */
    public void testKeySetClearChangesMap() {
<span class="fc bfc" id="L1058" title="All 2 branches covered.">        if (!isRemoveSupported()) {</span>
<span class="fc" id="L1059">            return;</span>
        }

        // clear values, reflected in map
<span class="fc" id="L1063">        resetFull();</span>
<span class="fc" id="L1064">        Set&lt;K&gt; keySet = getMap().keySet();</span>
<span class="pc bpc" id="L1065" title="1 of 2 branches missed.">        assertTrue(getMap().size() &gt; 0);</span>
<span class="pc bpc" id="L1066" title="1 of 2 branches missed.">        assertTrue(keySet.size() &gt; 0);</span>
<span class="fc" id="L1067">        keySet.clear();</span>
<span class="pc bpc" id="L1068" title="1 of 2 branches missed.">        assertTrue(getMap().size() == 0);</span>
<span class="pc bpc" id="L1069" title="1 of 2 branches missed.">        assertTrue(keySet.size() == 0);</span>

        // clear map, reflected in values
<span class="fc" id="L1072">        resetFull();</span>
<span class="fc" id="L1073">        keySet = getMap().keySet();</span>
<span class="pc bpc" id="L1074" title="1 of 2 branches missed.">        assertTrue(getMap().size() &gt; 0);</span>
<span class="pc bpc" id="L1075" title="1 of 2 branches missed.">        assertTrue(keySet.size() &gt; 0);</span>
<span class="fc" id="L1076">        getMap().clear();</span>
<span class="pc bpc" id="L1077" title="1 of 2 branches missed.">        assertTrue(getMap().size() == 0);</span>
<span class="pc bpc" id="L1078" title="1 of 2 branches missed.">        assertTrue(keySet.size() == 0);</span>
<span class="fc" id="L1079">    }</span>

    /**
     * Tests that the {@link Map#entrySet()} collection is backed by
     * the underlying map for clear().
     */
    public void testEntrySetClearChangesMap() {
<span class="fc bfc" id="L1086" title="All 2 branches covered.">        if (!isRemoveSupported()) {</span>
<span class="fc" id="L1087">            return;</span>
        }

        // clear values, reflected in map
<span class="fc" id="L1091">        resetFull();</span>
<span class="fc" id="L1092">        Set&lt;Map.Entry&lt;K, V&gt;&gt; entrySet = getMap().entrySet();</span>
<span class="pc bpc" id="L1093" title="1 of 2 branches missed.">        assertTrue(getMap().size() &gt; 0);</span>
<span class="pc bpc" id="L1094" title="1 of 2 branches missed.">        assertTrue(entrySet.size() &gt; 0);</span>
<span class="fc" id="L1095">        entrySet.clear();</span>
<span class="pc bpc" id="L1096" title="1 of 2 branches missed.">        assertTrue(getMap().size() == 0);</span>
<span class="pc bpc" id="L1097" title="1 of 2 branches missed.">        assertTrue(entrySet.size() == 0);</span>

        // clear map, reflected in values
<span class="fc" id="L1100">        resetFull();</span>
<span class="fc" id="L1101">        entrySet = getMap().entrySet();</span>
<span class="pc bpc" id="L1102" title="1 of 2 branches missed.">        assertTrue(getMap().size() &gt; 0);</span>
<span class="pc bpc" id="L1103" title="1 of 2 branches missed.">        assertTrue(entrySet.size() &gt; 0);</span>
<span class="fc" id="L1104">        getMap().clear();</span>
<span class="pc bpc" id="L1105" title="1 of 2 branches missed.">        assertTrue(getMap().size() == 0);</span>
<span class="pc bpc" id="L1106" title="1 of 2 branches missed.">        assertTrue(entrySet.size() == 0);</span>
<span class="fc" id="L1107">    }</span>

    //-----------------------------------------------------------------------
    public void testEntrySetContains1() {
<span class="fc" id="L1111">        resetFull();</span>
<span class="fc" id="L1112">        final Set&lt;Map.Entry&lt;K, V&gt;&gt; entrySet = getMap().entrySet();</span>
<span class="fc" id="L1113">        final Map.Entry&lt;K, V&gt; entry = entrySet.iterator().next();</span>
<span class="fc" id="L1114">        assertEquals(true, entrySet.contains(entry));</span>
<span class="fc" id="L1115">    }</span>

    public void testEntrySetContains2() {
<span class="fc" id="L1118">        resetFull();</span>
<span class="fc" id="L1119">        final Set&lt;Map.Entry&lt;K, V&gt;&gt; entrySet = getMap().entrySet();</span>
<span class="fc" id="L1120">        final Map.Entry&lt;K, V&gt; entry = entrySet.iterator().next();</span>
<span class="fc" id="L1121">        final Map.Entry&lt;K, V&gt; test = cloneMapEntry(entry);</span>
<span class="fc" id="L1122">        assertEquals(true, entrySet.contains(test));</span>
<span class="fc" id="L1123">    }</span>

    @SuppressWarnings(&quot;unchecked&quot;)
    public void testEntrySetContains3() {
<span class="fc" id="L1127">        resetFull();</span>
<span class="fc" id="L1128">        final Set&lt;Map.Entry&lt;K, V&gt;&gt; entrySet = getMap().entrySet();</span>
<span class="fc" id="L1129">        final Map.Entry&lt;K, V&gt; entry = entrySet.iterator().next();</span>
<span class="fc" id="L1130">        final HashMap&lt;K, V&gt; temp = new HashMap&lt;&gt;();</span>
<span class="fc" id="L1131">        temp.put(entry.getKey(), (V) &quot;A VERY DIFFERENT VALUE&quot;);</span>
<span class="fc" id="L1132">        final Map.Entry&lt;K, V&gt; test = temp.entrySet().iterator().next();</span>
<span class="fc" id="L1133">        assertEquals(false, entrySet.contains(test));</span>
<span class="fc" id="L1134">    }</span>

    public void testEntrySetRemove1() {
<span class="fc bfc" id="L1137" title="All 2 branches covered.">        if (!isRemoveSupported()) {</span>
<span class="fc" id="L1138">            return;</span>
        }
<span class="fc" id="L1140">        resetFull();</span>
<span class="fc" id="L1141">        final int size = getMap().size();</span>
<span class="fc" id="L1142">        final Set&lt;Map.Entry&lt;K, V&gt;&gt; entrySet = getMap().entrySet();</span>
<span class="fc" id="L1143">        final Map.Entry&lt;K, V&gt; entry = entrySet.iterator().next();</span>
<span class="fc" id="L1144">        final K key = entry.getKey();</span>

<span class="fc" id="L1146">        assertEquals(true, entrySet.remove(entry));</span>
<span class="fc" id="L1147">        assertEquals(false, getMap().containsKey(key));</span>
<span class="fc" id="L1148">        assertEquals(size - 1, getMap().size());</span>
<span class="fc" id="L1149">    }</span>

    public void testEntrySetRemove2() {
<span class="fc bfc" id="L1152" title="All 2 branches covered.">        if (!isRemoveSupported()) {</span>
<span class="fc" id="L1153">            return;</span>
        }
<span class="fc" id="L1155">        resetFull();</span>
<span class="fc" id="L1156">        final int size = getMap().size();</span>
<span class="fc" id="L1157">        final Set&lt;Map.Entry&lt;K, V&gt;&gt; entrySet = getMap().entrySet();</span>
<span class="fc" id="L1158">        final Map.Entry&lt;K, V&gt; entry = entrySet.iterator().next();</span>
<span class="fc" id="L1159">        final K key = entry.getKey();</span>
<span class="fc" id="L1160">        final Map.Entry&lt;K, V&gt; test = cloneMapEntry(entry);</span>

<span class="fc" id="L1162">        assertEquals(true, entrySet.remove(test));</span>
<span class="fc" id="L1163">        assertEquals(false, getMap().containsKey(key));</span>
<span class="fc" id="L1164">        assertEquals(size - 1, getMap().size());</span>
<span class="fc" id="L1165">    }</span>

    @SuppressWarnings(&quot;unchecked&quot;)
    public void testEntrySetRemove3() {
<span class="fc bfc" id="L1169" title="All 2 branches covered.">        if (!isRemoveSupported()) {</span>
<span class="fc" id="L1170">            return;</span>
        }
<span class="fc" id="L1172">        resetFull();</span>
<span class="fc" id="L1173">        final int size = getMap().size();</span>
<span class="fc" id="L1174">        final Set&lt;Map.Entry&lt;K, V&gt;&gt; entrySet = getMap().entrySet();</span>
<span class="fc" id="L1175">        final Map.Entry&lt;K, V&gt; entry = entrySet.iterator().next();</span>
<span class="fc" id="L1176">        final K key = entry.getKey();</span>
<span class="fc" id="L1177">        final HashMap&lt;K, V&gt; temp = new HashMap&lt;&gt;();</span>
<span class="fc" id="L1178">        temp.put(entry.getKey(), (V) &quot;A VERY DIFFERENT VALUE&quot;);</span>
<span class="fc" id="L1179">        final Map.Entry&lt;K, V&gt; test = temp.entrySet().iterator().next();</span>

<span class="fc" id="L1181">        assertEquals(false, entrySet.remove(test));</span>
<span class="fc" id="L1182">        assertEquals(true, getMap().containsKey(key));</span>
<span class="fc" id="L1183">        assertEquals(size, getMap().size());</span>
<span class="fc" id="L1184">    }</span>

    //-----------------------------------------------------------------------
    /**
     * Tests that the {@link Map#values} collection is backed by
     * the underlying map by removing from the values collection
     * and testing if the value was removed from the map.
     * &lt;p&gt;
     * We should really test the &quot;vice versa&quot; case--that values removed
     * from the map are removed from the values collection--also,
     * but that's a more difficult test to construct (lacking a
     * &quot;removeValue&quot; method.)
     * &lt;/p&gt;
     * &lt;p&gt;
     * See bug &lt;a href=&quot;http://issues.apache.org/bugzilla/show_bug.cgi?id=9573&quot;&gt;
     * 9573&lt;/a&gt;.
     * &lt;/p&gt;
     */
    public void testValuesRemoveChangesMap() {
<span class="fc" id="L1203">        resetFull();</span>
<span class="fc" id="L1204">        final V[] sampleValues = getSampleValues();</span>
<span class="fc" id="L1205">        final Collection&lt;V&gt; values = getMap().values();</span>
<span class="fc bfc" id="L1206" title="All 2 branches covered.">        for (final V sampleValue : sampleValues) {</span>
<span class="fc bfc" id="L1207" title="All 2 branches covered.">            if (map.containsValue(sampleValue)) {</span>
<span class="fc" id="L1208">                int j = 0;  // loop counter prevents infinite loops when remove is broken</span>
<span class="pc bpc" id="L1209" title="1 of 4 branches missed.">                while (values.contains(sampleValue) &amp;&amp; j &lt; 10000) {</span>
                    try {
<span class="fc" id="L1211">                        values.remove(sampleValue);</span>
<span class="fc" id="L1212">                    } catch (final UnsupportedOperationException e) {</span>
                        // if values.remove is unsupported, just skip this test
<span class="fc" id="L1214">                        return;</span>
<span class="fc" id="L1215">                    }</span>
<span class="fc" id="L1216">                    j++;</span>
                }
<span class="pc bpc" id="L1218" title="1 of 2 branches missed.">                assertTrue(&quot;values().remove(obj) is broken&quot;, j &lt; 10000);</span>
<span class="fc" id="L1219">                assertTrue(</span>
                    &quot;Value should have been removed from the underlying map.&quot;,
<span class="pc bpc" id="L1221" title="1 of 2 branches missed.">                    !getMap().containsValue(sampleValue));</span>
            }
        }
<span class="fc" id="L1224">    }</span>

    /**
     * Tests values.removeAll.
     */
    public void testValuesRemoveAll() {
<span class="fc" id="L1230">        resetFull();</span>
<span class="fc" id="L1231">        final Collection&lt;V&gt; values = getMap().values();</span>
<span class="fc" id="L1232">        final List&lt;V&gt; sampleValuesAsList = Arrays.asList(getSampleValues());</span>
<span class="fc bfc" id="L1233" title="All 2 branches covered.">        if (!values.equals(sampleValuesAsList)) {</span>
<span class="fc" id="L1234">            return;</span>
        }
        try {
<span class="fc" id="L1237">            assertFalse(values.removeAll(Collections.&lt;V&gt; emptySet()));</span>
<span class="nc" id="L1238">        } catch (final UnsupportedOperationException e) {</span>
            // if values.removeAll is unsupported, just skip this test
<span class="nc" id="L1240">            return;</span>
<span class="fc" id="L1241">        }</span>
<span class="fc" id="L1242">        assertEquals(sampleValuesAsList.size(), getMap().size());</span>
        try {
<span class="fc" id="L1244">            assertTrue(values.removeAll(sampleValuesAsList));</span>
<span class="nc" id="L1245">        } catch (final UnsupportedOperationException e) {</span>
            // if values.removeAll is unsupported, just skip this test
<span class="nc" id="L1247">            return;</span>
<span class="fc" id="L1248">        }</span>
<span class="fc" id="L1249">        assertTrue(getMap().isEmpty());</span>
<span class="fc" id="L1250">    }</span>

    /**
     * Test values.retainAll.
     */
    public void testValuesRetainAll() {
<span class="fc" id="L1256">        resetFull();</span>
<span class="fc" id="L1257">        final Collection&lt;V&gt; values = getMap().values();</span>
<span class="fc" id="L1258">        final List&lt;V&gt; sampleValuesAsList = Arrays.asList(getSampleValues());</span>
<span class="fc bfc" id="L1259" title="All 2 branches covered.">        if (!values.equals(sampleValuesAsList)) {</span>
<span class="fc" id="L1260">            return;</span>
        }
        try {
<span class="fc" id="L1263">            assertFalse(values.retainAll(sampleValuesAsList));</span>
<span class="nc" id="L1264">        } catch (final UnsupportedOperationException e) {</span>
            // if values.retainAll is unsupported, just skip this test
<span class="nc" id="L1266">            return;</span>
<span class="fc" id="L1267">        }</span>
<span class="fc" id="L1268">        assertEquals(sampleValuesAsList.size(), getMap().size());</span>
        try {
<span class="fc" id="L1270">            assertTrue(values.retainAll(Collections.&lt;V&gt; emptySet()));</span>
<span class="nc" id="L1271">        } catch (final UnsupportedOperationException e) {</span>
            // if values.retainAll is unsupported, just skip this test
<span class="nc" id="L1273">            return;</span>
<span class="fc" id="L1274">        }</span>
<span class="fc" id="L1275">        assertTrue(getMap().isEmpty());</span>
<span class="fc" id="L1276">    }</span>

    /**
     * Verifies that values.iterator.remove changes the underlying map.
     */
    @SuppressWarnings(&quot;boxing&quot;) // OK in test code
    public void testValuesIteratorRemoveChangesMap() {
<span class="fc" id="L1283">        resetFull();</span>
<span class="fc" id="L1284">        final List&lt;V&gt; sampleValuesAsList = Arrays.asList(getSampleValues());</span>
<span class="fc" id="L1285">        final Map&lt;V, Integer&gt; cardinality = CollectionUtils.getCardinalityMap(sampleValuesAsList);</span>
<span class="fc" id="L1286">        final Collection&lt;V&gt; values = getMap().values();</span>
<span class="fc bfc" id="L1287" title="All 2 branches covered.">        for (final Iterator&lt;V&gt; iter = values.iterator(); iter.hasNext();) {</span>
<span class="fc" id="L1288">            final V value = iter.next();</span>
<span class="fc" id="L1289">            Integer count = cardinality.get(value);</span>
<span class="pc bpc" id="L1290" title="1 of 2 branches missed.">            if (count == null) {</span>
<span class="nc" id="L1291">                return;</span>
            }
            try {
<span class="fc" id="L1294">                iter.remove();</span>
<span class="fc" id="L1295">                cardinality.put(value, --count);</span>
<span class="fc" id="L1296">            } catch (final UnsupportedOperationException e) {</span>
                // if values.iterator.remove is unsupported, just skip this test
<span class="fc" id="L1298">                return;</span>
<span class="fc" id="L1299">            }</span>
<span class="fc bfc" id="L1300" title="All 2 branches covered.">            final boolean expected = count &gt; 0;</span>
<span class="fc" id="L1301">            final StringBuilder msg = new StringBuilder(&quot;Value should &quot;);</span>
<span class="fc bfc" id="L1302" title="All 2 branches covered.">            msg.append(expected ? &quot;yet &quot; : &quot;no longer &quot;);</span>
<span class="fc" id="L1303">            msg.append(&quot;be present in the underlying map&quot;);</span>
<span class="fc" id="L1304">            assertEquals(msg.toString(), expected, getMap().containsValue(value));</span>
<span class="fc" id="L1305">        }</span>
<span class="fc" id="L1306">        assertTrue(getMap().isEmpty());</span>
<span class="fc" id="L1307">    }</span>

    /**
     * Tests that the {@link Map#keySet} set is backed by
     * the underlying map by removing from the keySet set
     * and testing if the key was removed from the map.
     */
    public void testKeySetRemoveChangesMap() {
<span class="fc" id="L1315">        resetFull();</span>
<span class="fc" id="L1316">        final K[] sampleKeys = getSampleKeys();</span>
<span class="fc" id="L1317">        final Set&lt;K&gt; keys = getMap().keySet();</span>
<span class="fc bfc" id="L1318" title="All 2 branches covered.">        for (final K sampleKey : sampleKeys) {</span>
            try {
<span class="fc" id="L1320">                keys.remove(sampleKey);</span>
<span class="fc" id="L1321">            } catch (final UnsupportedOperationException e) {</span>
                // if key.remove is unsupported, just skip this test
<span class="fc" id="L1323">                return;</span>
<span class="fc" id="L1324">            }</span>
<span class="fc" id="L1325">            assertTrue(</span>
                &quot;Key should have been removed from the underlying map.&quot;,
<span class="pc bpc" id="L1327" title="1 of 2 branches missed.">                !getMap().containsKey(sampleKey));</span>
        }
<span class="fc" id="L1329">    }</span>

    /**
     * Test keySet.removeAll.
     */
    public void testKeySetRemoveAll() {
<span class="fc" id="L1335">        resetFull();</span>
<span class="fc" id="L1336">        final Set&lt;K&gt; keys = getMap().keySet();</span>
<span class="fc" id="L1337">        final List&lt;K&gt; sampleKeysAsList = Arrays.asList(getSampleKeys());</span>
<span class="pc bpc" id="L1338" title="1 of 2 branches missed.">        if (!keys.equals(sampleKeysAsList)) {</span>
<span class="fc" id="L1339">            return;</span>
        }
        try {
<span class="nc" id="L1342">            assertFalse(keys.removeAll(Collections.&lt;K&gt; emptySet()));</span>
<span class="nc" id="L1343">        } catch (final UnsupportedOperationException e) {</span>
<span class="nc" id="L1344">            return;</span>
<span class="nc" id="L1345">        }</span>
<span class="nc" id="L1346">        assertEquals(sampleKeysAsList, keys);</span>
        try {
<span class="nc" id="L1348">            assertTrue(keys.removeAll(sampleKeysAsList));</span>
<span class="nc" id="L1349">        } catch (final UnsupportedOperationException e) {</span>
<span class="nc" id="L1350">            return;</span>
<span class="nc" id="L1351">        }</span>
<span class="nc" id="L1352">        assertTrue(getMap().isEmpty());</span>
<span class="nc" id="L1353">    }</span>

    /**
     * Test keySet.retainAll.
     */
    public void testKeySetRetainAll() {
<span class="fc" id="L1359">        resetFull();</span>
<span class="fc" id="L1360">        final Set&lt;K&gt; keys = getMap().keySet();</span>
<span class="fc" id="L1361">        final List&lt;K&gt; sampleKeysAsList = Arrays.asList(getSampleKeys());</span>
<span class="pc bpc" id="L1362" title="1 of 2 branches missed.">        if (!keys.equals(sampleKeysAsList)) {</span>
<span class="fc" id="L1363">            return;</span>
        }
        try {
<span class="nc" id="L1366">            assertFalse(keys.retainAll(sampleKeysAsList));</span>
<span class="nc" id="L1367">        } catch (final UnsupportedOperationException e) {</span>
<span class="nc" id="L1368">            return;</span>
<span class="nc" id="L1369">        }</span>
<span class="nc" id="L1370">        assertEquals(sampleKeysAsList, keys);</span>
        try {
<span class="nc" id="L1372">            assertTrue(keys.retainAll(Collections.&lt;K&gt; emptySet()));</span>
<span class="nc" id="L1373">        } catch (final UnsupportedOperationException e) {</span>
<span class="nc" id="L1374">            return;</span>
<span class="nc" id="L1375">        }</span>
<span class="nc" id="L1376">        assertTrue(getMap().isEmpty());</span>
<span class="nc" id="L1377">    }</span>

    /**
     * Verify that keySet.iterator.remove changes the underlying map.
     */
    public void testKeySetIteratorRemoveChangesMap() {
<span class="fc" id="L1383">        resetFull();</span>
<span class="fc bfc" id="L1384" title="All 2 branches covered.">        for (final Iterator&lt;K&gt; iter = getMap().keySet().iterator(); iter.hasNext();) {</span>
<span class="fc" id="L1385">            final K key = iter.next();</span>
            try {
<span class="fc" id="L1387">                iter.remove();</span>
<span class="fc" id="L1388">            } catch (final UnsupportedOperationException e) {</span>
<span class="fc" id="L1389">                return;</span>
<span class="fc" id="L1390">            }</span>
<span class="fc" id="L1391">            assertFalse(getMap().containsKey(key));</span>
<span class="fc" id="L1392">        }</span>
<span class="fc" id="L1393">    }</span>

    /**
     * Tests that the {@link Map#entrySet} set is backed by
     * the underlying map by removing from the entrySet set
     * and testing if the entry was removed from the map.
     */
    public void testEntrySetRemoveChangesMap() {
<span class="fc" id="L1401">        resetFull();</span>
<span class="fc" id="L1402">        final K[] sampleKeys = getSampleKeys();</span>
<span class="fc" id="L1403">        final V[] sampleValues = getSampleValues();</span>
<span class="fc" id="L1404">        final Set&lt;Map.Entry&lt;K, V&gt;&gt; entrySet = getMap().entrySet();</span>
<span class="fc bfc" id="L1405" title="All 2 branches covered.">        for (int i = 0; i &lt; sampleKeys.length; i++) {</span>
            try {
<span class="fc" id="L1407">                entrySet.remove(new DefaultMapEntry&lt;&gt;(sampleKeys[i], sampleValues[i]));</span>
<span class="fc" id="L1408">            } catch (final UnsupportedOperationException e) {</span>
                // if entrySet removal is unsupported, just skip this test
<span class="fc" id="L1410">                return;</span>
<span class="fc" id="L1411">            }</span>
<span class="fc" id="L1412">            assertTrue(</span>
                    &quot;Entry should have been removed from the underlying map.&quot;,
<span class="pc bpc" id="L1414" title="1 of 2 branches missed.">                    !getMap().containsKey(sampleKeys[i]));</span>
        }
<span class="fc" id="L1416">    }</span>

    /**
     * Test entrySet.removeAll.
     */
    public void testEntrySetRemoveAll() {
<span class="fc" id="L1422">        resetFull();</span>
<span class="fc" id="L1423">        final K[] sampleKeys = getSampleKeys();</span>
<span class="fc" id="L1424">        final V[] sampleValues = getSampleValues();</span>
        //verify map looks as expected:
<span class="fc bfc" id="L1426" title="All 2 branches covered.">        for (int i = 0; i &lt; sampleKeys.length; i++) {</span>
<span class="pc bpc" id="L1427" title="1 of 2 branches missed.">            if (!getMap().containsKey(sampleKeys[i])) {</span>
<span class="nc" id="L1428">                return;</span>
            }
<span class="fc" id="L1430">            final V value = sampleValues[i];</span>
<span class="fc" id="L1431">            final V test = getMap().get(sampleKeys[i]);</span>
<span class="pc bpc" id="L1432" title="2 of 6 branches missed.">            if (value == test || value != null &amp;&amp; value.equals(test)) {</span>
<span class="fc" id="L1433">                continue;</span>
            }
<span class="nc" id="L1435">            return;</span>
        }
<span class="fc" id="L1437">        final Set&lt;Map.Entry&lt;K, V&gt;&gt; entrySet = getMap().entrySet();</span>
<span class="fc" id="L1438">        final HashSet&lt;Map.Entry&lt;K, V&gt;&gt; comparisonSet = new HashSet&lt;&gt;(entrySet);</span>
        try {
<span class="fc" id="L1440">            assertFalse(entrySet.removeAll(Collections.&lt;Map.Entry&lt;K, V&gt;&gt; emptySet()));</span>
<span class="fc" id="L1441">        } catch (final UnsupportedOperationException e) {</span>
<span class="fc" id="L1442">            return;</span>
<span class="fc" id="L1443">        }</span>
<span class="fc" id="L1444">        assertEquals(sampleKeys.length, getMap().size());</span>
        try {
<span class="fc" id="L1446">            assertTrue(entrySet.removeAll(comparisonSet));</span>
<span class="fc" id="L1447">        } catch (final UnsupportedOperationException e) {</span>
<span class="fc" id="L1448">            return;</span>
<span class="fc" id="L1449">        }</span>
<span class="fc" id="L1450">        assertTrue(getMap().isEmpty());</span>
<span class="fc" id="L1451">    }</span>

    /**
     * Test entrySet.retainAll.
     */
    public void testEntrySetRetainAll() {
<span class="fc" id="L1457">        resetFull();</span>
<span class="fc" id="L1458">        final K[] sampleKeys = getSampleKeys();</span>
<span class="fc" id="L1459">        final V[] sampleValues = getSampleValues();</span>
        //verify map looks as expected:
<span class="fc bfc" id="L1461" title="All 2 branches covered.">        for (int i = 0; i &lt; sampleKeys.length; i++) {</span>
<span class="pc bpc" id="L1462" title="1 of 2 branches missed.">            if (!getMap().containsKey(sampleKeys[i])) {</span>
<span class="nc" id="L1463">                return;</span>
            }
<span class="fc" id="L1465">            final V value = sampleValues[i];</span>
<span class="fc" id="L1466">            final V test = getMap().get(sampleKeys[i]);</span>
<span class="pc bpc" id="L1467" title="2 of 6 branches missed.">            if (value == test || value != null &amp;&amp; value.equals(test)) {</span>
<span class="fc" id="L1468">                continue;</span>
            }
<span class="nc" id="L1470">            return;</span>
        }
<span class="fc" id="L1472">        final Set&lt;Map.Entry&lt;K, V&gt;&gt; entrySet = getMap().entrySet();</span>
<span class="fc" id="L1473">        final HashSet&lt;Map.Entry&lt;K, V&gt;&gt; comparisonSet = new HashSet&lt;&gt;(entrySet);</span>
        try {
<span class="fc" id="L1475">            assertFalse(entrySet.retainAll(comparisonSet));</span>
<span class="fc" id="L1476">        } catch (final UnsupportedOperationException e) {</span>
<span class="fc" id="L1477">            return;</span>
<span class="fc" id="L1478">        }</span>
<span class="fc" id="L1479">        assertEquals(sampleKeys.length, getMap().size());</span>
        try {
<span class="fc" id="L1481">            assertTrue(entrySet.retainAll(Collections.&lt;Map.Entry&lt;K, V&gt;&gt; emptySet()));</span>
<span class="fc" id="L1482">        } catch (final UnsupportedOperationException e) {</span>
<span class="fc" id="L1483">            return;</span>
<span class="fc" id="L1484">        }</span>
<span class="fc" id="L1485">        assertTrue(getMap().isEmpty());</span>
<span class="fc" id="L1486">    }</span>

    /**
     * Verify that entrySet.iterator.remove changes the underlying map.
     */
    public void testEntrySetIteratorRemoveChangesMap() {
<span class="fc" id="L1492">        resetFull();</span>
<span class="fc bfc" id="L1493" title="All 2 branches covered.">        for (final Iterator&lt;Map.Entry&lt;K, V&gt;&gt; iter = getMap().entrySet().iterator(); iter.hasNext();) {</span>
<span class="fc" id="L1494">            final K key = iter.next().getKey();</span>
            try {
<span class="fc" id="L1496">                iter.remove();</span>
<span class="fc" id="L1497">            } catch (final UnsupportedOperationException e) {</span>
<span class="fc" id="L1498">                return;</span>
<span class="fc" id="L1499">            }</span>
<span class="fc" id="L1500">            assertFalse(getMap().containsKey(key));</span>
<span class="fc" id="L1501">        }</span>
<span class="fc" id="L1502">    }</span>

    /**
     * Utility methods to create an array of Map.Entry objects
     * out of the given key and value arrays.&lt;P&gt;
     *
     * @param keys    the array of keys
     * @param values  the array of values
     * @return an array of Map.Entry of those keys to those values
     */
    @SuppressWarnings(&quot;unchecked&quot;)
    private Map.Entry&lt;K, V&gt;[] makeEntryArray(final K[] keys, final V[] values) {
<span class="fc" id="L1514">        final Map.Entry&lt;K, V&gt;[] result = new Map.Entry[keys.length];</span>
<span class="fc bfc" id="L1515" title="All 2 branches covered.">        for (int i = 0; i &lt; keys.length; i++) {</span>
<span class="fc" id="L1516">            final Map&lt;K, V&gt; map = makeConfirmedMap();</span>
<span class="fc" id="L1517">            map.put(keys[i], values[i]);</span>
<span class="fc" id="L1518">            result[i] = map.entrySet().iterator().next();</span>
        }
<span class="fc" id="L1520">        return result;</span>
    }

    /**
     * Bulk test {@link Map#entrySet()}.  This method runs through all of
     * the tests in {@link AbstractSetTest}.
     * After modification operations, {@link #verify()} is invoked to ensure
     * that the map and the other collection views are still valid.
     *
     * @return a {@link AbstractSetTest} instance for testing the map's entry set
     */
    public BulkTest bulkTestMapEntrySet() {
<span class="fc" id="L1532">        return new TestMapEntrySet();</span>
    }

    public class TestMapEntrySet extends AbstractSetTest&lt;Map.Entry&lt;K, V&gt;&gt; {
<span class="fc" id="L1536">        public TestMapEntrySet() {</span>
<span class="fc" id="L1537">            super(&quot;MapEntrySet&quot;);</span>
<span class="fc" id="L1538">        }</span>

        // Have to implement manually; entrySet doesn't support addAll
        /**
         * {@inheritDoc}
         */
        @Override
        public Entry&lt;K, V&gt;[] getFullElements() {
<span class="fc" id="L1546">            return getFullNonNullElements();</span>
        }

        /**
         * {@inheritDoc}
         */
        @Override
        public Map.Entry&lt;K, V&gt;[] getFullNonNullElements() {
<span class="fc" id="L1554">            final K[] k = getSampleKeys();</span>
<span class="fc" id="L1555">            final V[] v = getSampleValues();</span>
<span class="fc" id="L1556">            return makeEntryArray(k, v);</span>
        }

        // Have to implement manually; entrySet doesn't support addAll
        @Override
        public Map.Entry&lt;K, V&gt;[] getOtherElements() {
<span class="fc" id="L1562">            final K[] k = getOtherKeys();</span>
<span class="fc" id="L1563">            final V[] v = getOtherValues();</span>
<span class="fc" id="L1564">            return makeEntryArray(k, v);</span>
        }

        @Override
        public Set&lt;Map.Entry&lt;K, V&gt;&gt; makeObject() {
<span class="fc" id="L1569">            return AbstractMapTest.this.makeObject().entrySet();</span>
        }

        @Override
        public Set&lt;Map.Entry&lt;K, V&gt;&gt; makeFullCollection() {
<span class="fc" id="L1574">            return makeFullMap().entrySet();</span>
        }

        @Override
        public boolean isAddSupported() {
            // Collection views don't support add operations.
<span class="fc" id="L1580">            return false;</span>
        }

        @Override
        public boolean isRemoveSupported() {
            // Entry set should only support remove if map does
<span class="fc" id="L1586">            return AbstractMapTest.this.isRemoveSupported();</span>
        }

        public boolean isGetStructuralModify() {
<span class="fc" id="L1590">            return AbstractMapTest.this.isGetStructuralModify();</span>
        }

        @Override
        public boolean areEqualElementsDistinguishable() {
<span class="fc" id="L1595">            return AbstractMapTest.this.areEqualElementsDistinguishable();</span>
        }

        @Override
        public boolean isTestSerialization() {
<span class="fc" id="L1600">            return false;</span>
        }

        @Override
        public void resetFull() {
<span class="fc" id="L1605">            AbstractMapTest.this.resetFull();</span>
<span class="fc" id="L1606">            setCollection(AbstractMapTest.this.getMap().entrySet());</span>
<span class="fc" id="L1607">            TestMapEntrySet.this.setConfirmed(AbstractMapTest.this.getConfirmed().entrySet());</span>
<span class="fc" id="L1608">        }</span>

        @Override
        public void resetEmpty() {
<span class="fc" id="L1612">            AbstractMapTest.this.resetEmpty();</span>
<span class="fc" id="L1613">            setCollection(AbstractMapTest.this.getMap().entrySet());</span>
<span class="fc" id="L1614">            TestMapEntrySet.this.setConfirmed(AbstractMapTest.this.getConfirmed().entrySet());</span>
<span class="fc" id="L1615">        }</span>

        public void testMapEntrySetIteratorEntry() {
<span class="fc" id="L1618">            resetFull();</span>
<span class="fc" id="L1619">            final Iterator&lt;Map.Entry&lt;K, V&gt;&gt; it = getCollection().iterator();</span>
<span class="fc" id="L1620">            int count = 0;</span>
<span class="fc bfc" id="L1621" title="All 2 branches covered.">            while (it.hasNext()) {</span>
<span class="fc" id="L1622">                final Map.Entry&lt;K, V&gt; entry = it.next();</span>
<span class="fc" id="L1623">                assertEquals(true, AbstractMapTest.this.getMap().containsKey(entry.getKey()));</span>
<span class="fc" id="L1624">                assertEquals(true, AbstractMapTest.this.getMap().containsValue(entry.getValue()));</span>
<span class="fc bfc" id="L1625" title="All 2 branches covered.">                if (!isGetStructuralModify()) {</span>
<span class="fc" id="L1626">                    assertEquals(AbstractMapTest.this.getMap().get(entry.getKey()), entry.getValue());</span>
                }
<span class="fc" id="L1628">                count++;</span>
<span class="fc" id="L1629">            }</span>
<span class="fc" id="L1630">            assertEquals(getCollection().size(), count);</span>
<span class="fc" id="L1631">        }</span>

        public void testMapEntrySetIteratorEntrySetValue() {
<span class="fc" id="L1634">            final K key1 = getSampleKeys()[0];</span>
<span class="fc bfc" id="L1635" title="All 2 branches covered.">            final K key2 = getSampleKeys().length == 1 ? getSampleKeys()[0] : getSampleKeys()[1];</span>
<span class="fc" id="L1636">            final V newValue1 = getNewSampleValues()[0];</span>
<span class="fc bfc" id="L1637" title="All 2 branches covered.">            final V newValue2 = getNewSampleValues().length ==1 ? getNewSampleValues()[0] : getNewSampleValues()[1];</span>

<span class="fc" id="L1639">            resetFull();</span>
            // explicitly get entries as sample values/keys are connected for some maps
            // such as BeanMap
<span class="fc" id="L1642">            Iterator&lt;Map.Entry&lt;K, V&gt;&gt; it = TestMapEntrySet.this.getCollection().iterator();</span>
<span class="fc" id="L1643">            final Map.Entry&lt;K, V&gt; entry1 = getEntry(it, key1);</span>
<span class="fc" id="L1644">            it = TestMapEntrySet.this.getCollection().iterator();</span>
<span class="fc" id="L1645">            final Map.Entry&lt;K, V&gt; entry2 = getEntry(it, key2);</span>
<span class="fc" id="L1646">            Iterator&lt;Map.Entry&lt;K, V&gt;&gt; itConfirmed = TestMapEntrySet.this.getConfirmed().iterator();</span>
<span class="fc" id="L1647">            final Map.Entry&lt;K, V&gt; entryConfirmed1 = getEntry(itConfirmed, key1);</span>
<span class="fc" id="L1648">            itConfirmed = TestMapEntrySet.this.getConfirmed().iterator();</span>
<span class="fc" id="L1649">            final Map.Entry&lt;K, V&gt; entryConfirmed2 = getEntry(itConfirmed, key2);</span>
<span class="fc" id="L1650">            verify();</span>

<span class="fc bfc" id="L1652" title="All 2 branches covered.">            if (!isSetValueSupported()) {</span>
                try {
<span class="fc" id="L1654">                    entry1.setValue(newValue1);</span>
<span class="fc" id="L1655">                } catch (final UnsupportedOperationException ex) {</span>
<span class="fc" id="L1656">                }</span>
<span class="fc" id="L1657">                return;</span>
            }

<span class="fc" id="L1660">            entry1.setValue(newValue1);</span>
<span class="fc" id="L1661">            entryConfirmed1.setValue(newValue1);</span>
<span class="fc" id="L1662">            assertEquals(newValue1, entry1.getValue());</span>
<span class="fc" id="L1663">            assertEquals(true, AbstractMapTest.this.getMap().containsKey(entry1.getKey()));</span>
<span class="fc" id="L1664">            assertEquals(true, AbstractMapTest.this.getMap().containsValue(newValue1));</span>
<span class="fc" id="L1665">            assertEquals(newValue1, AbstractMapTest.this.getMap().get(entry1.getKey()));</span>
<span class="fc" id="L1666">            verify();</span>

<span class="fc" id="L1668">            entry1.setValue(newValue1);</span>
<span class="fc" id="L1669">            entryConfirmed1.setValue(newValue1);</span>
<span class="fc" id="L1670">            assertEquals(newValue1, entry1.getValue());</span>
<span class="fc" id="L1671">            assertEquals(true, AbstractMapTest.this.getMap().containsKey(entry1.getKey()));</span>
<span class="fc" id="L1672">            assertEquals(true, AbstractMapTest.this.getMap().containsValue(newValue1));</span>
<span class="fc" id="L1673">            assertEquals(newValue1, AbstractMapTest.this.getMap().get(entry1.getKey()));</span>
<span class="fc" id="L1674">            verify();</span>

<span class="fc" id="L1676">            entry2.setValue(newValue2);</span>
<span class="fc" id="L1677">            entryConfirmed2.setValue(newValue2);</span>
<span class="fc" id="L1678">            assertEquals(newValue2, entry2.getValue());</span>
<span class="fc" id="L1679">            assertEquals(true, AbstractMapTest.this.getMap().containsKey(entry2.getKey()));</span>
<span class="fc" id="L1680">            assertEquals(true, AbstractMapTest.this.getMap().containsValue(newValue2));</span>
<span class="fc" id="L1681">            assertEquals(newValue2, AbstractMapTest.this.getMap().get(entry2.getKey()));</span>
<span class="fc" id="L1682">            verify();</span>
<span class="fc" id="L1683">        }</span>

        public Map.Entry&lt;K, V&gt; getEntry(final Iterator&lt;Map.Entry&lt;K, V&gt;&gt; itConfirmed, final K key) {
<span class="fc" id="L1686">            Map.Entry&lt;K, V&gt; entry = null;</span>
<span class="pc bpc" id="L1687" title="1 of 2 branches missed.">            while (itConfirmed.hasNext()) {</span>
<span class="fc" id="L1688">                final Map.Entry&lt;K, V&gt; temp = itConfirmed.next();</span>
<span class="fc bfc" id="L1689" title="All 2 branches covered.">                if (temp.getKey() == null) {</span>
<span class="pc bpc" id="L1690" title="1 of 2 branches missed.">                    if (key == null) {</span>
<span class="nc" id="L1691">                        entry = temp;</span>
<span class="nc" id="L1692">                        break;</span>
                    }
<span class="fc bfc" id="L1694" title="All 2 branches covered.">                } else if (temp.getKey().equals(key)) {</span>
<span class="fc" id="L1695">                    entry = temp;</span>
<span class="fc" id="L1696">                    break;</span>
                }
<span class="fc" id="L1698">            }</span>
<span class="fc" id="L1699">            assertNotNull(&quot;No matching entry in map for key '&quot; + key + &quot;'&quot;, entry);</span>
<span class="fc" id="L1700">            return entry;</span>
        }

        public void testMapEntrySetRemoveNonMapEntry() {
<span class="fc bfc" id="L1704" title="All 2 branches covered.">            if (!isRemoveSupported()) {</span>
<span class="fc" id="L1705">                return;</span>
            }
<span class="fc" id="L1707">            resetFull();</span>
<span class="fc" id="L1708">            assertEquals(false, getCollection().remove(null));</span>
<span class="fc" id="L1709">            assertEquals(false, getCollection().remove(new Object()));</span>
<span class="fc" id="L1710">        }</span>

        @Override
        public void verify() {
<span class="fc" id="L1714">            super.verify();</span>
<span class="fc" id="L1715">            AbstractMapTest.this.verify();</span>
<span class="fc" id="L1716">        }</span>
    }


    /**
     * Bulk test {@link Map#keySet()}.  This method runs through all of
     * the tests in {@link AbstractSetTest}.
     * After modification operations, {@link #verify()} is invoked to ensure
     * that the map and the other collection views are still valid.
     *
     * @return a {@link AbstractSetTest} instance for testing the map's key set
     */
    public BulkTest bulkTestMapKeySet() {
<span class="fc" id="L1729">        return new TestMapKeySet();</span>
    }

    public class TestMapKeySet extends AbstractSetTest&lt;K&gt; {
<span class="fc" id="L1733">        public TestMapKeySet() {</span>
<span class="fc" id="L1734">            super(&quot;&quot;);</span>
<span class="fc" id="L1735">        }</span>

        @Override
        public K[] getFullElements() {
<span class="fc" id="L1739">            return getSampleKeys();</span>
        }

        @Override
        public K[] getOtherElements() {
<span class="fc" id="L1744">            return getOtherKeys();</span>
        }

        @Override
        public Set&lt;K&gt; makeObject() {
<span class="fc" id="L1749">            return AbstractMapTest.this.makeObject().keySet();</span>
        }

        @Override
        public Set&lt;K&gt; makeFullCollection() {
<span class="fc" id="L1754">            return AbstractMapTest.this.makeFullMap().keySet();</span>
        }

        @Override
        public boolean isNullSupported() {
<span class="nc" id="L1759">            return AbstractMapTest.this.isAllowNullKey();</span>
        }

        @Override
        public boolean isAddSupported() {
<span class="fc" id="L1764">            return false;</span>
        }

        @Override
        public boolean isRemoveSupported() {
<span class="fc" id="L1769">            return AbstractMapTest.this.isRemoveSupported();</span>
        }

        @Override
        public boolean isTestSerialization() {
<span class="fc" id="L1774">            return false;</span>
        }

        @Override
        public void resetEmpty() {
<span class="fc" id="L1779">            AbstractMapTest.this.resetEmpty();</span>
<span class="fc" id="L1780">            setCollection(AbstractMapTest.this.getMap().keySet());</span>
<span class="fc" id="L1781">            TestMapKeySet.this.setConfirmed(AbstractMapTest.this.getConfirmed().keySet());</span>
<span class="fc" id="L1782">        }</span>

        @Override
        public void resetFull() {
<span class="fc" id="L1786">            AbstractMapTest.this.resetFull();</span>
<span class="fc" id="L1787">            setCollection(AbstractMapTest.this.getMap().keySet());</span>
<span class="fc" id="L1788">            TestMapKeySet.this.setConfirmed(AbstractMapTest.this.getConfirmed().keySet());</span>
<span class="fc" id="L1789">        }</span>

        @Override
        public void verify() {
<span class="fc" id="L1793">            super.verify();</span>
<span class="fc" id="L1794">            AbstractMapTest.this.verify();</span>
<span class="fc" id="L1795">        }</span>
    }

    /**
     * Bulk test {@link Map#values()}.  This method runs through all of
     * the tests in {@link AbstractCollectionTest}.
     * After modification operations, {@link #verify()} is invoked to ensure
     * that the map and the other collection views are still valid.
     *
     * @return a {@link AbstractCollectionTest} instance for testing the map's
     *    values collection
     */
    public BulkTest bulkTestMapValues() {
<span class="fc" id="L1808">        return new TestMapValues();</span>
    }

    public class TestMapValues extends AbstractCollectionTest&lt;V&gt; {
<span class="fc" id="L1812">        public TestMapValues() {</span>
<span class="fc" id="L1813">            super(&quot;&quot;);</span>
<span class="fc" id="L1814">        }</span>

        @Override
        public V[] getFullElements() {
<span class="fc" id="L1818">            return getSampleValues();</span>
        }

        @Override
        public V[] getOtherElements() {
<span class="fc" id="L1823">            return getOtherValues();</span>
        }

        @Override
        public Collection&lt;V&gt; makeObject() {
<span class="fc" id="L1828">            return AbstractMapTest.this.makeObject().values();</span>
        }

        @Override
        public Collection&lt;V&gt; makeFullCollection() {
<span class="fc" id="L1833">            return AbstractMapTest.this.makeFullMap().values();</span>
        }

        @Override
        public boolean isNullSupported() {
<span class="nc" id="L1838">            return AbstractMapTest.this.isAllowNullKey();</span>
        }

        @Override
        public boolean isAddSupported() {
<span class="fc" id="L1843">            return false;</span>
        }

        @Override
        public boolean isRemoveSupported() {
<span class="fc" id="L1848">            return AbstractMapTest.this.isRemoveSupported();</span>
        }

        @Override
        public boolean isTestSerialization() {
<span class="fc" id="L1853">            return false;</span>
        }

        @Override
        public boolean areEqualElementsDistinguishable() {
            // equal values are associated with different keys, so they are
            // distinguishable.
<span class="fc" id="L1860">            return true;</span>
        }

        @Override
        public Collection&lt;V&gt; makeConfirmedCollection() {
            // never gets called, reset methods are overridden
<span class="nc" id="L1866">            return null;</span>
        }

        @Override
        public Collection&lt;V&gt; makeConfirmedFullCollection() {
            // never gets called, reset methods are overridden
<span class="nc" id="L1872">            return null;</span>
        }

        @Override
        public void resetFull() {
<span class="fc" id="L1877">            AbstractMapTest.this.resetFull();</span>
<span class="fc" id="L1878">            setCollection(map.values());</span>
<span class="fc" id="L1879">            TestMapValues.this.setConfirmed(AbstractMapTest.this.getConfirmed().values());</span>
<span class="fc" id="L1880">        }</span>

        @Override
        public void resetEmpty() {
<span class="fc" id="L1884">            AbstractMapTest.this.resetEmpty();</span>
<span class="fc" id="L1885">            setCollection(map.values());</span>
<span class="fc" id="L1886">            TestMapValues.this.setConfirmed(AbstractMapTest.this.getConfirmed().values());</span>
<span class="fc" id="L1887">        }</span>

        @Override
        public void verify() {
<span class="fc" id="L1891">            super.verify();</span>
<span class="fc" id="L1892">            AbstractMapTest.this.verify();</span>
<span class="fc" id="L1893">        }</span>

        // TODO: should test that a remove on the values collection view
        // removes the proper mapping and not just any mapping that may have
        // the value equal to the value returned from the values iterator.
    }


    /**
     * Resets the {@link #map}, {@link #entrySet}, {@link #keySet},
     * {@link #values} and {@link #confirmed} fields to empty.
     */
    public void resetEmpty() {
<span class="fc" id="L1906">        this.map = makeObject();</span>
<span class="fc" id="L1907">        views();</span>
<span class="fc" id="L1908">        this.confirmed = makeConfirmedMap();</span>
<span class="fc" id="L1909">    }</span>

    /**
     * Resets the {@link #map}, {@link #entrySet}, {@link #keySet},
     * {@link #values} and {@link #confirmed} fields to full.
     */
    public void resetFull() {
<span class="fc" id="L1916">        this.map = makeFullMap();</span>
<span class="fc" id="L1917">        views();</span>
<span class="fc" id="L1918">        this.confirmed = makeConfirmedMap();</span>
<span class="fc" id="L1919">        final K[] k = getSampleKeys();</span>
<span class="fc" id="L1920">        final V[] v = getSampleValues();</span>
<span class="fc bfc" id="L1921" title="All 2 branches covered.">        for (int i = 0; i &lt; k.length; i++) {</span>
<span class="fc" id="L1922">            confirmed.put(k[i], v[i]);</span>
        }
<span class="fc" id="L1924">    }</span>

    /**
     * Resets the collection view fields.
     */
    private void views() {
<span class="fc" id="L1930">        this.keySet = getMap().keySet();</span>
        // see verifyValues: retrieve the values collection only when verifying them
        // this.values = getMap().values();
<span class="fc" id="L1933">        this.entrySet = getMap().entrySet();</span>
<span class="fc" id="L1934">    }</span>

    /**
     * Verifies that {@link #map} is still equal to {@link #confirmed}.
     * This method checks that the map is equal to the HashMap,
     * &lt;I&gt;and&lt;/I&gt; that the map's collection views are still equal to
     * the HashMap's collection views.  An &lt;Code&gt;equals&lt;/Code&gt; test
     * is done on the maps and their collection views; their size and
     * &lt;Code&gt;isEmpty&lt;/Code&gt; results are compared; their hashCodes are
     * compared; and &lt;Code&gt;containsAll&lt;/Code&gt; tests are run on the
     * collection views.
     */
    public void verify() {
<span class="fc" id="L1947">        verifyMap();</span>
<span class="fc" id="L1948">        verifyEntrySet();</span>
<span class="fc" id="L1949">        verifyKeySet();</span>
<span class="fc" id="L1950">        verifyValues();</span>
<span class="fc" id="L1951">    }</span>

    public void verifyMap() {
<span class="fc" id="L1954">        final int size = getConfirmed().size();</span>
<span class="fc" id="L1955">        final boolean empty = getConfirmed().isEmpty();</span>
<span class="fc" id="L1956">        assertEquals(&quot;Map should be same size as HashMap&quot;, size, getMap().size());</span>
<span class="fc" id="L1957">        assertEquals(&quot;Map should be empty if HashMap is&quot;, empty, getMap().isEmpty());</span>
<span class="fc" id="L1958">        assertEquals(&quot;hashCodes should be the same&quot;, getConfirmed().hashCode(), getMap().hashCode());</span>
        // changing the order of the assertion below fails for LRUMap because confirmed is
        // another collection (e.g. treemap) and confirmed.equals() creates a normal iterator (not
        // #mapIterator()), which modifies the parent expected modCount of the map object, causing
        // concurrent modification exceptions.
        // Because of this we have assertEquals(map, confirmed), and not the other way around.
<span class="fc" id="L1964">        assertEquals(&quot;Map should still equal HashMap&quot;, map, confirmed);</span>
<span class="fc" id="L1965">        assertTrue(&quot;Map should still equal HashMap&quot;, getMap().equals(getConfirmed()));</span>
<span class="fc" id="L1966">    }</span>

    public void verifyEntrySet() {
<span class="fc" id="L1969">        final int size = getConfirmed().size();</span>
<span class="fc" id="L1970">        final boolean empty = getConfirmed().isEmpty();</span>
<span class="fc" id="L1971">        assertEquals(&quot;entrySet should be same size as HashMap's&quot; +</span>
<span class="fc" id="L1972">                     &quot;\nTest: &quot; + entrySet + &quot;\nReal: &quot; + getConfirmed().entrySet(),</span>
<span class="fc" id="L1973">                     size, entrySet.size());</span>
<span class="fc" id="L1974">        assertEquals(&quot;entrySet should be empty if HashMap is&quot; +</span>
<span class="fc" id="L1975">                     &quot;\nTest: &quot; + entrySet + &quot;\nReal: &quot; + getConfirmed().entrySet(),</span>
<span class="fc" id="L1976">                     empty, entrySet.isEmpty());</span>
<span class="fc" id="L1977">        assertTrue(&quot;entrySet should contain all HashMap's elements&quot; +</span>
<span class="fc" id="L1978">                   &quot;\nTest: &quot; + entrySet + &quot;\nReal: &quot; + getConfirmed().entrySet(),</span>
<span class="fc" id="L1979">                   entrySet.containsAll(getConfirmed().entrySet()));</span>
<span class="fc" id="L1980">        assertEquals(&quot;entrySet hashCodes should be the same&quot; +</span>
<span class="fc" id="L1981">                     &quot;\nTest: &quot; + entrySet + &quot;\nReal: &quot; + getConfirmed().entrySet(),</span>
<span class="fc" id="L1982">                     getConfirmed().entrySet().hashCode(), entrySet.hashCode());</span>
<span class="fc" id="L1983">        assertEquals(&quot;Map's entry set should still equal HashMap's&quot;,</span>
<span class="fc" id="L1984">                     getConfirmed().entrySet(), entrySet);</span>
<span class="fc" id="L1985">    }</span>

    public void verifyKeySet() {
<span class="fc" id="L1988">        final int size = getConfirmed().size();</span>
<span class="fc" id="L1989">        final boolean empty = getConfirmed().isEmpty();</span>
<span class="fc" id="L1990">        assertEquals(&quot;keySet should be same size as HashMap's&quot; +</span>
<span class="fc" id="L1991">                     &quot;\nTest: &quot; + keySet + &quot;\nReal: &quot; + getConfirmed().keySet(),</span>
<span class="fc" id="L1992">                     size, keySet.size());</span>
<span class="fc" id="L1993">        assertEquals(&quot;keySet should be empty if HashMap is&quot; +</span>
<span class="fc" id="L1994">                     &quot;\nTest: &quot; + keySet + &quot;\nReal: &quot; + getConfirmed().keySet(),</span>
<span class="fc" id="L1995">                     empty, keySet.isEmpty());</span>
<span class="fc" id="L1996">        assertTrue(&quot;keySet should contain all HashMap's elements&quot; +</span>
<span class="fc" id="L1997">                   &quot;\nTest: &quot; + keySet + &quot;\nReal: &quot; + getConfirmed().keySet(),</span>
<span class="fc" id="L1998">                   keySet.containsAll(getConfirmed().keySet()));</span>
<span class="fc" id="L1999">        assertEquals(&quot;keySet hashCodes should be the same&quot; +</span>
<span class="fc" id="L2000">                     &quot;\nTest: &quot; + keySet + &quot;\nReal: &quot; + getConfirmed().keySet(),</span>
<span class="fc" id="L2001">                     getConfirmed().keySet().hashCode(), keySet.hashCode());</span>
<span class="fc" id="L2002">        assertEquals(&quot;Map's key set should still equal HashMap's&quot;,</span>
<span class="fc" id="L2003">                getConfirmed().keySet(), keySet);</span>
<span class="fc" id="L2004">    }</span>

    public void verifyValues() {
<span class="fc" id="L2007">        final List&lt;V&gt; known = new ArrayList&lt;&gt;(getConfirmed().values());</span>

<span class="fc" id="L2009">        values = getMap().values();</span>

<span class="fc" id="L2011">        final List&lt;V&gt; test = new ArrayList&lt;&gt;(values);</span>

<span class="fc" id="L2013">        final int size = getConfirmed().size();</span>
<span class="fc" id="L2014">        final boolean empty = getConfirmed().isEmpty();</span>
<span class="fc" id="L2015">        assertEquals(&quot;values should be same size as HashMap's&quot; +</span>
                     &quot;\nTest: &quot; + test + &quot;\nReal: &quot; + known,
<span class="fc" id="L2017">                     size, values.size());</span>
<span class="fc" id="L2018">        assertEquals(&quot;values should be empty if HashMap is&quot; +</span>
                     &quot;\nTest: &quot; + test + &quot;\nReal: &quot; + known,
<span class="fc" id="L2020">                     empty, values.isEmpty());</span>
<span class="fc" id="L2021">        assertTrue(&quot;values should contain all HashMap's elements&quot; +</span>
                   &quot;\nTest: &quot; + test + &quot;\nReal: &quot; + known,
<span class="fc" id="L2023">                    test.containsAll(known));</span>
<span class="fc" id="L2024">        assertTrue(&quot;values should contain all HashMap's elements&quot; +</span>
                   &quot;\nTest: &quot; + test + &quot;\nReal: &quot; + known,
<span class="fc" id="L2026">                   known.containsAll(test));</span>
        // originally coded to use a HashBag, but now separate jar so...
<span class="fc bfc" id="L2028" title="All 2 branches covered.">        for (final V v : known) {</span>
<span class="fc" id="L2029">            final boolean removed = test.remove(v);</span>
<span class="fc" id="L2030">            assertTrue(&quot;Map's values should still equal HashMap's&quot;, removed);</span>
<span class="fc" id="L2031">        }</span>
<span class="fc" id="L2032">        assertTrue(&quot;Map's values should still equal HashMap's&quot;, test.isEmpty());</span>
<span class="fc" id="L2033">    }</span>

    /**
     * Erases any leftover instance variables by setting them to null.
     */
    @Override
    public void tearDown() throws Exception {
<span class="fc" id="L2040">        map = null;</span>
<span class="fc" id="L2041">        keySet = null;</span>
<span class="fc" id="L2042">        entrySet = null;</span>
<span class="fc" id="L2043">        values = null;</span>
<span class="fc" id="L2044">        confirmed = null;</span>
<span class="fc" id="L2045">    }</span>

    /**
     * Get the map.
     * @return Map&lt;K,V&gt;
     */
    public Map&lt;K, V&gt; getMap() {
<span class="fc" id="L2052">        return map;</span>
    }

    /**
     * Get the confirmed.
     * @return Map&lt;K,V&gt;
     */
    public Map&lt;K, V&gt; getConfirmed() {
<span class="fc" id="L2060">        return confirmed;</span>
    }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.1.201803210924</span></div></body></html>