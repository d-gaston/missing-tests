<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>AbstractCollectionTest.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">commons_collections4$All_in_commons_collections4.exec</a> &gt; <a href="index.source.html" class="el_package">org.apache.commons.collections4.collection</a> &gt; <span class="el_source">AbstractCollectionTest.java</span></div><h1>AbstractCollectionTest.java</h1><pre class="source lang-java linenums">/*
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the &quot;License&quot;); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.commons.collections4.collection;

import java.io.ByteArrayInputStream;
import java.io.ByteArrayOutputStream;
import java.io.ObjectInputStream;
import java.io.ObjectOutputStream;
import java.io.Serializable;
import java.lang.reflect.Array;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Collection;
import java.util.Collections;
import java.util.ConcurrentModificationException;
import java.util.HashMap;
import java.util.HashSet;
import java.util.Iterator;
import java.util.List;
import java.util.Map;
import java.util.NoSuchElementException;

import org.apache.commons.collections4.AbstractObjectTest;

/**
 * Abstract test class for {@link java.util.Collection} methods and contracts.
 * &lt;p&gt;
 * You should create a concrete subclass of this class to test any custom
 * {@link Collection} implementation.  At minimum, you'll have to
 * implement the @{@link #makeObject()}, {@link #makeConfirmedCollection()}
 * and {@link #makeConfirmedFullCollection()} methods.
 * You might want to override some of the additional public methods as well:
 * &lt;p&gt;
 * &lt;b&gt;Element Population Methods&lt;/b&gt;
 * &lt;p&gt;
 * Override these if your collection restricts what kind of elements are
 * allowed (for instance, if &lt;code&gt;null&lt;/code&gt; is not permitted):
 * &lt;ul&gt;
 * &lt;li&gt;{@link #getFullElements()}
 * &lt;li&gt;{@link #getOtherElements()}
 * &lt;/ul&gt;
 * &lt;p&gt;
 * &lt;b&gt;Supported Operation Methods&lt;/b&gt;
 * &lt;p&gt;
 * Override these if your collection doesn't support certain operations:
 * &lt;ul&gt;
 * &lt;li&gt;{@link #isAddSupported()}
 * &lt;li&gt;{@link #isRemoveSupported()}
 * &lt;li&gt;{@link #areEqualElementsDistinguishable()}
 * &lt;li&gt;{@link #isNullSupported()}
 * &lt;li&gt;{@link #isFailFastSupported()}
 * &lt;/ul&gt;
 * &lt;p&gt;
 * &lt;b&gt;Fixture Methods&lt;/b&gt;
 * &lt;p&gt;
 * Fixtures are used to verify that the operation results in correct state
 * for the collection.  Basically, the operation is performed against your
 * collection implementation, and an identical operation is performed against a
 * &lt;i&gt;confirmed&lt;/i&gt; collection implementation.  A confirmed collection
 * implementation is something like &lt;code&gt;java.util.ArrayList&lt;/code&gt;, which is
 * known to conform exactly to its collection interface's contract.  After the
 * operation takes place on both your collection implementation and the
 * confirmed collection implementation, the two collections are compared to see
 * if their state is identical.  The comparison is usually much more involved
 * than a simple &lt;code&gt;equals&lt;/code&gt; test.  This verification is used to ensure
 * proper modifications are made along with ensuring that the collection does
 * not change when read-only modifications are made.
 * &lt;p&gt;
 * The {@link #collection} field holds an instance of your collection
 * implementation; the {@link #confirmed} field holds an instance of the
 * confirmed collection implementation.  The {@link #resetEmpty()} and
 * {@link #resetFull()} methods set these fields to empty or full collections,
 * so that tests can proceed from a known state.
 * &lt;p&gt;
 * After a modification operation to both {@link #collection} and
 * {@link #confirmed}, the {@link #verify()} method is invoked to compare
 * the results.  You may want to override {@link #verify()} to perform
 * additional verifications.  For instance, when testing the collection
 * views of a map, {@link org.apache.commons.collections4.map.AbstractMapTest AbstractTestMap}
 * would override {@link #verify()} to make
 * sure the map is changed after the collection view is changed.
 * &lt;p&gt;
 * If you're extending this class directly, you will have to provide
 * implementations for the following:
 * &lt;ul&gt;
 * &lt;li&gt;{@link #makeConfirmedCollection()}
 * &lt;li&gt;{@link #makeConfirmedFullCollection()}
 * &lt;/ul&gt;
 * &lt;p&gt;
 * Those methods should provide a confirmed collection implementation
 * that's compatible with your collection implementation.
 * &lt;p&gt;
 * If you're extending {@link org.apache.commons.collections4.list.AbstractListTest AbstractListTest},
 * {@link org.apache.commons.collections4.set.AbstractSetTest AbstractTestSet},
 * or {@link org.apache.commons.collections4.bag.AbstractBagTest AbstractBagTest},
 * you probably don't have to worry about the
 * above methods, because those three classes already override the methods
 * to provide standard JDK confirmed collections.&lt;P&gt;
 * &lt;p&gt;
 * &lt;b&gt;Other notes&lt;/b&gt;
 * &lt;p&gt;
 * If your {@link Collection} fails one of these tests by design,
 * you may still use this base set of cases.  Simply override the
 * test case (method) your {@link Collection} fails.
 *
 */
public abstract class AbstractCollectionTest&lt;E&gt; extends AbstractObjectTest {

    //
    // NOTE:
    //
    // Collection doesn't define any semantics for equals, and recommends you
    // use reference-based default behavior of Object.equals.  (And a test for
    // that already exists in AbstractTestObject).  Tests for equality of lists, sets
    // and bags will have to be written in test subclasses.  Thus, there is no
    // tests on Collection.equals nor any for Collection.hashCode.
    //

    // These fields are used by reset() and verify(), and any test
    // method that tests a modification.

    /**
     *  A collection instance that will be used for testing.
     */
    private Collection&lt;E&gt; collection;

    /**
     *  Confirmed collection.  This is an instance of a collection that is
     *  confirmed to conform exactly to the java.util.Collection contract.
     *  Modification operations are tested by performing a mod on your
     *  collection, performing the exact same mod on an equivalent confirmed
     *  collection, and then calling verify() to make sure your collection
     *  still matches the confirmed collection.
     */
    private Collection&lt;E&gt; confirmed;

    /**
     * JUnit constructor.
     *
     * @param testName  the test class name
     */
    public AbstractCollectionTest(final String testName) {
<span class="fc" id="L157">        super(testName);</span>
<span class="fc" id="L158">    }</span>

    //-----------------------------------------------------------------------
    /**
     *  Specifies whether equal elements in the collection are, in fact,
     *  distinguishable with information not readily available.  That is, if a
     *  particular value is to be removed from the collection, then there is
     *  one and only one value that can be removed, even if there are other
     *  elements which are equal to it.
     *
     *  &lt;P&gt;In most collection cases, elements are not distinguishable (equal is
     *  equal), thus this method defaults to return false.  In some cases,
     *  however, they are.  For example, the collection returned from the map's
     *  values() collection view are backed by the map, so while there may be
     *  two values that are equal, their associated keys are not.  Since the
     *  keys are distinguishable, the values are.
     *
     *  &lt;P&gt;This flag is used to skip some verifications for iterator.remove()
     *  where it is impossible to perform an equivalent modification on the
     *  confirmed collection because it is not possible to determine which
     *  value in the confirmed collection to actually remove.  Tests that
     *  override the default (i.e. where equal elements are distinguishable),
     *  should provide additional tests on iterator.remove() to make sure the
     *  proper elements are removed when remove() is called on the iterator.
     **/
    public boolean areEqualElementsDistinguishable() {
<span class="fc" id="L184">        return false;</span>
    }

    /**
     *  Returns true if the collections produced by
     *  {@link #makeObject()} and {@link #makeFullCollection()}
     *  support the &lt;code&gt;add&lt;/code&gt; and &lt;code&gt;addAll&lt;/code&gt;
     *  operations.&lt;P&gt;
     *  Default implementation returns true.  Override if your collection
     *  class does not support add or addAll.
     */
    public boolean isAddSupported() {
<span class="fc" id="L196">        return true;</span>
    }

    /**
     *  Returns true if the collections produced by
     *  {@link #makeObject()} and {@link #makeFullCollection()}
     *  support the &lt;code&gt;remove&lt;/code&gt;, &lt;code&gt;removeAll&lt;/code&gt;,
     *  &lt;code&gt;retainAll&lt;/code&gt;, &lt;code&gt;clear&lt;/code&gt; and
     *  &lt;code&gt;iterator().remove()&lt;/code&gt; methods.
     *  Default implementation returns true.  Override if your collection
     *  class does not support removal operations.
     */
    public boolean isRemoveSupported() {
<span class="fc" id="L209">        return true;</span>
    }

    /**
     * Returns true to indicate that the collection supports holding null.
     * The default implementation returns true;
     */
    public boolean isNullSupported() {
<span class="fc" id="L217">        return true;</span>
    }

    /**
     * Returns true to indicate that the collection supports fail fast iterators.
     * The default implementation returns true;
     */
    public boolean isFailFastSupported() {
<span class="fc" id="L225">        return false;</span>
    }

    /**
     * Returns true to indicate that the collection supports equals() comparisons.
     * This implementation returns false;
     */
    @Override
    public boolean isEqualsCheckable() {
<span class="fc" id="L234">        return false;</span>
    }

    //-----------------------------------------------------------------------
    /**
     *  Verifies that {@link #collection} and {@link #confirmed} have
     *  identical state.
     */
    public void verify() {
<span class="fc" id="L243">        final int confirmedSize = getConfirmed().size();</span>
<span class="fc" id="L244">        assertEquals(&quot;Collection size should match confirmed collection's&quot;, confirmedSize,</span>
<span class="fc" id="L245">                getCollection().size());</span>
<span class="fc" id="L246">        assertEquals(&quot;Collection isEmpty() result should match confirmed collection's&quot;,</span>
<span class="fc" id="L247">                getConfirmed().isEmpty(), getCollection().isEmpty());</span>

        // verify the collections are the same by attempting to match each
        // object in the collection and confirmed collection.  To account for
        // duplicates and differing orders, each confirmed element is copied
        // into an array and a flag is maintained for each element to determine
        // whether it has been matched once and only once.  If all elements in
        // the confirmed collection are matched once and only once and there
        // aren't any elements left to be matched in the collection,
        // verification is a success.

        // copy each collection value into an array
<span class="fc" id="L259">        final Object[] confirmedValues = new Object[confirmedSize];</span>

        Iterator&lt;E&gt; iter;

<span class="fc" id="L263">        iter = getConfirmed().iterator();</span>
<span class="fc" id="L264">        int pos = 0;</span>
<span class="fc bfc" id="L265" title="All 2 branches covered.">        while (iter.hasNext()) {</span>
<span class="fc" id="L266">            confirmedValues[pos++] = iter.next();</span>
        }

        // allocate an array of boolean flags for tracking values that have
        // been matched once and only once.
<span class="fc" id="L271">        final boolean[] matched = new boolean[confirmedSize];</span>

        // now iterate through the values of the collection and try to match
        // the value with one in the confirmed array.
<span class="fc" id="L275">        iter = getCollection().iterator();</span>
<span class="fc bfc" id="L276" title="All 2 branches covered.">        while (iter.hasNext()) {</span>
<span class="fc" id="L277">            final Object o = iter.next();</span>
<span class="fc" id="L278">            boolean match = false;</span>
<span class="pc bpc" id="L279" title="1 of 2 branches missed.">            for (int i = 0; i &lt; confirmedSize; i++) {</span>
<span class="fc bfc" id="L280" title="All 2 branches covered.">                if (matched[i]) {</span>
                    // skip values already matched
<span class="fc" id="L282">                    continue;</span>
                }
<span class="fc bfc" id="L284" title="All 6 branches covered.">                if (o == confirmedValues[i] || o != null &amp;&amp; o.equals(confirmedValues[i])) {</span>
                    // values matched
<span class="fc" id="L286">                    matched[i] = true;</span>
<span class="fc" id="L287">                    match = true;</span>
<span class="fc" id="L288">                    break;</span>
                }
            }
            // no match found!
<span class="pc bpc" id="L292" title="1 of 2 branches missed.">            if (!match) {</span>
<span class="nc" id="L293">                fail(&quot;Collection should not contain a value that the &quot;</span>
<span class="nc" id="L294">                        + &quot;confirmed collection does not have: &quot; + o + &quot;\nTest: &quot; + getCollection()</span>
<span class="nc" id="L295">                        + &quot;\nReal: &quot; + getConfirmed());</span>
            }
<span class="fc" id="L297">        }</span>

        // make sure there aren't any unmatched values
<span class="fc bfc" id="L300" title="All 2 branches covered.">        for (int i = 0; i &lt; confirmedSize; i++) {</span>
<span class="pc bpc" id="L301" title="1 of 2 branches missed.">            if (!matched[i]) {</span>
                // the collection didn't match all the confirmed values
<span class="nc" id="L303">                fail(&quot;Collection should contain all values that are in the confirmed collection&quot;</span>
<span class="nc" id="L304">                        + &quot;\nTest: &quot; + getCollection() + &quot;\nReal: &quot; + getConfirmed());</span>
            }
        }
<span class="fc" id="L307">    }</span>

    //-----------------------------------------------------------------------
    /**
     *  Resets the {@link #collection} and {@link #confirmed} fields to empty
     *  collections.  Invoke this method before performing a modification
     *  test.
     */
    public void resetEmpty() {
<span class="fc" id="L316">        this.setCollection(makeObject());</span>
<span class="fc" id="L317">        this.setConfirmed(makeConfirmedCollection());</span>
<span class="fc" id="L318">    }</span>

    /**
     *  Resets the {@link #collection} and {@link #confirmed} fields to full
     *  collections.  Invoke this method before performing a modification
     *  test.
     */
    public void resetFull() {
<span class="fc" id="L326">        this.setCollection(makeFullCollection());</span>
<span class="fc" id="L327">        this.setConfirmed(makeConfirmedFullCollection());</span>
<span class="fc" id="L328">    }</span>

    //-----------------------------------------------------------------------
    /**
     *  Returns a confirmed empty collection.
     *  For instance, an {@link java.util.ArrayList} for lists or a
     *  {@link java.util.HashSet} for sets.
     *
     *  @return a confirmed empty collection
     */
    public abstract Collection&lt;E&gt; makeConfirmedCollection();

    /**
     *  Returns a confirmed full collection.
     *  For instance, an {@link java.util.ArrayList} for lists or a
     *  {@link java.util.HashSet} for sets.  The returned collection
     *  should contain the elements returned by {@link #getFullElements()}.
     *
     *  @return a confirmed full collection
     */
    public abstract Collection&lt;E&gt; makeConfirmedFullCollection();

    /**
     * Return a new, empty {@link Collection} to be used for testing.
     */
    @Override
    public abstract Collection&lt;E&gt; makeObject();

    /**
     *  Returns a full collection to be used for testing.  The collection
     *  returned by this method should contain every element returned by
     *  {@link #getFullElements()}.  The default implementation, in fact,
     *  simply invokes &lt;code&gt;addAll&lt;/code&gt; on an empty collection with
     *  the results of {@link #getFullElements()}.  Override this default
     *  if your collection doesn't support addAll.
     */
    public Collection&lt;E&gt; makeFullCollection() {
<span class="fc" id="L365">        final Collection&lt;E&gt; c = makeObject();</span>
<span class="fc" id="L366">        c.addAll(Arrays.asList(getFullElements()));</span>
<span class="fc" id="L367">        return c;</span>
    }

    /**
     * Creates a new Map Entry that is independent of the first and the map.
     */
    public Map.Entry&lt;E, E&gt; cloneMapEntry(final Map.Entry&lt;E, E&gt; entry) {
<span class="fc" id="L374">        final HashMap&lt;E, E&gt; map = new HashMap&lt;&gt;();</span>
<span class="fc" id="L375">        map.put(entry.getKey(), entry.getValue());</span>
<span class="fc" id="L376">        return map.entrySet().iterator().next();</span>
    }

    //-----------------------------------------------------------------------
    /**
     *  Returns an array of objects that are contained in a collection
     *  produced by {@link #makeFullCollection()}.  Every element in the
     *  returned array &lt;I&gt;must&lt;/I&gt; be an element in a full collection.&lt;P&gt;
     *  The default implementation returns a heterogenous array of
     *  objects with some duplicates. null is added if allowed.
     *  Override if you require specific testing elements.  Note that if you
     *  override {@link #makeFullCollection()}, you &lt;I&gt;must&lt;/I&gt; override
     *  this method to reflect the contents of a full collection.
     */
    @SuppressWarnings(&quot;unchecked&quot;)
    public E[] getFullElements() {
<span class="fc bfc" id="L392" title="All 2 branches covered.">        if (isNullSupported()) {</span>
<span class="fc" id="L393">            final ArrayList&lt;E&gt; list = new ArrayList&lt;&gt;();</span>
<span class="fc" id="L394">            list.addAll(Arrays.asList(getFullNonNullElements()));</span>
<span class="fc" id="L395">            list.add(4, null);</span>
<span class="fc" id="L396">            return (E[]) list.toArray();</span>
        }
<span class="fc" id="L398">        return getFullNonNullElements().clone();</span>
    }

    /**
     *  Returns an array of elements that are &lt;I&gt;not&lt;/I&gt; contained in a
     *  full collection.  Every element in the returned array must
     *  not exist in a collection returned by {@link #makeFullCollection()}.
     *  The default implementation returns a heterogenous array of elements
     *  without null.  Note that some of the tests add these elements
     *  to an empty or full collection, so if your collection restricts
     *  certain kinds of elements, you should override this method.
     */
    public E[] getOtherElements() {
<span class="fc" id="L411">        return getOtherNonNullElements();</span>
    }

    //-----------------------------------------------------------------------
    /**
     *  Returns a list of elements suitable for return by
     *  {@link #getFullElements()}.  The array returned by this method
     *  does not include null, but does include a variety of objects
     *  of different types.  Override getFullElements to return
     *  the results of this method if your collection does not support
     *  the null element.
     */
    @SuppressWarnings(&quot;unchecked&quot;)
    public E[] getFullNonNullElements() {
<span class="fc" id="L425">        return (E[]) new Object[] {</span>
            new String(&quot;&quot;),
            new String(&quot;One&quot;),
<span class="fc" id="L428">            Integer.valueOf(2),</span>
            &quot;Three&quot;,
<span class="fc" id="L430">            Integer.valueOf(4),</span>
            &quot;One&quot;,
            new Double(5),
            new Float(6),
            &quot;Seven&quot;,
            &quot;Eight&quot;,
            new String(&quot;Nine&quot;),
<span class="fc" id="L437">            Integer.valueOf(10),</span>
            new Short((short)11),
            new Long(12),
            &quot;Thirteen&quot;,
            &quot;14&quot;,
            &quot;15&quot;,
            new Byte((byte)16)
        };
    }

    /**
     *  Returns the default list of objects returned by
     *  {@link #getOtherElements()}.  Includes many objects
     *  of different types.
     */
    @SuppressWarnings(&quot;unchecked&quot;)
    public E[] getOtherNonNullElements() {
<span class="fc" id="L454">        return (E[]) new Object[] {</span>
<span class="fc" id="L455">            Integer.valueOf(0),</span>
            new Float(0),
            new Double(0),
            &quot;Zero&quot;,
            new Short((short)0),
            new Byte((byte)0),
            new Long(0),
            new Character('\u0000'),
            &quot;0&quot;
        };
    }

    /**
     *  Returns a list of string elements suitable for return by
     *  {@link #getFullElements()}.  Override getFullElements to return
     *  the results of this method if your collection does not support
     *  heterogenous elements or the null element.
     */
    public Object[] getFullNonNullStringElements() {
<span class="nc" id="L474">        return new Object[] {</span>
            &quot;If&quot;, &quot;the&quot;, &quot;dull&quot;, &quot;substance&quot;, &quot;of&quot;, &quot;my&quot;, &quot;flesh&quot;, &quot;were&quot;,
                &quot;thought&quot;, &quot;Injurious&quot;, &quot;distance&quot;, &quot;could&quot;, &quot;not&quot;, &quot;stop&quot;, &quot;my&quot;, &quot;way&quot;,
        };
    }

    /**
     *  Returns a list of string elements suitable for return by
     *  {@link #getOtherElements()}.  Override getOtherElements to return
     *  the results of this method if your collection does not support
     *  heterogenous elements or the null element.
     */
    public Object[] getOtherNonNullStringElements() {
<span class="nc" id="L487">        return new Object[] {</span>
            &quot;For&quot;, &quot;then&quot;, &quot;despite&quot;,/* of */&quot;space&quot;, &quot;I&quot;, &quot;would&quot;, &quot;be&quot;,
                &quot;brought&quot;, &quot;From&quot;, &quot;limits&quot;, &quot;far&quot;, &quot;remote&quot;, &quot;where&quot;, &quot;thou&quot;, &quot;dost&quot;, &quot;stay&quot;
        };
    }

    // Tests
    //-----------------------------------------------------------------------
    /**
     *  Tests {@link Collection#add(Object)}.
     */
    public void testCollectionAdd() {
<span class="fc bfc" id="L499" title="All 2 branches covered.">        if (!isAddSupported()) {</span>
<span class="fc" id="L500">            return;</span>
        }

<span class="fc" id="L503">        final E[] elements = getFullElements();</span>
<span class="fc bfc" id="L504" title="All 2 branches covered.">        for (final E element : elements) {</span>
<span class="fc" id="L505">            resetEmpty();</span>
<span class="fc" id="L506">            final boolean r = getCollection().add(element);</span>
<span class="fc" id="L507">            getConfirmed().add(element);</span>
<span class="fc" id="L508">            verify();</span>
<span class="fc" id="L509">            assertTrue(&quot;Empty collection changed after add&quot;, r);</span>
<span class="fc" id="L510">            assertEquals(&quot;Collection size is 1 after first add&quot;, 1, getCollection().size());</span>
        }

<span class="fc" id="L513">        resetEmpty();</span>
<span class="fc" id="L514">        int size = 0;</span>
<span class="fc bfc" id="L515" title="All 2 branches covered.">        for (final E element : elements) {</span>
<span class="fc" id="L516">            final boolean r = getCollection().add(element);</span>
<span class="fc" id="L517">            getConfirmed().add(element);</span>
<span class="fc" id="L518">            verify();</span>
<span class="fc bfc" id="L519" title="All 2 branches covered.">            if (r) {</span>
<span class="fc" id="L520">                size++;</span>
            }
<span class="fc" id="L522">            assertEquals(&quot;Collection size should grow after add&quot;, size, getCollection().size());</span>
<span class="fc" id="L523">            assertTrue(&quot;Collection should contain added element&quot;, getCollection().contains(element));</span>
        }
<span class="fc" id="L525">    }</span>

    /**
     *  Tests {@link Collection#addAll(Collection)}.
     */
    public void testCollectionAddAll() {
<span class="fc bfc" id="L531" title="All 2 branches covered.">        if (!isAddSupported()) {</span>
<span class="fc" id="L532">            return;</span>
        }

<span class="fc" id="L535">        resetEmpty();</span>
<span class="fc" id="L536">        E[] elements = getFullElements();</span>
<span class="fc" id="L537">        boolean r = getCollection().addAll(Arrays.asList(elements));</span>
<span class="fc" id="L538">        getConfirmed().addAll(Arrays.asList(elements));</span>
<span class="fc" id="L539">        verify();</span>
<span class="fc" id="L540">        assertTrue(&quot;Empty collection should change after addAll&quot;, r);</span>
<span class="fc bfc" id="L541" title="All 2 branches covered.">        for (final E element : elements) {</span>
<span class="fc" id="L542">            assertTrue(&quot;Collection should contain added element&quot;, getCollection().contains(element));</span>
        }

<span class="fc" id="L545">        resetFull();</span>
<span class="fc" id="L546">        int size = getCollection().size();</span>
<span class="fc" id="L547">        elements = getOtherElements();</span>
<span class="fc" id="L548">        r = getCollection().addAll(Arrays.asList(elements));</span>
<span class="fc" id="L549">        getConfirmed().addAll(Arrays.asList(elements));</span>
<span class="fc" id="L550">        verify();</span>
<span class="fc" id="L551">        assertTrue(&quot;Full collection should change after addAll&quot;, r);</span>
<span class="fc bfc" id="L552" title="All 2 branches covered.">        for (final E element : elements) {</span>
<span class="fc" id="L553">            assertTrue(&quot;Full collection should contain added element&quot;,</span>
<span class="fc" id="L554">                    getCollection().contains(element));</span>
        }
<span class="fc" id="L556">        assertEquals(&quot;Size should increase after addAll&quot;, size + elements.length, getCollection().size());</span>

<span class="fc" id="L558">        resetFull();</span>
<span class="fc" id="L559">        size = getCollection().size();</span>
<span class="fc" id="L560">        r = getCollection().addAll(Arrays.asList(getFullElements()));</span>
<span class="fc" id="L561">        getConfirmed().addAll(Arrays.asList(getFullElements()));</span>
<span class="fc" id="L562">        verify();</span>
<span class="fc bfc" id="L563" title="All 2 branches covered.">        if (r) {</span>
<span class="pc bpc" id="L564" title="1 of 2 branches missed.">            assertTrue(&quot;Size should increase if addAll returns true&quot;, size &lt; getCollection().size());</span>
        } else {
<span class="fc" id="L566">            assertEquals(&quot;Size should not change if addAll returns false&quot;, size, getCollection().size());</span>
        }
<span class="fc" id="L568">    }</span>

    /**
     *  If {@link #isAddSupported()} returns false, tests that add operations
     *  raise &lt;code&gt;UnsupportedOperationException.
     */
    public void testUnsupportedAdd() {
<span class="fc bfc" id="L575" title="All 2 branches covered.">        if (isAddSupported()) {</span>
<span class="fc" id="L576">            return;</span>
        }

<span class="fc" id="L579">        resetEmpty();</span>
        try {
<span class="nc" id="L581">            getCollection().add(getFullNonNullElements()[0]);</span>
<span class="nc" id="L582">            fail(&quot;Empty collection should not support add.&quot;);</span>
<span class="fc" id="L583">        } catch (final UnsupportedOperationException e) {</span>
            // expected
<span class="nc" id="L585">        }</span>
        // make sure things didn't change even if the expected exception was
        // thrown.
<span class="fc" id="L588">        verify();</span>

        try {
<span class="nc" id="L591">            getCollection().addAll(Arrays.asList(getFullElements()));</span>
<span class="nc" id="L592">            fail(&quot;Empty collection should not support addAll.&quot;);</span>
<span class="fc" id="L593">        } catch (final UnsupportedOperationException e) {</span>
            // expected
<span class="nc" id="L595">        }</span>
        // make sure things didn't change even if the expected exception was
        // thrown.
<span class="fc" id="L598">        verify();</span>

<span class="fc" id="L600">        resetFull();</span>
        try {
<span class="nc" id="L602">            getCollection().add(getFullNonNullElements()[0]);</span>
<span class="nc" id="L603">            fail(&quot;Full collection should not support add.&quot;);</span>
<span class="fc" id="L604">        } catch (final UnsupportedOperationException e) {</span>
            // expected
<span class="nc" id="L606">        }</span>
        // make sure things didn't change even if the expected exception was
        // thrown.
<span class="fc" id="L609">        verify();</span>

        try {
<span class="nc" id="L612">            getCollection().addAll(Arrays.asList(getOtherElements()));</span>
<span class="nc" id="L613">            fail(&quot;Full collection should not support addAll.&quot;);</span>
<span class="fc" id="L614">        } catch (final UnsupportedOperationException e) {</span>
            // expected
<span class="nc" id="L616">        }</span>
        // make sure things didn't change even if the expected exception was
        // thrown.
<span class="fc" id="L619">        verify();</span>
<span class="fc" id="L620">    }</span>

    /**
     *  Test {@link Collection#clear()}.
     */
    public void testCollectionClear() {
<span class="fc bfc" id="L626" title="All 2 branches covered.">        if (!isRemoveSupported()) {</span>
<span class="fc" id="L627">            return;</span>
        }

<span class="fc" id="L630">        resetEmpty();</span>
<span class="fc" id="L631">        getCollection().clear(); // just to make sure it doesn't raise anything</span>
<span class="fc" id="L632">        verify();</span>

<span class="fc" id="L634">        resetFull();</span>
<span class="fc" id="L635">        getCollection().clear();</span>
<span class="fc" id="L636">        getConfirmed().clear();</span>
<span class="fc" id="L637">        verify();</span>
<span class="fc" id="L638">    }</span>

    /**
     *  Tests {@link Collection#contains(Object)}.
     */
    public void testCollectionContains() {
        Object[] elements;

<span class="fc" id="L646">        resetEmpty();</span>
<span class="fc" id="L647">        elements = getFullElements();</span>
<span class="fc bfc" id="L648" title="All 2 branches covered.">        for (int i = 0; i &lt; elements.length; i++) {</span>
<span class="fc" id="L649">            assertTrue(&quot;Empty collection shouldn't contain element[&quot; + i + &quot;]&quot;,</span>
<span class="pc bpc" id="L650" title="1 of 2 branches missed.">                    !getCollection().contains(elements[i]));</span>
        }
        // make sure calls to &quot;contains&quot; don't change anything
<span class="fc" id="L653">        verify();</span>

<span class="fc" id="L655">        elements = getOtherElements();</span>
<span class="fc bfc" id="L656" title="All 2 branches covered.">        for (int i = 0; i &lt; elements.length; i++) {</span>
<span class="fc" id="L657">            assertTrue(&quot;Empty collection shouldn't contain element[&quot; + i + &quot;]&quot;,</span>
<span class="pc bpc" id="L658" title="1 of 2 branches missed.">                    !getCollection().contains(elements[i]));</span>
        }
        // make sure calls to &quot;contains&quot; don't change anything
<span class="fc" id="L661">        verify();</span>

<span class="fc" id="L663">        resetFull();</span>
<span class="fc" id="L664">        elements = getFullElements();</span>
<span class="fc bfc" id="L665" title="All 2 branches covered.">        for (int i = 0; i &lt; elements.length; i++) {</span>
<span class="fc" id="L666">            assertTrue(&quot;Full collection should contain element[&quot; + i + &quot;]&quot;,</span>
<span class="fc" id="L667">                    getCollection().contains(elements[i]));</span>
        }
        // make sure calls to &quot;contains&quot; don't change anything
<span class="fc" id="L670">        verify();</span>

<span class="fc" id="L672">        resetFull();</span>
<span class="fc" id="L673">        elements = getOtherElements();</span>
<span class="fc bfc" id="L674" title="All 2 branches covered.">        for (final Object element : elements) {</span>
<span class="fc" id="L675">            assertTrue(&quot;Full collection shouldn't contain element&quot;,</span>
<span class="pc bpc" id="L676" title="1 of 2 branches missed.">                    !getCollection().contains(element));</span>
        }
<span class="fc" id="L678">    }</span>

    /**
     *  Tests {@link Collection#containsAll(Collection)}.
     */
    public void testCollectionContainsAll() {
<span class="fc" id="L684">        resetEmpty();</span>
<span class="fc" id="L685">        Collection&lt;E&gt; col = new HashSet&lt;&gt;();</span>
<span class="fc" id="L686">        assertTrue(&quot;Every Collection should contain all elements of an &quot; +</span>
<span class="fc" id="L687">                &quot;empty Collection.&quot;, getCollection().containsAll(col));</span>
<span class="fc" id="L688">        col.addAll(Arrays.asList(getOtherElements()));</span>
<span class="fc" id="L689">        assertTrue(&quot;Empty Collection shouldn't contain all elements of &quot; +</span>
<span class="pc bpc" id="L690" title="1 of 2 branches missed.">                &quot;a non-empty Collection.&quot;, !getCollection().containsAll(col));</span>
        // make sure calls to &quot;containsAll&quot; don't change anything
<span class="fc" id="L692">        verify();</span>

<span class="fc" id="L694">        resetFull();</span>
<span class="fc" id="L695">        assertTrue(&quot;Full collection shouldn't contain other elements&quot;,</span>
<span class="pc bpc" id="L696" title="1 of 2 branches missed.">                !getCollection().containsAll(col));</span>

<span class="fc" id="L698">        col.clear();</span>
<span class="fc" id="L699">        col.addAll(Arrays.asList(getFullElements()));</span>
<span class="fc" id="L700">        assertTrue(&quot;Full collection should containAll full elements&quot;,</span>
<span class="fc" id="L701">                getCollection().containsAll(col));</span>
        // make sure calls to &quot;containsAll&quot; don't change anything
<span class="fc" id="L703">        verify();</span>

<span class="fc bfc" id="L705" title="All 2 branches covered.">        final int min = getFullElements().length &lt; 4 ? 0 : 2;</span>
<span class="fc bfc" id="L706" title="All 2 branches covered.">        final int max = getFullElements().length == 1 ? 1 :</span>
<span class="fc bfc" id="L707" title="All 2 branches covered.">                getFullElements().length &lt;= 5 ? getFullElements().length - 1 : 5;</span>
<span class="fc" id="L708">        col = Arrays.asList(getFullElements()).subList(min, max);</span>
<span class="fc" id="L709">        assertTrue(&quot;Full collection should containAll partial full elements&quot;,</span>
<span class="fc" id="L710">                getCollection().containsAll(col));</span>
<span class="fc" id="L711">        assertTrue(&quot;Full collection should containAll itself&quot;, getCollection().containsAll(getCollection()));</span>
        // make sure calls to &quot;containsAll&quot; don't change anything
<span class="fc" id="L713">        verify();</span>

<span class="fc" id="L715">        col = new ArrayList&lt;&gt;();</span>
<span class="fc" id="L716">        col.addAll(Arrays.asList(getFullElements()));</span>
<span class="fc" id="L717">        col.addAll(Arrays.asList(getFullElements()));</span>
<span class="fc" id="L718">        assertTrue(&quot;Full collection should containAll duplicate full elements&quot;,</span>
<span class="fc" id="L719">                getCollection().containsAll(col));</span>

        // make sure calls to &quot;containsAll&quot; don't change anything
<span class="fc" id="L722">        verify();</span>
<span class="fc" id="L723">    }</span>

    /**
     *  Tests {@link Collection#isEmpty()}.
     */
    public void testCollectionIsEmpty() {
<span class="fc" id="L729">        resetEmpty();</span>
<span class="fc" id="L730">        assertEquals(&quot;New Collection should be empty.&quot;, true, getCollection().isEmpty());</span>
        // make sure calls to &quot;isEmpty() don't change anything
<span class="fc" id="L732">        verify();</span>

<span class="fc" id="L734">        resetFull();</span>
<span class="fc" id="L735">        assertEquals(&quot;Full collection shouldn't be empty&quot;, false, getCollection().isEmpty());</span>
        // make sure calls to &quot;isEmpty() don't change anything
<span class="fc" id="L737">        verify();</span>
<span class="fc" id="L738">    }</span>

    /**
     *  Tests the read-only functionality of {@link Collection#iterator()}.
     */
    public void testCollectionIterator() {
<span class="fc" id="L744">        resetEmpty();</span>
<span class="fc" id="L745">        Iterator&lt;E&gt; it1 = getCollection().iterator();</span>
<span class="fc" id="L746">        assertEquals(&quot;Iterator for empty Collection shouldn't have next.&quot;, false, it1.hasNext());</span>
        try {
<span class="nc" id="L748">            it1.next();</span>
<span class="nc" id="L749">            fail(&quot;Iterator at end of Collection should throw &quot;</span>
                    + &quot;NoSuchElementException when next is called.&quot;);
<span class="fc" id="L751">        } catch (final NoSuchElementException e) {</span>
            // expected
<span class="nc" id="L753">        }</span>
        // make sure nothing has changed after non-modification
<span class="fc" id="L755">        verify();</span>

<span class="fc" id="L757">        resetFull();</span>
<span class="fc" id="L758">        it1 = getCollection().iterator();</span>
<span class="fc bfc" id="L759" title="All 2 branches covered.">        for (int i = 0; i &lt; getCollection().size(); i++) {</span>
<span class="fc" id="L760">            assertTrue(&quot;Iterator for full collection should haveNext&quot;, it1.hasNext());</span>
<span class="fc" id="L761">            it1.next();</span>
        }
<span class="pc bpc" id="L763" title="1 of 2 branches missed.">        assertTrue(&quot;Iterator should be finished&quot;, !it1.hasNext());</span>

<span class="fc" id="L765">        final ArrayList&lt;E&gt; list = new ArrayList&lt;&gt;();</span>
<span class="fc" id="L766">        it1 = getCollection().iterator();</span>
<span class="fc bfc" id="L767" title="All 2 branches covered.">        for (int i = 0; i &lt; getCollection().size(); i++) {</span>
<span class="fc" id="L768">            final E next = it1.next();</span>
<span class="fc" id="L769">            assertTrue(&quot;Collection should contain element returned by its iterator&quot;,</span>
<span class="fc" id="L770">                    getCollection().contains(next));</span>
<span class="fc" id="L771">            list.add(next);</span>
        }
        try {
<span class="nc" id="L774">            it1.next();</span>
<span class="nc" id="L775">            fail(&quot;iterator.next() should raise NoSuchElementException after it finishes&quot;);</span>
<span class="fc" id="L776">        } catch (final NoSuchElementException e) {</span>
            // expected
<span class="nc" id="L778">        }</span>
        // make sure nothing has changed after non-modification
<span class="fc" id="L780">        verify();</span>
<span class="fc" id="L781">    }</span>

    /**
     *  Tests removals from {@link Collection#iterator()}.
     */
    @SuppressWarnings(&quot;unchecked&quot;)
    public void testCollectionIteratorRemove() {
<span class="fc bfc" id="L788" title="All 2 branches covered.">        if (!isRemoveSupported()) {</span>
<span class="fc" id="L789">            return;</span>
        }

<span class="fc" id="L792">        resetEmpty();</span>
        try {
<span class="nc" id="L794">            getCollection().iterator().remove();</span>
<span class="nc" id="L795">            fail(&quot;New iterator.remove should raise IllegalState&quot;);</span>
<span class="fc" id="L796">        } catch (final IllegalStateException e) {</span>
            // expected
<span class="nc" id="L798">        }</span>
<span class="fc" id="L799">        verify();</span>

        try {
<span class="fc" id="L802">            final Iterator&lt;E&gt; iter = getCollection().iterator();</span>
<span class="fc" id="L803">            iter.hasNext();</span>
<span class="nc" id="L804">            iter.remove();</span>
<span class="nc" id="L805">            fail(&quot;New iterator.remove should raise IllegalState even after hasNext&quot;);</span>
<span class="fc" id="L806">        } catch (final IllegalStateException e) {</span>
            // expected
<span class="nc" id="L808">        }</span>
<span class="fc" id="L809">        verify();</span>

<span class="fc" id="L811">        resetFull();</span>
<span class="fc" id="L812">        int size = getCollection().size();</span>
<span class="fc" id="L813">        Iterator&lt;E&gt; iter = getCollection().iterator();</span>
<span class="fc bfc" id="L814" title="All 2 branches covered.">        while (iter.hasNext()) {</span>
<span class="fc" id="L815">            Object o = iter.next();</span>
            // TreeMap reuses the Map Entry, so the verify below fails
            // Clone it here if necessary
<span class="fc bfc" id="L818" title="All 2 branches covered.">            if (o instanceof Map.Entry) {</span>
<span class="fc" id="L819">                o = cloneMapEntry((Map.Entry&lt;E, E&gt;) o);</span>
            }
<span class="fc" id="L821">            iter.remove();</span>

            // if the elements aren't distinguishable, we can just remove a
            // matching element from the confirmed collection and verify
            // contents are still the same.  Otherwise, we don't have the
            // ability to distinguish the elements and determine which to
            // remove from the confirmed collection (in which case, we don't
            // verify because we don't know how).
            //
            // see areEqualElementsDistinguishable()
<span class="fc bfc" id="L831" title="All 2 branches covered.">            if (!areEqualElementsDistinguishable()) {</span>
<span class="fc" id="L832">                getConfirmed().remove(o);</span>
<span class="fc" id="L833">                verify();</span>
            }

<span class="fc" id="L836">            size--;</span>
<span class="fc" id="L837">            assertEquals(&quot;Collection should shrink by one after iterator.remove&quot;, size,</span>
<span class="fc" id="L838">                    getCollection().size());</span>
<span class="fc" id="L839">        }</span>
<span class="fc" id="L840">        assertTrue(&quot;Collection should be empty after iterator purge&quot;, getCollection().isEmpty());</span>

<span class="fc" id="L842">        resetFull();</span>
<span class="fc" id="L843">        iter = getCollection().iterator();</span>
<span class="fc" id="L844">        iter.next();</span>
<span class="fc" id="L845">        iter.remove();</span>
        try {
<span class="nc" id="L847">            iter.remove();</span>
<span class="nc" id="L848">            fail(&quot;Second iter.remove should raise IllegalState&quot;);</span>
<span class="fc" id="L849">        } catch (final IllegalStateException e) {</span>
            // expected
<span class="nc" id="L851">        }</span>
<span class="fc" id="L852">    }</span>

    /**
     *  Tests {@link Collection#remove(Object)}.
     */
    public void testCollectionRemove() {
<span class="fc bfc" id="L858" title="All 2 branches covered.">        if (!isRemoveSupported()) {</span>
<span class="fc" id="L859">            return;</span>
        }

<span class="fc" id="L862">        resetEmpty();</span>
<span class="fc" id="L863">        final E[] elements = getFullElements();</span>
<span class="fc bfc" id="L864" title="All 2 branches covered.">        for (final E element : elements) {</span>
<span class="pc bpc" id="L865" title="1 of 2 branches missed.">            assertTrue(&quot;Shouldn't remove nonexistent element&quot;, !getCollection().remove(element));</span>
<span class="fc" id="L866">            verify();</span>
        }

<span class="fc" id="L869">        final E[] other = getOtherElements();</span>

<span class="fc" id="L871">        resetFull();</span>
<span class="fc bfc" id="L872" title="All 2 branches covered.">        for (final E element : other) {</span>
<span class="pc bpc" id="L873" title="1 of 2 branches missed.">            assertTrue(&quot;Shouldn't remove nonexistent other element&quot;, !getCollection().remove(element));</span>
<span class="fc" id="L874">            verify();</span>
        }

<span class="fc" id="L877">        final int size = getCollection().size();</span>
<span class="fc bfc" id="L878" title="All 2 branches covered.">        for (final E element : elements) {</span>
<span class="fc" id="L879">            resetFull();</span>
<span class="fc" id="L880">            assertTrue(&quot;Collection should remove extant element: &quot; + element,</span>
<span class="fc" id="L881">                    getCollection().remove(element));</span>

            // if the elements aren't distinguishable, we can just remove a
            // matching element from the confirmed collection and verify
            // contents are still the same.  Otherwise, we don't have the
            // ability to distinguish the elements and determine which to
            // remove from the confirmed collection (in which case, we don't
            // verify because we don't know how).
            //
            // see areEqualElementsDistinguishable()
<span class="fc bfc" id="L891" title="All 2 branches covered.">            if (!areEqualElementsDistinguishable()) {</span>
<span class="fc" id="L892">                getConfirmed().remove(element);</span>
<span class="fc" id="L893">                verify();</span>
            }

<span class="fc" id="L896">            assertEquals(&quot;Collection should shrink after remove&quot;, size - 1, getCollection().size());</span>
        }
<span class="fc" id="L898">    }</span>

    /**
     *  Tests {@link Collection#removeAll(Collection)}.
     */
    public void testCollectionRemoveAll() {
<span class="fc bfc" id="L904" title="All 2 branches covered.">        if (!isRemoveSupported()) {</span>
<span class="fc" id="L905">            return;</span>
        }

<span class="fc" id="L908">        resetEmpty();</span>
<span class="fc" id="L909">        assertTrue(&quot;Empty collection removeAll should return false for empty input&quot;,</span>
<span class="pc bpc" id="L910" title="1 of 2 branches missed.">                !getCollection().removeAll(Collections.EMPTY_SET));</span>
<span class="fc" id="L911">        verify();</span>

<span class="fc" id="L913">        assertTrue(&quot;Empty collection removeAll should return false for nonempty input&quot;,</span>
<span class="pc bpc" id="L914" title="1 of 2 branches missed.">                   !getCollection().removeAll(new ArrayList&lt;&gt;(getCollection())));</span>
<span class="fc" id="L915">        verify();</span>

<span class="fc" id="L917">        resetFull();</span>
<span class="fc" id="L918">        assertTrue(&quot;Full collection removeAll should return false for empty input&quot;,</span>
<span class="pc bpc" id="L919" title="1 of 2 branches missed.">                   !getCollection().removeAll(Collections.EMPTY_SET));</span>
<span class="fc" id="L920">        verify();</span>

<span class="fc" id="L922">        assertTrue(&quot;Full collection removeAll should return false for other elements&quot;,</span>
<span class="pc bpc" id="L923" title="1 of 2 branches missed.">                   !getCollection().removeAll(Arrays.asList(getOtherElements())));</span>
<span class="fc" id="L924">        verify();</span>

<span class="fc" id="L926">        assertTrue(&quot;Full collection removeAll should return true for full elements&quot;,</span>
<span class="fc" id="L927">                getCollection().removeAll(new HashSet&lt;&gt;(getCollection())));</span>
<span class="fc" id="L928">        getConfirmed().removeAll(new HashSet&lt;&gt;(getConfirmed()));</span>
<span class="fc" id="L929">        verify();</span>

<span class="fc" id="L931">        resetFull();</span>
<span class="fc" id="L932">        final int size = getCollection().size();</span>
<span class="fc bfc" id="L933" title="All 2 branches covered.">        final int min = getFullElements().length &lt; 4 ? 0 : 2;</span>
<span class="pc bpc" id="L934" title="1 of 2 branches missed.">        final int max = getFullElements().length == 1 ? 1 :</span>
<span class="fc bfc" id="L935" title="All 2 branches covered.">                getFullElements().length &lt;= 5 ? getFullElements().length - 1 : 5;</span>
<span class="fc" id="L936">        final Collection&lt;E&gt; all = Arrays.asList(getFullElements()).subList(min, max);</span>
<span class="fc" id="L937">        assertTrue(&quot;Full collection removeAll should work&quot;, getCollection().removeAll(all));</span>
<span class="fc" id="L938">        getConfirmed().removeAll(all);</span>
<span class="fc" id="L939">        verify();</span>

<span class="pc bpc" id="L941" title="1 of 2 branches missed.">        assertTrue(&quot;Collection should shrink after removeAll&quot;, getCollection().size() &lt; size);</span>
<span class="fc bfc" id="L942" title="All 2 branches covered.">        for (final E element : all) {</span>
<span class="pc bpc" id="L943" title="1 of 2 branches missed.">            assertTrue(&quot;Collection shouldn't contain removed element&quot;, !getCollection().contains(element));</span>
<span class="fc" id="L944">        }</span>
<span class="fc" id="L945">    }</span>

    /**
     *  Tests {@link Collection#retainAll(Collection)}.
     */
    public void testCollectionRetainAll() {
<span class="fc bfc" id="L951" title="All 2 branches covered.">        if (!isRemoveSupported()) {</span>
<span class="fc" id="L952">            return;</span>
        }

<span class="fc" id="L955">        resetEmpty();</span>
<span class="fc" id="L956">        final List&lt;E&gt; elements = Arrays.asList(getFullElements());</span>
<span class="fc" id="L957">        final List&lt;E&gt; other = Arrays.asList(getOtherElements());</span>

<span class="fc" id="L959">        assertTrue(&quot;Empty retainAll() should return false&quot;,</span>
<span class="pc bpc" id="L960" title="1 of 2 branches missed.">                !getCollection().retainAll(Collections.EMPTY_SET));</span>
<span class="fc" id="L961">        verify();</span>

<span class="pc bpc" id="L963" title="1 of 2 branches missed.">        assertTrue(&quot;Empty retainAll() should return false&quot;, !getCollection().retainAll(elements));</span>
<span class="fc" id="L964">        verify();</span>

<span class="fc" id="L966">        resetFull();</span>
<span class="fc" id="L967">        assertTrue(&quot;Collection should change from retainAll empty&quot;,</span>
<span class="fc" id="L968">                getCollection().retainAll(Collections.EMPTY_SET));</span>
<span class="fc" id="L969">        getConfirmed().retainAll(Collections.EMPTY_SET);</span>
<span class="fc" id="L970">        verify();</span>

<span class="fc" id="L972">        resetFull();</span>
<span class="fc" id="L973">        assertTrue(&quot;Collection changed from retainAll other&quot;, getCollection().retainAll(other));</span>
<span class="fc" id="L974">        getConfirmed().retainAll(other);</span>
<span class="fc" id="L975">        verify();</span>

<span class="fc" id="L977">        resetFull();</span>
<span class="fc" id="L978">        int size = getCollection().size();</span>
<span class="fc" id="L979">        assertTrue(&quot;Collection shouldn't change from retainAll elements&quot;,</span>
<span class="pc bpc" id="L980" title="1 of 2 branches missed.">                   !getCollection().retainAll(elements));</span>
<span class="fc" id="L981">        verify();</span>
<span class="fc" id="L982">        assertEquals(&quot;Collection size shouldn't change&quot;, size, getCollection().size());</span>

<span class="pc bpc" id="L984" title="1 of 2 branches missed.">        if (getFullElements().length &gt; 1) {</span>
<span class="fc" id="L985">            resetFull();</span>
<span class="fc" id="L986">            size = getCollection().size();</span>
<span class="fc bfc" id="L987" title="All 2 branches covered.">            final int min = getFullElements().length &lt; 4 ? 0 : 2;</span>
<span class="fc bfc" id="L988" title="All 2 branches covered.">            final int max = getFullElements().length &lt;= 5 ? getFullElements().length - 1 : 5;</span>
<span class="fc" id="L989">            assertTrue(&quot;Collection should changed by partial retainAll&quot;,</span>
<span class="fc" id="L990">                    getCollection().retainAll(elements.subList(min, max)));</span>
<span class="fc" id="L991">            getConfirmed().retainAll(elements.subList(min, max));</span>
<span class="fc" id="L992">            verify();</span>

<span class="fc bfc" id="L994" title="All 2 branches covered.">            for (final E element : getCollection()) {</span>
<span class="fc" id="L995">                assertTrue(&quot;Collection only contains retained element&quot;, elements.subList(min, max).contains(element));</span>
<span class="fc" id="L996">            }</span>
        }

<span class="fc" id="L999">        resetFull();</span>
<span class="fc" id="L1000">        final HashSet&lt;E&gt; set = new HashSet&lt;&gt;(elements);</span>
<span class="fc" id="L1001">        size = getCollection().size();</span>
<span class="fc" id="L1002">        assertTrue(&quot;Collection shouldn't change from retainAll without &quot; +</span>
<span class="pc bpc" id="L1003" title="1 of 2 branches missed.">                   &quot;duplicate elements&quot;, !getCollection().retainAll(set));</span>
<span class="fc" id="L1004">        verify();</span>
<span class="fc" id="L1005">        assertEquals(&quot;Collection size didn't change from nonduplicate &quot; +</span>
<span class="fc" id="L1006">                     &quot;retainAll&quot;, size, getCollection().size());</span>
<span class="fc" id="L1007">    }</span>

    /**
     *  Tests {@link Collection#size()}.
     */
    public void testCollectionSize() {
<span class="fc" id="L1013">        resetEmpty();</span>
<span class="fc" id="L1014">        assertEquals(&quot;Size of new Collection is 0.&quot;, 0, getCollection().size());</span>

<span class="fc" id="L1016">        resetFull();</span>
<span class="pc bpc" id="L1017" title="1 of 2 branches missed.">        assertTrue(&quot;Size of full collection should be greater than zero&quot;, getCollection().size() &gt; 0);</span>
<span class="fc" id="L1018">    }</span>

    /**
     *  Tests {@link Collection#toArray()}.
     */
    public void testCollectionToArray() {
<span class="fc" id="L1024">        resetEmpty();</span>
<span class="fc" id="L1025">        assertEquals(&quot;Empty Collection should return empty array for toArray&quot;,</span>
<span class="fc" id="L1026">                     0, getCollection().toArray().length);</span>

<span class="fc" id="L1028">        resetFull();</span>
<span class="fc" id="L1029">        final Object[] array = getCollection().toArray();</span>
<span class="fc" id="L1030">        assertEquals(&quot;Full collection toArray should be same size as collection&quot;,</span>
<span class="fc" id="L1031">                array.length, getCollection().size());</span>
<span class="fc" id="L1032">        final Object[] confirmedArray = getConfirmed().toArray();</span>
<span class="fc" id="L1033">        assertEquals(&quot;length of array from confirmed collection should &quot;</span>
                + &quot;match the length of the collection's array&quot;, confirmedArray.length, array.length);
<span class="fc" id="L1035">        final boolean[] matched = new boolean[array.length];</span>

<span class="fc bfc" id="L1037" title="All 2 branches covered.">        for (int i = 0; i &lt; array.length; i++) {</span>
<span class="fc" id="L1038">            assertTrue(&quot;Collection should contain element in toArray&quot;,</span>
<span class="fc" id="L1039">                    getCollection().contains(array[i]));</span>

<span class="fc" id="L1041">            boolean match = false;</span>
            // find a match in the confirmed array
<span class="pc bpc" id="L1043" title="1 of 2 branches missed.">            for (int j = 0; j &lt; array.length; j++) {</span>
                // skip already matched
<span class="fc bfc" id="L1045" title="All 2 branches covered.">                if (matched[j]) {</span>
<span class="fc" id="L1046">                    continue;</span>
                }
<span class="fc bfc" id="L1048" title="All 4 branches covered.">                if (array[i] == confirmedArray[j]</span>
<span class="fc bfc" id="L1049" title="All 2 branches covered.">                        || array[i] != null &amp;&amp; array[i].equals(confirmedArray[j])) {</span>
<span class="fc" id="L1050">                    matched[j] = true;</span>
<span class="fc" id="L1051">                    match = true;</span>
<span class="fc" id="L1052">                    break;</span>
                }
            }
<span class="pc bpc" id="L1055" title="1 of 2 branches missed.">            if (!match) {</span>
<span class="nc" id="L1056">                fail(&quot;element &quot; + i + &quot; in returned array should be found &quot;</span>
                        + &quot;in the confirmed collection's array&quot;);
            }
        }
<span class="fc bfc" id="L1060" title="All 2 branches covered.">        for (final boolean element : matched) {</span>
<span class="fc" id="L1061">            assertEquals(&quot;Collection should return all its elements in &quot; + &quot;toArray&quot;, true,</span>
                    element);
        }
<span class="fc" id="L1064">    }</span>

    /**
     *  Tests {@link Collection#toArray(Object[])}.
     */
    public void testCollectionToArray2() {
<span class="fc" id="L1070">        resetEmpty();</span>
<span class="fc" id="L1071">        Object[] a = new Object[] { new Object(), null, null };</span>
<span class="fc" id="L1072">        Object[] array = getCollection().toArray(a);</span>
<span class="fc" id="L1073">        assertEquals(&quot;Given array shouldn't shrink&quot;, array, a);</span>
<span class="fc" id="L1074">        assertNull(&quot;Last element should be set to null&quot;, a[0]);</span>
<span class="fc" id="L1075">        verify();</span>

<span class="fc" id="L1077">        resetFull();</span>
        try {
<span class="nc" id="L1079">            array = getCollection().toArray(new Void[0]);</span>
<span class="nc" id="L1080">            fail(&quot;toArray(new Void[0]) should raise ArrayStore&quot;);</span>
<span class="fc" id="L1081">        } catch (final ArrayStoreException e) {</span>
            // expected
<span class="nc" id="L1083">        }</span>
<span class="fc" id="L1084">        verify();</span>

        try {
            // Casting to Object[] allows compilation on Java 11.
<span class="nc" id="L1088">            array = getCollection().toArray((Object[]) null);</span>
<span class="nc" id="L1089">            fail(&quot;toArray(null) should raise NPE&quot;);</span>
<span class="fc" id="L1090">        } catch (final NullPointerException e) {</span>
            // expected
<span class="nc" id="L1092">        }</span>
<span class="fc" id="L1093">        verify();</span>

<span class="fc" id="L1095">        array = getCollection().toArray(new Object[0]);</span>
<span class="fc" id="L1096">        a = getCollection().toArray();</span>
<span class="fc" id="L1097">        assertEquals(&quot;toArrays should be equal&quot;,</span>
<span class="fc" id="L1098">                     Arrays.asList(array), Arrays.asList(a));</span>

        // Figure out if they're all the same class
        // TODO: It'd be nicer to detect a common superclass
<span class="fc" id="L1102">        final HashSet&lt;Class&lt;?&gt;&gt; classes = new HashSet&lt;&gt;();</span>
<span class="fc bfc" id="L1103" title="All 2 branches covered.">        for (final Object element : array) {</span>
<span class="fc bfc" id="L1104" title="All 2 branches covered.">            classes.add(element == null ? null : element.getClass());</span>
        }
<span class="fc bfc" id="L1106" title="All 2 branches covered.">        if (classes.size() &gt; 1) {</span>
<span class="fc" id="L1107">            return;</span>
        }

<span class="fc" id="L1110">        Class&lt;?&gt; cl = classes.iterator().next();</span>
<span class="fc bfc" id="L1111" title="All 2 branches covered.">        if (Map.Entry.class.isAssignableFrom(cl)) {  // check needed for protective cases like Predicated/Unmod map entrySet</span>
<span class="fc" id="L1112">            cl = Map.Entry.class;</span>
        }
<span class="fc" id="L1114">        a = (Object[]) Array.newInstance(cl, 0);</span>
<span class="fc" id="L1115">        array = getCollection().toArray(a);</span>
<span class="fc" id="L1116">        assertEquals(&quot;toArray(Object[]) should return correct array type&quot;,</span>
<span class="fc" id="L1117">                a.getClass(), array.getClass());</span>
<span class="fc" id="L1118">        assertEquals(&quot;type-specific toArrays should be equal&quot;,</span>
<span class="fc" id="L1119">                Arrays.asList(array),</span>
<span class="fc" id="L1120">                Arrays.asList(getCollection().toArray()));</span>
<span class="fc" id="L1121">        verify();</span>
<span class="fc" id="L1122">    }</span>

    /**
     *  Tests &lt;code&gt;toString&lt;/code&gt; on a collection.
     */
    public void testCollectionToString() {
<span class="fc" id="L1128">        resetEmpty();</span>
<span class="pc bpc" id="L1129" title="1 of 2 branches missed.">        assertTrue(&quot;toString shouldn't return null&quot;, getCollection().toString() != null);</span>

<span class="fc" id="L1131">        resetFull();</span>
<span class="pc bpc" id="L1132" title="1 of 2 branches missed.">        assertTrue(&quot;toString shouldn't return null&quot;, getCollection().toString() != null);</span>
<span class="fc" id="L1133">    }</span>

    /**
     *  If isRemoveSupported() returns false, tests to see that remove
     *  operations raise an UnsupportedOperationException.
     */
    public void testUnsupportedRemove() {
<span class="fc bfc" id="L1140" title="All 2 branches covered.">        if (isRemoveSupported()) {</span>
<span class="fc" id="L1141">            return;</span>
        }

<span class="fc" id="L1144">        resetEmpty();</span>
        try {
<span class="nc" id="L1146">            getCollection().clear();</span>
<span class="nc" id="L1147">            fail(&quot;clear should raise UnsupportedOperationException&quot;);</span>
<span class="fc" id="L1148">        } catch (final UnsupportedOperationException e) {</span>
            // expected
<span class="nc" id="L1150">        }</span>
<span class="fc" id="L1151">        verify();</span>

        try {
<span class="nc" id="L1154">            getCollection().remove(null);</span>
<span class="nc" id="L1155">            fail(&quot;remove should raise UnsupportedOperationException&quot;);</span>
<span class="fc" id="L1156">        } catch (final UnsupportedOperationException e) {</span>
            // expected
<span class="nc" id="L1158">        }</span>
<span class="fc" id="L1159">        verify();</span>

        try {
<span class="nc" id="L1162">            getCollection().removeAll(null);</span>
<span class="nc" id="L1163">            fail(&quot;removeAll should raise UnsupportedOperationException&quot;);</span>
<span class="fc" id="L1164">        } catch (final UnsupportedOperationException e) {</span>
            // expected
<span class="nc" id="L1166">        }</span>
<span class="fc" id="L1167">        verify();</span>

        try {
<span class="nc" id="L1170">            getCollection().retainAll(null);</span>
<span class="nc" id="L1171">            fail(&quot;retainAll should raise UnsupportedOperationException&quot;);</span>
<span class="fc" id="L1172">        } catch (final UnsupportedOperationException e) {</span>
            // expected
<span class="nc" id="L1174">        }</span>
<span class="fc" id="L1175">        verify();</span>

<span class="fc" id="L1177">        resetFull();</span>
        try {
<span class="fc" id="L1179">            final Iterator&lt;E&gt; iterator = getCollection().iterator();</span>
<span class="fc" id="L1180">            iterator.next();</span>
<span class="nc" id="L1181">            iterator.remove();</span>
<span class="nc" id="L1182">            fail(&quot;iterator.remove should raise UnsupportedOperationException&quot;);</span>
<span class="fc" id="L1183">        } catch (final UnsupportedOperationException e) {</span>
            // expected
<span class="nc" id="L1185">        }</span>
<span class="fc" id="L1186">        verify();</span>

<span class="fc" id="L1188">    }</span>

    /**
     *  Tests that the collection's iterator is fail-fast.
     */
    public void testCollectionIteratorFailFast() {
<span class="pc bpc" id="L1194" title="1 of 2 branches missed.">        if (!isFailFastSupported()) {</span>
<span class="fc" id="L1195">            return;</span>
        }

<span class="nc bnc" id="L1198" title="All 2 branches missed.">        if (isAddSupported()) {</span>
<span class="nc" id="L1199">            resetFull();</span>
            try {
<span class="nc" id="L1201">                final Iterator&lt;E&gt; iter = getCollection().iterator();</span>
<span class="nc" id="L1202">                final E o = getOtherElements()[0];</span>
<span class="nc" id="L1203">                getCollection().add(o);</span>
<span class="nc" id="L1204">                getConfirmed().add(o);</span>
<span class="nc" id="L1205">                iter.next();</span>
<span class="nc" id="L1206">                fail(&quot;next after add should raise ConcurrentModification&quot;);</span>
<span class="nc" id="L1207">            } catch (final ConcurrentModificationException e) {</span>
                // expected
<span class="nc" id="L1209">            }</span>
<span class="nc" id="L1210">            verify();</span>

<span class="nc" id="L1212">            resetFull();</span>
            try {
<span class="nc" id="L1214">                final Iterator&lt;E&gt; iter = getCollection().iterator();</span>
<span class="nc" id="L1215">                getCollection().addAll(Arrays.asList(getOtherElements()));</span>
<span class="nc" id="L1216">                getConfirmed().addAll(Arrays.asList(getOtherElements()));</span>
<span class="nc" id="L1217">                iter.next();</span>
<span class="nc" id="L1218">                fail(&quot;next after addAll should raise ConcurrentModification&quot;);</span>
<span class="nc" id="L1219">            } catch (final ConcurrentModificationException e) {</span>
                // expected
<span class="nc" id="L1221">            }</span>
<span class="nc" id="L1222">            verify();</span>
        }

<span class="nc bnc" id="L1225" title="All 2 branches missed.">        if (!isRemoveSupported()) {</span>
<span class="nc" id="L1226">            return;</span>
        }

<span class="nc" id="L1229">        resetFull();</span>
        try {
<span class="nc" id="L1231">            final Iterator&lt;E&gt; iter = getCollection().iterator();</span>
<span class="nc" id="L1232">            getCollection().clear();</span>
<span class="nc" id="L1233">            iter.next();</span>
<span class="nc" id="L1234">            fail(&quot;next after clear should raise ConcurrentModification&quot;);</span>
<span class="nc" id="L1235">        } catch (final ConcurrentModificationException e) {</span>
            // expected
<span class="nc" id="L1237">        } catch (final NoSuchElementException e) {</span>
            // (also legal given spec)
<span class="nc" id="L1239">        }</span>

<span class="nc" id="L1241">        resetFull();</span>
        try {
<span class="nc" id="L1243">            final Iterator&lt;E&gt; iter = getCollection().iterator();</span>
<span class="nc" id="L1244">            getCollection().remove(getFullElements()[0]);</span>
<span class="nc" id="L1245">            iter.next();</span>
<span class="nc" id="L1246">            fail(&quot;next after remove should raise ConcurrentModification&quot;);</span>
<span class="nc" id="L1247">        } catch (final ConcurrentModificationException e) {</span>
            // expected
<span class="nc" id="L1249">        }</span>

<span class="nc" id="L1251">        resetFull();</span>
        try {
<span class="nc" id="L1253">            final Iterator&lt;E&gt; iter = getCollection().iterator();</span>
<span class="nc" id="L1254">            final List&lt;E&gt; sublist = Arrays.asList(getFullElements()).subList(2,5);</span>
<span class="nc" id="L1255">            getCollection().removeAll(sublist);</span>
<span class="nc" id="L1256">            iter.next();</span>
<span class="nc" id="L1257">            fail(&quot;next after removeAll should raise ConcurrentModification&quot;);</span>
<span class="nc" id="L1258">        } catch (final ConcurrentModificationException e) {</span>
            // expected
<span class="nc" id="L1260">        }</span>

<span class="nc" id="L1262">        resetFull();</span>
        try {
<span class="nc" id="L1264">            final Iterator&lt;E&gt; iter = getCollection().iterator();</span>
<span class="nc" id="L1265">            final List&lt;E&gt; sublist = Arrays.asList(getFullElements()).subList(2,5);</span>
<span class="nc" id="L1266">            getCollection().retainAll(sublist);</span>
<span class="nc" id="L1267">            iter.next();</span>
<span class="nc" id="L1268">            fail(&quot;next after retainAll should raise ConcurrentModification&quot;);</span>
<span class="nc" id="L1269">        } catch (final ConcurrentModificationException e) {</span>
            // expected
<span class="nc" id="L1271">        }</span>
<span class="nc" id="L1272">    }</span>

    @Override
    public void testSerializeDeserializeThenCompare() throws Exception {
<span class="fc" id="L1276">        Object obj = makeObject();</span>
<span class="fc bfc" id="L1277" title="All 4 branches covered.">        if (obj instanceof Serializable &amp;&amp; isTestSerialization()) {</span>
<span class="fc" id="L1278">            final ByteArrayOutputStream buffer = new ByteArrayOutputStream();</span>
<span class="fc" id="L1279">            final ObjectOutputStream out = new ObjectOutputStream(buffer);</span>
<span class="fc" id="L1280">            out.writeObject(obj);</span>
<span class="fc" id="L1281">            out.close();</span>

<span class="fc" id="L1283">            final ObjectInputStream in = new ObjectInputStream(new ByteArrayInputStream(buffer.toByteArray()));</span>
<span class="fc" id="L1284">            final Object dest = in.readObject();</span>
<span class="fc" id="L1285">            in.close();</span>
<span class="fc bfc" id="L1286" title="All 2 branches covered.">            if (isEqualsCheckable()) {</span>
<span class="fc" id="L1287">                assertEquals(&quot;obj != deserialize(serialize(obj)) - EMPTY Collection&quot;, obj, dest);</span>
            }
        }
<span class="fc" id="L1290">        obj = makeFullCollection();</span>
<span class="fc bfc" id="L1291" title="All 4 branches covered.">        if (obj instanceof Serializable &amp;&amp; isTestSerialization()) {</span>
<span class="fc" id="L1292">            final ByteArrayOutputStream buffer = new ByteArrayOutputStream();</span>
<span class="fc" id="L1293">            final ObjectOutputStream out = new ObjectOutputStream(buffer);</span>
<span class="fc" id="L1294">            out.writeObject(obj);</span>
<span class="fc" id="L1295">            out.close();</span>

<span class="fc" id="L1297">            final ObjectInputStream in = new ObjectInputStream(new ByteArrayInputStream(buffer.toByteArray()));</span>
<span class="fc" id="L1298">            final Object dest = in.readObject();</span>
<span class="fc" id="L1299">            in.close();</span>
<span class="fc bfc" id="L1300" title="All 2 branches covered.">            if (isEqualsCheckable()) {</span>
<span class="fc" id="L1301">                assertEquals(&quot;obj != deserialize(serialize(obj)) - FULL Collection&quot;, obj, dest);</span>
            }
        }
<span class="fc" id="L1304">    }</span>

    public Collection&lt;E&gt; getCollection() {
<span class="fc" id="L1307">        return collection;</span>
    }

    /**
     * Set the collection.
     * @param collection the Collection&lt;E&gt; to set
     */
    public void setCollection(final Collection&lt;E&gt; collection) {
<span class="fc" id="L1315">        this.collection = collection;</span>
<span class="fc" id="L1316">    }</span>

    public Collection&lt;E&gt; getConfirmed() {
<span class="fc" id="L1319">        return confirmed;</span>
    }

    /**
     * Set the confirmed.
     * @param confirmed the Collection&lt;E&gt; to set
     */
    public void setConfirmed(final Collection&lt;E&gt; confirmed) {
<span class="fc" id="L1327">        this.confirmed = confirmed;</span>
<span class="fc" id="L1328">    }</span>

    /**
     * Handle the optional exceptions declared by {@link Collection#contains(Object)}
     * @param coll
     * @param element
     */
    protected static void assertNotCollectionContains(final Collection&lt;?&gt; coll, final Object element) {
        try {
<span class="nc" id="L1337">            assertFalse(coll.contains(element));</span>
<span class="nc" id="L1338">        } catch (final ClassCastException e) {</span>
            //apparently not
<span class="nc" id="L1340">        } catch (final NullPointerException e) {</span>
            //apparently not
<span class="nc" id="L1342">        }</span>
<span class="nc" id="L1343">    }</span>

    /**
     * Handle the optional exceptions declared by {@link Collection#containsAll(Collection)}
     * @param coll
     * @param sub
     */
    protected static void assertNotCollectionContainsAll(final Collection&lt;?&gt; coll, final Collection&lt;?&gt; sub) {
        try {
<span class="nc" id="L1352">            assertFalse(coll.containsAll(sub));</span>
<span class="nc" id="L1353">        } catch (final ClassCastException cce) {</span>
            //apparently not
<span class="nc" id="L1355">        } catch (final NullPointerException e) {</span>
            //apparently not
<span class="nc" id="L1357">        }</span>
<span class="nc" id="L1358">    }</span>

    /**
     * Handle optional exceptions of {@link Collection#remove(Object)}
     * @param coll
     * @param element
     */
    protected static void assertNotRemoveFromCollection(final Collection&lt;?&gt; coll, final Object element) {
        try {
<span class="nc" id="L1367">            assertFalse(coll.remove(element));</span>
<span class="nc" id="L1368">        } catch (final ClassCastException cce) {</span>
            //apparently not
<span class="nc" id="L1370">        } catch (final NullPointerException e) {</span>
            //apparently not
<span class="nc" id="L1372">        }</span>
<span class="nc" id="L1373">    }</span>

    /**
     * Handle optional exceptions of {@link Collection#removeAll(Collection)}
     * @param coll
     * @param sub
     */
    protected static void assertNotRemoveAllFromCollection(final Collection&lt;?&gt; coll, final Collection&lt;?&gt; sub) {
        try {
<span class="nc" id="L1382">            assertFalse(coll.removeAll(sub));</span>
<span class="nc" id="L1383">        } catch (final ClassCastException cce) {</span>
            //apparently not
<span class="nc" id="L1385">        } catch (final NullPointerException e) {</span>
            //apparently not
<span class="nc" id="L1387">        }</span>
<span class="nc" id="L1388">    }</span>
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.1.201803210924</span></div></body></html>