<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>CMAESOptimizerTest.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">commons_math4$All_in_commons_math4.exec</a> &gt; <a href="index.source.html" class="el_package">org.apache.commons.math4.optim.nonlinear.scalar.noderiv</a> &gt; <span class="el_source">CMAESOptimizerTest.java</span></div><h1>CMAESOptimizerTest.java</h1><pre class="source lang-java linenums">/*
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the &quot;License&quot;); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.commons.math4.optim.nonlinear.scalar.noderiv;

import java.util.Arrays;
import java.util.Random;

import org.apache.commons.math4.Retry;
import org.apache.commons.math4.RetryRunner;
import org.apache.commons.math4.analysis.MultivariateFunction;
import org.apache.commons.math4.exception.DimensionMismatchException;
import org.apache.commons.math4.exception.NotPositiveException;
import org.apache.commons.math4.exception.NumberIsTooLargeException;
import org.apache.commons.math4.exception.NumberIsTooSmallException;
import org.apache.commons.math4.exception.OutOfRangeException;
import org.apache.commons.math4.optim.InitialGuess;
import org.apache.commons.math4.optim.MaxEval;
import org.apache.commons.math4.optim.PointValuePair;
import org.apache.commons.math4.optim.SimpleBounds;
import org.apache.commons.math4.optim.nonlinear.scalar.GoalType;
import org.apache.commons.math4.optim.nonlinear.scalar.ObjectiveFunction;
import org.apache.commons.math4.optim.nonlinear.scalar.noderiv.CMAESOptimizer;
import org.apache.commons.rng.simple.RandomSource;
import org.apache.commons.math4.util.FastMath;
import org.junit.Assert;
import org.junit.Test;
import org.junit.runner.RunWith;

/**
 * Test for {@link CMAESOptimizer}.
 */
@RunWith(RetryRunner.class)
<span class="fc" id="L47">public class CMAESOptimizerTest {</span>

    static final int DIM = 13;
<span class="fc" id="L50">    static final int LAMBDA = 4 + (int)(3.*FastMath.log(DIM));</span>

    @Test(expected = NumberIsTooLargeException.class)
    public void testInitOutofbounds1() {
<span class="fc" id="L54">        double[] startPoint = point(DIM,3);</span>
<span class="fc" id="L55">        double[] insigma = point(DIM, 0.3);</span>
<span class="fc" id="L56">        double[][] boundaries = boundaries(DIM,-1,2);</span>
<span class="fc" id="L57">        PointValuePair expected =</span>
<span class="fc" id="L58">            new PointValuePair(point(DIM,1.0),0.0);</span>
<span class="nc" id="L59">        doTest(new Rosen(), startPoint, insigma, boundaries,</span>
                GoalType.MINIMIZE, LAMBDA, true, 0, 1e-13,
                1e-13, 1e-6, 100000, expected);
<span class="nc" id="L62">    }</span>
    @Test(expected = NumberIsTooSmallException.class)
    public void testInitOutofbounds2() {
<span class="fc" id="L65">        double[] startPoint = point(DIM, -2);</span>
<span class="fc" id="L66">        double[] insigma = point(DIM, 0.3);</span>
<span class="fc" id="L67">        double[][] boundaries = boundaries(DIM,-1,2);</span>
<span class="fc" id="L68">        PointValuePair expected =</span>
<span class="fc" id="L69">            new PointValuePair(point(DIM,1.0),0.0);</span>
<span class="nc" id="L70">        doTest(new Rosen(), startPoint, insigma, boundaries,</span>
                GoalType.MINIMIZE, LAMBDA, true, 0, 1e-13,
                1e-13, 1e-6, 100000, expected);
<span class="nc" id="L73">    }</span>

    @Test(expected = DimensionMismatchException.class)
    public void testBoundariesDimensionMismatch() {
<span class="fc" id="L77">        double[] startPoint = point(DIM,0.5);</span>
<span class="fc" id="L78">        double[] insigma = point(DIM, 0.3);</span>
<span class="fc" id="L79">        double[][] boundaries = boundaries(DIM+1,-1,2);</span>
<span class="fc" id="L80">        PointValuePair expected =</span>
<span class="fc" id="L81">            new PointValuePair(point(DIM,1.0),0.0);</span>
<span class="nc" id="L82">        doTest(new Rosen(), startPoint, insigma, boundaries,</span>
                GoalType.MINIMIZE, LAMBDA, true, 0, 1e-13,
                1e-13, 1e-6, 100000, expected);
<span class="nc" id="L85">    }</span>

    @Test(expected = NotPositiveException.class)
    public void testInputSigmaNegative() {
<span class="fc" id="L89">        double[] startPoint = point(DIM,0.5);</span>
<span class="fc" id="L90">        double[] insigma = point(DIM,-0.5);</span>
<span class="fc" id="L91">        double[][] boundaries = null;</span>
<span class="fc" id="L92">        PointValuePair expected =</span>
<span class="fc" id="L93">            new PointValuePair(point(DIM,1.0),0.0);</span>
<span class="nc" id="L94">        doTest(new Rosen(), startPoint, insigma, boundaries,</span>
                GoalType.MINIMIZE, LAMBDA, true, 0, 1e-13,
                1e-13, 1e-6, 100000, expected);
<span class="nc" id="L97">    }</span>

    @Test(expected = OutOfRangeException.class)
    public void testInputSigmaOutOfRange() {
<span class="fc" id="L101">        double[] startPoint = point(DIM,0.5);</span>
<span class="fc" id="L102">        double[] insigma = point(DIM, 1.1);</span>
<span class="fc" id="L103">        double[][] boundaries = boundaries(DIM,-0.5,0.5);</span>
<span class="fc" id="L104">        PointValuePair expected =</span>
<span class="fc" id="L105">            new PointValuePair(point(DIM,1.0),0.0);</span>
<span class="nc" id="L106">        doTest(new Rosen(), startPoint, insigma, boundaries,</span>
                GoalType.MINIMIZE, LAMBDA, true, 0, 1e-13,
                1e-13, 1e-6, 100000, expected);
<span class="nc" id="L109">    }</span>

    @Test(expected = DimensionMismatchException.class)
    public void testInputSigmaDimensionMismatch() {
<span class="fc" id="L113">        double[] startPoint = point(DIM,0.5);</span>
<span class="fc" id="L114">        double[] insigma = point(DIM + 1, 0.5);</span>
<span class="fc" id="L115">        double[][] boundaries = null;</span>
<span class="fc" id="L116">        PointValuePair expected =</span>
<span class="fc" id="L117">            new PointValuePair(point(DIM,1.0),0.0);</span>
<span class="nc" id="L118">        doTest(new Rosen(), startPoint, insigma, boundaries,</span>
                GoalType.MINIMIZE, LAMBDA, true, 0, 1e-13,
                1e-13, 1e-6, 100000, expected);
<span class="nc" id="L121">    }</span>

    @Test
    @Retry(3)
    public void testRosen() {
<span class="fc" id="L126">        double[] startPoint = point(DIM,0.1);</span>
<span class="fc" id="L127">        double[] insigma = point(DIM,0.1);</span>
<span class="fc" id="L128">        double[][] boundaries = null;</span>
<span class="fc" id="L129">        PointValuePair expected =</span>
<span class="fc" id="L130">            new PointValuePair(point(DIM,1.0),0.0);</span>
<span class="fc" id="L131">        doTest(new Rosen(), startPoint, insigma, boundaries,</span>
                GoalType.MINIMIZE, LAMBDA, true, 0, 1e-13,
                1e-13, 1e-6, 100000, expected);
<span class="fc" id="L134">        doTest(new Rosen(), startPoint, insigma, boundaries,</span>
                GoalType.MINIMIZE, LAMBDA, false, 0, 1e-13,
                1e-13, 1e-6, 100000, expected);
<span class="fc" id="L137">    }</span>

    @Test
    @Retry(3)
    public void testMaximize() {
<span class="fc" id="L142">        double[] startPoint = point(DIM,1.0);</span>
<span class="fc" id="L143">        double[] insigma = point(DIM,0.1);</span>
<span class="fc" id="L144">        double[][] boundaries = null;</span>
<span class="fc" id="L145">        PointValuePair expected =</span>
<span class="fc" id="L146">            new PointValuePair(point(DIM,0.0),1.0);</span>
<span class="fc" id="L147">        doTest(new MinusElli(), startPoint, insigma, boundaries,</span>
                GoalType.MAXIMIZE, LAMBDA, true, 0, 1.0-1e-13,
                2e-10, 5e-6, 100000, expected);
<span class="fc" id="L150">        doTest(new MinusElli(), startPoint, insigma, boundaries,</span>
                GoalType.MAXIMIZE, LAMBDA, false, 0, 1.0-1e-13,
                2e-10, 5e-6, 100000, expected);
<span class="fc" id="L153">        boundaries = boundaries(DIM,-0.3,0.3);</span>
<span class="fc" id="L154">        startPoint = point(DIM,0.1);</span>
<span class="fc" id="L155">        doTest(new MinusElli(), startPoint, insigma, boundaries,</span>
                GoalType.MAXIMIZE, LAMBDA, true, 0, 1.0-1e-13,
                2e-10, 5e-6, 100000, expected);
<span class="fc" id="L158">    }</span>

    @Test
    public void testMath1466() {
<span class="fc" id="L162">        final CMAESOptimizer optimizer</span>
            = new CMAESOptimizer(30000, Double.NEGATIVE_INFINITY, true, 10,
<span class="fc" id="L164">                                 0, RandomSource.create(RandomSource.MT_64), false, null);</span>
<span class="fc" id="L165">        final MultivariateFunction fitnessFunction = new MultivariateFunction() {</span>
                @Override
                public double value(double[] x) {
<span class="fc" id="L168">                    return x[0] * x[0] - 100;</span>
                }
            };

<span class="fc" id="L172">        final double[] start = { 100 };</span>
<span class="fc" id="L173">        final double[] sigma = { 1e-1 };</span>
<span class="fc" id="L174">        final double[] result = optimizer.optimize(new MaxEval(10000),</span>
                                                   new ObjectiveFunction(fitnessFunction),
<span class="fc" id="L176">                                                   SimpleBounds.unbounded(1),</span>
                                                   GoalType.MINIMIZE,
                                                   new CMAESOptimizer.PopulationSize(5),
                                                   new CMAESOptimizer.Sigma(sigma),
<span class="fc" id="L180">                                                   new InitialGuess(start)).getPoint();</span>
<span class="fc" id="L181">        Assert.assertEquals(0, result[0], 1e-7);</span>
<span class="fc" id="L182">    }</span>

    @Test
    public void testEllipse() {
<span class="fc" id="L186">        double[] startPoint = point(DIM,1.0);</span>
<span class="fc" id="L187">        double[] insigma = point(DIM,0.1);</span>
<span class="fc" id="L188">        double[][] boundaries = null;</span>
<span class="fc" id="L189">        PointValuePair expected =</span>
<span class="fc" id="L190">            new PointValuePair(point(DIM,0.0),0.0);</span>
<span class="fc" id="L191">        doTest(new Elli(), startPoint, insigma, boundaries,</span>
                GoalType.MINIMIZE, LAMBDA, true, 0, 1e-13,
                1e-13, 1e-6, 100000, expected);
<span class="fc" id="L194">        doTest(new Elli(), startPoint, insigma, boundaries,</span>
                GoalType.MINIMIZE, LAMBDA, false, 0, 1e-13,
                1e-13, 1e-6, 100000, expected);
<span class="fc" id="L197">    }</span>

    @Test
    public void testElliRotated() {
<span class="fc" id="L201">        double[] startPoint = point(DIM,1.0);</span>
<span class="fc" id="L202">        double[] insigma = point(DIM,0.1);</span>
<span class="fc" id="L203">        double[][] boundaries = null;</span>
<span class="fc" id="L204">        PointValuePair expected =</span>
<span class="fc" id="L205">            new PointValuePair(point(DIM,0.0),0.0);</span>
<span class="fc" id="L206">        doTest(new ElliRotated(), startPoint, insigma, boundaries,</span>
                GoalType.MINIMIZE, LAMBDA, true, 0, 1e-13,
                1e-13, 1e-6, 100000, expected);
<span class="fc" id="L209">        doTest(new ElliRotated(), startPoint, insigma, boundaries,</span>
                GoalType.MINIMIZE, LAMBDA, false, 0, 1e-13,
                1e-13, 1e-6, 100000, expected);
<span class="fc" id="L212">    }</span>

    @Test
    public void testCigar() {
<span class="fc" id="L216">        double[] startPoint = point(DIM,1.0);</span>
<span class="fc" id="L217">        double[] insigma = point(DIM,0.1);</span>
<span class="fc" id="L218">        double[][] boundaries = null;</span>
<span class="fc" id="L219">        PointValuePair expected =</span>
<span class="fc" id="L220">            new PointValuePair(point(DIM,0.0),0.0);</span>
<span class="fc" id="L221">        doTest(new Cigar(), startPoint, insigma, boundaries,</span>
                GoalType.MINIMIZE, LAMBDA, true, 0, 1e-13,
                1e-13, 1e-6, 200000, expected);
<span class="fc" id="L224">        doTest(new Cigar(), startPoint, insigma, boundaries,</span>
                GoalType.MINIMIZE, LAMBDA, false, 0, 1e-13,
                1e-13, 1e-6, 100000, expected);
<span class="fc" id="L227">    }</span>

    @Test
    public void testCigarWithBoundaries() {
<span class="fc" id="L231">        double[] startPoint = point(DIM,1.0);</span>
<span class="fc" id="L232">        double[] insigma = point(DIM,0.1);</span>
<span class="fc" id="L233">        double[][] boundaries = boundaries(DIM, -1e100, Double.POSITIVE_INFINITY);</span>
<span class="fc" id="L234">        PointValuePair expected =</span>
<span class="fc" id="L235">            new PointValuePair(point(DIM,0.0),0.0);</span>
<span class="fc" id="L236">        doTest(new Cigar(), startPoint, insigma, boundaries,</span>
                GoalType.MINIMIZE, LAMBDA, true, 0, 1e-13,
                1e-13, 1e-6, 200000, expected);
<span class="fc" id="L239">        doTest(new Cigar(), startPoint, insigma, boundaries,</span>
                GoalType.MINIMIZE, LAMBDA, false, 0, 1e-13,
                1e-13, 1e-6, 100000, expected);
<span class="fc" id="L242">    }</span>

    @Test
    public void testTwoAxes() {
<span class="fc" id="L246">        double[] startPoint = point(DIM,1.0);</span>
<span class="fc" id="L247">        double[] insigma = point(DIM,0.1);</span>
<span class="fc" id="L248">        double[][] boundaries = null;</span>
<span class="fc" id="L249">        PointValuePair expected =</span>
<span class="fc" id="L250">            new PointValuePair(point(DIM,0.0),0.0);</span>
<span class="fc" id="L251">        doTest(new TwoAxes(), startPoint, insigma, boundaries,</span>
                GoalType.MINIMIZE, 2*LAMBDA, true, 0, 1e-13,
                1e-13, 1e-6, 200000, expected);
<span class="fc" id="L254">        doTest(new TwoAxes(), startPoint, insigma, boundaries,</span>
                GoalType.MINIMIZE, 2*LAMBDA, false, 0, 1e-13,
                1e-8, 1e-3, 200000, expected);
<span class="fc" id="L257">    }</span>

    @Test
    public void testCigTab() {
<span class="fc" id="L261">        double[] startPoint = point(DIM,1.0);</span>
<span class="fc" id="L262">        double[] insigma = point(DIM,0.3);</span>
<span class="fc" id="L263">        double[][] boundaries = null;</span>
<span class="fc" id="L264">        PointValuePair expected =</span>
<span class="fc" id="L265">            new PointValuePair(point(DIM,0.0),0.0);</span>
<span class="fc" id="L266">        doTest(new CigTab(), startPoint, insigma, boundaries,</span>
                GoalType.MINIMIZE, LAMBDA, true, 0, 1e-13,
                1e-13, 5e-5, 100000, expected);
<span class="fc" id="L269">        doTest(new CigTab(), startPoint, insigma, boundaries,</span>
                GoalType.MINIMIZE, LAMBDA, false, 0, 1e-13,
                1e-13, 5e-5, 100000, expected);
<span class="fc" id="L272">    }</span>

    @Test
    public void testSphere() {
<span class="fc" id="L276">        double[] startPoint = point(DIM,1.0);</span>
<span class="fc" id="L277">        double[] insigma = point(DIM,0.1);</span>
<span class="fc" id="L278">        double[][] boundaries = null;</span>
<span class="fc" id="L279">        PointValuePair expected =</span>
<span class="fc" id="L280">            new PointValuePair(point(DIM,0.0),0.0);</span>
<span class="fc" id="L281">        doTest(new Sphere(), startPoint, insigma, boundaries,</span>
                GoalType.MINIMIZE, LAMBDA, true, 0, 1e-13,
                1e-13, 1e-6, 100000, expected);
<span class="fc" id="L284">        doTest(new Sphere(), startPoint, insigma, boundaries,</span>
                GoalType.MINIMIZE, LAMBDA, false, 0, 1e-13,
                1e-13, 1e-6, 100000, expected);
<span class="fc" id="L287">    }</span>

    @Test
    public void testTablet() {
<span class="fc" id="L291">        double[] startPoint = point(DIM,1.0);</span>
<span class="fc" id="L292">        double[] insigma = point(DIM,0.1);</span>
<span class="fc" id="L293">        double[][] boundaries = null;</span>
<span class="fc" id="L294">        PointValuePair expected =</span>
<span class="fc" id="L295">            new PointValuePair(point(DIM,0.0),0.0);</span>
<span class="fc" id="L296">        doTest(new Tablet(), startPoint, insigma, boundaries,</span>
                GoalType.MINIMIZE, LAMBDA, true, 0, 1e-13,
                1e-13, 1e-6, 100000, expected);
<span class="fc" id="L299">        doTest(new Tablet(), startPoint, insigma, boundaries,</span>
                GoalType.MINIMIZE, LAMBDA, false, 0, 1e-13,
                1e-13, 1e-6, 100000, expected);
<span class="fc" id="L302">    }</span>

    @Test
    public void testDiffPow() {
<span class="fc" id="L306">        double[] startPoint = point(DIM,1.0);</span>
<span class="fc" id="L307">        double[] insigma = point(DIM,0.1);</span>
<span class="fc" id="L308">        double[][] boundaries = null;</span>
<span class="fc" id="L309">        PointValuePair expected =</span>
<span class="fc" id="L310">            new PointValuePair(point(DIM,0.0),0.0);</span>
<span class="fc" id="L311">        doTest(new DiffPow(), startPoint, insigma, boundaries,</span>
                GoalType.MINIMIZE, 10, true, 0, 1e-13,
                1e-8, 1e-1, 100000, expected);
<span class="fc" id="L314">        doTest(new DiffPow(), startPoint, insigma, boundaries,</span>
                GoalType.MINIMIZE, 10, false, 0, 1e-13,
                1e-8, 2e-1, 100000, expected);
<span class="fc" id="L317">    }</span>

    @Test
    public void testSsDiffPow() {
<span class="fc" id="L321">        double[] startPoint = point(DIM,1.0);</span>
<span class="fc" id="L322">        double[] insigma = point(DIM,0.1);</span>
<span class="fc" id="L323">        double[][] boundaries = null;</span>
<span class="fc" id="L324">        PointValuePair expected =</span>
<span class="fc" id="L325">            new PointValuePair(point(DIM,0.0),0.0);</span>
<span class="fc" id="L326">        doTest(new SsDiffPow(), startPoint, insigma, boundaries,</span>
                GoalType.MINIMIZE, 10, true, 0, 1e-13,
                1e-4, 1e-1, 200000, expected);
<span class="fc" id="L329">        doTest(new SsDiffPow(), startPoint, insigma, boundaries,</span>
                GoalType.MINIMIZE, 10, false, 0, 1e-13,
                1e-4, 1e-1, 200000, expected);
<span class="fc" id="L332">    }</span>

    @Test
    public void testAckley() {
<span class="fc" id="L336">        double[] startPoint = point(DIM,1.0);</span>
<span class="fc" id="L337">        double[] insigma = point(DIM,1.0);</span>
<span class="fc" id="L338">        double[][] boundaries = null;</span>
<span class="fc" id="L339">        PointValuePair expected =</span>
<span class="fc" id="L340">            new PointValuePair(point(DIM,0.0),0.0);</span>
<span class="fc" id="L341">        doTest(new Ackley(), startPoint, insigma, boundaries,</span>
                GoalType.MINIMIZE, 2*LAMBDA, true, 0, 1e-13,
                1e-9, 1e-5, 100000, expected);
<span class="fc" id="L344">        doTest(new Ackley(), startPoint, insigma, boundaries,</span>
                GoalType.MINIMIZE, 2*LAMBDA, false, 0, 1e-13,
                1e-9, 1e-5, 100000, expected);
<span class="fc" id="L347">    }</span>

    @Test
    public void testRastrigin() {
<span class="fc" id="L351">        double[] startPoint = point(DIM,0.1);</span>
<span class="fc" id="L352">        double[] insigma = point(DIM,0.1);</span>
<span class="fc" id="L353">        double[][] boundaries = null;</span>
<span class="fc" id="L354">        PointValuePair expected =</span>
<span class="fc" id="L355">            new PointValuePair(point(DIM,0.0),0.0);</span>
<span class="fc" id="L356">        doTest(new Rastrigin(), startPoint, insigma, boundaries,</span>
<span class="fc" id="L357">                GoalType.MINIMIZE, (int)(200*FastMath.sqrt(DIM)), true, 0, 1e-13,</span>
                1e-13, 1e-6, 200000, expected);
<span class="fc" id="L359">        doTest(new Rastrigin(), startPoint, insigma, boundaries,</span>
<span class="fc" id="L360">                GoalType.MINIMIZE, (int)(200*FastMath.sqrt(DIM)), false, 0, 1e-13,</span>
                1e-13, 1e-6, 200000, expected);
<span class="fc" id="L362">    }</span>

    @Test
    public void testConstrainedRosen() {
<span class="fc" id="L366">        double[] startPoint = point(DIM, 0.1);</span>
<span class="fc" id="L367">        double[] insigma = point(DIM, 0.1);</span>
<span class="fc" id="L368">        double[][] boundaries = boundaries(DIM, -1, 2);</span>
<span class="fc" id="L369">        PointValuePair expected =</span>
<span class="fc" id="L370">            new PointValuePair(point(DIM,1.0),0.0);</span>
<span class="fc" id="L371">        doTest(new Rosen(), startPoint, insigma, boundaries,</span>
                GoalType.MINIMIZE, 2*LAMBDA, true, 0, 1e-13,
                1e-13, 1e-6, 100000, expected);
<span class="fc" id="L374">        doTest(new Rosen(), startPoint, insigma, boundaries,</span>
                GoalType.MINIMIZE, 2*LAMBDA, false, 0, 1e-13,
                1e-13, 1e-6, 100000, expected);
<span class="fc" id="L377">    }</span>

    @Test
    public void testDiagonalRosen() {
<span class="fc" id="L381">        double[] startPoint = point(DIM,0.1);</span>
<span class="fc" id="L382">        double[] insigma = point(DIM,0.1);</span>
<span class="fc" id="L383">        double[][] boundaries = null;</span>
<span class="fc" id="L384">        PointValuePair expected =</span>
<span class="fc" id="L385">            new PointValuePair(point(DIM,1.0),0.0);</span>
<span class="fc" id="L386">        doTest(new Rosen(), startPoint, insigma, boundaries,</span>
                GoalType.MINIMIZE, LAMBDA, false, 1, 1e-13,
                1e-10, 1e-4, 1000000, expected);
<span class="fc" id="L389">     }</span>

    @Test
    public void testMath864() {
<span class="fc" id="L393">        final CMAESOptimizer optimizer</span>
            = new CMAESOptimizer(30000, 0, true, 10,
<span class="fc" id="L395">                                 0, RandomSource.create(RandomSource.MT_64), false, null);</span>
<span class="fc" id="L396">        final MultivariateFunction fitnessFunction = new MultivariateFunction() {</span>
                @Override
                public double value(double[] parameters) {
<span class="fc" id="L399">                    final double target = 1;</span>
<span class="fc" id="L400">                    final double error = target - parameters[0];</span>
<span class="fc" id="L401">                    return error * error;</span>
                }
            };

<span class="fc" id="L405">        final double[] start = { 0 };</span>
<span class="fc" id="L406">        final double[] lower = { -1e6 };</span>
<span class="fc" id="L407">        final double[] upper = { 1.5 };</span>
<span class="fc" id="L408">        final double[] sigma = { 1e-1 };</span>
<span class="fc" id="L409">        final double[] result = optimizer.optimize(new MaxEval(10000),</span>
                                                   new ObjectiveFunction(fitnessFunction),
                                                   GoalType.MINIMIZE,
                                                   new CMAESOptimizer.PopulationSize(5),
                                                   new CMAESOptimizer.Sigma(sigma),
                                                   new InitialGuess(start),
<span class="fc" id="L415">                                                   new SimpleBounds(lower, upper)).getPoint();</span>
<span class="pc bpc" id="L416" title="1 of 2 branches missed.">        Assert.assertTrue(&quot;Out of bounds (&quot; + result[0] + &quot; &gt; &quot; + upper[0] + &quot;)&quot;,</span>
                          result[0] &lt;= upper[0]);
<span class="fc" id="L418">    }</span>

    /**
     * Cf. MATH-867
     */
    @Test
    public void testFitAccuracyDependsOnBoundary() {
<span class="fc" id="L425">        final CMAESOptimizer optimizer</span>
            = new CMAESOptimizer(30000, 0, true, 10,
<span class="fc" id="L427">                                 0, RandomSource.create(RandomSource.MT_64), false, null);</span>
<span class="fc" id="L428">        final MultivariateFunction fitnessFunction = new MultivariateFunction() {</span>
                @Override
                public double value(double[] parameters) {
<span class="fc" id="L431">                    final double target = 11.1;</span>
<span class="fc" id="L432">                    final double error = target - parameters[0];</span>
<span class="fc" id="L433">                    return error * error;</span>
                }
            };

<span class="fc" id="L437">        final double[] start = { 1 };</span>

        // No bounds.
<span class="fc" id="L440">        PointValuePair result = optimizer.optimize(new MaxEval(100000),</span>
                                                   new ObjectiveFunction(fitnessFunction),
                                                   GoalType.MINIMIZE,
<span class="fc" id="L443">                                                   SimpleBounds.unbounded(1),</span>
                                                   new CMAESOptimizer.PopulationSize(5),
                                                   new CMAESOptimizer.Sigma(new double[] { 1e-1 }),
                                                   new InitialGuess(start));
<span class="fc" id="L447">        final double resNoBound = result.getPoint()[0];</span>

        // Optimum is near the lower bound.
<span class="fc" id="L450">        final double[] lower = { -20 };</span>
<span class="fc" id="L451">        final double[] upper = { 5e16 };</span>
<span class="fc" id="L452">        final double[] sigma = { 10 };</span>
<span class="fc" id="L453">        result = optimizer.optimize(new MaxEval(100000),</span>
                                    new ObjectiveFunction(fitnessFunction),
                                    GoalType.MINIMIZE,
                                    new CMAESOptimizer.PopulationSize(5),
                                    new CMAESOptimizer.Sigma(sigma),
                                    new InitialGuess(start),
                                    new SimpleBounds(lower, upper));
<span class="fc" id="L460">        final double resNearLo = result.getPoint()[0];</span>

        // Optimum is near the upper bound.
<span class="fc" id="L463">        lower[0] = -5e16;</span>
<span class="fc" id="L464">        upper[0] = 20;</span>
<span class="fc" id="L465">        result = optimizer.optimize(new MaxEval(100000),</span>
                                    new ObjectiveFunction(fitnessFunction),
                                    GoalType.MINIMIZE,
                                    new CMAESOptimizer.PopulationSize(5),
                                    new CMAESOptimizer.Sigma(sigma),
                                    new InitialGuess(start),
                                    new SimpleBounds(lower, upper));
<span class="fc" id="L472">        final double resNearHi = result.getPoint()[0];</span>

        // System.out.println(&quot;resNoBound=&quot; + resNoBound +
        //                    &quot; resNearLo=&quot; + resNearLo +
        //                    &quot; resNearHi=&quot; + resNearHi);

        // The two values currently differ by a substantial amount, indicating that
        // the bounds definition can prevent reaching the optimum.
<span class="fc" id="L480">        Assert.assertEquals(resNoBound, resNearLo, 1e-3);</span>
<span class="fc" id="L481">        Assert.assertEquals(resNoBound, resNearHi, 1e-3);</span>
<span class="fc" id="L482">    }</span>

    /**
     * @param func Function to optimize.
     * @param startPoint Starting point.
     * @param inSigma Individual input sigma.
     * @param boundaries Upper / lower point limit.
     * @param goal Minimization or maximization.
     * @param lambda Population size used for offspring.
     * @param isActive Covariance update mechanism.
     * @param diagonalOnly Simplified covariance update.
     * @param stopValue Termination criteria for optimization.
     * @param fTol Tolerance relative error on the objective function.
     * @param pointTol Tolerance for checking that the optimum is correct.
     * @param maxEvaluations Maximum number of evaluations.
     * @param expected Expected point / value.
     */
    private void doTest(MultivariateFunction func,
                        double[] startPoint,
                        double[] inSigma,
                        double[][] boundaries,
                        GoalType goal,
                        int lambda,
                        boolean isActive,
                        int diagonalOnly,
                        double stopValue,
                        double fTol,
                        double pointTol,
                        int maxEvaluations,
                        PointValuePair expected) {
<span class="fc" id="L512">        int dim = startPoint.length;</span>
        // test diagonalOnly = 0 - slow but normally fewer feval#
<span class="fc" id="L514">        CMAESOptimizer optim = new CMAESOptimizer(30000, stopValue, isActive, diagonalOnly,</span>
<span class="fc" id="L515">                                                  0, RandomSource.create(RandomSource.MT_64), false, null);</span>
<span class="fc bfc" id="L516" title="All 2 branches covered.">        PointValuePair result = boundaries == null ?</span>
<span class="fc" id="L517">            optim.optimize(new MaxEval(maxEvaluations),</span>
                           new ObjectiveFunction(func),
                           goal,
                           new InitialGuess(startPoint),
<span class="fc" id="L521">                           SimpleBounds.unbounded(dim),</span>
                           new CMAESOptimizer.Sigma(inSigma),
                           new CMAESOptimizer.PopulationSize(lambda)) :
<span class="fc" id="L524">            optim.optimize(new MaxEval(maxEvaluations),</span>
                           new ObjectiveFunction(func),
                           goal,
                           new SimpleBounds(boundaries[0],
                                            boundaries[1]),
                           new InitialGuess(startPoint),
                           new CMAESOptimizer.Sigma(inSigma),
                           new CMAESOptimizer.PopulationSize(lambda));

        // System.out.println(&quot;sol=&quot; + Arrays.toString(result.getPoint()));
<span class="fc" id="L534">        Assert.assertEquals(expected.getValue(), result.getValue(), fTol);</span>
<span class="fc bfc" id="L535" title="All 2 branches covered.">        for (int i = 0; i &lt; dim; i++) {</span>
<span class="fc" id="L536">            Assert.assertEquals(expected.getPoint()[i], result.getPoint()[i], pointTol);</span>
        }

<span class="pc bpc" id="L539" title="1 of 2 branches missed.">        Assert.assertTrue(optim.getIterations() &gt; 0);</span>
<span class="fc" id="L540">    }</span>

    private static double[] point(int n, double value) {
<span class="fc" id="L543">        double[] ds = new double[n];</span>
<span class="fc" id="L544">        Arrays.fill(ds, value);</span>
<span class="fc" id="L545">        return ds;</span>
    }

    private static double[][] boundaries(int dim,
            double lower, double upper) {
<span class="fc" id="L550">        double[][] boundaries = new double[2][dim];</span>
<span class="fc bfc" id="L551" title="All 2 branches covered.">        for (int i = 0; i &lt; dim; i++) {</span>
<span class="fc" id="L552">            boundaries[0][i] = lower;</span>
        }
<span class="fc bfc" id="L554" title="All 2 branches covered.">        for (int i = 0; i &lt; dim; i++) {</span>
<span class="fc" id="L555">            boundaries[1][i] = upper;</span>
        }
<span class="fc" id="L557">        return boundaries;</span>
    }

    private static class Sphere implements MultivariateFunction {

        @Override
        public double value(double[] x) {
<span class="fc" id="L564">            double f = 0;</span>
<span class="fc bfc" id="L565" title="All 2 branches covered.">            for (int i = 0; i &lt; x.length; ++i) {</span>
<span class="fc" id="L566">                f += x[i] * x[i];</span>
            }
<span class="fc" id="L568">            return f;</span>
        }
    }

    private static class Cigar implements MultivariateFunction {
        private double factor;

        Cigar() {
<span class="fc" id="L576">            this(1e3);</span>
<span class="fc" id="L577">        }</span>

<span class="fc" id="L579">        Cigar(double axisratio) {</span>
<span class="fc" id="L580">            factor = axisratio * axisratio;</span>
<span class="fc" id="L581">        }</span>

        @Override
        public double value(double[] x) {
<span class="fc" id="L585">            double f = x[0] * x[0];</span>
<span class="fc bfc" id="L586" title="All 2 branches covered.">            for (int i = 1; i &lt; x.length; ++i) {</span>
<span class="fc" id="L587">                f += factor * x[i] * x[i];</span>
            }
<span class="fc" id="L589">            return f;</span>
        }
    }

    private static class Tablet implements MultivariateFunction {
        private double factor;

        Tablet() {
<span class="fc" id="L597">            this(1e3);</span>
<span class="fc" id="L598">        }</span>

<span class="fc" id="L600">        Tablet(double axisratio) {</span>
<span class="fc" id="L601">            factor = axisratio * axisratio;</span>
<span class="fc" id="L602">        }</span>

        @Override
        public double value(double[] x) {
<span class="fc" id="L606">            double f = factor * x[0] * x[0];</span>
<span class="fc bfc" id="L607" title="All 2 branches covered.">            for (int i = 1; i &lt; x.length; ++i) {</span>
<span class="fc" id="L608">                f += x[i] * x[i];</span>
            }
<span class="fc" id="L610">            return f;</span>
        }
    }

    private static class CigTab implements MultivariateFunction {
        private double factor;

        CigTab() {
<span class="fc" id="L618">            this(1e4);</span>
<span class="fc" id="L619">        }</span>

<span class="fc" id="L621">        CigTab(double axisratio) {</span>
<span class="fc" id="L622">            factor = axisratio;</span>
<span class="fc" id="L623">        }</span>

        @Override
        public double value(double[] x) {
<span class="fc" id="L627">            int end = x.length - 1;</span>
<span class="fc" id="L628">            double f = x[0] * x[0] / factor + factor * x[end] * x[end];</span>
<span class="fc bfc" id="L629" title="All 2 branches covered.">            for (int i = 1; i &lt; end; ++i) {</span>
<span class="fc" id="L630">                f += x[i] * x[i];</span>
            }
<span class="fc" id="L632">            return f;</span>
        }
    }

    private static class TwoAxes implements MultivariateFunction {

        private double factor;

        TwoAxes() {
<span class="fc" id="L641">            this(1e6);</span>
<span class="fc" id="L642">        }</span>

<span class="fc" id="L644">        TwoAxes(double axisratio) {</span>
<span class="fc" id="L645">            factor = axisratio * axisratio;</span>
<span class="fc" id="L646">        }</span>

        @Override
        public double value(double[] x) {
<span class="fc" id="L650">            double f = 0;</span>
<span class="fc bfc" id="L651" title="All 2 branches covered.">            for (int i = 0; i &lt; x.length; ++i) {</span>
<span class="fc bfc" id="L652" title="All 2 branches covered.">                f += (i &lt; x.length / 2 ? factor : 1) * x[i] * x[i];</span>
            }
<span class="fc" id="L654">            return f;</span>
        }
    }

    private static class ElliRotated implements MultivariateFunction {
<span class="fc" id="L659">        private Basis B = new Basis();</span>
        private double factor;

        ElliRotated() {
<span class="fc" id="L663">            this(1e3);</span>
<span class="fc" id="L664">        }</span>

<span class="fc" id="L666">        ElliRotated(double axisratio) {</span>
<span class="fc" id="L667">            factor = axisratio * axisratio;</span>
<span class="fc" id="L668">        }</span>

        @Override
        public double value(double[] x) {
<span class="fc" id="L672">            double f = 0;</span>
<span class="fc" id="L673">            x = B.Rotate(x);</span>
<span class="fc bfc" id="L674" title="All 2 branches covered.">            for (int i = 0; i &lt; x.length; ++i) {</span>
<span class="fc" id="L675">                f += FastMath.pow(factor, i / (x.length - 1.)) * x[i] * x[i];</span>
            }
<span class="fc" id="L677">            return f;</span>
        }
    }

    private static class Elli implements MultivariateFunction {

        private double factor;

        Elli() {
<span class="fc" id="L686">            this(1e3);</span>
<span class="fc" id="L687">        }</span>

<span class="fc" id="L689">        Elli(double axisratio) {</span>
<span class="fc" id="L690">            factor = axisratio * axisratio;</span>
<span class="fc" id="L691">        }</span>

        @Override
        public double value(double[] x) {
<span class="fc" id="L695">            double f = 0;</span>
<span class="fc bfc" id="L696" title="All 2 branches covered.">            for (int i = 0; i &lt; x.length; ++i) {</span>
<span class="fc" id="L697">                f += FastMath.pow(factor, i / (x.length - 1.)) * x[i] * x[i];</span>
            }
<span class="fc" id="L699">            return f;</span>
        }
    }

    private static class MinusElli implements MultivariateFunction {

        @Override
        public double value(double[] x) {
<span class="fc" id="L707">            return 1.0-(new Elli().value(x));</span>
        }
    }

    private static class DiffPow implements MultivariateFunction {

        @Override
        public double value(double[] x) {
<span class="fc" id="L715">            double f = 0;</span>
<span class="fc bfc" id="L716" title="All 2 branches covered.">            for (int i = 0; i &lt; x.length; ++i) {</span>
<span class="fc" id="L717">                f += FastMath.pow(FastMath.abs(x[i]), 2. + 10 * (double) i</span>
                        / (x.length - 1.));
            }
<span class="fc" id="L720">            return f;</span>
        }
    }

    private static class SsDiffPow implements MultivariateFunction {

        @Override
        public double value(double[] x) {
<span class="fc" id="L728">            double f = FastMath.pow(new DiffPow().value(x), 0.25);</span>
<span class="fc" id="L729">            return f;</span>
        }
    }

    private static class Rosen implements MultivariateFunction {

        @Override
        public double value(double[] x) {
<span class="fc" id="L737">            double f = 0;</span>
<span class="fc bfc" id="L738" title="All 2 branches covered.">            for (int i = 0; i &lt; x.length - 1; ++i) {</span>
<span class="fc" id="L739">                f += 1e2 * (x[i] * x[i] - x[i + 1]) * (x[i] * x[i] - x[i + 1])</span>
                + (x[i] - 1.) * (x[i] - 1.);
            }
<span class="fc" id="L742">            return f;</span>
        }
    }

    private static class Ackley implements MultivariateFunction {
        private double axisratio;

<span class="fc" id="L749">        Ackley(double axra) {</span>
<span class="fc" id="L750">            axisratio = axra;</span>
<span class="fc" id="L751">        }</span>

        public Ackley() {
<span class="fc" id="L754">            this(1);</span>
<span class="fc" id="L755">        }</span>

        @Override
        public double value(double[] x) {
<span class="fc" id="L759">            double f = 0;</span>
<span class="fc" id="L760">            double res2 = 0;</span>
<span class="fc" id="L761">            double fac = 0;</span>
<span class="fc bfc" id="L762" title="All 2 branches covered.">            for (int i = 0; i &lt; x.length; ++i) {</span>
<span class="fc" id="L763">                fac = FastMath.pow(axisratio, (i - 1.) / (x.length - 1.));</span>
<span class="fc" id="L764">                f += fac * fac * x[i] * x[i];</span>
<span class="fc" id="L765">                res2 += FastMath.cos(2. * FastMath.PI * fac * x[i]);</span>
            }
<span class="fc" id="L767">            f = (20. - 20. * FastMath.exp(-0.2 * FastMath.sqrt(f / x.length))</span>
<span class="fc" id="L768">                    + FastMath.exp(1.) - FastMath.exp(res2 / x.length));</span>
<span class="fc" id="L769">            return f;</span>
        }
    }

    private static class Rastrigin implements MultivariateFunction {

        private double axisratio;
        private double amplitude;

        Rastrigin() {
<span class="fc" id="L779">            this(1, 10);</span>
<span class="fc" id="L780">        }</span>

<span class="fc" id="L782">        Rastrigin(double axisratio, double amplitude) {</span>
<span class="fc" id="L783">            this.axisratio = axisratio;</span>
<span class="fc" id="L784">            this.amplitude = amplitude;</span>
<span class="fc" id="L785">        }</span>

        @Override
        public double value(double[] x) {
<span class="fc" id="L789">            double f = 0;</span>
            double fac;
<span class="fc bfc" id="L791" title="All 2 branches covered.">            for (int i = 0; i &lt; x.length; ++i) {</span>
<span class="fc" id="L792">                fac = FastMath.pow(axisratio, (i - 1.) / (x.length - 1.));</span>
<span class="fc bfc" id="L793" title="All 4 branches covered.">                if (i == 0 &amp;&amp; x[i] &lt; 0) {</span>
<span class="fc" id="L794">                    fac *= 1.;</span>
                }
<span class="fc" id="L796">                f += fac * fac * x[i] * x[i] + amplitude</span>
<span class="fc" id="L797">                * (1. - FastMath.cos(2. * FastMath.PI * fac * x[i]));</span>
            }
<span class="fc" id="L799">            return f;</span>
        }
    }

<span class="fc" id="L803">    private static class Basis {</span>
        double[][] basis;
<span class="fc" id="L805">        Random rand = new Random(2); // use not always the same basis</span>

        double[] Rotate(double[] x) {
<span class="fc" id="L808">            GenBasis(x.length);</span>
<span class="fc" id="L809">            double[] y = new double[x.length];</span>
<span class="fc bfc" id="L810" title="All 2 branches covered.">            for (int i = 0; i &lt; x.length; ++i) {</span>
<span class="fc" id="L811">                y[i] = 0;</span>
<span class="fc bfc" id="L812" title="All 2 branches covered.">                for (int j = 0; j &lt; x.length; ++j) {</span>
<span class="fc" id="L813">                    y[i] += basis[i][j] * x[j];</span>
                }
            }
<span class="fc" id="L816">            return y;</span>
        }

        void GenBasis(int DIM) {
<span class="pc bpc" id="L820" title="1 of 4 branches missed.">            if (basis != null ? basis.length == DIM : false) {</span>
<span class="fc" id="L821">                return;</span>
            }

            double sp;
            int i, j, k;

            /* generate orthogonal basis */
<span class="fc" id="L828">            basis = new double[DIM][DIM];</span>
<span class="fc bfc" id="L829" title="All 2 branches covered.">            for (i = 0; i &lt; DIM; ++i) {</span>
                /* sample components gaussian */
<span class="fc bfc" id="L831" title="All 2 branches covered.">                for (j = 0; j &lt; DIM; ++j) {</span>
<span class="fc" id="L832">                    basis[i][j] = rand.nextGaussian();</span>
                }
                /* substract projection of previous vectors */
<span class="fc bfc" id="L835" title="All 2 branches covered.">                for (j = i - 1; j &gt;= 0; --j) {</span>
<span class="fc bfc" id="L836" title="All 2 branches covered.">                    for (sp = 0., k = 0; k &lt; DIM; ++k) {</span>
<span class="fc" id="L837">                        sp += basis[i][k] * basis[j][k]; /* scalar product */</span>
                    }
<span class="fc bfc" id="L839" title="All 2 branches covered.">                    for (k = 0; k &lt; DIM; ++k) {</span>
<span class="fc" id="L840">                        basis[i][k] -= sp * basis[j][k]; /* substract */</span>
                    }
                }
                /* normalize */
<span class="fc bfc" id="L844" title="All 2 branches covered.">                for (sp = 0., k = 0; k &lt; DIM; ++k) {</span>
<span class="fc" id="L845">                    sp += basis[i][k] * basis[i][k]; /* squared norm */</span>
                }
<span class="fc bfc" id="L847" title="All 2 branches covered.">                for (k = 0; k &lt; DIM; ++k) {</span>
<span class="fc" id="L848">                    basis[i][k] /= FastMath.sqrt(sp);</span>
                }
            }
<span class="fc" id="L851">        }</span>
    }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.1.201803210924</span></div></body></html>