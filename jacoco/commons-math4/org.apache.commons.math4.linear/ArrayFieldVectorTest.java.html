<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>ArrayFieldVectorTest.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">commons_math4$All_in_commons_math4.exec</a> &gt; <a href="index.source.html" class="el_package">org.apache.commons.math4.linear</a> &gt; <span class="el_source">ArrayFieldVectorTest.java</span></div><h1>ArrayFieldVectorTest.java</h1><pre class="source lang-java linenums">/*
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the &quot;License&quot;); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.commons.math4.linear;

import java.io.Serializable;
import java.lang.reflect.Array;
import java.util.Arrays;

import org.apache.commons.math4.Field;
import org.apache.commons.math4.FieldElement;
import org.apache.commons.math4.TestUtils;
import org.apache.commons.math4.exception.MathIllegalArgumentException;
import org.apache.commons.math4.exception.NumberIsTooSmallException;
import org.apache.commons.math4.exception.OutOfRangeException;
import org.apache.commons.math4.fraction.Fraction;
import org.apache.commons.math4.fraction.FractionField;
import org.apache.commons.math4.linear.ArrayFieldVector;
import org.apache.commons.math4.linear.FieldMatrix;
import org.apache.commons.math4.linear.FieldVector;
import org.apache.commons.math4.linear.FieldVectorChangingVisitor;
import org.apache.commons.math4.linear.FieldVectorPreservingVisitor;
import org.junit.Assert;
import org.junit.Test;

/**
 * Test cases for the {@link ArrayFieldVector} class.
 *
 */
<span class="fc" id="L43">public class ArrayFieldVectorTest {</span>

    //
<span class="fc" id="L46">    protected Fraction[][] ma1 = {</span>
            {new Fraction(1), new Fraction(2), new Fraction(3)},
            {new Fraction(4), new Fraction(5), new Fraction(6)},
            {new Fraction(7), new Fraction(8), new Fraction(9)}
    };
<span class="fc" id="L51">    protected Fraction[] vec1 = {new Fraction(1), new Fraction(2), new Fraction(3)};</span>
<span class="fc" id="L52">    protected Fraction[] vec2 = {new Fraction(4), new Fraction(5), new Fraction(6)};</span>
<span class="fc" id="L53">    protected Fraction[] vec3 = {new Fraction(7), new Fraction(8), new Fraction(9)};</span>
<span class="fc" id="L54">    protected Fraction[] vec4 = { new Fraction(1), new Fraction(2), new Fraction(3),</span>
                                  new Fraction(4), new Fraction(5), new Fraction(6),
                                  new Fraction(7), new Fraction(8), new Fraction(9)};
<span class="fc" id="L57">    protected Fraction[] vec_null = {Fraction.ZERO, Fraction.ZERO, Fraction.ZERO};</span>
<span class="fc" id="L58">    protected Fraction[] dvec1 = {new Fraction(1), new Fraction(2), new Fraction(3),</span>
                                  new Fraction(4), new Fraction(5), new Fraction(6),
                                  new Fraction(7), new Fraction(8), new Fraction(9)};
<span class="fc" id="L61">    protected Fraction[][] mat1 = {</span>
            {new Fraction(1), new Fraction(2), new Fraction(3)},
            {new Fraction(4), new Fraction(5), new Fraction(6)},
            {new Fraction(7), new Fraction(8), new Fraction(9)}
    };

    // Testclass to test the FieldVector&lt;Fraction&gt; interface
    // only with enough content to support the test
    public static class FieldVectorTestImpl&lt;T extends FieldElement&lt;T&gt;&gt;
        implements FieldVector&lt;T&gt;, Serializable {

        private static final long serialVersionUID = 3970959016014158539L;

        private final Field&lt;T&gt; field;

        /** Entries of the vector. */
        protected T[] data;

        /** Build an array of elements.
         * @param length size of the array to build
         * @return a new array
         */
        @SuppressWarnings(&quot;unchecked&quot;) // field is of type T
        private T[] buildArray(final int length) {
<span class="fc" id="L85">            return (T[]) Array.newInstance(field.getRuntimeClass(), length);</span>
        }

<span class="fc" id="L88">        public FieldVectorTestImpl(T[] d) {</span>
<span class="fc" id="L89">            field = d[0].getField();</span>
<span class="fc" id="L90">            data = d.clone();</span>
<span class="fc" id="L91">        }</span>

        @Override
        public Field&lt;T&gt; getField() {
<span class="fc" id="L95">            return field;</span>
        }

        private UnsupportedOperationException unsupported() {
<span class="nc" id="L99">            return new UnsupportedOperationException(&quot;Not supported, unneeded for test purposes&quot;);</span>
        }

        @Override
        public FieldVector&lt;T&gt; copy() {
<span class="nc" id="L104">            throw unsupported();</span>
        }

        @Override
        public FieldVector&lt;T&gt; add(FieldVector&lt;T&gt; v) {
<span class="nc" id="L109">            throw unsupported();</span>
        }

        public FieldVector&lt;T&gt; add(T[] v) {
<span class="nc" id="L113">            throw unsupported();</span>
        }

        @Override
        public FieldVector&lt;T&gt; subtract(FieldVector&lt;T&gt; v) {
<span class="nc" id="L118">            throw unsupported();</span>
        }

        public FieldVector&lt;T&gt; subtract(T[] v) {
<span class="nc" id="L122">            throw unsupported();</span>
        }

        @Override
        public FieldVector&lt;T&gt; mapAdd(T d) {
<span class="nc" id="L127">            throw unsupported();</span>
        }

        @Override
        public FieldVector&lt;T&gt; mapAddToSelf(T d) {
<span class="nc" id="L132">            throw unsupported();</span>
        }

        @Override
        public FieldVector&lt;T&gt; mapSubtract(T d) {
<span class="nc" id="L137">            throw unsupported();</span>
        }

        @Override
        public FieldVector&lt;T&gt; mapSubtractToSelf(T d) {
<span class="nc" id="L142">            throw unsupported();</span>
        }

        @Override
        public FieldVector&lt;T&gt; mapMultiply(T d) {
<span class="fc" id="L147">            T[] out = buildArray(data.length);</span>
<span class="fc bfc" id="L148" title="All 2 branches covered.">            for (int i = 0; i &lt; data.length; i++) {</span>
<span class="fc" id="L149">                out[i] = data[i].multiply(d);</span>
            }
<span class="fc" id="L151">            return new FieldVectorTestImpl&lt;&gt;(out);</span>
        }

        @Override
        public FieldVector&lt;T&gt; mapMultiplyToSelf(T d) {
<span class="nc" id="L156">            throw unsupported();</span>
        }

        @Override
        public FieldVector&lt;T&gt; mapDivide(T d) {
<span class="nc" id="L161">            throw unsupported();</span>
        }

        @Override
        public FieldVector&lt;T&gt; mapDivideToSelf(T d) {
<span class="nc" id="L166">            throw unsupported();</span>
        }

        @Override
        public FieldVector&lt;T&gt; mapInv() {
<span class="nc" id="L171">            throw unsupported();</span>
        }

        @Override
        public FieldVector&lt;T&gt; mapInvToSelf() {
<span class="nc" id="L176">            throw unsupported();</span>
        }

        @Override
        public FieldVector&lt;T&gt; ebeMultiply(FieldVector&lt;T&gt; v) {
<span class="nc" id="L181">            throw unsupported();</span>
        }

        public FieldVector&lt;T&gt; ebeMultiply(T[] v) {
<span class="nc" id="L185">            throw unsupported();</span>
        }

        @Override
        public FieldVector&lt;T&gt; ebeDivide(FieldVector&lt;T&gt; v) {
<span class="nc" id="L190">            throw unsupported();</span>
        }

        public FieldVector&lt;T&gt; ebeDivide(T[] v) {
<span class="nc" id="L194">            throw unsupported();</span>
        }

        public T[] getData() {
<span class="nc" id="L198">            return data.clone();</span>
        }

        @Override
        public T dotProduct(FieldVector&lt;T&gt; v) {
<span class="fc" id="L203">            T dot = field.getZero();</span>
<span class="fc bfc" id="L204" title="All 2 branches covered.">            for (int i = 0; i &lt; data.length; i++) {</span>
<span class="fc" id="L205">                dot = dot.add(data[i].multiply(v.getEntry(i)));</span>
            }
<span class="fc" id="L207">            return dot;</span>
        }

        public T dotProduct(T[] v) {
<span class="nc" id="L211">            T dot = field.getZero();</span>
<span class="nc bnc" id="L212" title="All 2 branches missed.">            for (int i = 0; i &lt; data.length; i++) {</span>
<span class="nc" id="L213">                dot = dot.add(data[i].multiply(v[i]));</span>
            }
<span class="nc" id="L215">            return dot;</span>
        }

        @Override
        public FieldVector&lt;T&gt; projection(FieldVector&lt;T&gt; v) {
<span class="nc" id="L220">            throw unsupported();</span>
        }

        public FieldVector&lt;T&gt; projection(T[] v) {
<span class="nc" id="L224">            throw unsupported();</span>
        }

        @Override
        public FieldMatrix&lt;T&gt; outerProduct(FieldVector&lt;T&gt; v) {
<span class="nc" id="L229">            throw unsupported();</span>
        }

        public FieldMatrix&lt;T&gt; outerProduct(T[] v) {
<span class="nc" id="L233">            throw unsupported();</span>
        }

        @Override
        public T getEntry(int index) {
<span class="fc" id="L238">            return data[index];</span>
        }

        @Override
        public int getDimension() {
<span class="fc" id="L243">            return data.length;</span>
        }

        @Override
        public FieldVector&lt;T&gt; append(FieldVector&lt;T&gt; v) {
<span class="nc" id="L248">            throw unsupported();</span>
        }

        @Override
        public FieldVector&lt;T&gt; append(T d) {
<span class="nc" id="L253">            throw unsupported();</span>
        }

        public FieldVector&lt;T&gt; append(T[] a) {
<span class="nc" id="L257">            throw unsupported();</span>
        }

        @Override
        public FieldVector&lt;T&gt; getSubVector(int index, int n) {
<span class="nc" id="L262">            throw unsupported();</span>
        }

        @Override
        public void setEntry(int index, T value) {
<span class="nc" id="L267">            throw unsupported();</span>
        }

        @Override
        public void setSubVector(int index, FieldVector&lt;T&gt; v) {
<span class="nc" id="L272">            throw unsupported();</span>
        }

        public void setSubVector(int index, T[] v) {
<span class="nc" id="L276">            throw unsupported();</span>
        }

        @Override
        public void set(T value) {
<span class="nc" id="L281">            throw unsupported();</span>
        }

        @Override
        public T[] toArray() {
<span class="fc" id="L286">            return data.clone();</span>
        }

    }

    @Test
    public void testConstructors() {

<span class="fc" id="L294">        ArrayFieldVector&lt;Fraction&gt; v0 = new ArrayFieldVector&lt;&gt;(FractionField.getInstance());</span>
<span class="fc" id="L295">        Assert.assertEquals(0, v0.getDimension());</span>

<span class="fc" id="L297">        ArrayFieldVector&lt;Fraction&gt; v1 = new ArrayFieldVector&lt;&gt;(FractionField.getInstance(), 7);</span>
<span class="fc" id="L298">        Assert.assertEquals(7, v1.getDimension());</span>
<span class="fc" id="L299">        Assert.assertEquals(Fraction.ZERO, v1.getEntry(6));</span>

<span class="fc" id="L301">        ArrayFieldVector&lt;Fraction&gt; v2 = new ArrayFieldVector&lt;&gt;(5, new Fraction(123, 100));</span>
<span class="fc" id="L302">        Assert.assertEquals(5, v2.getDimension());</span>
<span class="fc" id="L303">        Assert.assertEquals(new Fraction(123, 100), v2.getEntry(4));</span>

<span class="fc" id="L305">        ArrayFieldVector&lt;Fraction&gt; v3 = new ArrayFieldVector&lt;&gt;(FractionField.getInstance(), vec1);</span>
<span class="fc" id="L306">        Assert.assertEquals(3, v3.getDimension());</span>
<span class="fc" id="L307">        Assert.assertEquals(new Fraction(2), v3.getEntry(1));</span>

<span class="fc" id="L309">        ArrayFieldVector&lt;Fraction&gt; v4 = new ArrayFieldVector&lt;&gt;(FractionField.getInstance(), vec4, 3, 2);</span>
<span class="fc" id="L310">        Assert.assertEquals(2, v4.getDimension());</span>
<span class="fc" id="L311">        Assert.assertEquals(new Fraction(4), v4.getEntry(0));</span>
        try {
<span class="nc" id="L313">            new ArrayFieldVector&lt;&gt;(vec4, 8, 3);</span>
<span class="nc" id="L314">            Assert.fail(&quot;MathIllegalArgumentException expected&quot;);</span>
<span class="fc" id="L315">        } catch (MathIllegalArgumentException ex) {</span>
            // expected behavior
<span class="nc" id="L317">        }</span>

<span class="fc" id="L319">        FieldVector&lt;Fraction&gt; v5_i = new ArrayFieldVector&lt;&gt;(dvec1);</span>
<span class="fc" id="L320">        Assert.assertEquals(9, v5_i.getDimension());</span>
<span class="fc" id="L321">        Assert.assertEquals(new Fraction(9), v5_i.getEntry(8));</span>

<span class="fc" id="L323">        ArrayFieldVector&lt;Fraction&gt; v5 = new ArrayFieldVector&lt;&gt;(dvec1);</span>
<span class="fc" id="L324">        Assert.assertEquals(9, v5.getDimension());</span>
<span class="fc" id="L325">        Assert.assertEquals(new Fraction(9), v5.getEntry(8));</span>

<span class="fc" id="L327">        ArrayFieldVector&lt;Fraction&gt; v6 = new ArrayFieldVector&lt;&gt;(dvec1, 3, 2);</span>
<span class="fc" id="L328">        Assert.assertEquals(2, v6.getDimension());</span>
<span class="fc" id="L329">        Assert.assertEquals(new Fraction(4), v6.getEntry(0));</span>
        try {
<span class="nc" id="L331">            new ArrayFieldVector&lt;&gt;(dvec1, 8, 3);</span>
<span class="nc" id="L332">            Assert.fail(&quot;MathIllegalArgumentException expected&quot;);</span>
<span class="fc" id="L333">        } catch (MathIllegalArgumentException ex) {</span>
            // expected behavior
<span class="nc" id="L335">        }</span>

<span class="fc" id="L337">        ArrayFieldVector&lt;Fraction&gt; v7 = new ArrayFieldVector&lt;&gt;(v1);</span>
<span class="fc" id="L338">        Assert.assertEquals(7, v7.getDimension());</span>
<span class="fc" id="L339">        Assert.assertEquals(Fraction.ZERO, v7.getEntry(6));</span>

<span class="fc" id="L341">        FieldVectorTestImpl&lt;Fraction&gt; v7_i = new FieldVectorTestImpl&lt;&gt;(vec1);</span>

<span class="fc" id="L343">        ArrayFieldVector&lt;Fraction&gt; v7_2 = new ArrayFieldVector&lt;&gt;(v7_i);</span>
<span class="fc" id="L344">        Assert.assertEquals(3, v7_2.getDimension());</span>
<span class="fc" id="L345">        Assert.assertEquals(new Fraction(2), v7_2.getEntry(1));</span>

<span class="fc" id="L347">        ArrayFieldVector&lt;Fraction&gt; v8 = new ArrayFieldVector&lt;&gt;(v1, true);</span>
<span class="fc" id="L348">        Assert.assertEquals(7, v8.getDimension());</span>
<span class="fc" id="L349">        Assert.assertEquals(Fraction.ZERO, v8.getEntry(6));</span>
<span class="fc" id="L350">        Assert.assertNotSame(&quot;testData not same object &quot;, v1.getDataRef(), v8.getDataRef());</span>

<span class="fc" id="L352">        ArrayFieldVector&lt;Fraction&gt; v8_2 = new ArrayFieldVector&lt;&gt;(v1, false);</span>
<span class="fc" id="L353">        Assert.assertEquals(7, v8_2.getDimension());</span>
<span class="fc" id="L354">        Assert.assertEquals(Fraction.ZERO, v8_2.getEntry(6));</span>
<span class="fc" id="L355">        Assert.assertArrayEquals(v1.getDataRef(), v8_2.getDataRef());</span>

<span class="fc" id="L357">        ArrayFieldVector&lt;Fraction&gt; v9 = new ArrayFieldVector&lt;&gt;((FieldVector&lt;Fraction&gt;) v1, (FieldVector&lt;Fraction&gt;) v3);</span>
<span class="fc" id="L358">        Assert.assertEquals(10, v9.getDimension());</span>
<span class="fc" id="L359">        Assert.assertEquals(new Fraction(1), v9.getEntry(7));</span>

<span class="fc" id="L361">    }</span>

    @Test
    public void testDataInOut() {

<span class="fc" id="L366">        ArrayFieldVector&lt;Fraction&gt; v1 = new ArrayFieldVector&lt;&gt;(vec1);</span>
<span class="fc" id="L367">        ArrayFieldVector&lt;Fraction&gt; v2 = new ArrayFieldVector&lt;&gt;(vec2);</span>
<span class="fc" id="L368">        ArrayFieldVector&lt;Fraction&gt; v4 = new ArrayFieldVector&lt;&gt;(vec4);</span>
<span class="fc" id="L369">        FieldVectorTestImpl&lt;Fraction&gt; v2_t = new FieldVectorTestImpl&lt;&gt;(vec2);</span>

<span class="fc" id="L371">        FieldVector&lt;Fraction&gt; v_append_1 = v1.append(v2);</span>
<span class="fc" id="L372">        Assert.assertEquals(6, v_append_1.getDimension());</span>
<span class="fc" id="L373">        Assert.assertEquals(new Fraction(4), v_append_1.getEntry(3));</span>

<span class="fc" id="L375">        FieldVector&lt;Fraction&gt; v_append_2 = v1.append(new Fraction(2));</span>
<span class="fc" id="L376">        Assert.assertEquals(4, v_append_2.getDimension());</span>
<span class="fc" id="L377">        Assert.assertEquals(new Fraction(2), v_append_2.getEntry(3));</span>

<span class="fc" id="L379">        FieldVector&lt;Fraction&gt; v_append_4 = v1.append(v2_t);</span>
<span class="fc" id="L380">        Assert.assertEquals(6, v_append_4.getDimension());</span>
<span class="fc" id="L381">        Assert.assertEquals(new Fraction(4), v_append_4.getEntry(3));</span>

<span class="fc" id="L383">        FieldVector&lt;Fraction&gt; v_copy = v1.copy();</span>
<span class="fc" id="L384">        Assert.assertEquals(3, v_copy.getDimension());</span>
<span class="fc" id="L385">        Assert.assertNotSame(&quot;testData not same object &quot;, v1.getDataRef(), v_copy.toArray());</span>

<span class="fc" id="L387">        Fraction[] a_frac = v1.toArray();</span>
<span class="fc" id="L388">        Assert.assertEquals(3, a_frac.length);</span>
<span class="fc" id="L389">        Assert.assertNotSame(&quot;testData not same object &quot;, v1.getDataRef(), a_frac);</span>


//      ArrayFieldVector&lt;Fraction&gt; vout4 = (ArrayFieldVector&lt;Fraction&gt;) v1.clone();
//      Assert.assertEquals(3, vout4.getDimension());
//      Assert.assertEquals(v1.getDataRef(), vout4.getDataRef());


<span class="fc" id="L397">        FieldVector&lt;Fraction&gt; vout5 = v4.getSubVector(3, 3);</span>
<span class="fc" id="L398">        Assert.assertEquals(3, vout5.getDimension());</span>
<span class="fc" id="L399">        Assert.assertEquals(new Fraction(5), vout5.getEntry(1));</span>
        try {
<span class="nc" id="L401">            v4.getSubVector(3, 7);</span>
<span class="nc" id="L402">            Assert.fail(&quot;OutOfRangeException expected&quot;);</span>
<span class="fc" id="L403">        } catch (OutOfRangeException ex) {</span>
            // expected behavior
<span class="nc" id="L405">        }</span>

<span class="fc" id="L407">        ArrayFieldVector&lt;Fraction&gt; v_set1 = (ArrayFieldVector&lt;Fraction&gt;) v1.copy();</span>
<span class="fc" id="L408">        v_set1.setEntry(1, new Fraction(11));</span>
<span class="fc" id="L409">        Assert.assertEquals(new Fraction(11), v_set1.getEntry(1));</span>
        try {
<span class="nc" id="L411">            v_set1.setEntry(3, new Fraction(11));</span>
<span class="nc" id="L412">            Assert.fail(&quot;OutOfRangeException expected&quot;);</span>
<span class="fc" id="L413">        } catch (OutOfRangeException ex) {</span>
            // expected behavior
<span class="nc" id="L415">        }</span>

<span class="fc" id="L417">        ArrayFieldVector&lt;Fraction&gt; v_set2 = (ArrayFieldVector&lt;Fraction&gt;) v4.copy();</span>
<span class="fc" id="L418">        v_set2.set(3, v1);</span>
<span class="fc" id="L419">        Assert.assertEquals(new Fraction(1), v_set2.getEntry(3));</span>
<span class="fc" id="L420">        Assert.assertEquals(new Fraction(7), v_set2.getEntry(6));</span>
        try {
<span class="nc" id="L422">            v_set2.set(7, v1);</span>
<span class="nc" id="L423">            Assert.fail(&quot;OutOfRangeException expected&quot;);</span>
<span class="fc" id="L424">        } catch (OutOfRangeException ex) {</span>
            // expected behavior
<span class="nc" id="L426">        }</span>

<span class="fc" id="L428">        ArrayFieldVector&lt;Fraction&gt; v_set3 = (ArrayFieldVector&lt;Fraction&gt;) v1.copy();</span>
<span class="fc" id="L429">        v_set3.set(new Fraction(13));</span>
<span class="fc" id="L430">        Assert.assertEquals(new Fraction(13), v_set3.getEntry(2));</span>

        try {
<span class="nc" id="L433">            v_set3.getEntry(23);</span>
<span class="nc" id="L434">            Assert.fail(&quot;ArrayIndexOutOfBoundsException expected&quot;);</span>
<span class="fc" id="L435">        } catch (ArrayIndexOutOfBoundsException ex) {</span>
            // expected behavior
<span class="nc" id="L437">        }</span>

<span class="fc" id="L439">        ArrayFieldVector&lt;Fraction&gt; v_set4 = (ArrayFieldVector&lt;Fraction&gt;) v4.copy();</span>
<span class="fc" id="L440">        v_set4.setSubVector(3, v2_t);</span>
<span class="fc" id="L441">        Assert.assertEquals(new Fraction(4), v_set4.getEntry(3));</span>
<span class="fc" id="L442">        Assert.assertEquals(new Fraction(7), v_set4.getEntry(6));</span>
        try {
<span class="nc" id="L444">            v_set4.setSubVector(7, v2_t);</span>
<span class="nc" id="L445">            Assert.fail(&quot;OutOfRangeException expected&quot;);</span>
<span class="fc" id="L446">        } catch (OutOfRangeException ex) {</span>
            // expected behavior
<span class="nc" id="L448">        }</span>


<span class="fc" id="L451">        ArrayFieldVector&lt;Fraction&gt; vout10 = (ArrayFieldVector&lt;Fraction&gt;) v1.copy();</span>
<span class="fc" id="L452">        ArrayFieldVector&lt;Fraction&gt; vout10_2 = (ArrayFieldVector&lt;Fraction&gt;) v1.copy();</span>
<span class="fc" id="L453">        Assert.assertEquals(vout10, vout10_2);</span>
<span class="fc" id="L454">        vout10_2.setEntry(0, new Fraction(11, 10));</span>
<span class="fc" id="L455">        Assert.assertNotSame(vout10, vout10_2);</span>

<span class="fc" id="L457">    }</span>

    @Test
    public void testMapFunctions() {
<span class="fc" id="L461">        ArrayFieldVector&lt;Fraction&gt; v1 = new ArrayFieldVector&lt;&gt;(vec1);</span>

        //octave =  v1 .+ 2.0
<span class="fc" id="L464">        FieldVector&lt;Fraction&gt; v_mapAdd = v1.mapAdd(new Fraction(2));</span>
<span class="fc" id="L465">        Fraction[] result_mapAdd = {new Fraction(3), new Fraction(4), new Fraction(5)};</span>
<span class="fc" id="L466">        checkArray(&quot;compare vectors&quot; ,result_mapAdd,v_mapAdd.toArray());</span>

        //octave =  v1 .+ 2.0
<span class="fc" id="L469">        FieldVector&lt;Fraction&gt; v_mapAddToSelf = v1.copy();</span>
<span class="fc" id="L470">        v_mapAddToSelf.mapAddToSelf(new Fraction(2));</span>
<span class="fc" id="L471">        Fraction[] result_mapAddToSelf = {new Fraction(3), new Fraction(4), new Fraction(5)};</span>
<span class="fc" id="L472">        checkArray(&quot;compare vectors&quot; ,result_mapAddToSelf,v_mapAddToSelf.toArray());</span>

        //octave =  v1 .- 2.0
<span class="fc" id="L475">        FieldVector&lt;Fraction&gt; v_mapSubtract = v1.mapSubtract(new Fraction(2));</span>
<span class="fc" id="L476">        Fraction[] result_mapSubtract = {new Fraction(-1), Fraction.ZERO, new Fraction(1)};</span>
<span class="fc" id="L477">        checkArray(&quot;compare vectors&quot; ,result_mapSubtract,v_mapSubtract.toArray());</span>

        //octave =  v1 .- 2.0
<span class="fc" id="L480">        FieldVector&lt;Fraction&gt; v_mapSubtractToSelf = v1.copy();</span>
<span class="fc" id="L481">        v_mapSubtractToSelf.mapSubtractToSelf(new Fraction(2));</span>
<span class="fc" id="L482">        Fraction[] result_mapSubtractToSelf = {new Fraction(-1), Fraction.ZERO, new Fraction(1)};</span>
<span class="fc" id="L483">        checkArray(&quot;compare vectors&quot; ,result_mapSubtractToSelf,v_mapSubtractToSelf.toArray());</span>

        //octave =  v1 .* 2.0
<span class="fc" id="L486">        FieldVector&lt;Fraction&gt; v_mapMultiply = v1.mapMultiply(new Fraction(2));</span>
<span class="fc" id="L487">        Fraction[] result_mapMultiply = {new Fraction(2), new Fraction(4), new Fraction(6)};</span>
<span class="fc" id="L488">        checkArray(&quot;compare vectors&quot; ,result_mapMultiply,v_mapMultiply.toArray());</span>

        //octave =  v1 .* 2.0
<span class="fc" id="L491">        FieldVector&lt;Fraction&gt; v_mapMultiplyToSelf = v1.copy();</span>
<span class="fc" id="L492">        v_mapMultiplyToSelf.mapMultiplyToSelf(new Fraction(2));</span>
<span class="fc" id="L493">        Fraction[] result_mapMultiplyToSelf = {new Fraction(2), new Fraction(4), new Fraction(6)};</span>
<span class="fc" id="L494">        checkArray(&quot;compare vectors&quot; ,result_mapMultiplyToSelf,v_mapMultiplyToSelf.toArray());</span>

        //octave =  v1 ./ 2.0
<span class="fc" id="L497">        FieldVector&lt;Fraction&gt; v_mapDivide = v1.mapDivide(new Fraction(2));</span>
<span class="fc" id="L498">        Fraction[] result_mapDivide = {new Fraction(1, 2), new Fraction(1), new Fraction(3, 2)};</span>
<span class="fc" id="L499">        checkArray(&quot;compare vectors&quot; ,result_mapDivide,v_mapDivide.toArray());</span>

        //octave =  v1 ./ 2.0
<span class="fc" id="L502">        FieldVector&lt;Fraction&gt; v_mapDivideToSelf = v1.copy();</span>
<span class="fc" id="L503">        v_mapDivideToSelf.mapDivideToSelf(new Fraction(2));</span>
<span class="fc" id="L504">        Fraction[] result_mapDivideToSelf = {new Fraction(1, 2), new Fraction(1), new Fraction(3, 2)};</span>
<span class="fc" id="L505">        checkArray(&quot;compare vectors&quot; ,result_mapDivideToSelf,v_mapDivideToSelf.toArray());</span>

        //octave =  v1 .^-1
<span class="fc" id="L508">        FieldVector&lt;Fraction&gt; v_mapInv = v1.mapInv();</span>
<span class="fc" id="L509">        Fraction[] result_mapInv = {new Fraction(1),new Fraction(1, 2),new Fraction(1, 3)};</span>
<span class="fc" id="L510">        checkArray(&quot;compare vectors&quot; ,result_mapInv,v_mapInv.toArray());</span>

        //octave =  v1 .^-1
<span class="fc" id="L513">        FieldVector&lt;Fraction&gt; v_mapInvToSelf = v1.copy();</span>
<span class="fc" id="L514">        v_mapInvToSelf.mapInvToSelf();</span>
<span class="fc" id="L515">        Fraction[] result_mapInvToSelf = {new Fraction(1),new Fraction(1, 2),new Fraction(1, 3)};</span>
<span class="fc" id="L516">        checkArray(&quot;compare vectors&quot; ,result_mapInvToSelf,v_mapInvToSelf.toArray());</span>

<span class="fc" id="L518">    }</span>

    @Test
    public void testBasicFunctions() {
<span class="fc" id="L522">        ArrayFieldVector&lt;Fraction&gt; v1 = new ArrayFieldVector&lt;&gt;(vec1);</span>
<span class="fc" id="L523">        ArrayFieldVector&lt;Fraction&gt; v2 = new ArrayFieldVector&lt;&gt;(vec2);</span>
<span class="fc" id="L524">        new ArrayFieldVector&lt;&gt;(vec_null);</span>

<span class="fc" id="L526">        FieldVectorTestImpl&lt;Fraction&gt; v2_t = new FieldVectorTestImpl&lt;&gt;(vec2);</span>

        //octave =  v1 + v2
<span class="fc" id="L529">        ArrayFieldVector&lt;Fraction&gt; v_add = v1.add(v2);</span>
<span class="fc" id="L530">        Fraction[] result_add = {new Fraction(5), new Fraction(7), new Fraction(9)};</span>
<span class="fc" id="L531">        checkArray(&quot;compare vect&quot; ,v_add.toArray(),result_add);</span>

<span class="fc" id="L533">        FieldVectorTestImpl&lt;Fraction&gt; vt2 = new FieldVectorTestImpl&lt;&gt;(vec2);</span>
<span class="fc" id="L534">        FieldVector&lt;Fraction&gt; v_add_i = v1.add(vt2);</span>
<span class="fc" id="L535">        Fraction[] result_add_i = {new Fraction(5), new Fraction(7), new Fraction(9)};</span>
<span class="fc" id="L536">        checkArray(&quot;compare vect&quot; ,v_add_i.toArray(),result_add_i);</span>

        //octave =  v1 - v2
<span class="fc" id="L539">        ArrayFieldVector&lt;Fraction&gt; v_subtract = v1.subtract(v2);</span>
<span class="fc" id="L540">        Fraction[] result_subtract = {new Fraction(-3), new Fraction(-3), new Fraction(-3)};</span>
<span class="fc" id="L541">        checkArray(&quot;compare vect&quot; ,v_subtract.toArray(),result_subtract);</span>

<span class="fc" id="L543">        FieldVector&lt;Fraction&gt; v_subtract_i = v1.subtract(vt2);</span>
<span class="fc" id="L544">        Fraction[] result_subtract_i = {new Fraction(-3), new Fraction(-3), new Fraction(-3)};</span>
<span class="fc" id="L545">        checkArray(&quot;compare vect&quot; ,v_subtract_i.toArray(),result_subtract_i);</span>

        // octave v1 .* v2
<span class="fc" id="L548">        ArrayFieldVector&lt;Fraction&gt;  v_ebeMultiply = v1.ebeMultiply(v2);</span>
<span class="fc" id="L549">        Fraction[] result_ebeMultiply = {new Fraction(4), new Fraction(10), new Fraction(18)};</span>
<span class="fc" id="L550">        checkArray(&quot;compare vect&quot; ,v_ebeMultiply.toArray(),result_ebeMultiply);</span>

<span class="fc" id="L552">        FieldVector&lt;Fraction&gt;  v_ebeMultiply_2 = v1.ebeMultiply(v2_t);</span>
<span class="fc" id="L553">        Fraction[] result_ebeMultiply_2 = {new Fraction(4), new Fraction(10), new Fraction(18)};</span>
<span class="fc" id="L554">        checkArray(&quot;compare vect&quot; ,v_ebeMultiply_2.toArray(),result_ebeMultiply_2);</span>

        // octave v1 ./ v2
<span class="fc" id="L557">        ArrayFieldVector&lt;Fraction&gt;  v_ebeDivide = v1.ebeDivide(v2);</span>
<span class="fc" id="L558">        Fraction[] result_ebeDivide = {new Fraction(1, 4), new Fraction(2, 5), new Fraction(1, 2)};</span>
<span class="fc" id="L559">        checkArray(&quot;compare vect&quot; ,v_ebeDivide.toArray(),result_ebeDivide);</span>

<span class="fc" id="L561">        FieldVector&lt;Fraction&gt;  v_ebeDivide_2 = v1.ebeDivide(v2_t);</span>
<span class="fc" id="L562">        Fraction[] result_ebeDivide_2 = {new Fraction(1, 4), new Fraction(2, 5), new Fraction(1, 2)};</span>
<span class="fc" id="L563">        checkArray(&quot;compare vect&quot; ,v_ebeDivide_2.toArray(),result_ebeDivide_2);</span>

        // octave  dot(v1,v2)
<span class="fc" id="L566">        Fraction dot =  v1.dotProduct(v2);</span>
<span class="fc" id="L567">        Assert.assertEquals(&quot;compare val &quot;,new Fraction(32), dot);</span>

        // octave  dot(v1,v2_t)
<span class="fc" id="L570">        Fraction dot_2 =  v1.dotProduct(v2_t);</span>
<span class="fc" id="L571">        Assert.assertEquals(&quot;compare val &quot;,new Fraction(32), dot_2);</span>

<span class="fc" id="L573">        FieldMatrix&lt;Fraction&gt; m_outerProduct = v1.outerProduct(v2);</span>
<span class="fc" id="L574">        Assert.assertEquals(&quot;compare val &quot;,new Fraction(4), m_outerProduct.getEntry(0,0));</span>

<span class="fc" id="L576">        FieldMatrix&lt;Fraction&gt; m_outerProduct_2 = v1.outerProduct(v2_t);</span>
<span class="fc" id="L577">        Assert.assertEquals(&quot;compare val &quot;,new Fraction(4), m_outerProduct_2.getEntry(0,0));</span>

<span class="fc" id="L579">        ArrayFieldVector&lt;Fraction&gt; v_projection = v1.projection(v2);</span>
<span class="fc" id="L580">        Fraction[] result_projection = {new Fraction(128, 77), new Fraction(160, 77), new Fraction(192, 77)};</span>
<span class="fc" id="L581">        checkArray(&quot;compare vect&quot;, v_projection.toArray(), result_projection);</span>

<span class="fc" id="L583">        FieldVector&lt;Fraction&gt; v_projection_2 = v1.projection(v2_t);</span>
<span class="fc" id="L584">        Fraction[] result_projection_2 = {new Fraction(128, 77), new Fraction(160, 77), new Fraction(192, 77)};</span>
<span class="fc" id="L585">        checkArray(&quot;compare vect&quot;, v_projection_2.toArray(), result_projection_2);</span>

<span class="fc" id="L587">    }</span>

    @Test
    public void testMisc() {
<span class="fc" id="L591">        ArrayFieldVector&lt;Fraction&gt; v1 = new ArrayFieldVector&lt;&gt;(vec1);</span>
<span class="fc" id="L592">        ArrayFieldVector&lt;Fraction&gt; v4 = new ArrayFieldVector&lt;&gt;(vec4);</span>
<span class="fc" id="L593">        FieldVector&lt;Fraction&gt; v4_2 = new ArrayFieldVector&lt;&gt;(vec4);</span>

<span class="fc" id="L595">        String out1 = v1.toString();</span>
<span class="pc bpc" id="L596" title="1 of 2 branches missed.">        Assert.assertTrue(&quot;some output &quot;,  out1.length()!=0);</span>
        /*
         Fraction[] dout1 = v1.copyOut();
        Assert.assertEquals(3, dout1.length);
        assertNotSame(&quot;testData not same object &quot;, v1.getDataRef(), dout1);
         */
        try {
<span class="nc" id="L603">            v1.checkVectorDimensions(2);</span>
<span class="nc" id="L604">            Assert.fail(&quot;MathIllegalArgumentException expected&quot;);</span>
<span class="fc" id="L605">        } catch (MathIllegalArgumentException ex) {</span>
            // expected behavior
<span class="nc" id="L607">        }</span>

       try {
<span class="nc" id="L610">            v1.checkVectorDimensions(v4);</span>
<span class="nc" id="L611">            Assert.fail(&quot;MathIllegalArgumentException expected&quot;);</span>
<span class="fc" id="L612">        } catch (MathIllegalArgumentException ex) {</span>
            // expected behavior
<span class="nc" id="L614">        }</span>

        try {
<span class="nc" id="L617">            v1.checkVectorDimensions(v4_2);</span>
<span class="nc" id="L618">            Assert.fail(&quot;MathIllegalArgumentException expected&quot;);</span>
<span class="fc" id="L619">        } catch (MathIllegalArgumentException ex) {</span>
            // expected behavior
<span class="nc" id="L621">        }</span>

<span class="fc" id="L623">    }</span>

    @Test
    public void testSerial()  {
<span class="fc" id="L627">        ArrayFieldVector&lt;Fraction&gt; v = new ArrayFieldVector&lt;&gt;(vec1);</span>
<span class="fc" id="L628">        Assert.assertEquals(v,TestUtils.serializeAndRecover(v));</span>
<span class="fc" id="L629">    }</span>

    @Test
    public void testZeroVectors() {

        // when the field is not specified, array cannot be empty
        try {
<span class="nc" id="L636">            new ArrayFieldVector&lt;&gt;(new Fraction[0]);</span>
<span class="nc" id="L637">            Assert.fail(&quot;MathIllegalArgumentException expected&quot;);</span>
<span class="fc" id="L638">        } catch (MathIllegalArgumentException ex) {</span>
            // expected behavior
<span class="nc" id="L640">        }</span>
        try {
<span class="nc" id="L642">            new ArrayFieldVector&lt;&gt;(new Fraction[0], true);</span>
<span class="nc" id="L643">            Assert.fail(&quot;MathIllegalArgumentException expected&quot;);</span>
<span class="fc" id="L644">        } catch (MathIllegalArgumentException ex) {</span>
            // expected behavior
<span class="nc" id="L646">        }</span>
        try {
<span class="nc" id="L648">            new ArrayFieldVector&lt;&gt;(new Fraction[0], false);</span>
<span class="nc" id="L649">            Assert.fail(&quot;MathIllegalArgumentException expected&quot;);</span>
<span class="fc" id="L650">        } catch (MathIllegalArgumentException ex) {</span>
            // expected behavior
<span class="nc" id="L652">        }</span>

        // when the field is specified, array can be empty
<span class="fc" id="L655">        Assert.assertEquals(0, new ArrayFieldVector&lt;&gt;(FractionField.getInstance(), new Fraction[0]).getDimension());</span>
<span class="fc" id="L656">        Assert.assertEquals(0, new ArrayFieldVector&lt;&gt;(FractionField.getInstance(), new Fraction[0], true).getDimension());</span>
<span class="fc" id="L657">        Assert.assertEquals(0, new ArrayFieldVector&lt;&gt;(FractionField.getInstance(), new Fraction[0], false).getDimension());</span>

<span class="fc" id="L659">    }</span>

    @Test
    public void testOuterProduct() {
<span class="fc" id="L663">        final ArrayFieldVector&lt;Fraction&gt; u</span>
<span class="fc" id="L664">            = new ArrayFieldVector&lt;&gt;(FractionField.getInstance(),</span>
                                             new Fraction[] {new Fraction(1),
                                                             new Fraction(2),
                                                             new Fraction(-3)});
<span class="fc" id="L668">        final ArrayFieldVector&lt;Fraction&gt; v</span>
<span class="fc" id="L669">            = new ArrayFieldVector&lt;&gt;(FractionField.getInstance(),</span>
                                             new Fraction[] {new Fraction(4),
                                                             new Fraction(-2)});

<span class="fc" id="L673">        final FieldMatrix&lt;Fraction&gt; uv = u.outerProduct(v);</span>

<span class="fc" id="L675">        final double tol = Math.ulp(1d);</span>
<span class="fc" id="L676">        Assert.assertEquals(new Fraction(4).doubleValue(), uv.getEntry(0, 0).doubleValue(), tol);</span>
<span class="fc" id="L677">        Assert.assertEquals(new Fraction(-2).doubleValue(), uv.getEntry(0, 1).doubleValue(), tol);</span>
<span class="fc" id="L678">        Assert.assertEquals(new Fraction(8).doubleValue(), uv.getEntry(1, 0).doubleValue(), tol);</span>
<span class="fc" id="L679">        Assert.assertEquals(new Fraction(-4).doubleValue(), uv.getEntry(1, 1).doubleValue(), tol);</span>
<span class="fc" id="L680">        Assert.assertEquals(new Fraction(-12).doubleValue(), uv.getEntry(2, 0).doubleValue(), tol);</span>
<span class="fc" id="L681">        Assert.assertEquals(new Fraction(6).doubleValue(), uv.getEntry(2, 1).doubleValue(), tol);</span>
<span class="fc" id="L682">    }</span>

    /** verifies that two vectors are equals */
    protected void checkArray(String msg, Fraction[] m, Fraction[] n) {
<span class="pc bpc" id="L686" title="1 of 2 branches missed.">        if (m.length != n.length) {</span>
<span class="nc" id="L687">            Assert.fail(&quot;vectors have different lengths&quot;);</span>
        }
<span class="fc bfc" id="L689" title="All 2 branches covered.">        for (int i = 0; i &lt; m.length; i++) {</span>
<span class="fc" id="L690">            Assert.assertEquals(msg + &quot; &quot; +  i + &quot; elements differ&quot;, m[i],n[i]);</span>
        }
<span class="fc" id="L692">    }</span>

    /*
     * TESTS OF THE VISITOR PATTERN
     */

    /** The whole vector is visited. */
    @Test
    public void testWalkInDefaultOrderPreservingVisitor1() {
<span class="fc" id="L701">        final Fraction[] data = new Fraction[] {</span>
            Fraction.ZERO, Fraction.ONE, Fraction.ZERO,
            Fraction.ZERO, Fraction.TWO, Fraction.ZERO,
            Fraction.ZERO, Fraction.ZERO, new Fraction(3)
        };
<span class="fc" id="L706">        final ArrayFieldVector&lt;Fraction&gt; v = new ArrayFieldVector&lt;&gt;(data);</span>
        final FieldVectorPreservingVisitor&lt;Fraction&gt; visitor;
<span class="fc" id="L708">        visitor = new FieldVectorPreservingVisitor&lt;Fraction&gt;() {</span>

            private int expectedIndex;

            @Override
            public void visit(final int actualIndex, final Fraction actualValue) {
<span class="fc" id="L714">                Assert.assertEquals(expectedIndex, actualIndex);</span>
<span class="fc" id="L715">                Assert.assertEquals(Integer.toString(actualIndex),</span>
                                    data[actualIndex], actualValue);
<span class="fc" id="L717">                ++expectedIndex;</span>
<span class="fc" id="L718">            }</span>

            @Override
            public void start(final int actualSize, final int actualStart,
                              final int actualEnd) {
<span class="fc" id="L723">                Assert.assertEquals(data.length, actualSize);</span>
<span class="fc" id="L724">                Assert.assertEquals(0, actualStart);</span>
<span class="fc" id="L725">                Assert.assertEquals(data.length - 1, actualEnd);</span>
<span class="fc" id="L726">                expectedIndex = 0;</span>
<span class="fc" id="L727">            }</span>

            @Override
            public Fraction end() {
<span class="fc" id="L731">                return Fraction.ZERO;</span>
            }
        };
<span class="fc" id="L734">        v.walkInDefaultOrder(visitor);</span>
<span class="fc" id="L735">    }</span>

    /** Visiting an invalid subvector. */
    @Test
    public void testWalkInDefaultOrderPreservingVisitor2() {
<span class="fc" id="L740">        final ArrayFieldVector&lt;Fraction&gt; v = create(5);</span>
        final FieldVectorPreservingVisitor&lt;Fraction&gt; visitor;
<span class="fc" id="L742">        visitor = new FieldVectorPreservingVisitor&lt;Fraction&gt;() {</span>

            @Override
            public void visit(int index, Fraction value) {
                // Do nothing
<span class="nc" id="L747">            }</span>

            @Override
            public void start(int dimension, int start, int end) {
                // Do nothing
<span class="nc" id="L752">            }</span>

            @Override
            public Fraction end() {
<span class="nc" id="L756">                return Fraction.ZERO;</span>
            }
        };
        try {
<span class="nc" id="L760">            v.walkInDefaultOrder(visitor, -1, 4);</span>
<span class="nc" id="L761">            Assert.fail();</span>
<span class="fc" id="L762">        } catch (OutOfRangeException e) {</span>
            // Expected behavior
<span class="nc" id="L764">        }</span>
        try {
<span class="nc" id="L766">            v.walkInDefaultOrder(visitor, 5, 4);</span>
<span class="nc" id="L767">            Assert.fail();</span>
<span class="fc" id="L768">        } catch (OutOfRangeException e) {</span>
            // Expected behavior
<span class="nc" id="L770">        }</span>
        try {
<span class="nc" id="L772">            v.walkInDefaultOrder(visitor, 0, -1);</span>
<span class="nc" id="L773">            Assert.fail();</span>
<span class="fc" id="L774">        } catch (OutOfRangeException e) {</span>
            // Expected behavior
<span class="nc" id="L776">        }</span>
        try {
<span class="nc" id="L778">            v.walkInDefaultOrder(visitor, 0, 5);</span>
<span class="nc" id="L779">            Assert.fail();</span>
<span class="fc" id="L780">        } catch (OutOfRangeException e) {</span>
            // Expected behavior
<span class="nc" id="L782">        }</span>
        try {
<span class="nc" id="L784">            v.walkInDefaultOrder(visitor, 4, 0);</span>
<span class="nc" id="L785">            Assert.fail();</span>
<span class="fc" id="L786">        } catch (NumberIsTooSmallException e) {</span>
            // Expected behavior
<span class="nc" id="L788">        }</span>
<span class="fc" id="L789">    }</span>

    /** Visiting a valid subvector. */
    @Test
    public void testWalkInDefaultOrderPreservingVisitor3() {
<span class="fc" id="L794">        final Fraction[] data = new Fraction[] {</span>
            Fraction.ZERO, Fraction.ONE, Fraction.ZERO,
            Fraction.ZERO, Fraction.TWO, Fraction.ZERO,
            Fraction.ZERO, Fraction.ZERO, new Fraction(3)
        };
<span class="fc" id="L799">        final ArrayFieldVector&lt;Fraction&gt; v = new ArrayFieldVector&lt;&gt;(data);</span>
<span class="fc" id="L800">        final int expectedStart = 2;</span>
<span class="fc" id="L801">        final int expectedEnd = 7;</span>
        final FieldVectorPreservingVisitor&lt;Fraction&gt; visitor;
<span class="fc" id="L803">        visitor = new FieldVectorPreservingVisitor&lt;Fraction&gt;() {</span>

            private int expectedIndex;

            @Override
            public void visit(final int actualIndex, final Fraction actualValue) {
<span class="fc" id="L809">                Assert.assertEquals(expectedIndex, actualIndex);</span>
<span class="fc" id="L810">                Assert.assertEquals(Integer.toString(actualIndex),</span>
                                    data[actualIndex], actualValue);
<span class="fc" id="L812">                ++expectedIndex;</span>
<span class="fc" id="L813">            }</span>

            @Override
            public void start(final int actualSize, final int actualStart,
                              final int actualEnd) {
<span class="fc" id="L818">                Assert.assertEquals(data.length, actualSize);</span>
<span class="fc" id="L819">                Assert.assertEquals(expectedStart, actualStart);</span>
<span class="fc" id="L820">                Assert.assertEquals(expectedEnd, actualEnd);</span>
<span class="fc" id="L821">                expectedIndex = expectedStart;</span>
<span class="fc" id="L822">            }</span>

            @Override
            public Fraction end() {
<span class="fc" id="L826">                return Fraction.ZERO;</span>
            }
        };
<span class="fc" id="L829">        v.walkInDefaultOrder(visitor, expectedStart, expectedEnd);</span>
<span class="fc" id="L830">    }</span>

    /** The whole vector is visited. */
    @Test
    public void testWalkInOptimizedOrderPreservingVisitor1() {
<span class="fc" id="L835">        final Fraction[] data = new Fraction[] {</span>
            Fraction.ZERO, Fraction.ONE, Fraction.ZERO,
            Fraction.ZERO, Fraction.TWO, Fraction.ZERO,
            Fraction.ZERO, Fraction.ZERO, new Fraction(3)
        };
<span class="fc" id="L840">        final ArrayFieldVector&lt;Fraction&gt; v = new ArrayFieldVector&lt;&gt;(data);</span>
        final FieldVectorPreservingVisitor&lt;Fraction&gt; visitor;
<span class="fc" id="L842">        visitor = new FieldVectorPreservingVisitor&lt;Fraction&gt;() {</span>
<span class="fc" id="L843">            private final boolean[] visited = new boolean[data.length];</span>

            @Override
            public void visit(final int actualIndex, final Fraction actualValue) {
<span class="fc" id="L847">                visited[actualIndex] = true;</span>
<span class="fc" id="L848">                Assert.assertEquals(Integer.toString(actualIndex),</span>
                                    data[actualIndex], actualValue);
<span class="fc" id="L850">            }</span>

            @Override
            public void start(final int actualSize, final int actualStart,
                              final int actualEnd) {
<span class="fc" id="L855">                Assert.assertEquals(data.length, actualSize);</span>
<span class="fc" id="L856">                Assert.assertEquals(0, actualStart);</span>
<span class="fc" id="L857">                Assert.assertEquals(data.length - 1, actualEnd);</span>
<span class="fc" id="L858">                Arrays.fill(visited, false);</span>
<span class="fc" id="L859">            }</span>

            @Override
            public Fraction end() {
<span class="fc bfc" id="L863" title="All 2 branches covered.">                for (int i = 0; i &lt; data.length; i++) {</span>
<span class="fc" id="L864">                    Assert.assertTrue(&quot;entry &quot; + i + &quot;has not been visited&quot;,</span>
                                      visited[i]);
                }
<span class="fc" id="L867">                return Fraction.ZERO;</span>
            }
        };
<span class="fc" id="L870">        v.walkInOptimizedOrder(visitor);</span>
<span class="fc" id="L871">    }</span>

    /** Visiting an invalid subvector. */
    @Test
    public void testWalkInOptimizedOrderPreservingVisitor2() {
<span class="fc" id="L876">        final ArrayFieldVector&lt;Fraction&gt; v = create(5);</span>
        final FieldVectorPreservingVisitor&lt;Fraction&gt; visitor;
<span class="fc" id="L878">        visitor = new FieldVectorPreservingVisitor&lt;Fraction&gt;() {</span>

            @Override
            public void visit(int index, Fraction value) {
                // Do nothing
<span class="nc" id="L883">            }</span>

            @Override
            public void start(int dimension, int start, int end) {
                // Do nothing
<span class="nc" id="L888">            }</span>

            @Override
            public Fraction end() {
<span class="nc" id="L892">                return Fraction.ZERO;</span>
            }
        };
        try {
<span class="nc" id="L896">            v.walkInOptimizedOrder(visitor, -1, 4);</span>
<span class="nc" id="L897">            Assert.fail();</span>
<span class="fc" id="L898">        } catch (OutOfRangeException e) {</span>
            // Expected behavior
<span class="nc" id="L900">        }</span>
        try {
<span class="nc" id="L902">            v.walkInOptimizedOrder(visitor, 5, 4);</span>
<span class="nc" id="L903">            Assert.fail();</span>
<span class="fc" id="L904">        } catch (OutOfRangeException e) {</span>
            // Expected behavior
<span class="nc" id="L906">        }</span>
        try {
<span class="nc" id="L908">            v.walkInOptimizedOrder(visitor, 0, -1);</span>
<span class="nc" id="L909">            Assert.fail();</span>
<span class="fc" id="L910">        } catch (OutOfRangeException e) {</span>
            // Expected behavior
<span class="nc" id="L912">        }</span>
        try {
<span class="nc" id="L914">            v.walkInOptimizedOrder(visitor, 0, 5);</span>
<span class="nc" id="L915">            Assert.fail();</span>
<span class="fc" id="L916">        } catch (OutOfRangeException e) {</span>
            // Expected behavior
<span class="nc" id="L918">        }</span>
        try {
<span class="nc" id="L920">            v.walkInOptimizedOrder(visitor, 4, 0);</span>
<span class="nc" id="L921">            Assert.fail();</span>
<span class="fc" id="L922">        } catch (NumberIsTooSmallException e) {</span>
            // Expected behavior
<span class="nc" id="L924">        }</span>
<span class="fc" id="L925">    }</span>

    /** Visiting a valid subvector. */
    @Test
    public void testWalkInOptimizedOrderPreservingVisitor3() {
<span class="fc" id="L930">        final Fraction[] data = new Fraction[] {</span>
            Fraction.ZERO, Fraction.ONE, Fraction.ZERO,
            Fraction.ZERO, Fraction.TWO, Fraction.ZERO,
            Fraction.ZERO, Fraction.ZERO, new Fraction(3)
        };
<span class="fc" id="L935">        final ArrayFieldVector&lt;Fraction&gt; v = new ArrayFieldVector&lt;&gt;(data);</span>
<span class="fc" id="L936">        final int expectedStart = 2;</span>
<span class="fc" id="L937">        final int expectedEnd = 7;</span>
        final FieldVectorPreservingVisitor&lt;Fraction&gt; visitor;
<span class="fc" id="L939">        visitor = new FieldVectorPreservingVisitor&lt;Fraction&gt;() {</span>
<span class="fc" id="L940">            private final boolean[] visited = new boolean[data.length];</span>

            @Override
            public void visit(final int actualIndex, final Fraction actualValue) {
<span class="fc" id="L944">                Assert.assertEquals(Integer.toString(actualIndex),</span>
                                    data[actualIndex], actualValue);
<span class="fc" id="L946">                visited[actualIndex] = true;</span>
<span class="fc" id="L947">            }</span>

            @Override
            public void start(final int actualSize, final int actualStart,
                              final int actualEnd) {
<span class="fc" id="L952">                Assert.assertEquals(data.length, actualSize);</span>
<span class="fc" id="L953">                Assert.assertEquals(expectedStart, actualStart);</span>
<span class="fc" id="L954">                Assert.assertEquals(expectedEnd, actualEnd);</span>
<span class="fc" id="L955">                Arrays.fill(visited, true);</span>
<span class="fc" id="L956">            }</span>

            @Override
            public Fraction end() {
<span class="fc bfc" id="L960" title="All 2 branches covered.">                for (int i = expectedStart; i &lt;= expectedEnd; i++) {</span>
<span class="fc" id="L961">                    Assert.assertTrue(&quot;entry &quot; + i + &quot;has not been visited&quot;,</span>
                                      visited[i]);
                }
<span class="fc" id="L964">                return Fraction.ZERO;</span>
            }
        };
<span class="fc" id="L967">        v.walkInOptimizedOrder(visitor, expectedStart, expectedEnd);</span>
<span class="fc" id="L968">    }</span>

    /** The whole vector is visited. */
    @Test
    public void testWalkInDefaultOrderChangingVisitor1() {
<span class="fc" id="L973">        final Fraction[] data = new Fraction[] {</span>
            Fraction.ZERO, Fraction.ONE, Fraction.ZERO,
            Fraction.ZERO, Fraction.TWO, Fraction.ZERO,
            Fraction.ZERO, Fraction.ZERO, new Fraction(3)
        };
<span class="fc" id="L978">        final ArrayFieldVector&lt;Fraction&gt; v = new ArrayFieldVector&lt;&gt;(data);</span>
        final FieldVectorChangingVisitor&lt;Fraction&gt; visitor;
<span class="fc" id="L980">        visitor = new FieldVectorChangingVisitor&lt;Fraction&gt;() {</span>

            private int expectedIndex;

            @Override
            public Fraction visit(final int actualIndex, final Fraction actualValue) {
<span class="fc" id="L986">                Assert.assertEquals(expectedIndex, actualIndex);</span>
<span class="fc" id="L987">                Assert.assertEquals(Integer.toString(actualIndex),</span>
                                    data[actualIndex], actualValue);
<span class="fc" id="L989">                ++expectedIndex;</span>
<span class="fc" id="L990">                return actualValue.add(actualIndex);</span>
            }

            @Override
            public void start(final int actualSize, final int actualStart,
                              final int actualEnd) {
<span class="fc" id="L996">                Assert.assertEquals(data.length, actualSize);</span>
<span class="fc" id="L997">                Assert.assertEquals(0, actualStart);</span>
<span class="fc" id="L998">                Assert.assertEquals(data.length - 1, actualEnd);</span>
<span class="fc" id="L999">                expectedIndex = 0;</span>
<span class="fc" id="L1000">            }</span>

            @Override
            public Fraction end() {
<span class="fc" id="L1004">                return Fraction.ZERO;</span>
            }
        };
<span class="fc" id="L1007">        v.walkInDefaultOrder(visitor);</span>
<span class="fc bfc" id="L1008" title="All 2 branches covered.">        for (int i = 0; i &lt; data.length; i++) {</span>
<span class="fc" id="L1009">            Assert.assertEquals(&quot;entry &quot; + i, data[i].add(i), v.getEntry(i));</span>
        }
<span class="fc" id="L1011">    }</span>

    /** Visiting an invalid subvector. */
    @Test
    public void testWalkInDefaultOrderChangingVisitor2() {
<span class="fc" id="L1016">        final ArrayFieldVector&lt;Fraction&gt; v = create(5);</span>
        final FieldVectorChangingVisitor&lt;Fraction&gt; visitor;
<span class="fc" id="L1018">        visitor = new FieldVectorChangingVisitor&lt;Fraction&gt;() {</span>

            @Override
            public Fraction visit(int index, Fraction value) {
<span class="nc" id="L1022">                return Fraction.ZERO;</span>
            }

            @Override
            public void start(int dimension, int start, int end) {
                // Do nothing
<span class="nc" id="L1028">            }</span>

            @Override
            public Fraction end() {
<span class="nc" id="L1032">                return Fraction.ZERO;</span>
            }
        };
        try {
<span class="nc" id="L1036">            v.walkInDefaultOrder(visitor, -1, 4);</span>
<span class="nc" id="L1037">            Assert.fail();</span>
<span class="fc" id="L1038">        } catch (OutOfRangeException e) {</span>
            // Expected behavior
<span class="nc" id="L1040">        }</span>
        try {
<span class="nc" id="L1042">            v.walkInDefaultOrder(visitor, 5, 4);</span>
<span class="nc" id="L1043">            Assert.fail();</span>
<span class="fc" id="L1044">        } catch (OutOfRangeException e) {</span>
            // Expected behavior
<span class="nc" id="L1046">        }</span>
        try {
<span class="nc" id="L1048">            v.walkInDefaultOrder(visitor, 0, -1);</span>
<span class="nc" id="L1049">            Assert.fail();</span>
<span class="fc" id="L1050">        } catch (OutOfRangeException e) {</span>
            // Expected behavior
<span class="nc" id="L1052">        }</span>
        try {
<span class="nc" id="L1054">            v.walkInDefaultOrder(visitor, 0, 5);</span>
<span class="nc" id="L1055">            Assert.fail();</span>
<span class="fc" id="L1056">        } catch (OutOfRangeException e) {</span>
            // Expected behavior
<span class="nc" id="L1058">        }</span>
        try {
<span class="nc" id="L1060">            v.walkInDefaultOrder(visitor, 4, 0);</span>
<span class="nc" id="L1061">            Assert.fail();</span>
<span class="fc" id="L1062">        } catch (NumberIsTooSmallException e) {</span>
            // Expected behavior
<span class="nc" id="L1064">        }</span>
<span class="fc" id="L1065">    }</span>

    /** Visiting a valid subvector. */
    @Test
    public void testWalkInDefaultOrderChangingVisitor3() {
<span class="fc" id="L1070">        final Fraction[] data = new Fraction[] {</span>
            Fraction.ZERO, Fraction.ONE, Fraction.ZERO,
            Fraction.ZERO, Fraction.TWO, Fraction.ZERO,
            Fraction.ZERO, Fraction.ZERO, new Fraction(3)
        };
<span class="fc" id="L1075">        final ArrayFieldVector&lt;Fraction&gt; v = new ArrayFieldVector&lt;&gt;(data);</span>
<span class="fc" id="L1076">        final int expectedStart = 2;</span>
<span class="fc" id="L1077">        final int expectedEnd = 7;</span>
        final FieldVectorChangingVisitor&lt;Fraction&gt; visitor;
<span class="fc" id="L1079">        visitor = new FieldVectorChangingVisitor&lt;Fraction&gt;() {</span>

            private int expectedIndex;

            @Override
            public Fraction visit(final int actualIndex, final Fraction actualValue) {
<span class="fc" id="L1085">                Assert.assertEquals(expectedIndex, actualIndex);</span>
<span class="fc" id="L1086">                Assert.assertEquals(Integer.toString(actualIndex),</span>
                                    data[actualIndex], actualValue);
<span class="fc" id="L1088">                ++expectedIndex;</span>
<span class="fc" id="L1089">                return actualValue.add(actualIndex);</span>
            }

            @Override
            public void start(final int actualSize, final int actualStart,
                              final int actualEnd) {
<span class="fc" id="L1095">                Assert.assertEquals(data.length, actualSize);</span>
<span class="fc" id="L1096">                Assert.assertEquals(expectedStart, actualStart);</span>
<span class="fc" id="L1097">                Assert.assertEquals(expectedEnd, actualEnd);</span>
<span class="fc" id="L1098">                expectedIndex = expectedStart;</span>
<span class="fc" id="L1099">            }</span>

            @Override
            public Fraction end() {
<span class="fc" id="L1103">                return Fraction.ZERO;</span>
            }
        };
<span class="fc" id="L1106">        v.walkInDefaultOrder(visitor, expectedStart, expectedEnd);</span>
<span class="fc bfc" id="L1107" title="All 2 branches covered.">        for (int i = expectedStart; i &lt;= expectedEnd; i++) {</span>
<span class="fc" id="L1108">            Assert.assertEquals(&quot;entry &quot; + i, data[i].add(i), v.getEntry(i));</span>
        }
<span class="fc" id="L1110">    }</span>

    /** The whole vector is visited. */
    @Test
    public void testWalkInOptimizedOrderChangingVisitor1() {
<span class="fc" id="L1115">        final Fraction[] data = new Fraction[] {</span>
            Fraction.ZERO, Fraction.ONE, Fraction.ZERO,
            Fraction.ZERO, Fraction.TWO, Fraction.ZERO,
            Fraction.ZERO, Fraction.ZERO, new Fraction(3)
        };
<span class="fc" id="L1120">        final ArrayFieldVector&lt;Fraction&gt; v = new ArrayFieldVector&lt;&gt;(data);</span>
        final FieldVectorChangingVisitor&lt;Fraction&gt; visitor;
<span class="fc" id="L1122">        visitor = new FieldVectorChangingVisitor&lt;Fraction&gt;() {</span>
<span class="fc" id="L1123">            private final boolean[] visited = new boolean[data.length];</span>

            @Override
            public Fraction visit(final int actualIndex, final Fraction actualValue) {
<span class="fc" id="L1127">                visited[actualIndex] = true;</span>
<span class="fc" id="L1128">                Assert.assertEquals(Integer.toString(actualIndex),</span>
                                    data[actualIndex], actualValue);
<span class="fc" id="L1130">                return actualValue.add(actualIndex);</span>
            }

            @Override
            public void start(final int actualSize, final int actualStart,
                              final int actualEnd) {
<span class="fc" id="L1136">                Assert.assertEquals(data.length, actualSize);</span>
<span class="fc" id="L1137">                Assert.assertEquals(0, actualStart);</span>
<span class="fc" id="L1138">                Assert.assertEquals(data.length - 1, actualEnd);</span>
<span class="fc" id="L1139">                Arrays.fill(visited, false);</span>
<span class="fc" id="L1140">            }</span>

            @Override
            public Fraction end() {
<span class="fc bfc" id="L1144" title="All 2 branches covered.">                for (int i = 0; i &lt; data.length; i++) {</span>
<span class="fc" id="L1145">                    Assert.assertTrue(&quot;entry &quot; + i + &quot;has not been visited&quot;,</span>
                                      visited[i]);
                }
<span class="fc" id="L1148">                return Fraction.ZERO;</span>
            }
        };
<span class="fc" id="L1151">        v.walkInOptimizedOrder(visitor);</span>
<span class="fc bfc" id="L1152" title="All 2 branches covered.">        for (int i = 0; i &lt; data.length; i++) {</span>
<span class="fc" id="L1153">            Assert.assertEquals(&quot;entry &quot; + i, data[i].add(i), v.getEntry(i));</span>
        }
<span class="fc" id="L1155">    }</span>

    /** Visiting an invalid subvector. */
    @Test
    public void testWalkInOptimizedOrderChangingVisitor2() {
<span class="fc" id="L1160">        final ArrayFieldVector&lt;Fraction&gt; v = create(5);</span>
        final FieldVectorChangingVisitor&lt;Fraction&gt; visitor;
<span class="fc" id="L1162">        visitor = new FieldVectorChangingVisitor&lt;Fraction&gt;() {</span>

            @Override
            public Fraction visit(int index, Fraction value) {
<span class="nc" id="L1166">                return Fraction.ZERO;</span>
            }

            @Override
            public void start(int dimension, int start, int end) {
                // Do nothing
<span class="nc" id="L1172">            }</span>

            @Override
            public Fraction end() {
<span class="nc" id="L1176">                return Fraction.ZERO;</span>
            }
        };
        try {
<span class="nc" id="L1180">            v.walkInOptimizedOrder(visitor, -1, 4);</span>
<span class="nc" id="L1181">            Assert.fail();</span>
<span class="fc" id="L1182">        } catch (OutOfRangeException e) {</span>
            // Expected behavior
<span class="nc" id="L1184">        }</span>
        try {
<span class="nc" id="L1186">            v.walkInOptimizedOrder(visitor, 5, 4);</span>
<span class="nc" id="L1187">            Assert.fail();</span>
<span class="fc" id="L1188">        } catch (OutOfRangeException e) {</span>
            // Expected behavior
<span class="nc" id="L1190">        }</span>
        try {
<span class="nc" id="L1192">            v.walkInOptimizedOrder(visitor, 0, -1);</span>
<span class="nc" id="L1193">            Assert.fail();</span>
<span class="fc" id="L1194">        } catch (OutOfRangeException e) {</span>
            // Expected behavior
<span class="nc" id="L1196">        }</span>
        try {
<span class="nc" id="L1198">            v.walkInOptimizedOrder(visitor, 0, 5);</span>
<span class="nc" id="L1199">            Assert.fail();</span>
<span class="fc" id="L1200">        } catch (OutOfRangeException e) {</span>
            // Expected behavior
<span class="nc" id="L1202">        }</span>
        try {
<span class="nc" id="L1204">            v.walkInOptimizedOrder(visitor, 4, 0);</span>
<span class="nc" id="L1205">            Assert.fail();</span>
<span class="fc" id="L1206">        } catch (NumberIsTooSmallException e) {</span>
            // Expected behavior
<span class="nc" id="L1208">        }</span>
<span class="fc" id="L1209">    }</span>

    /** Visiting a valid subvector. */
    @Test
    public void testWalkInOptimizedOrderChangingVisitor3() {
<span class="fc" id="L1214">        final Fraction[] data = new Fraction[] {</span>
            Fraction.ZERO, Fraction.ONE, Fraction.ZERO,
            Fraction.ZERO, Fraction.TWO, Fraction.ZERO,
            Fraction.ZERO, Fraction.ZERO, new Fraction(3)
        };
<span class="fc" id="L1219">        final ArrayFieldVector&lt;Fraction&gt; v = new ArrayFieldVector&lt;&gt;(data);</span>
<span class="fc" id="L1220">        final int expectedStart = 2;</span>
<span class="fc" id="L1221">        final int expectedEnd = 7;</span>
        final FieldVectorChangingVisitor&lt;Fraction&gt; visitor;
<span class="fc" id="L1223">        visitor = new FieldVectorChangingVisitor&lt;Fraction&gt;() {</span>
<span class="fc" id="L1224">            private final boolean[] visited = new boolean[data.length];</span>

            @Override
            public Fraction visit(final int actualIndex, final Fraction actualValue) {
<span class="fc" id="L1228">                Assert.assertEquals(Integer.toString(actualIndex),</span>
                                    data[actualIndex], actualValue);
<span class="fc" id="L1230">                visited[actualIndex] = true;</span>
<span class="fc" id="L1231">                return actualValue.add(actualIndex);</span>
            }

            @Override
            public void start(final int actualSize, final int actualStart,
                              final int actualEnd) {
<span class="fc" id="L1237">                Assert.assertEquals(data.length, actualSize);</span>
<span class="fc" id="L1238">                Assert.assertEquals(expectedStart, actualStart);</span>
<span class="fc" id="L1239">                Assert.assertEquals(expectedEnd, actualEnd);</span>
<span class="fc" id="L1240">                Arrays.fill(visited, true);</span>
<span class="fc" id="L1241">            }</span>

            @Override
            public Fraction end() {
<span class="fc bfc" id="L1245" title="All 2 branches covered.">                for (int i = expectedStart; i &lt;= expectedEnd; i++) {</span>
<span class="fc" id="L1246">                    Assert.assertTrue(&quot;entry &quot; + i + &quot;has not been visited&quot;,</span>
                                      visited[i]);
                }
<span class="fc" id="L1249">                return Fraction.ZERO;</span>
            }
        };
<span class="fc" id="L1252">        v.walkInOptimizedOrder(visitor, expectedStart, expectedEnd);</span>
<span class="fc bfc" id="L1253" title="All 2 branches covered.">        for (int i = expectedStart; i &lt;= expectedEnd; i++) {</span>
<span class="fc" id="L1254">            Assert.assertEquals(&quot;entry &quot; + i, data[i].add(i), v.getEntry(i));</span>
        }
<span class="fc" id="L1256">    }</span>

    private ArrayFieldVector&lt;Fraction&gt; create(int n) {
<span class="fc" id="L1259">        Fraction[] t = new Fraction[n];</span>
<span class="fc bfc" id="L1260" title="All 2 branches covered.">        for (int i = 0; i &lt; n; ++i) {</span>
<span class="fc" id="L1261">            t[i] = Fraction.ZERO;</span>
        }
<span class="fc" id="L1263">        return new ArrayFieldVector&lt;&gt;(t);</span>
    }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.1.201803210924</span></div></body></html>