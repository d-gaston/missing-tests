<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>SparseFieldVectorTest.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">commons_math4$All_in_commons_math4.exec</a> &gt; <a href="index.source.html" class="el_package">org.apache.commons.math4.linear</a> &gt; <span class="el_source">SparseFieldVectorTest.java</span></div><h1>SparseFieldVectorTest.java</h1><pre class="source lang-java linenums">/*
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the &quot;License&quot;); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.commons.math4.linear;


import java.util.Arrays;

import org.apache.commons.math4.exception.MathIllegalArgumentException;
import org.apache.commons.math4.exception.NumberIsTooSmallException;
import org.apache.commons.math4.exception.OutOfRangeException;
import org.apache.commons.math4.fraction.Fraction;
import org.apache.commons.math4.fraction.FractionConversionException;
import org.apache.commons.math4.fraction.FractionField;
import org.apache.commons.math4.linear.FieldMatrix;
import org.apache.commons.math4.linear.FieldVector;
import org.apache.commons.math4.linear.FieldVectorChangingVisitor;
import org.apache.commons.math4.linear.FieldVectorPreservingVisitor;
import org.apache.commons.math4.linear.SparseFieldVector;
import org.junit.Assert;
import org.junit.Test;


/**
 * Test cases for the {@link SparseFieldVector} class.
 *
 */
<span class="fc" id="L41">public class SparseFieldVectorTest {</span>

    //
<span class="fc" id="L44">    protected Fraction[][] ma1 = {{new Fraction(1), new Fraction(2), new Fraction(3)}, {new Fraction(4), new Fraction(5), new Fraction(6)}, {new Fraction(7), new Fraction(8), new Fraction(9)}};</span>
<span class="fc" id="L45">    protected Fraction[] vec1 = {new Fraction(1), new Fraction(2), new Fraction(3)};</span>
<span class="fc" id="L46">    protected Fraction[] vec2 = {new Fraction(4), new Fraction(5), new Fraction(6)};</span>
<span class="fc" id="L47">    protected Fraction[] vec3 = {new Fraction(7), new Fraction(8), new Fraction(9)};</span>
<span class="fc" id="L48">    protected Fraction[] vec4 = {new Fraction(1), new Fraction(2), new Fraction(3), new Fraction(4), new Fraction(5), new Fraction(6), new Fraction(7), new Fraction(8), new Fraction(9)};</span>
<span class="fc" id="L49">    protected Fraction[] vec_null = {new Fraction(0), new Fraction(0), new Fraction(0)};</span>
<span class="fc" id="L50">    protected Fraction[] dvec1 = {new Fraction(1), new Fraction(2), new Fraction(3), new Fraction(4), new Fraction(5), new Fraction(6), new Fraction(7), new Fraction(8),new Fraction(9)};</span>
<span class="fc" id="L51">    protected Fraction[][] mat1 = {{new Fraction(1), new Fraction(2), new Fraction(3)}, {new Fraction(4), new Fraction(5), new Fraction(6)},{ new Fraction(7), new Fraction(8), new Fraction(9)}};</span>

    // tolerances
<span class="fc" id="L54">    protected double entryTolerance = 10E-16;</span>
<span class="fc" id="L55">    protected double normTolerance = 10E-14;</span>

<span class="fc" id="L57">    protected FractionField field = FractionField.getInstance();</span>

    @Test
    public void testMapFunctions() throws FractionConversionException {
<span class="fc" id="L61">        SparseFieldVector&lt;Fraction&gt; v1 = new SparseFieldVector&lt;&gt;(field,vec1);</span>

        //octave =  v1 .+ 2.0
<span class="fc" id="L64">        FieldVector&lt;Fraction&gt; v_mapAdd = v1.mapAdd(new Fraction(2));</span>
<span class="fc" id="L65">        Fraction[] result_mapAdd = {new Fraction(3), new Fraction(4), new Fraction(5)};</span>
<span class="fc" id="L66">        Assert.assertArrayEquals(&quot;compare vectors&quot; ,result_mapAdd,v_mapAdd.toArray());</span>

        //octave =  v1 .+ 2.0
<span class="fc" id="L69">        FieldVector&lt;Fraction&gt; v_mapAddToSelf = v1.copy();</span>
<span class="fc" id="L70">        v_mapAddToSelf.mapAddToSelf(new Fraction(2));</span>
<span class="fc" id="L71">        Fraction[] result_mapAddToSelf = {new Fraction(3), new Fraction(4), new Fraction(5)};</span>
<span class="fc" id="L72">        Assert.assertArrayEquals(&quot;compare vectors&quot; ,result_mapAddToSelf,v_mapAddToSelf.toArray());</span>

        //octave =  v1 .- 2.0
<span class="fc" id="L75">        FieldVector&lt;Fraction&gt; v_mapSubtract = v1.mapSubtract(new Fraction(2));</span>
<span class="fc" id="L76">        Fraction[] result_mapSubtract = {new Fraction(-1), new Fraction(0), new Fraction(1)};</span>
<span class="fc" id="L77">        Assert.assertArrayEquals(&quot;compare vectors&quot; ,result_mapSubtract,v_mapSubtract.toArray());</span>

        //octave =  v1 .- 2.0
<span class="fc" id="L80">        FieldVector&lt;Fraction&gt; v_mapSubtractToSelf = v1.copy();</span>
<span class="fc" id="L81">        v_mapSubtractToSelf.mapSubtractToSelf(new Fraction(2));</span>
<span class="fc" id="L82">        Fraction[] result_mapSubtractToSelf = {new Fraction(-1), new Fraction(0), new Fraction(1)};</span>
<span class="fc" id="L83">        Assert.assertArrayEquals(&quot;compare vectors&quot; ,result_mapSubtractToSelf,v_mapSubtractToSelf.toArray());</span>

        //octave =  v1 .* 2.0
<span class="fc" id="L86">        FieldVector&lt;Fraction&gt; v_mapMultiply = v1.mapMultiply(new Fraction(2));</span>
<span class="fc" id="L87">        Fraction[] result_mapMultiply = {new Fraction(2), new Fraction(4), new Fraction(6)};</span>
<span class="fc" id="L88">        Assert.assertArrayEquals(&quot;compare vectors&quot; ,result_mapMultiply,v_mapMultiply.toArray());</span>

        //octave =  v1 .* 2.0
<span class="fc" id="L91">        FieldVector&lt;Fraction&gt; v_mapMultiplyToSelf = v1.copy();</span>
<span class="fc" id="L92">        v_mapMultiplyToSelf.mapMultiplyToSelf(new Fraction(2));</span>
<span class="fc" id="L93">        Fraction[] result_mapMultiplyToSelf = {new Fraction(2), new Fraction(4), new Fraction(6)};</span>
<span class="fc" id="L94">        Assert.assertArrayEquals(&quot;compare vectors&quot; ,result_mapMultiplyToSelf,v_mapMultiplyToSelf.toArray());</span>

        //octave =  v1 ./ 2.0
<span class="fc" id="L97">        FieldVector&lt;Fraction&gt; v_mapDivide = v1.mapDivide(new Fraction(2));</span>
<span class="fc" id="L98">        Fraction[] result_mapDivide = {new Fraction(.5d), new Fraction(1), new Fraction(1.5d)};</span>
<span class="fc" id="L99">        Assert.assertArrayEquals(&quot;compare vectors&quot; ,result_mapDivide,v_mapDivide.toArray());</span>

        //octave =  v1 ./ 2.0
<span class="fc" id="L102">        FieldVector&lt;Fraction&gt; v_mapDivideToSelf = v1.copy();</span>
<span class="fc" id="L103">        v_mapDivideToSelf.mapDivideToSelf(new Fraction(2));</span>
<span class="fc" id="L104">        Fraction[] result_mapDivideToSelf = {new Fraction(.5d), new Fraction(1), new Fraction(1.5d)};</span>
<span class="fc" id="L105">        Assert.assertArrayEquals(&quot;compare vectors&quot; ,result_mapDivideToSelf,v_mapDivideToSelf.toArray());</span>

        //octave =  v1 .^-1
<span class="fc" id="L108">        FieldVector&lt;Fraction&gt; v_mapInv = v1.mapInv();</span>
<span class="fc" id="L109">        Fraction[] result_mapInv = {new Fraction(1),new Fraction(0.5d),new Fraction(3.333333333333333e-01d)};</span>
<span class="fc" id="L110">        Assert.assertArrayEquals(&quot;compare vectors&quot; ,result_mapInv,v_mapInv.toArray());</span>

        //octave =  v1 .^-1
<span class="fc" id="L113">        FieldVector&lt;Fraction&gt; v_mapInvToSelf = v1.copy();</span>
<span class="fc" id="L114">        v_mapInvToSelf.mapInvToSelf();</span>
<span class="fc" id="L115">        Fraction[] result_mapInvToSelf = {new Fraction(1),new Fraction(0.5d),new Fraction(3.333333333333333e-01d)};</span>
<span class="fc" id="L116">        Assert.assertArrayEquals(&quot;compare vectors&quot; ,result_mapInvToSelf,v_mapInvToSelf.toArray());</span>


<span class="fc" id="L119">    }</span>

    @Test
    public void testBasicFunctions() throws FractionConversionException {
<span class="fc" id="L123">        SparseFieldVector&lt;Fraction&gt; v1 = new SparseFieldVector&lt;&gt;(field,vec1);</span>
<span class="fc" id="L124">        SparseFieldVector&lt;Fraction&gt; v2 = new SparseFieldVector&lt;&gt;(field,vec2);</span>

<span class="fc" id="L126">        FieldVector&lt;Fraction&gt; v2_t = new ArrayFieldVectorTest.FieldVectorTestImpl&lt;&gt;(vec2);</span>

        //octave =  v1 + v2
<span class="fc" id="L129">        FieldVector&lt;Fraction&gt; v_add = v1.add(v2);</span>
<span class="fc" id="L130">        Fraction[] result_add = {new Fraction(5), new Fraction(7), new Fraction(9)};</span>
<span class="fc" id="L131">        Assert.assertArrayEquals(&quot;compare vect&quot; ,v_add.toArray(),result_add);</span>

<span class="fc" id="L133">        FieldVector&lt;Fraction&gt; vt2 = new ArrayFieldVectorTest.FieldVectorTestImpl&lt;&gt;(vec2);</span>
<span class="fc" id="L134">        FieldVector&lt;Fraction&gt; v_add_i = v1.add(vt2);</span>
<span class="fc" id="L135">        Fraction[] result_add_i = {new Fraction(5), new Fraction(7), new Fraction(9)};</span>
<span class="fc" id="L136">        Assert.assertArrayEquals(&quot;compare vect&quot; ,v_add_i.toArray(),result_add_i);</span>

        //octave =  v1 - v2
<span class="fc" id="L139">        SparseFieldVector&lt;Fraction&gt; v_subtract = v1.subtract(v2);</span>
<span class="fc" id="L140">        Fraction[] result_subtract = {new Fraction(-3), new Fraction(-3), new Fraction(-3)};</span>
<span class="fc" id="L141">        assertClose(&quot;compare vect&quot; ,v_subtract.toArray(),result_subtract,normTolerance);</span>

<span class="fc" id="L143">        FieldVector&lt;Fraction&gt; v_subtract_i = v1.subtract(vt2);</span>
<span class="fc" id="L144">        Fraction[] result_subtract_i = {new Fraction(-3), new Fraction(-3), new Fraction(-3)};</span>
<span class="fc" id="L145">        assertClose(&quot;compare vect&quot; ,v_subtract_i.toArray(),result_subtract_i,normTolerance);</span>

        // octave v1 .* v2
<span class="fc" id="L148">        FieldVector&lt;Fraction&gt;  v_ebeMultiply = v1.ebeMultiply(v2);</span>
<span class="fc" id="L149">        Fraction[] result_ebeMultiply = {new Fraction(4), new Fraction(10), new Fraction(18)};</span>
<span class="fc" id="L150">        assertClose(&quot;compare vect&quot; ,v_ebeMultiply.toArray(),result_ebeMultiply,normTolerance);</span>

<span class="fc" id="L152">        FieldVector&lt;Fraction&gt;  v_ebeMultiply_2 = v1.ebeMultiply(v2_t);</span>
<span class="fc" id="L153">        Fraction[] result_ebeMultiply_2 = {new Fraction(4), new Fraction(10), new Fraction(18)};</span>
<span class="fc" id="L154">        assertClose(&quot;compare vect&quot; ,v_ebeMultiply_2.toArray(),result_ebeMultiply_2,normTolerance);</span>

        // octave v1 ./ v2
<span class="fc" id="L157">        FieldVector&lt;Fraction&gt;  v_ebeDivide = v1.ebeDivide(v2);</span>
<span class="fc" id="L158">        Fraction[] result_ebeDivide = {new Fraction(0.25d), new Fraction(0.4d), new Fraction(0.5d)};</span>
<span class="fc" id="L159">        assertClose(&quot;compare vect&quot; ,v_ebeDivide.toArray(),result_ebeDivide,normTolerance);</span>

<span class="fc" id="L161">        FieldVector&lt;Fraction&gt;  v_ebeDivide_2 = v1.ebeDivide(v2_t);</span>
<span class="fc" id="L162">        Fraction[] result_ebeDivide_2 = {new Fraction(0.25d), new Fraction(0.4d), new Fraction(0.5d)};</span>
<span class="fc" id="L163">        assertClose(&quot;compare vect&quot; ,v_ebeDivide_2.toArray(),result_ebeDivide_2,normTolerance);</span>

        // octave  dot(v1,v2)
<span class="fc" id="L166">        Fraction dot =  v1.dotProduct(v2);</span>
<span class="fc" id="L167">        Assert.assertEquals(&quot;compare val &quot;,new Fraction(32), dot);</span>

        // octave  dot(v1,v2_t)
<span class="fc" id="L170">        Fraction dot_2 =  v1.dotProduct(v2_t);</span>
<span class="fc" id="L171">        Assert.assertEquals(&quot;compare val &quot;,new Fraction(32), dot_2);</span>

<span class="fc" id="L173">        FieldMatrix&lt;Fraction&gt; m_outerProduct = v1.outerProduct(v2);</span>
<span class="fc" id="L174">        Assert.assertEquals(&quot;compare val &quot;,new Fraction(4), m_outerProduct.getEntry(0,0));</span>

<span class="fc" id="L176">        FieldMatrix&lt;Fraction&gt; m_outerProduct_2 = v1.outerProduct(v2_t);</span>
<span class="fc" id="L177">        Assert.assertEquals(&quot;compare val &quot;,new Fraction(4), m_outerProduct_2.getEntry(0,0));</span>

<span class="fc" id="L179">    }</span>

    @Test
    public void testOuterProduct() {
<span class="fc" id="L183">        final SparseFieldVector&lt;Fraction&gt; u</span>
<span class="fc" id="L184">            = new SparseFieldVector&lt;&gt;(FractionField.getInstance(),</span>
                                              new Fraction[] {new Fraction(1),
                                                              new Fraction(2),
                                                              new Fraction(-3)});
<span class="fc" id="L188">        final SparseFieldVector&lt;Fraction&gt; v</span>
<span class="fc" id="L189">            = new SparseFieldVector&lt;&gt;(FractionField.getInstance(),</span>
                                              new Fraction[] {new Fraction(4),
                                                              new Fraction(-2)});

<span class="fc" id="L193">        final FieldMatrix&lt;Fraction&gt; uv = u.outerProduct(v);</span>

<span class="fc" id="L195">        final double tol = Math.ulp(1d);</span>
<span class="fc" id="L196">        Assert.assertEquals(new Fraction(4).doubleValue(), uv.getEntry(0, 0).doubleValue(), tol);</span>
<span class="fc" id="L197">        Assert.assertEquals(new Fraction(-2).doubleValue(), uv.getEntry(0, 1).doubleValue(), tol);</span>
<span class="fc" id="L198">        Assert.assertEquals(new Fraction(8).doubleValue(), uv.getEntry(1, 0).doubleValue(), tol);</span>
<span class="fc" id="L199">        Assert.assertEquals(new Fraction(-4).doubleValue(), uv.getEntry(1, 1).doubleValue(), tol);</span>
<span class="fc" id="L200">        Assert.assertEquals(new Fraction(-12).doubleValue(), uv.getEntry(2, 0).doubleValue(), tol);</span>
<span class="fc" id="L201">        Assert.assertEquals(new Fraction(6).doubleValue(), uv.getEntry(2, 1).doubleValue(), tol);</span>
<span class="fc" id="L202">    }</span>

    @Test
    public void testMisc() {
<span class="fc" id="L206">        SparseFieldVector&lt;Fraction&gt; v1 = new SparseFieldVector&lt;&gt;(field,vec1);</span>

<span class="fc" id="L208">        String out1 = v1.toString();</span>
<span class="pc bpc" id="L209" title="1 of 2 branches missed.">        Assert.assertTrue(&quot;some output &quot;,  out1.length()!=0);</span>
        try {
<span class="nc" id="L211">            v1.checkVectorDimensions(2);</span>
<span class="nc" id="L212">            Assert.fail(&quot;MathIllegalArgumentException expected&quot;);</span>
<span class="fc" id="L213">        } catch (MathIllegalArgumentException ex) {</span>
            // expected behavior
<span class="nc" id="L215">        }</span>


<span class="fc" id="L218">    }</span>

    @Test
    public void testPredicates() {

<span class="fc" id="L223">        SparseFieldVector&lt;Fraction&gt; v = new SparseFieldVector&lt;&gt;(field, new Fraction[] { new Fraction(0), new Fraction(1), new Fraction(2) });</span>

<span class="fc" id="L225">        v.setEntry(0, field.getZero());</span>
<span class="fc" id="L226">        Assert.assertEquals(v, new SparseFieldVector&lt;&gt;(field, new Fraction[] { new Fraction(0), new Fraction(1), new Fraction(2) }));</span>
<span class="fc" id="L227">        Assert.assertNotSame(v, new SparseFieldVector&lt;&gt;(field, new Fraction[] { new Fraction(0), new Fraction(1), new Fraction(2), new Fraction(3) }));</span>

<span class="fc" id="L229">    }</span>

    /** verifies that two vectors are close (sup norm) */
    protected void assertEquals(String msg, Fraction[] m, Fraction[] n) {
<span class="nc bnc" id="L233" title="All 2 branches missed.">        if (m.length != n.length) {</span>
<span class="nc" id="L234">            Assert.fail(&quot;vectors have different lengths&quot;);</span>
        }
<span class="nc bnc" id="L236" title="All 2 branches missed.">        for (int i = 0; i &lt; m.length; i++) {</span>
<span class="nc" id="L237">            Assert.assertEquals(msg + &quot; &quot; +  i + &quot; elements differ&quot;, m[i],n[i]);</span>
        }
<span class="nc" id="L239">    }</span>

    /** verifies that two vectors are close (sup norm) */
    protected void assertClose(String msg, Fraction[] m, Fraction[] n, double tolerance) {
<span class="pc bpc" id="L243" title="1 of 2 branches missed.">        if (m.length != n.length) {</span>
<span class="nc" id="L244">            Assert.fail(&quot;vectors have different lengths&quot;);</span>
        }
<span class="fc bfc" id="L246" title="All 2 branches covered.">        for (int i = 0; i &lt; m.length; i++) {</span>
<span class="fc" id="L247">            Assert.assertEquals(msg + &quot; &quot; +  i + &quot; elements differ&quot;, m[i].doubleValue(),n[i].doubleValue(), tolerance);</span>
        }
<span class="fc" id="L249">    }</span>

    /*
     * TESTS OF THE VISITOR PATTERN
     */

    /** The whole vector is visited. */
    @Test
    public void testWalkInDefaultOrderPreservingVisitor1() {
<span class="fc" id="L258">        final Fraction[] data = new Fraction[] {</span>
            Fraction.ZERO, Fraction.ONE, Fraction.ZERO,
            Fraction.ZERO, Fraction.TWO, Fraction.ZERO,
            Fraction.ZERO, Fraction.ZERO, new Fraction(3)
        };
<span class="fc" id="L263">        final SparseFieldVector&lt;Fraction&gt; v = new SparseFieldVector&lt;&gt;(field, data);</span>
        final FieldVectorPreservingVisitor&lt;Fraction&gt; visitor;
<span class="fc" id="L265">        visitor = new FieldVectorPreservingVisitor&lt;Fraction&gt;() {</span>

            private int expectedIndex;

            @Override
            public void visit(final int actualIndex, final Fraction actualValue) {
<span class="fc" id="L271">                Assert.assertEquals(expectedIndex, actualIndex);</span>
<span class="fc" id="L272">                Assert.assertEquals(Integer.toString(actualIndex),</span>
                                    data[actualIndex], actualValue);
<span class="fc" id="L274">                ++expectedIndex;</span>
<span class="fc" id="L275">            }</span>

            @Override
            public void start(final int actualSize, final int actualStart,
                              final int actualEnd) {
<span class="fc" id="L280">                Assert.assertEquals(data.length, actualSize);</span>
<span class="fc" id="L281">                Assert.assertEquals(0, actualStart);</span>
<span class="fc" id="L282">                Assert.assertEquals(data.length - 1, actualEnd);</span>
<span class="fc" id="L283">                expectedIndex = 0;</span>
<span class="fc" id="L284">            }</span>

            @Override
            public Fraction end() {
<span class="fc" id="L288">                return Fraction.ZERO;</span>
            }
        };
<span class="fc" id="L291">        v.walkInDefaultOrder(visitor);</span>
<span class="fc" id="L292">    }</span>

    /** Visiting an invalid subvector. */
    @Test
    public void testWalkInDefaultOrderPreservingVisitor2() {
<span class="fc" id="L297">        final SparseFieldVector&lt;Fraction&gt; v = create(5);</span>
        final FieldVectorPreservingVisitor&lt;Fraction&gt; visitor;
<span class="fc" id="L299">        visitor = new FieldVectorPreservingVisitor&lt;Fraction&gt;() {</span>

            @Override
            public void visit(int index, Fraction value) {
                // Do nothing
<span class="nc" id="L304">            }</span>

            @Override
            public void start(int dimension, int start, int end) {
                // Do nothing
<span class="nc" id="L309">            }</span>

            @Override
            public Fraction end() {
<span class="nc" id="L313">                return Fraction.ZERO;</span>
            }
        };
        try {
<span class="nc" id="L317">            v.walkInDefaultOrder(visitor, -1, 4);</span>
<span class="nc" id="L318">            Assert.fail();</span>
<span class="fc" id="L319">        } catch (OutOfRangeException e) {</span>
            // Expected behavior
<span class="nc" id="L321">        }</span>
        try {
<span class="nc" id="L323">            v.walkInDefaultOrder(visitor, 5, 4);</span>
<span class="nc" id="L324">            Assert.fail();</span>
<span class="fc" id="L325">        } catch (OutOfRangeException e) {</span>
            // Expected behavior
<span class="nc" id="L327">        }</span>
        try {
<span class="nc" id="L329">            v.walkInDefaultOrder(visitor, 0, -1);</span>
<span class="nc" id="L330">            Assert.fail();</span>
<span class="fc" id="L331">        } catch (OutOfRangeException e) {</span>
            // Expected behavior
<span class="nc" id="L333">        }</span>
        try {
<span class="nc" id="L335">            v.walkInDefaultOrder(visitor, 0, 5);</span>
<span class="nc" id="L336">            Assert.fail();</span>
<span class="fc" id="L337">        } catch (OutOfRangeException e) {</span>
            // Expected behavior
<span class="nc" id="L339">        }</span>
        try {
<span class="nc" id="L341">            v.walkInDefaultOrder(visitor, 4, 0);</span>
<span class="nc" id="L342">            Assert.fail();</span>
<span class="fc" id="L343">        } catch (NumberIsTooSmallException e) {</span>
            // Expected behavior
<span class="nc" id="L345">        }</span>
<span class="fc" id="L346">    }</span>

    /** Visiting a valid subvector. */
    @Test
    public void testWalkInDefaultOrderPreservingVisitor3() {
<span class="fc" id="L351">        final Fraction[] data = new Fraction[] {</span>
            Fraction.ZERO, Fraction.ONE, Fraction.ZERO,
            Fraction.ZERO, Fraction.TWO, Fraction.ZERO,
            Fraction.ZERO, Fraction.ZERO, new Fraction(3)
        };
<span class="fc" id="L356">        final SparseFieldVector&lt;Fraction&gt; v = new SparseFieldVector&lt;&gt;(field, data);</span>
<span class="fc" id="L357">        final int expectedStart = 2;</span>
<span class="fc" id="L358">        final int expectedEnd = 7;</span>
        final FieldVectorPreservingVisitor&lt;Fraction&gt; visitor;
<span class="fc" id="L360">        visitor = new FieldVectorPreservingVisitor&lt;Fraction&gt;() {</span>

            private int expectedIndex;

            @Override
            public void visit(final int actualIndex, final Fraction actualValue) {
<span class="fc" id="L366">                Assert.assertEquals(expectedIndex, actualIndex);</span>
<span class="fc" id="L367">                Assert.assertEquals(Integer.toString(actualIndex),</span>
                                    data[actualIndex], actualValue);
<span class="fc" id="L369">                ++expectedIndex;</span>
<span class="fc" id="L370">            }</span>

            @Override
            public void start(final int actualSize, final int actualStart,
                              final int actualEnd) {
<span class="fc" id="L375">                Assert.assertEquals(data.length, actualSize);</span>
<span class="fc" id="L376">                Assert.assertEquals(expectedStart, actualStart);</span>
<span class="fc" id="L377">                Assert.assertEquals(expectedEnd, actualEnd);</span>
<span class="fc" id="L378">                expectedIndex = expectedStart;</span>
<span class="fc" id="L379">            }</span>

            @Override
            public Fraction end() {
<span class="fc" id="L383">                return Fraction.ZERO;</span>
            }
        };
<span class="fc" id="L386">        v.walkInDefaultOrder(visitor, expectedStart, expectedEnd);</span>
<span class="fc" id="L387">    }</span>

    /** The whole vector is visited. */
    @Test
    public void testWalkInOptimizedOrderPreservingVisitor1() {
<span class="fc" id="L392">        final Fraction[] data = new Fraction[] {</span>
            Fraction.ZERO, Fraction.ONE, Fraction.ZERO,
            Fraction.ZERO, Fraction.TWO, Fraction.ZERO,
            Fraction.ZERO, Fraction.ZERO, new Fraction(3)
        };
<span class="fc" id="L397">        final SparseFieldVector&lt;Fraction&gt; v = new SparseFieldVector&lt;&gt;(field, data);</span>
        final FieldVectorPreservingVisitor&lt;Fraction&gt; visitor;
<span class="fc" id="L399">        visitor = new FieldVectorPreservingVisitor&lt;Fraction&gt;() {</span>
<span class="fc" id="L400">            private final boolean[] visited = new boolean[data.length];</span>

            @Override
            public void visit(final int actualIndex, final Fraction actualValue) {
<span class="fc" id="L404">                visited[actualIndex] = true;</span>
<span class="fc" id="L405">                Assert.assertEquals(Integer.toString(actualIndex),</span>
                                    data[actualIndex], actualValue);
<span class="fc" id="L407">            }</span>

            @Override
            public void start(final int actualSize, final int actualStart,
                              final int actualEnd) {
<span class="fc" id="L412">                Assert.assertEquals(data.length, actualSize);</span>
<span class="fc" id="L413">                Assert.assertEquals(0, actualStart);</span>
<span class="fc" id="L414">                Assert.assertEquals(data.length - 1, actualEnd);</span>
<span class="fc" id="L415">                Arrays.fill(visited, false);</span>
<span class="fc" id="L416">            }</span>

            @Override
            public Fraction end() {
<span class="fc bfc" id="L420" title="All 2 branches covered.">                for (int i = 0; i &lt; data.length; i++) {</span>
<span class="fc" id="L421">                    Assert.assertTrue(&quot;entry &quot; + i + &quot;has not been visited&quot;,</span>
                                      visited[i]);
                }
<span class="fc" id="L424">                return Fraction.ZERO;</span>
            }
        };
<span class="fc" id="L427">        v.walkInOptimizedOrder(visitor);</span>
<span class="fc" id="L428">    }</span>

    /** Visiting an invalid subvector. */
    @Test
    public void testWalkInOptimizedOrderPreservingVisitor2() {
<span class="fc" id="L433">        final SparseFieldVector&lt;Fraction&gt; v = create(5);</span>
        final FieldVectorPreservingVisitor&lt;Fraction&gt; visitor;
<span class="fc" id="L435">        visitor = new FieldVectorPreservingVisitor&lt;Fraction&gt;() {</span>

            @Override
            public void visit(int index, Fraction value) {
                // Do nothing
<span class="nc" id="L440">            }</span>

            @Override
            public void start(int dimension, int start, int end) {
                // Do nothing
<span class="nc" id="L445">            }</span>

            @Override
            public Fraction end() {
<span class="nc" id="L449">                return Fraction.ZERO;</span>
            }
        };
        try {
<span class="nc" id="L453">            v.walkInOptimizedOrder(visitor, -1, 4);</span>
<span class="nc" id="L454">            Assert.fail();</span>
<span class="fc" id="L455">        } catch (OutOfRangeException e) {</span>
            // Expected behavior
<span class="nc" id="L457">        }</span>
        try {
<span class="nc" id="L459">            v.walkInOptimizedOrder(visitor, 5, 4);</span>
<span class="nc" id="L460">            Assert.fail();</span>
<span class="fc" id="L461">        } catch (OutOfRangeException e) {</span>
            // Expected behavior
<span class="nc" id="L463">        }</span>
        try {
<span class="nc" id="L465">            v.walkInOptimizedOrder(visitor, 0, -1);</span>
<span class="nc" id="L466">            Assert.fail();</span>
<span class="fc" id="L467">        } catch (OutOfRangeException e) {</span>
            // Expected behavior
<span class="nc" id="L469">        }</span>
        try {
<span class="nc" id="L471">            v.walkInOptimizedOrder(visitor, 0, 5);</span>
<span class="nc" id="L472">            Assert.fail();</span>
<span class="fc" id="L473">        } catch (OutOfRangeException e) {</span>
            // Expected behavior
<span class="nc" id="L475">        }</span>
        try {
<span class="nc" id="L477">            v.walkInOptimizedOrder(visitor, 4, 0);</span>
<span class="nc" id="L478">            Assert.fail();</span>
<span class="fc" id="L479">        } catch (NumberIsTooSmallException e) {</span>
            // Expected behavior
<span class="nc" id="L481">        }</span>
<span class="fc" id="L482">    }</span>

    /** Visiting a valid subvector. */
    @Test
    public void testWalkInOptimizedOrderPreservingVisitor3() {
<span class="fc" id="L487">        final Fraction[] data = new Fraction[] {</span>
            Fraction.ZERO, Fraction.ONE, Fraction.ZERO,
            Fraction.ZERO, Fraction.TWO, Fraction.ZERO,
            Fraction.ZERO, Fraction.ZERO, new Fraction(3)
        };
<span class="fc" id="L492">        final SparseFieldVector&lt;Fraction&gt; v = new SparseFieldVector&lt;&gt;(field, data);</span>
<span class="fc" id="L493">        final int expectedStart = 2;</span>
<span class="fc" id="L494">        final int expectedEnd = 7;</span>
        final FieldVectorPreservingVisitor&lt;Fraction&gt; visitor;
<span class="fc" id="L496">        visitor = new FieldVectorPreservingVisitor&lt;Fraction&gt;() {</span>
<span class="fc" id="L497">            private final boolean[] visited = new boolean[data.length];</span>

            @Override
            public void visit(final int actualIndex, final Fraction actualValue) {
<span class="fc" id="L501">                Assert.assertEquals(Integer.toString(actualIndex),</span>
                                    data[actualIndex], actualValue);
<span class="fc" id="L503">                visited[actualIndex] = true;</span>
<span class="fc" id="L504">            }</span>

            @Override
            public void start(final int actualSize, final int actualStart,
                              final int actualEnd) {
<span class="fc" id="L509">                Assert.assertEquals(data.length, actualSize);</span>
<span class="fc" id="L510">                Assert.assertEquals(expectedStart, actualStart);</span>
<span class="fc" id="L511">                Assert.assertEquals(expectedEnd, actualEnd);</span>
<span class="fc" id="L512">                Arrays.fill(visited, true);</span>
<span class="fc" id="L513">            }</span>

            @Override
            public Fraction end() {
<span class="fc bfc" id="L517" title="All 2 branches covered.">                for (int i = expectedStart; i &lt;= expectedEnd; i++) {</span>
<span class="fc" id="L518">                    Assert.assertTrue(&quot;entry &quot; + i + &quot;has not been visited&quot;,</span>
                                      visited[i]);
                }
<span class="fc" id="L521">                return Fraction.ZERO;</span>
            }
        };
<span class="fc" id="L524">        v.walkInOptimizedOrder(visitor, expectedStart, expectedEnd);</span>
<span class="fc" id="L525">    }</span>

    /** The whole vector is visited. */
    @Test
    public void testWalkInDefaultOrderChangingVisitor1() {
<span class="fc" id="L530">        final Fraction[] data = new Fraction[] {</span>
            Fraction.ZERO, Fraction.ONE, Fraction.ZERO,
            Fraction.ZERO, Fraction.TWO, Fraction.ZERO,
            Fraction.ZERO, Fraction.ZERO, new Fraction(3)
        };
<span class="fc" id="L535">        final SparseFieldVector&lt;Fraction&gt; v = new SparseFieldVector&lt;&gt;(field, data);</span>
        final FieldVectorChangingVisitor&lt;Fraction&gt; visitor;
<span class="fc" id="L537">        visitor = new FieldVectorChangingVisitor&lt;Fraction&gt;() {</span>

            private int expectedIndex;

            @Override
            public Fraction visit(final int actualIndex, final Fraction actualValue) {
<span class="fc" id="L543">                Assert.assertEquals(expectedIndex, actualIndex);</span>
<span class="fc" id="L544">                Assert.assertEquals(Integer.toString(actualIndex),</span>
                                    data[actualIndex], actualValue);
<span class="fc" id="L546">                ++expectedIndex;</span>
<span class="fc" id="L547">                return actualValue.add(actualIndex);</span>
            }

            @Override
            public void start(final int actualSize, final int actualStart,
                              final int actualEnd) {
<span class="fc" id="L553">                Assert.assertEquals(data.length, actualSize);</span>
<span class="fc" id="L554">                Assert.assertEquals(0, actualStart);</span>
<span class="fc" id="L555">                Assert.assertEquals(data.length - 1, actualEnd);</span>
<span class="fc" id="L556">                expectedIndex = 0;</span>
<span class="fc" id="L557">            }</span>

            @Override
            public Fraction end() {
<span class="fc" id="L561">                return Fraction.ZERO;</span>
            }
        };
<span class="fc" id="L564">        v.walkInDefaultOrder(visitor);</span>
<span class="fc bfc" id="L565" title="All 2 branches covered.">        for (int i = 0; i &lt; data.length; i++) {</span>
<span class="fc" id="L566">            Assert.assertEquals(&quot;entry &quot; + i, data[i].add(i), v.getEntry(i));</span>
        }
<span class="fc" id="L568">    }</span>

    /** Visiting an invalid subvector. */
    @Test
    public void testWalkInDefaultOrderChangingVisitor2() {
<span class="fc" id="L573">        final SparseFieldVector&lt;Fraction&gt; v = create(5);</span>
        final FieldVectorChangingVisitor&lt;Fraction&gt; visitor;
<span class="fc" id="L575">        visitor = new FieldVectorChangingVisitor&lt;Fraction&gt;() {</span>

            @Override
            public Fraction visit(int index, Fraction value) {
<span class="nc" id="L579">                return Fraction.ZERO;</span>
            }

            @Override
            public void start(int dimension, int start, int end) {
                // Do nothing
<span class="nc" id="L585">            }</span>

            @Override
            public Fraction end() {
<span class="nc" id="L589">                return Fraction.ZERO;</span>
            }
        };
        try {
<span class="nc" id="L593">            v.walkInDefaultOrder(visitor, -1, 4);</span>
<span class="nc" id="L594">            Assert.fail();</span>
<span class="fc" id="L595">        } catch (OutOfRangeException e) {</span>
            // Expected behavior
<span class="nc" id="L597">        }</span>
        try {
<span class="nc" id="L599">            v.walkInDefaultOrder(visitor, 5, 4);</span>
<span class="nc" id="L600">            Assert.fail();</span>
<span class="fc" id="L601">        } catch (OutOfRangeException e) {</span>
            // Expected behavior
<span class="nc" id="L603">        }</span>
        try {
<span class="nc" id="L605">            v.walkInDefaultOrder(visitor, 0, -1);</span>
<span class="nc" id="L606">            Assert.fail();</span>
<span class="fc" id="L607">        } catch (OutOfRangeException e) {</span>
            // Expected behavior
<span class="nc" id="L609">        }</span>
        try {
<span class="nc" id="L611">            v.walkInDefaultOrder(visitor, 0, 5);</span>
<span class="nc" id="L612">            Assert.fail();</span>
<span class="fc" id="L613">        } catch (OutOfRangeException e) {</span>
            // Expected behavior
<span class="nc" id="L615">        }</span>
        try {
<span class="nc" id="L617">            v.walkInDefaultOrder(visitor, 4, 0);</span>
<span class="nc" id="L618">            Assert.fail();</span>
<span class="fc" id="L619">        } catch (NumberIsTooSmallException e) {</span>
            // Expected behavior
<span class="nc" id="L621">        }</span>
<span class="fc" id="L622">    }</span>

    /** Visiting a valid subvector. */
    @Test
    public void testWalkInDefaultOrderChangingVisitor3() {
<span class="fc" id="L627">        final Fraction[] data = new Fraction[] {</span>
            Fraction.ZERO, Fraction.ONE, Fraction.ZERO,
            Fraction.ZERO, Fraction.TWO, Fraction.ZERO,
            Fraction.ZERO, Fraction.ZERO, new Fraction(3)
        };
<span class="fc" id="L632">        final SparseFieldVector&lt;Fraction&gt; v = new SparseFieldVector&lt;&gt;(field, data);</span>
<span class="fc" id="L633">        final int expectedStart = 2;</span>
<span class="fc" id="L634">        final int expectedEnd = 7;</span>
        final FieldVectorChangingVisitor&lt;Fraction&gt; visitor;
<span class="fc" id="L636">        visitor = new FieldVectorChangingVisitor&lt;Fraction&gt;() {</span>

            private int expectedIndex;

            @Override
            public Fraction visit(final int actualIndex, final Fraction actualValue) {
<span class="fc" id="L642">                Assert.assertEquals(expectedIndex, actualIndex);</span>
<span class="fc" id="L643">                Assert.assertEquals(Integer.toString(actualIndex),</span>
                                    data[actualIndex], actualValue);
<span class="fc" id="L645">                ++expectedIndex;</span>
<span class="fc" id="L646">                return actualValue.add(actualIndex);</span>
            }

            @Override
            public void start(final int actualSize, final int actualStart,
                              final int actualEnd) {
<span class="fc" id="L652">                Assert.assertEquals(data.length, actualSize);</span>
<span class="fc" id="L653">                Assert.assertEquals(expectedStart, actualStart);</span>
<span class="fc" id="L654">                Assert.assertEquals(expectedEnd, actualEnd);</span>
<span class="fc" id="L655">                expectedIndex = expectedStart;</span>
<span class="fc" id="L656">            }</span>

            @Override
            public Fraction end() {
<span class="fc" id="L660">                return Fraction.ZERO;</span>
            }
        };
<span class="fc" id="L663">        v.walkInDefaultOrder(visitor, expectedStart, expectedEnd);</span>
<span class="fc bfc" id="L664" title="All 2 branches covered.">        for (int i = expectedStart; i &lt;= expectedEnd; i++) {</span>
<span class="fc" id="L665">            Assert.assertEquals(&quot;entry &quot; + i, data[i].add(i), v.getEntry(i));</span>
        }
<span class="fc" id="L667">    }</span>

    /** The whole vector is visited. */
    @Test
    public void testWalkInOptimizedOrderChangingVisitor1() {
<span class="fc" id="L672">        final Fraction[] data = new Fraction[] {</span>
            Fraction.ZERO, Fraction.ONE, Fraction.ZERO,
            Fraction.ZERO, Fraction.TWO, Fraction.ZERO,
            Fraction.ZERO, Fraction.ZERO, new Fraction(3)
        };
<span class="fc" id="L677">        final SparseFieldVector&lt;Fraction&gt; v = new SparseFieldVector&lt;&gt;(field, data);</span>
        final FieldVectorChangingVisitor&lt;Fraction&gt; visitor;
<span class="fc" id="L679">        visitor = new FieldVectorChangingVisitor&lt;Fraction&gt;() {</span>
<span class="fc" id="L680">            private final boolean[] visited = new boolean[data.length];</span>

            @Override
            public Fraction visit(final int actualIndex, final Fraction actualValue) {
<span class="fc" id="L684">                visited[actualIndex] = true;</span>
<span class="fc" id="L685">                Assert.assertEquals(Integer.toString(actualIndex),</span>
                                    data[actualIndex], actualValue);
<span class="fc" id="L687">                return actualValue.add(actualIndex);</span>
            }

            @Override
            public void start(final int actualSize, final int actualStart,
                              final int actualEnd) {
<span class="fc" id="L693">                Assert.assertEquals(data.length, actualSize);</span>
<span class="fc" id="L694">                Assert.assertEquals(0, actualStart);</span>
<span class="fc" id="L695">                Assert.assertEquals(data.length - 1, actualEnd);</span>
<span class="fc" id="L696">                Arrays.fill(visited, false);</span>
<span class="fc" id="L697">            }</span>

            @Override
            public Fraction end() {
<span class="fc bfc" id="L701" title="All 2 branches covered.">                for (int i = 0; i &lt; data.length; i++) {</span>
<span class="fc" id="L702">                    Assert.assertTrue(&quot;entry &quot; + i + &quot;has not been visited&quot;,</span>
                                      visited[i]);
                }
<span class="fc" id="L705">                return Fraction.ZERO;</span>
            }
        };
<span class="fc" id="L708">        v.walkInOptimizedOrder(visitor);</span>
<span class="fc bfc" id="L709" title="All 2 branches covered.">        for (int i = 0; i &lt; data.length; i++) {</span>
<span class="fc" id="L710">            Assert.assertEquals(&quot;entry &quot; + i, data[i].add(i), v.getEntry(i));</span>
        }
<span class="fc" id="L712">    }</span>

    /** Visiting an invalid subvector. */
    @Test
    public void testWalkInOptimizedOrderChangingVisitor2() {
<span class="fc" id="L717">        final SparseFieldVector&lt;Fraction&gt; v = create(5);</span>
        final FieldVectorChangingVisitor&lt;Fraction&gt; visitor;
<span class="fc" id="L719">        visitor = new FieldVectorChangingVisitor&lt;Fraction&gt;() {</span>

            @Override
            public Fraction visit(int index, Fraction value) {
<span class="nc" id="L723">                return Fraction.ZERO;</span>
            }

            @Override
            public void start(int dimension, int start, int end) {
                // Do nothing
<span class="nc" id="L729">            }</span>

            @Override
            public Fraction end() {
<span class="nc" id="L733">                return Fraction.ZERO;</span>
            }
        };
        try {
<span class="nc" id="L737">            v.walkInOptimizedOrder(visitor, -1, 4);</span>
<span class="nc" id="L738">            Assert.fail();</span>
<span class="fc" id="L739">        } catch (OutOfRangeException e) {</span>
            // Expected behavior
<span class="nc" id="L741">        }</span>
        try {
<span class="nc" id="L743">            v.walkInOptimizedOrder(visitor, 5, 4);</span>
<span class="nc" id="L744">            Assert.fail();</span>
<span class="fc" id="L745">        } catch (OutOfRangeException e) {</span>
            // Expected behavior
<span class="nc" id="L747">        }</span>
        try {
<span class="nc" id="L749">            v.walkInOptimizedOrder(visitor, 0, -1);</span>
<span class="nc" id="L750">            Assert.fail();</span>
<span class="fc" id="L751">        } catch (OutOfRangeException e) {</span>
            // Expected behavior
<span class="nc" id="L753">        }</span>
        try {
<span class="nc" id="L755">            v.walkInOptimizedOrder(visitor, 0, 5);</span>
<span class="nc" id="L756">            Assert.fail();</span>
<span class="fc" id="L757">        } catch (OutOfRangeException e) {</span>
            // Expected behavior
<span class="nc" id="L759">        }</span>
        try {
<span class="nc" id="L761">            v.walkInOptimizedOrder(visitor, 4, 0);</span>
<span class="nc" id="L762">            Assert.fail();</span>
<span class="fc" id="L763">        } catch (NumberIsTooSmallException e) {</span>
            // Expected behavior
<span class="nc" id="L765">        }</span>
<span class="fc" id="L766">    }</span>

    /** Visiting a valid subvector. */
    @Test
    public void testWalkInOptimizedOrderChangingVisitor3() {
<span class="fc" id="L771">        final Fraction[] data = new Fraction[] {</span>
            Fraction.ZERO, Fraction.ONE, Fraction.ZERO,
            Fraction.ZERO, Fraction.TWO, Fraction.ZERO,
            Fraction.ZERO, Fraction.ZERO, new Fraction(3)
        };
<span class="fc" id="L776">        final SparseFieldVector&lt;Fraction&gt; v = new SparseFieldVector&lt;&gt;(field, data);</span>
<span class="fc" id="L777">        final int expectedStart = 2;</span>
<span class="fc" id="L778">        final int expectedEnd = 7;</span>
        final FieldVectorChangingVisitor&lt;Fraction&gt; visitor;
<span class="fc" id="L780">        visitor = new FieldVectorChangingVisitor&lt;Fraction&gt;() {</span>
<span class="fc" id="L781">            private final boolean[] visited = new boolean[data.length];</span>

            @Override
            public Fraction visit(final int actualIndex, final Fraction actualValue) {
<span class="fc" id="L785">                Assert.assertEquals(Integer.toString(actualIndex),</span>
                                    data[actualIndex], actualValue);
<span class="fc" id="L787">                visited[actualIndex] = true;</span>
<span class="fc" id="L788">                return actualValue.add(actualIndex);</span>
            }

            @Override
            public void start(final int actualSize, final int actualStart,
                              final int actualEnd) {
<span class="fc" id="L794">                Assert.assertEquals(data.length, actualSize);</span>
<span class="fc" id="L795">                Assert.assertEquals(expectedStart, actualStart);</span>
<span class="fc" id="L796">                Assert.assertEquals(expectedEnd, actualEnd);</span>
<span class="fc" id="L797">                Arrays.fill(visited, true);</span>
<span class="fc" id="L798">            }</span>

            @Override
            public Fraction end() {
<span class="fc bfc" id="L802" title="All 2 branches covered.">                for (int i = expectedStart; i &lt;= expectedEnd; i++) {</span>
<span class="fc" id="L803">                    Assert.assertTrue(&quot;entry &quot; + i + &quot;has not been visited&quot;,</span>
                                      visited[i]);
                }
<span class="fc" id="L806">                return Fraction.ZERO;</span>
            }
        };
<span class="fc" id="L809">        v.walkInOptimizedOrder(visitor, expectedStart, expectedEnd);</span>
<span class="fc bfc" id="L810" title="All 2 branches covered.">        for (int i = expectedStart; i &lt;= expectedEnd; i++) {</span>
<span class="fc" id="L811">            Assert.assertEquals(&quot;entry &quot; + i, data[i].add(i), v.getEntry(i));</span>
        }
<span class="fc" id="L813">    }</span>

    private SparseFieldVector&lt;Fraction&gt; create(int n) {
<span class="fc" id="L816">        Fraction[] t = new Fraction[n];</span>
<span class="fc bfc" id="L817" title="All 2 branches covered.">        for (int i = 0; i &lt; n; ++i) {</span>
<span class="fc" id="L818">            t[i] = Fraction.ZERO;</span>
        }
<span class="fc" id="L820">        return new SparseFieldVector&lt;&gt;(field, t);</span>
    }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.1.201803210924</span></div></body></html>