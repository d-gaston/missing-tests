<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>EigenDecompositionTest.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">commons_math4$All_in_commons_math4.exec</a> &gt; <a href="index.source.html" class="el_package">org.apache.commons.math4.linear</a> &gt; <span class="el_source">EigenDecompositionTest.java</span></div><h1>EigenDecompositionTest.java</h1><pre class="source lang-java linenums">/*
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the &quot;License&quot;); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package org.apache.commons.math4.linear;

import java.util.Arrays;
import java.util.Random;

import org.apache.commons.statistics.distribution.ContinuousDistribution;
import org.apache.commons.statistics.distribution.NormalDistribution;
import org.apache.commons.math4.exception.MathUnsupportedOperationException;
import org.apache.commons.math4.linear.ArrayRealVector;
import org.apache.commons.math4.linear.EigenDecomposition;
import org.apache.commons.math4.linear.LUDecomposition;
import org.apache.commons.math4.linear.MatrixUtils;
import org.apache.commons.math4.linear.RealMatrix;
import org.apache.commons.math4.linear.RealVector;
import org.apache.commons.math4.linear.TriDiagonalTransformer;
import org.apache.commons.math4.util.FastMath;
import org.apache.commons.math4.util.MathArrays;
import org.apache.commons.numbers.core.Precision;
import org.apache.commons.rng.simple.RandomSource;
import org.junit.After;
import org.junit.Assert;
import org.junit.Before;
import org.junit.Ignore;
import org.junit.Test;

<span class="fc" id="L43">public class EigenDecompositionTest {</span>

    private double[] refValues;
    private RealMatrix matrix;

    @Test
    public void testDimension1() {
<span class="fc" id="L50">        RealMatrix matrix =</span>
<span class="fc" id="L51">            MatrixUtils.createRealMatrix(new double[][] { { 1.5 } });</span>
        EigenDecomposition ed;
<span class="fc" id="L53">        ed = new EigenDecomposition(matrix);</span>
<span class="fc" id="L54">        Assert.assertEquals(1.5, ed.getRealEigenvalue(0), 1.0e-15);</span>
<span class="fc" id="L55">    }</span>

    @Test
    public void testDimension2() {
<span class="fc" id="L59">        RealMatrix matrix =</span>
<span class="fc" id="L60">            MatrixUtils.createRealMatrix(new double[][] {</span>
                    { 59.0, 12.0 },
                    { 12.0, 66.0 }
            });
        EigenDecomposition ed;
<span class="fc" id="L65">        ed = new EigenDecomposition(matrix);</span>
<span class="fc" id="L66">        Assert.assertEquals(75.0, ed.getRealEigenvalue(0), 1.0e-15);</span>
<span class="fc" id="L67">        Assert.assertEquals(50.0, ed.getRealEigenvalue(1), 1.0e-15);</span>
<span class="fc" id="L68">    }</span>

    @Test
    public void testDimension3() {
<span class="fc" id="L72">        RealMatrix matrix =</span>
<span class="fc" id="L73">            MatrixUtils.createRealMatrix(new double[][] {</span>
                                   {  39632.0, -4824.0, -16560.0 },
                                   {  -4824.0,  8693.0,   7920.0 },
                                   { -16560.0,  7920.0,  17300.0 }
                               });
        EigenDecomposition ed;
<span class="fc" id="L79">        ed = new EigenDecomposition(matrix);</span>
<span class="fc" id="L80">        Assert.assertEquals(50000.0, ed.getRealEigenvalue(0), 3.0e-11);</span>
<span class="fc" id="L81">        Assert.assertEquals(12500.0, ed.getRealEigenvalue(1), 3.0e-11);</span>
<span class="fc" id="L82">        Assert.assertEquals( 3125.0, ed.getRealEigenvalue(2), 3.0e-11);</span>
<span class="fc" id="L83">    }</span>

    @Test
    public void testDimension3MultipleRoot() {
<span class="fc" id="L87">        RealMatrix matrix =</span>
<span class="fc" id="L88">            MatrixUtils.createRealMatrix(new double[][] {</span>
                    {  5,   10,   15 },
                    { 10,   20,   30 },
                    { 15,   30,   45 }
            });
        EigenDecomposition ed;
<span class="fc" id="L94">        ed = new EigenDecomposition(matrix);</span>
<span class="fc" id="L95">        Assert.assertEquals(70.0, ed.getRealEigenvalue(0), 3.0e-11);</span>
<span class="fc" id="L96">        Assert.assertEquals(0.0,  ed.getRealEigenvalue(1), 3.0e-11);</span>
<span class="fc" id="L97">        Assert.assertEquals(0.0,  ed.getRealEigenvalue(2), 3.0e-11);</span>
<span class="fc" id="L98">    }</span>

    @Test
    public void testDimension4WithSplit() {
<span class="fc" id="L102">        RealMatrix matrix =</span>
<span class="fc" id="L103">            MatrixUtils.createRealMatrix(new double[][] {</span>
                                   {  0.784, -0.288,  0.000,  0.000 },
                                   { -0.288,  0.616,  0.000,  0.000 },
                                   {  0.000,  0.000,  0.164, -0.048 },
                                   {  0.000,  0.000, -0.048,  0.136 }
                               });
        EigenDecomposition ed;
<span class="fc" id="L110">        ed = new EigenDecomposition(matrix);</span>
<span class="fc" id="L111">        Assert.assertEquals(1.0, ed.getRealEigenvalue(0), 1.0e-15);</span>
<span class="fc" id="L112">        Assert.assertEquals(0.4, ed.getRealEigenvalue(1), 1.0e-15);</span>
<span class="fc" id="L113">        Assert.assertEquals(0.2, ed.getRealEigenvalue(2), 1.0e-15);</span>
<span class="fc" id="L114">        Assert.assertEquals(0.1, ed.getRealEigenvalue(3), 1.0e-15);</span>
<span class="fc" id="L115">    }</span>

    @Test
    public void testDimension4WithoutSplit() {
<span class="fc" id="L119">        RealMatrix matrix =</span>
<span class="fc" id="L120">            MatrixUtils.createRealMatrix(new double[][] {</span>
                                   {  0.5608, -0.2016,  0.1152, -0.2976 },
                                   { -0.2016,  0.4432, -0.2304,  0.1152 },
                                   {  0.1152, -0.2304,  0.3088, -0.1344 },
                                   { -0.2976,  0.1152, -0.1344,  0.3872 }
                               });
        EigenDecomposition ed;
<span class="fc" id="L127">        ed = new EigenDecomposition(matrix);</span>
<span class="fc" id="L128">        Assert.assertEquals(1.0, ed.getRealEigenvalue(0), 1.0e-15);</span>
<span class="fc" id="L129">        Assert.assertEquals(0.4, ed.getRealEigenvalue(1), 1.0e-15);</span>
<span class="fc" id="L130">        Assert.assertEquals(0.2, ed.getRealEigenvalue(2), 1.0e-15);</span>
<span class="fc" id="L131">        Assert.assertEquals(0.1, ed.getRealEigenvalue(3), 1.0e-15);</span>
<span class="fc" id="L132">    }</span>

    // the following test triggered an ArrayIndexOutOfBoundsException in commons-math 2.0
    @Test
    public void testMath308() {

<span class="fc" id="L138">        double[] mainTridiagonal = {</span>
            22.330154644539597, 46.65485522478641, 17.393672330044705, 54.46687435351116, 80.17800767709437
        };
<span class="fc" id="L141">        double[] secondaryTridiagonal = {</span>
            13.04450406501361, -5.977590941539671, 2.9040909856707517, 7.1570352792841225
        };

        // the reference values have been computed using routine DSTEMR
        // from the fortran library LAPACK version 3.2.1
<span class="fc" id="L147">        double[] refEigenValues = {</span>
            82.044413207204002, 53.456697699894512, 52.536278520113882, 18.847969733754262, 14.138204224043099
        };
<span class="fc" id="L150">        RealVector[] refEigenVectors = {</span>
            new ArrayRealVector(new double[] { -0.000462690386766, -0.002118073109055,  0.011530080757413,  0.252322434584915,  0.967572088232592 }),
            new ArrayRealVector(new double[] {  0.314647769490148,  0.750806415553905, -0.167700312025760, -0.537092972407375,  0.143854968127780 }),
            new ArrayRealVector(new double[] {  0.222368839324646,  0.514921891363332, -0.021377019336614,  0.801196801016305, -0.207446991247740 }),
            new ArrayRealVector(new double[] { -0.713933751051495,  0.190582113553930, -0.671410443368332,  0.056056055955050, -0.006541576993581 }),
            new ArrayRealVector(new double[] { -0.584677060845929,  0.367177264979103,  0.721453187784497, -0.052971054621812,  0.005740715188257 })
        };

        EigenDecomposition decomposition;
<span class="fc" id="L159">        decomposition = new EigenDecomposition(mainTridiagonal, secondaryTridiagonal);</span>

<span class="fc" id="L161">        double[] eigenValues = decomposition.getRealEigenvalues();</span>
<span class="fc bfc" id="L162" title="All 2 branches covered.">        for (int i = 0; i &lt; refEigenValues.length; ++i) {</span>
<span class="fc" id="L163">            Assert.assertEquals(refEigenValues[i], eigenValues[i], 1.0e-5);</span>
<span class="fc" id="L164">            Assert.assertEquals(0, refEigenVectors[i].subtract(decomposition.getEigenvector(i)).getNorm(), 2.0e-7);</span>
        }

<span class="fc" id="L167">    }</span>

    @Test
    public void testMathpbx02() {

<span class="fc" id="L172">        double[] mainTridiagonal = {</span>
              7484.860960227216, 18405.28129035345, 13855.225609560746,
             10016.708722343366, 559.8117399576674, 6750.190788301587,
                71.21428769782159
        };
<span class="fc" id="L177">        double[] secondaryTridiagonal = {</span>
             -4175.088570476366,1975.7955858241994,5193.178422374075,
              1995.286659169179,75.34535882933804,-234.0808002076056
        };

        // the reference values have been computed using routine DSTEMR
        // from the fortran library LAPACK version 3.2.1
<span class="fc" id="L184">        double[] refEigenValues = {</span>
                20654.744890306974412,16828.208208485466457,
                6893.155912634994820,6757.083016675340332,
                5887.799885688558788,64.309089923240379,
                57.992628792736340
        };
<span class="fc" id="L190">        RealVector[] refEigenVectors = {</span>
                new ArrayRealVector(new double[] {-0.270356342026904, 0.852811091326997, 0.399639490702077, 0.198794657813990, 0.019739323307666, 0.000106983022327, -0.000001216636321}),
                new ArrayRealVector(new double[] {0.179995273578326,-0.402807848153042,0.701870993525734,0.555058211014888,0.068079148898236,0.000509139115227,-0.000007112235617}),
                new ArrayRealVector(new double[] {-0.399582721284727,-0.056629954519333,-0.514406488522827,0.711168164518580,0.225548081276367,0.125943999652923,-0.004321507456014}),
                new ArrayRealVector(new double[] {0.058515721572821,0.010200130057739,0.063516274916536,-0.090696087449378,-0.017148420432597,0.991318870265707,-0.034707338554096}),
                new ArrayRealVector(new double[] {0.855205995537564,0.327134656629775,-0.265382397060548,0.282690729026706,0.105736068025572,-0.009138126622039,0.000367751821196}),
                new ArrayRealVector(new double[] {-0.002913069901144,-0.005177515777101,0.041906334478672,-0.109315918416258,0.436192305456741,0.026307315639535,0.891797507436344}),
                new ArrayRealVector(new double[] {-0.005738311176435,-0.010207611670378,0.082662420517928,-0.215733886094368,0.861606487840411,-0.025478530652759,-0.451080697503958})
        };

        // the following line triggers the exception
        EigenDecomposition decomposition;
<span class="fc" id="L202">        decomposition = new EigenDecomposition(mainTridiagonal, secondaryTridiagonal);</span>

<span class="fc" id="L204">        double[] eigenValues = decomposition.getRealEigenvalues();</span>
<span class="fc bfc" id="L205" title="All 2 branches covered.">        for (int i = 0; i &lt; refEigenValues.length; ++i) {</span>
<span class="fc" id="L206">            Assert.assertEquals(refEigenValues[i], eigenValues[i], 1.0e-3);</span>
<span class="fc bfc" id="L207" title="All 2 branches covered.">            if (refEigenVectors[i].dotProduct(decomposition.getEigenvector(i)) &lt; 0) {</span>
<span class="fc" id="L208">                Assert.assertEquals(0, refEigenVectors[i].add(decomposition.getEigenvector(i)).getNorm(), 1.0e-5);</span>
            } else {
<span class="fc" id="L210">                Assert.assertEquals(0, refEigenVectors[i].subtract(decomposition.getEigenvector(i)).getNorm(), 1.0e-5);</span>
            }
        }

<span class="fc" id="L214">    }</span>

    @Test
    public void testMathpbx03() {

<span class="fc" id="L219">        double[] mainTridiagonal = {</span>
            1809.0978259647177,3395.4763425956166,1832.1894584712693,3804.364873592377,
            806.0482458637571,2403.656427234185,28.48691431556015
        };
<span class="fc" id="L223">        double[] secondaryTridiagonal = {</span>
            -656.8932064545833,-469.30804108920734,-1021.7714889369421,
            -1152.540497328983,-939.9765163817368,-12.885877015422391
        };

        // the reference values have been computed using routine DSTEMR
        // from the fortran library LAPACK version 3.2.1
<span class="fc" id="L230">        double[] refEigenValues = {</span>
            4603.121913685183245,3691.195818048970978,2743.442955402465032,1657.596442107321764,
            1336.797819095331306,30.129865209677519,17.035352085224986
        };

<span class="fc" id="L235">        RealVector[] refEigenVectors = {</span>
            new ArrayRealVector(new double[] {-0.036249830202337,0.154184732411519,-0.346016328392363,0.867540105133093,-0.294483395433451,0.125854235969548,-0.000354507444044}),
            new ArrayRealVector(new double[] {-0.318654191697157,0.912992309960507,-0.129270874079777,-0.184150038178035,0.096521712579439,-0.070468788536461,0.000247918177736}),
            new ArrayRealVector(new double[] {-0.051394668681147,0.073102235876933,0.173502042943743,-0.188311980310942,-0.327158794289386,0.905206581432676,-0.004296342252659}),
            new ArrayRealVector(new double[] {0.838150199198361,0.193305209055716,-0.457341242126146,-0.166933875895419,0.094512811358535,0.119062381338757,-0.000941755685226}),
            new ArrayRealVector(new double[] {0.438071395458547,0.314969169786246,0.768480630802146,0.227919171600705,-0.193317045298647,-0.170305467485594,0.001677380536009}),
            new ArrayRealVector(new double[] {-0.003726503878741,-0.010091946369146,-0.067152015137611,-0.113798146542187,-0.313123000097908,-0.118940107954918,0.932862311396062}),
            new ArrayRealVector(new double[] {0.009373003194332,0.025570377559400,0.170955836081348,0.291954519805750,0.807824267665706,0.320108347088646,0.360202112392266}),
        };

        // the following line triggers the exception
        EigenDecomposition decomposition;
<span class="fc" id="L247">        decomposition = new EigenDecomposition(mainTridiagonal, secondaryTridiagonal);</span>

<span class="fc" id="L249">        double[] eigenValues = decomposition.getRealEigenvalues();</span>
<span class="fc bfc" id="L250" title="All 2 branches covered.">        for (int i = 0; i &lt; refEigenValues.length; ++i) {</span>
<span class="fc" id="L251">            Assert.assertEquals(refEigenValues[i], eigenValues[i], 1.0e-4);</span>
<span class="fc bfc" id="L252" title="All 2 branches covered.">            if (refEigenVectors[i].dotProduct(decomposition.getEigenvector(i)) &lt; 0) {</span>
<span class="fc" id="L253">                Assert.assertEquals(0, refEigenVectors[i].add(decomposition.getEigenvector(i)).getNorm(), 1.0e-5);</span>
            } else {
<span class="fc" id="L255">                Assert.assertEquals(0, refEigenVectors[i].subtract(decomposition.getEigenvector(i)).getNorm(), 1.0e-5);</span>
            }
        }

<span class="fc" id="L259">    }</span>

    /** test a matrix already in tridiagonal form. */
    @Test
    public void testTridiagonal() {
<span class="fc" id="L264">        Random r = new Random(4366663527842l);</span>
<span class="fc" id="L265">        double[] ref = new double[30];</span>
<span class="fc bfc" id="L266" title="All 2 branches covered.">        for (int i = 0; i &lt; ref.length; ++i) {</span>
<span class="fc bfc" id="L267" title="All 2 branches covered.">            if (i &lt; 5) {</span>
<span class="fc" id="L268">                ref[i] = 2 * r.nextDouble() - 1;</span>
            } else {
<span class="fc" id="L270">                ref[i] = 0.0001 * r.nextDouble() + 6;</span>
            }
        }
<span class="fc" id="L273">        Arrays.sort(ref);</span>
<span class="fc" id="L274">        TriDiagonalTransformer t =</span>
<span class="fc" id="L275">            new TriDiagonalTransformer(createTestMatrix(r, ref));</span>
        EigenDecomposition ed;
<span class="fc" id="L277">        ed = new EigenDecomposition(t.getMainDiagonalRef(), t.getSecondaryDiagonalRef());</span>
<span class="fc" id="L278">        double[] eigenValues = ed.getRealEigenvalues();</span>
<span class="fc" id="L279">        Assert.assertEquals(ref.length, eigenValues.length);</span>
<span class="fc bfc" id="L280" title="All 2 branches covered.">        for (int i = 0; i &lt; ref.length; ++i) {</span>
<span class="fc" id="L281">            Assert.assertEquals(ref[ref.length - i - 1], eigenValues[i], 2.0e-14);</span>
        }

<span class="fc" id="L284">    }</span>

    /** test dimensions */
    @Test
    public void testDimensions() {
<span class="fc" id="L289">        final int m = matrix.getRowDimension();</span>
        EigenDecomposition ed;
<span class="fc" id="L291">        ed = new EigenDecomposition(matrix);</span>
<span class="fc" id="L292">        Assert.assertEquals(m, ed.getV().getRowDimension());</span>
<span class="fc" id="L293">        Assert.assertEquals(m, ed.getV().getColumnDimension());</span>
<span class="fc" id="L294">        Assert.assertEquals(m, ed.getD().getColumnDimension());</span>
<span class="fc" id="L295">        Assert.assertEquals(m, ed.getD().getColumnDimension());</span>
<span class="fc" id="L296">        Assert.assertEquals(m, ed.getVT().getRowDimension());</span>
<span class="fc" id="L297">        Assert.assertEquals(m, ed.getVT().getColumnDimension());</span>
<span class="fc" id="L298">    }</span>

    /** test eigenvalues */
    @Test
    public void testEigenvalues() {
        EigenDecomposition ed;
<span class="fc" id="L304">        ed = new EigenDecomposition(matrix);</span>
<span class="fc" id="L305">        double[] eigenValues = ed.getRealEigenvalues();</span>
<span class="fc" id="L306">        Assert.assertEquals(refValues.length, eigenValues.length);</span>
<span class="fc bfc" id="L307" title="All 2 branches covered.">        for (int i = 0; i &lt; refValues.length; ++i) {</span>
<span class="fc" id="L308">            Assert.assertEquals(refValues[i], eigenValues[i], 3.0e-15);</span>
        }
<span class="fc" id="L310">    }</span>

    /** test eigenvalues for a big matrix. */
    @Test
    public void testBigMatrix() {
<span class="fc" id="L315">        Random r = new Random(17748333525117l);</span>
<span class="fc" id="L316">        double[] bigValues = new double[200];</span>
<span class="fc bfc" id="L317" title="All 2 branches covered.">        for (int i = 0; i &lt; bigValues.length; ++i) {</span>
<span class="fc" id="L318">            bigValues[i] = 2 * r.nextDouble() - 1;</span>
        }
<span class="fc" id="L320">        Arrays.sort(bigValues);</span>
        EigenDecomposition ed;
<span class="fc" id="L322">        ed = new EigenDecomposition(createTestMatrix(r, bigValues));</span>
<span class="fc" id="L323">        double[] eigenValues = ed.getRealEigenvalues();</span>
<span class="fc" id="L324">        Assert.assertEquals(bigValues.length, eigenValues.length);</span>
<span class="fc bfc" id="L325" title="All 2 branches covered.">        for (int i = 0; i &lt; bigValues.length; ++i) {</span>
<span class="fc" id="L326">            Assert.assertEquals(bigValues[bigValues.length - i - 1], eigenValues[i], 2.0e-14);</span>
        }
<span class="fc" id="L328">    }</span>

    @Test
    public void testSymmetric() {
<span class="fc" id="L332">        RealMatrix symmetric = MatrixUtils.createRealMatrix(new double[][] {</span>
                {4, 1, 1},
                {1, 2, 3},
                {1, 3, 6}
        });

        EigenDecomposition ed;
<span class="fc" id="L339">        ed = new EigenDecomposition(symmetric);</span>

<span class="fc" id="L341">        RealMatrix d = ed.getD();</span>
<span class="fc" id="L342">        RealMatrix v = ed.getV();</span>
<span class="fc" id="L343">        RealMatrix vT = ed.getVT();</span>

<span class="fc" id="L345">        double norm = v.multiply(d).multiply(vT).subtract(symmetric).getNorm();</span>
<span class="fc" id="L346">        Assert.assertEquals(0, norm, 6.0e-13);</span>
<span class="fc" id="L347">    }</span>

    @Test
    public void testSquareRoot() {
<span class="fc" id="L351">        final double[][] data = {</span>
            { 33, 24,  7 },
            { 24, 57, 11 },
            {  7, 11,  9 }
        };

<span class="fc" id="L357">        final EigenDecomposition dec = new EigenDecomposition(MatrixUtils.createRealMatrix(data));</span>
<span class="fc" id="L358">        final RealMatrix sqrtM = dec.getSquareRoot();</span>

        // Reconstruct initial matrix.
<span class="fc" id="L361">        final RealMatrix m = sqrtM.multiply(sqrtM);</span>

<span class="fc" id="L363">        final int dim = data.length;</span>
<span class="fc bfc" id="L364" title="All 2 branches covered.">        for (int r = 0; r &lt; dim; r++) {</span>
<span class="fc bfc" id="L365" title="All 2 branches covered.">            for (int c = 0; c &lt; dim; c++) {</span>
<span class="fc" id="L366">                Assert.assertEquals(&quot;m[&quot; + r + &quot;][&quot; + c + &quot;]&quot;,</span>
<span class="fc" id="L367">                                    data[r][c], m.getEntry(r, c), 1e-13);</span>
            }
        }
<span class="fc" id="L370">    }</span>

    @Test(expected=MathUnsupportedOperationException.class)
    public void testSquareRootNonSymmetric() {
<span class="fc" id="L374">        final double[][] data = {</span>
            { 1,  2, 4 },
            { 2,  3, 5 },
            { 11, 5, 9 }
        };

<span class="fc" id="L380">        final EigenDecomposition dec = new EigenDecomposition(MatrixUtils.createRealMatrix(data));</span>
        @SuppressWarnings(&quot;unused&quot;)
<span class="nc" id="L382">        final RealMatrix sqrtM = dec.getSquareRoot();</span>
<span class="nc" id="L383">    }</span>

    @Test(expected=MathUnsupportedOperationException.class)
    public void testSquareRootNonPositiveDefinite() {
<span class="fc" id="L387">        final double[][] data = {</span>
            { 1, 2,  4 },
            { 2, 3,  5 },
            { 4, 5, -9 }
        };

<span class="fc" id="L393">        final EigenDecomposition dec = new EigenDecomposition(MatrixUtils.createRealMatrix(data));</span>
        @SuppressWarnings(&quot;unused&quot;)
<span class="nc" id="L395">        final RealMatrix sqrtM = dec.getSquareRoot();</span>
<span class="nc" id="L396">    }</span>

    @Test
    public void testUnsymmetric() {
        // Vandermonde matrix V(x;i,j) = x_i^{n - j} with x = (-1,-2,3,4)
<span class="fc" id="L401">        double[][] vData = { { -1.0, 1.0, -1.0, 1.0 },</span>
                             { -8.0, 4.0, -2.0, 1.0 },
                             { 27.0, 9.0,  3.0, 1.0 },
                             { 64.0, 16.0, 4.0, 1.0 } };
<span class="fc" id="L405">        checkUnsymmetricMatrix(MatrixUtils.createRealMatrix(vData));</span>

<span class="fc" id="L407">        RealMatrix randMatrix = MatrixUtils.createRealMatrix(new double[][] {</span>
                {0,  1,     0,     0},
                {1,  0,     2.e-7, 0},
                {0, -2.e-7, 0,     1},
                {0,  0,     1,     0}
        });
<span class="fc" id="L413">        checkUnsymmetricMatrix(randMatrix);</span>

        // from http://eigen.tuxfamily.org/dox/classEigen_1_1RealSchur.html
<span class="fc" id="L416">        double[][] randData2 = {</span>
                {  0.680, -0.3300, -0.2700, -0.717, -0.687,  0.0259 },
                { -0.211,  0.5360,  0.0268,  0.214, -0.198,  0.6780 },
                {  0.566, -0.4440,  0.9040, -0.967, -0.740,  0.2250 },
                {  0.597,  0.1080,  0.8320, -0.514, -0.782, -0.4080 },
                {  0.823, -0.0452,  0.2710, -0.726,  0.998,  0.2750 },
                { -0.605,  0.2580,  0.4350,  0.608, -0.563,  0.0486 }
        };
<span class="fc" id="L424">        checkUnsymmetricMatrix(MatrixUtils.createRealMatrix(randData2));</span>
<span class="fc" id="L425">    }</span>

    @Test
    @Ignore
    public void testRandomUnsymmetricMatrix() {
<span class="nc bnc" id="L430" title="All 2 branches missed.">        for (int run = 0; run &lt; 100; run++) {</span>
<span class="nc" id="L431">            Random r = new Random(System.currentTimeMillis());</span>

            // matrix size
<span class="nc" id="L434">            int size = r.nextInt(20) + 4;</span>

<span class="nc" id="L436">            double[][] data = new double[size][size];</span>
<span class="nc bnc" id="L437" title="All 2 branches missed.">            for (int i = 0; i &lt; size; i++) {</span>
<span class="nc bnc" id="L438" title="All 2 branches missed.">                for (int j = 0; j &lt; size; j++) {</span>
<span class="nc" id="L439">                    data[i][j] = r.nextInt(100);</span>
                }
            }

<span class="nc" id="L443">            RealMatrix m = MatrixUtils.createRealMatrix(data);</span>
<span class="nc" id="L444">            checkUnsymmetricMatrix(m);</span>
        }
<span class="nc" id="L446">    }</span>

    /**
     * Tests the porting of a bugfix in Jama-1.0.3 (from changelog):
     *
     *  Patched hqr2 method in Jama.EigenvalueDecomposition to avoid infinite loop;
     *  Thanks Frederic Devernay &lt;frederic.devernay@m4x.org&gt;
     */
    @Test
    public void testMath1051() {
<span class="fc" id="L456">        double[][] data = {</span>
                {0,0,0,0,0},
                {0,0,0,0,1},
                {0,0,0,1,0},
                {1,1,0,0,1},
                {1,0,1,0,1}
        };

<span class="fc" id="L464">        RealMatrix m = MatrixUtils.createRealMatrix(data);</span>
<span class="fc" id="L465">        checkUnsymmetricMatrix(m);</span>
<span class="fc" id="L466">    }</span>

    @Test
    @Ignore
    public void testNormalDistributionUnsymmetricMatrix() {
<span class="nc bnc" id="L471" title="All 2 branches missed.">        for (int run = 0; run &lt; 100; run++) {</span>
<span class="nc" id="L472">            Random r = new Random(System.currentTimeMillis());</span>
<span class="nc" id="L473">            ContinuousDistribution.Sampler dist</span>
<span class="nc" id="L474">                = new NormalDistribution(0.0, r.nextDouble() * 5).createSampler(RandomSource.create(RandomSource.WELL_512_A,</span>
<span class="nc" id="L475">                                                                                                    64925784252L));</span>

            // matrix size
<span class="nc" id="L478">            int size = r.nextInt(20) + 4;</span>

<span class="nc" id="L480">            double[][] data = new double[size][size];</span>
<span class="nc bnc" id="L481" title="All 2 branches missed.">            for (int i = 0; i &lt; size; i++) {</span>
<span class="nc bnc" id="L482" title="All 2 branches missed.">                for (int j = 0; j &lt; size; j++) {</span>
<span class="nc" id="L483">                    data[i][j] = dist.sample();</span>
                }
            }

<span class="nc" id="L487">            RealMatrix m = MatrixUtils.createRealMatrix(data);</span>
<span class="nc" id="L488">            checkUnsymmetricMatrix(m);</span>
        }
<span class="nc" id="L490">    }</span>

    @Test
    public void testMath848() {
<span class="fc" id="L494">        double[][] data = {</span>
                { 0.1849449280, -0.0646971046,  0.0774755812, -0.0969651755, -0.0692648806,  0.3282344352, -0.0177423074,  0.2063136340},
                {-0.0742700134, -0.0289063030, -0.0017269460, -0.0375550146, -0.0487737922, -0.2616837868, -0.0821201295, -0.2530000167},
                { 0.2549910127,  0.0995733692, -0.0009718388,  0.0149282808,  0.1791878897, -0.0823182816,  0.0582629256,  0.3219545182},
                {-0.0694747557, -0.1880649148, -0.2740630911,  0.0720096468, -0.1800836914, -0.3518996425,  0.2486747833,  0.6257938167},
                { 0.0536360918, -0.1339297778,  0.2241579764, -0.0195327484, -0.0054103808,  0.0347564518,  0.5120802482, -0.0329902864},
                {-0.5933332356, -0.2488721082,  0.2357173629,  0.0177285473,  0.0856630593, -0.3567126300, -0.1600668126, -0.1010899621},
                {-0.0514349819, -0.0854319435,  0.1125050061,  0.0063453560, -0.2250000688, -0.2209343090,  0.1964623477, -0.1512329924},
                { 0.0197395947, -0.1997170581, -0.1425959019, -0.2749477910, -0.0969467073,  0.0603688520, -0.2826905192,  0.1794315473}};
<span class="fc" id="L503">        RealMatrix m = MatrixUtils.createRealMatrix(data);</span>
<span class="fc" id="L504">        checkUnsymmetricMatrix(m);</span>
<span class="fc" id="L505">    }</span>

    /**
     * Checks that the eigen decomposition of a general (unsymmetric) matrix is valid by
     * checking: A*V = V*D
     */
    private void checkUnsymmetricMatrix(final RealMatrix m) {
        try {
<span class="fc" id="L513">            EigenDecomposition ed = new EigenDecomposition(m);</span>

<span class="fc" id="L515">            RealMatrix d = ed.getD();</span>
<span class="fc" id="L516">            RealMatrix v = ed.getV();</span>
            //RealMatrix vT = ed.getVT();

<span class="fc" id="L519">            RealMatrix x = m.multiply(v);</span>
<span class="fc" id="L520">            RealMatrix y = v.multiply(d);</span>

<span class="fc" id="L522">            double diffNorm = x.subtract(y).getNorm();</span>
<span class="fc" id="L523">            Assert.assertTrue(&quot;The norm of (X-Y) is too large: &quot; + diffNorm + &quot;, matrix=&quot; + m.toString(),</span>
<span class="pc bpc" id="L524" title="1 of 2 branches missed.">                    x.subtract(y).getNorm() &lt; 1000 * Precision.EPSILON * FastMath.max(x.getNorm(), y.getNorm()));</span>

<span class="fc" id="L526">            RealMatrix invV = new LUDecomposition(v).getSolver().getInverse();</span>
<span class="fc" id="L527">            double norm = v.multiply(d).multiply(invV).subtract(m).getNorm();</span>
<span class="fc" id="L528">            Assert.assertEquals(0.0, norm, 1.0e-10);</span>
<span class="nc" id="L529">        } catch (Exception e) {</span>
<span class="nc" id="L530">            Assert.fail(&quot;Failed to create EigenDecomposition for matrix &quot; + m.toString() + &quot;, ex=&quot; + e.toString());</span>
<span class="fc" id="L531">        }</span>
<span class="fc" id="L532">    }</span>

    /** test eigenvectors */
    @Test
    public void testEigenvectors() {
        EigenDecomposition ed;
<span class="fc" id="L538">        ed = new EigenDecomposition(matrix);</span>
<span class="fc bfc" id="L539" title="All 2 branches covered.">        for (int i = 0; i &lt; matrix.getRowDimension(); ++i) {</span>
<span class="fc" id="L540">            double lambda = ed.getRealEigenvalue(i);</span>
<span class="fc" id="L541">            RealVector v  = ed.getEigenvector(i);</span>
<span class="fc" id="L542">            RealVector mV = matrix.operate(v);</span>
<span class="fc" id="L543">            Assert.assertEquals(0, mV.subtract(v.mapMultiplyToSelf(lambda)).getNorm(), 1.0e-13);</span>
        }
<span class="fc" id="L545">    }</span>

    /** test A = VDVt */
    @Test
    public void testAEqualVDVt() {
        EigenDecomposition ed;
<span class="fc" id="L551">        ed = new EigenDecomposition(matrix);</span>
<span class="fc" id="L552">        RealMatrix v  = ed.getV();</span>
<span class="fc" id="L553">        RealMatrix d  = ed.getD();</span>
<span class="fc" id="L554">        RealMatrix vT = ed.getVT();</span>
<span class="fc" id="L555">        double norm = v.multiply(d).multiply(vT).subtract(matrix).getNorm();</span>
<span class="fc" id="L556">        Assert.assertEquals(0, norm, 6.0e-13);</span>
<span class="fc" id="L557">    }</span>

    /** test that V is orthogonal */
    @Test
    public void testVOrthogonal() {
<span class="fc" id="L562">        RealMatrix v = new EigenDecomposition(matrix).getV();</span>
<span class="fc" id="L563">        RealMatrix vTv = v.transpose().multiply(v);</span>
<span class="fc" id="L564">        RealMatrix id  = MatrixUtils.createRealIdentityMatrix(vTv.getRowDimension());</span>
<span class="fc" id="L565">        Assert.assertEquals(0, vTv.subtract(id).getNorm(), 2.0e-13);</span>
<span class="fc" id="L566">    }</span>

    /** test diagonal matrix */
    @Test
    public void testDiagonal() {
<span class="fc" id="L571">        double[] diagonal = new double[] { -3.0, -2.0, 2.0, 5.0 };</span>
<span class="fc" id="L572">        RealMatrix m = MatrixUtils.createRealDiagonalMatrix(diagonal);</span>
        EigenDecomposition ed;
<span class="fc" id="L574">        ed = new EigenDecomposition(m);</span>
<span class="fc" id="L575">        Assert.assertEquals(diagonal[0], ed.getRealEigenvalue(3), 2.0e-15);</span>
<span class="fc" id="L576">        Assert.assertEquals(diagonal[1], ed.getRealEigenvalue(2), 2.0e-15);</span>
<span class="fc" id="L577">        Assert.assertEquals(diagonal[2], ed.getRealEigenvalue(1), 2.0e-15);</span>
<span class="fc" id="L578">        Assert.assertEquals(diagonal[3], ed.getRealEigenvalue(0), 2.0e-15);</span>
<span class="fc" id="L579">    }</span>

    /**
     * Matrix with eigenvalues {8, -1, -1}
     */
    @Test
    public void testRepeatedEigenvalue() {
<span class="fc" id="L586">        RealMatrix repeated = MatrixUtils.createRealMatrix(new double[][] {</span>
                {3,  2,  4},
                {2,  0,  2},
                {4,  2,  3}
        });
        EigenDecomposition ed;
<span class="fc" id="L592">        ed = new EigenDecomposition(repeated);</span>
<span class="fc" id="L593">        checkEigenValues((new double[] {8, -1, -1}), ed, 1E-12);</span>
<span class="fc" id="L594">        checkEigenVector((new double[] {2, 1, 2}), ed, 1E-12);</span>
<span class="fc" id="L595">    }</span>

    /**
     * Matrix with eigenvalues {2, 0, 12}
     */
    @Test
    public void testDistinctEigenvalues() {
<span class="fc" id="L602">        RealMatrix distinct = MatrixUtils.createRealMatrix(new double[][] {</span>
                {3, 1, -4},
                {1, 3, -4},
                {-4, -4, 8}
        });
        EigenDecomposition ed;
<span class="fc" id="L608">        ed = new EigenDecomposition(distinct);</span>
<span class="fc" id="L609">        checkEigenValues((new double[] {2, 0, 12}), ed, 1E-12);</span>
<span class="fc" id="L610">        checkEigenVector((new double[] {1, -1, 0}), ed, 1E-12);</span>
<span class="fc" id="L611">        checkEigenVector((new double[] {1, 1, 1}), ed, 1E-12);</span>
<span class="fc" id="L612">        checkEigenVector((new double[] {-1, -1, 2}), ed, 1E-12);</span>
<span class="fc" id="L613">    }</span>

    /**
     * Verifies operation on indefinite matrix
     */
    @Test
    public void testZeroDivide() {
<span class="fc" id="L620">        RealMatrix indefinite = MatrixUtils.createRealMatrix(new double [][] {</span>
                { 0.0, 1.0, -1.0 },
                { 1.0, 1.0, 0.0 },
                { -1.0,0.0, 1.0 }
        });
        EigenDecomposition ed;
<span class="fc" id="L626">        ed = new EigenDecomposition(indefinite);</span>
<span class="fc" id="L627">        checkEigenValues((new double[] {2, 1, -1}), ed, 1E-12);</span>
<span class="fc" id="L628">        double isqrt3 = 1/FastMath.sqrt(3.0);</span>
<span class="fc" id="L629">        checkEigenVector((new double[] {isqrt3,isqrt3,-isqrt3}), ed, 1E-12);</span>
<span class="fc" id="L630">        double isqrt2 = 1/FastMath.sqrt(2.0);</span>
<span class="fc" id="L631">        checkEigenVector((new double[] {0.0,-isqrt2,-isqrt2}), ed, 1E-12);</span>
<span class="fc" id="L632">        double isqrt6 = 1/FastMath.sqrt(6.0);</span>
<span class="fc" id="L633">        checkEigenVector((new double[] {2*isqrt6,-isqrt6,isqrt6}), ed, 1E-12);</span>
<span class="fc" id="L634">    }</span>

    /**
     * Verifies operation on very small values.
     * Matrix with eigenvalues {2e-100, 0, 12e-100}
     */
    @Test
    public void testTinyValues() {
<span class="fc" id="L642">        final double tiny = 1e-100;</span>
<span class="fc" id="L643">        RealMatrix distinct = MatrixUtils.createRealMatrix(new double[][] {</span>
                {3, 1, -4},
                {1, 3, -4},
                {-4, -4, 8}
        });
<span class="fc" id="L648">        distinct = distinct.scalarMultiply(tiny);</span>

<span class="fc" id="L650">        final EigenDecomposition ed = new EigenDecomposition(distinct);</span>
<span class="fc" id="L651">        checkEigenValues(MathArrays.scale(tiny, new double[] {2, 0, 12}), ed, 1e-12 * tiny);</span>
<span class="fc" id="L652">        checkEigenVector(new double[] {1, -1, 0}, ed, 1e-12);</span>
<span class="fc" id="L653">        checkEigenVector(new double[] {1, 1, 1}, ed, 1e-12);</span>
<span class="fc" id="L654">        checkEigenVector(new double[] {-1, -1, 2}, ed, 1e-12);</span>
<span class="fc" id="L655">    }</span>

    /**
     * Verifies that the given EigenDecomposition has eigenvalues equivalent to
     * the targetValues, ignoring the order of the values and allowing
     * values to differ by tolerance.
     */
    protected void checkEigenValues(double[] targetValues,
            EigenDecomposition ed, double tolerance) {
<span class="fc" id="L664">        double[] observed = ed.getRealEigenvalues();</span>
<span class="fc bfc" id="L665" title="All 2 branches covered.">        for (int i = 0; i &lt; observed.length; i++) {</span>
<span class="fc" id="L666">            Assert.assertTrue(isIncludedValue(observed[i], targetValues, tolerance));</span>
<span class="fc" id="L667">            Assert.assertTrue(isIncludedValue(targetValues[i], observed, tolerance));</span>
        }
<span class="fc" id="L669">    }</span>


    /**
     * Returns true iff there is an entry within tolerance of value in
     * searchArray.
     */
    private boolean isIncludedValue(double value, double[] searchArray,
            double tolerance) {
<span class="fc" id="L678">       boolean found = false;</span>
<span class="fc" id="L679">       int i = 0;</span>
<span class="pc bpc" id="L680" title="1 of 4 branches missed.">       while (!found &amp;&amp; i &lt; searchArray.length) {</span>
<span class="fc bfc" id="L681" title="All 2 branches covered.">           if (FastMath.abs(value - searchArray[i]) &lt; tolerance) {</span>
<span class="fc" id="L682">               found = true;</span>
           }
<span class="fc" id="L684">           i++;</span>
       }
<span class="fc" id="L686">       return found;</span>
    }

    /**
     * Returns true iff eigenVector is a scalar multiple of one of the columns
     * of ed.getV().  Does not try linear combinations - i.e., should only be
     * used to find vectors in one-dimensional eigenspaces.
     */
    protected void checkEigenVector(double[] eigenVector,
            EigenDecomposition ed, double tolerance) {
<span class="fc" id="L696">        Assert.assertTrue(isIncludedColumn(eigenVector, ed.getV(), tolerance));</span>
<span class="fc" id="L697">    }</span>

    /**
     * Returns true iff there is a column that is a scalar multiple of column
     * in searchMatrix (modulo tolerance)
     */
    private boolean isIncludedColumn(double[] column, RealMatrix searchMatrix,
            double tolerance) {
<span class="fc" id="L705">        boolean found = false;</span>
<span class="fc" id="L706">        int i = 0;</span>
<span class="pc bpc" id="L707" title="1 of 4 branches missed.">        while (!found &amp;&amp; i &lt; searchMatrix.getColumnDimension()) {</span>
<span class="fc" id="L708">            double multiplier = 1.0;</span>
<span class="fc" id="L709">            boolean matching = true;</span>
<span class="fc" id="L710">            int j = 0;</span>
<span class="fc bfc" id="L711" title="All 4 branches covered.">            while (matching &amp;&amp; j &lt; searchMatrix.getRowDimension()) {</span>
<span class="fc" id="L712">                double colEntry = searchMatrix.getEntry(j, i);</span>
                // Use the first entry where both are non-zero as scalar
<span class="fc bfc" id="L714" title="All 4 branches covered.">                if (FastMath.abs(multiplier - 1.0) &lt;= FastMath.ulp(1.0) &amp;&amp; FastMath.abs(colEntry) &gt; 1E-14</span>
<span class="fc bfc" id="L715" title="All 2 branches covered.">                        &amp;&amp; FastMath.abs(column[j]) &gt; 1e-14) {</span>
<span class="fc" id="L716">                    multiplier = colEntry / column[j];</span>
                }
<span class="fc bfc" id="L718" title="All 2 branches covered.">                if (FastMath.abs(column[j] * multiplier - colEntry) &gt; tolerance) {</span>
<span class="fc" id="L719">                    matching = false;</span>
                }
<span class="fc" id="L721">                j++;</span>
<span class="fc" id="L722">            }</span>
<span class="fc" id="L723">            found = matching;</span>
<span class="fc" id="L724">            i++;</span>
<span class="fc" id="L725">        }</span>
<span class="fc" id="L726">        return found;</span>
    }

    @Before
    public void setUp() {
<span class="fc" id="L731">        refValues = new double[] {</span>
                2.003, 2.002, 2.001, 1.001, 1.000, 0.001
        };
<span class="fc" id="L734">        matrix = createTestMatrix(new Random(35992629946426l), refValues);</span>
<span class="fc" id="L735">    }</span>

    @After
    public void tearDown() {
<span class="fc" id="L739">        refValues = null;</span>
<span class="fc" id="L740">        matrix    = null;</span>
<span class="fc" id="L741">    }</span>

    static RealMatrix createTestMatrix(final Random r, final double[] eigenValues) {
<span class="fc" id="L744">        final int n = eigenValues.length;</span>
<span class="fc" id="L745">        final RealMatrix v = createOrthogonalMatrix(r, n);</span>
<span class="fc" id="L746">        final RealMatrix d = MatrixUtils.createRealDiagonalMatrix(eigenValues);</span>
<span class="fc" id="L747">        return v.multiply(d).multiply(v.transpose());</span>
    }

    public static RealMatrix createOrthogonalMatrix(final Random r, final int size) {

<span class="fc" id="L752">        final double[][] data = new double[size][size];</span>

<span class="fc bfc" id="L754" title="All 2 branches covered.">        for (int i = 0; i &lt; size; ++i) {</span>
<span class="fc" id="L755">            final double[] dataI = data[i];</span>
<span class="fc" id="L756">            double norm2 = 0;</span>
            do {

                // generate randomly row I
<span class="fc bfc" id="L760" title="All 2 branches covered.">                for (int j = 0; j &lt; size; ++j) {</span>
<span class="fc" id="L761">                    dataI[j] = 2 * r.nextDouble() - 1;</span>
                }

                // project the row in the subspace orthogonal to previous rows
<span class="fc bfc" id="L765" title="All 2 branches covered.">                for (int k = 0; k &lt; i; ++k) {</span>
<span class="fc" id="L766">                    final double[] dataK = data[k];</span>
<span class="fc" id="L767">                    double dotProduct = 0;</span>
<span class="fc bfc" id="L768" title="All 2 branches covered.">                    for (int j = 0; j &lt; size; ++j) {</span>
<span class="fc" id="L769">                        dotProduct += dataI[j] * dataK[j];</span>
                    }
<span class="fc bfc" id="L771" title="All 2 branches covered.">                    for (int j = 0; j &lt; size; ++j) {</span>
<span class="fc" id="L772">                        dataI[j] -= dotProduct * dataK[j];</span>
                    }
                }

                // normalize the row
<span class="fc" id="L777">                norm2 = 0;</span>
<span class="fc bfc" id="L778" title="All 2 branches covered.">                for (final double dataIJ : dataI) {</span>
<span class="fc" id="L779">                    norm2 += dataIJ * dataIJ;</span>
                }
<span class="fc" id="L781">                final double inv = 1.0 / FastMath.sqrt(norm2);</span>
<span class="fc bfc" id="L782" title="All 2 branches covered.">                for (int j = 0; j &lt; size; ++j) {</span>
<span class="fc" id="L783">                    dataI[j] *= inv;</span>
                }

<span class="pc bpc" id="L786" title="1 of 2 branches missed.">            } while (norm2 * size &lt; 0.01);</span>
        }

<span class="fc" id="L789">        return MatrixUtils.createRealMatrix(data);</span>

    }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.1.201803210924</span></div></body></html>