<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>RealVectorAbstractTest.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">commons_math4$All_in_commons_math4.exec</a> &gt; <a href="index.source.html" class="el_package">org.apache.commons.math4.linear</a> &gt; <span class="el_source">RealVectorAbstractTest.java</span></div><h1>RealVectorAbstractTest.java</h1><pre class="source lang-java linenums">/*
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the &quot;License&quot;); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.commons.math4.linear;

import java.io.Serializable;
import java.util.Arrays;
import java.util.Iterator;
import java.util.NoSuchElementException;

import org.apache.commons.math4.TestUtils;
import org.apache.commons.math4.analysis.UnivariateFunction;
import org.apache.commons.math4.analysis.function.Abs;
import org.apache.commons.math4.analysis.function.Acos;
import org.apache.commons.math4.analysis.function.Asin;
import org.apache.commons.math4.analysis.function.Atan;
import org.apache.commons.math4.analysis.function.Cbrt;
import org.apache.commons.math4.analysis.function.Ceil;
import org.apache.commons.math4.analysis.function.Cos;
import org.apache.commons.math4.analysis.function.Cosh;
import org.apache.commons.math4.analysis.function.Exp;
import org.apache.commons.math4.analysis.function.Expm1;
import org.apache.commons.math4.analysis.function.Floor;
import org.apache.commons.math4.analysis.function.Inverse;
import org.apache.commons.math4.analysis.function.Log;
import org.apache.commons.math4.analysis.function.Log10;
import org.apache.commons.math4.analysis.function.Log1p;
import org.apache.commons.math4.analysis.function.Power;
import org.apache.commons.math4.analysis.function.Rint;
import org.apache.commons.math4.analysis.function.Signum;
import org.apache.commons.math4.analysis.function.Sin;
import org.apache.commons.math4.analysis.function.Sinh;
import org.apache.commons.math4.analysis.function.Sqrt;
import org.apache.commons.math4.analysis.function.Tan;
import org.apache.commons.math4.analysis.function.Tanh;
import org.apache.commons.math4.analysis.function.Ulp;
import org.apache.commons.math4.exception.DimensionMismatchException;
import org.apache.commons.math4.exception.MathArithmeticException;
import org.apache.commons.math4.exception.MathUnsupportedOperationException;
import org.apache.commons.math4.exception.NotPositiveException;
import org.apache.commons.math4.exception.NumberIsTooSmallException;
import org.apache.commons.math4.exception.OutOfRangeException;
import org.apache.commons.math4.linear.OpenMapRealVector;
import org.apache.commons.math4.linear.RealMatrix;
import org.apache.commons.math4.linear.RealVector;
import org.apache.commons.math4.linear.RealVectorChangingVisitor;
import org.apache.commons.math4.linear.RealVectorPreservingVisitor;
import org.apache.commons.math4.util.FastMath;
import org.apache.commons.math4.util.MathArrays;
import org.junit.Assert;
import org.junit.Test;


public abstract class RealVectorAbstractTest {

<span class="fc" id="L69">    protected enum BinaryOperation {</span>
<span class="fc" id="L70">        ADD, SUB, MUL, DIV</span>
    }

    /**
     * &lt;p&gt;
     * This is an attempt at covering most particular cases of combining two
     * values. Here {@code x} is the value returned by
     * {@link #getPreferredEntryValue()}, while {@code y} and {@code z} are two
     * &quot;normal&quot; values.
     * &lt;/p&gt;
     * &lt;ol&gt;
     *   &lt;li&gt;
     *     Addition: the following cases should be covered
     *     &lt;ul&gt;
     *       &lt;li&gt;{@code (2 * x) + (-x)}&lt;/li&gt;
     *       &lt;li&gt;{@code (-x) + 2 * x}&lt;/li&gt;
     *       &lt;li&gt;{@code x + y}&lt;/li&gt;
     *       &lt;li&gt;{@code y + x}&lt;/li&gt;
     *       &lt;li&gt;{@code y + z}&lt;/li&gt;
     *       &lt;li&gt;{@code y + (x - y)}&lt;/li&gt;
     *       &lt;li&gt;{@code (y - x) + x}&lt;/li&gt;
     *     &lt;/ul&gt;
     *     The values to be considered are:
     *     {@code x, y, z, 2 * x, -x, x - y, y - x}.
     *   &lt;/li&gt;
     *   &lt;li&gt;
     *     Subtraction: the following cases should be covered
     *     &lt;ul&gt;
     *       &lt;li&gt;{@code (2 * x) - x}&lt;/li&gt;
     *       &lt;li&gt;{@code x - y}&lt;/li&gt;
     *       &lt;li&gt;{@code y - x}&lt;/li&gt;
     *       &lt;li&gt;{@code y - z}&lt;/li&gt;
     *       &lt;li&gt;{@code y - (y - x)}&lt;/li&gt;
     *       &lt;li&gt;{@code (y + x) - y}&lt;/li&gt;
     *     &lt;/ul&gt;
     *     The values to be considered are: {@code x, y, z, x + y, y - x}.
     *   &lt;/li&gt;
     *   &lt;li&gt;
     *     Multiplication
     *     &lt;ul&gt;
     *       &lt;li&gt;{@code (x * x) * (1 / x)}&lt;/li&gt;
     *       &lt;li&gt;{@code (1 / x) * (x * x)}&lt;/li&gt;
     *       &lt;li&gt;{@code x * y}&lt;/li&gt;
     *       &lt;li&gt;{@code y * x}&lt;/li&gt;
     *       &lt;li&gt;{@code y * z}&lt;/li&gt;
     *     &lt;/ul&gt;
     *     The values to be considered are: {@code x, y, z, 1 / x, x * x}.
     *   &lt;/li&gt;
     *   &lt;li&gt;
     *     Division
     *     &lt;ul&gt;
     *       &lt;li&gt;{@code (x * x) / x}&lt;/li&gt;
     *       &lt;li&gt;{@code x / y}&lt;/li&gt;
     *       &lt;li&gt;{@code y / x}&lt;/li&gt;
     *       &lt;li&gt;{@code y / z}&lt;/li&gt;
     *     &lt;/ul&gt;
     *     The values to be considered are: {@code x, y, z, x * x}.
     *   &lt;/li&gt;
     * &lt;/ol&gt;
     * Also to be considered {@code NaN}, {@code POSITIVE_INFINITY},
     * {@code NEGATIVE_INFINITY}, {@code +0.0}, {@code -0.0}.
     */
    private final double[] values;

    /**
     * Creates a new instance of {@link RealVector}, with specified entries.
     * The returned vector must be of the type currently tested. It should be
     * noted that some tests assume that no references to the specified
     * {@code double[]} are kept in the returned object: if necessary, defensive
     * copy of this array should be made.
     *
     * @param data the entries of the vector to be created
     * @return a new {@link RealVector} of the type to be tested
     */
    public abstract RealVector create(double[] data);

    /**
     * Creates a new instance of {@link RealVector}, with specified entries.
     * The type of the returned vector must be different from the type currently
     * tested. It should be noted that some tests assume that no references to
     * the specified {@code double[]} are kept in the returned object: if
     * necessary, defensive copy of this array should be made.
     *
     * @param data the entries of the vector to be created
     * @return a new {@link RealVector} of an alien type
     */
    public RealVector createAlien(double[] data){
<span class="fc" id="L157">        return new RealVectorTestImpl(data);</span>
    }

    /**
     * Returns a preferred value of the entries, to be tested specifically. Some
     * implementations of {@link RealVector} (e.g. {@link OpenMapRealVector}) do
     * not store specific values of entries. In order to ensure that all tests
     * take into account this specific value, some entries of the vectors to be
     * tested are deliberately set to the value returned by the present method.
     * The default implementation returns {@code 0.0}.
     *
     * @return a value which &lt;em&gt;should&lt;/em&gt; be present in all vectors to be
     * tested
     */
    public double getPreferredEntryValue() {
<span class="fc" id="L172">        return 0.0;</span>
    }

<span class="fc" id="L175">    public RealVectorAbstractTest() {</span>
        /*
         * Make sure that x, y, z are three different values. Also, x is the
         * preferred value (e.g. the value which is not stored in sparse
         * implementations).
         */
<span class="fc" id="L181">        final double x = getPreferredEntryValue();</span>
<span class="fc" id="L182">        final double y = x + 1d;</span>
<span class="fc" id="L183">        final double z = y + 1d;</span>

<span class="fc" id="L185">        values =</span>
            new double[] {
                Double.NaN, Double.POSITIVE_INFINITY, Double.NEGATIVE_INFINITY,
                0d, -0d, x, y, z, 2 * x, -x, 1 / x, x * x, x + y, x - y, y - x
            };
<span class="fc" id="L190">    }</span>

    @Test
    public void testGetDimension() {
<span class="fc" id="L194">        final double x = getPreferredEntryValue();</span>
<span class="fc" id="L195">        final double[] data1 = {x, x, x, x};</span>
<span class="fc" id="L196">        Assert.assertEquals(data1.length, create(data1).getDimension());</span>
<span class="fc" id="L197">        final double y = x + 1;</span>
<span class="fc" id="L198">        final double[] data2 = {y, y, y, y};</span>
<span class="fc" id="L199">        Assert.assertEquals(data2.length, create(data2).getDimension());</span>
<span class="fc" id="L200">    }</span>

    @Test
    public void testGetEntry() {
<span class="fc" id="L204">        final double x = getPreferredEntryValue();</span>
<span class="fc" id="L205">        final double[] data = {x, 1d, 2d, x, x};</span>
<span class="fc" id="L206">        final RealVector v = create(data);</span>
<span class="fc bfc" id="L207" title="All 2 branches covered.">        for (int i = 0; i &lt; data.length; i++) {</span>
<span class="fc" id="L208">            Assert.assertEquals(&quot;entry &quot; + i, data[i], v.getEntry(i), 0d);</span>
        }
<span class="fc" id="L210">    }</span>

    @Test(expected=OutOfRangeException.class)
    public void testGetEntryInvalidIndex1() {
<span class="nc" id="L214">        create(new double[4]).getEntry(-1);</span>
<span class="nc" id="L215">    }</span>

    @Test(expected=OutOfRangeException.class)
    public void testGetEntryInvalidIndex2() {
<span class="nc" id="L219">        create(new double[4]).getEntry(4);</span>
<span class="nc" id="L220">    }</span>

    @Test
    public void testSetEntry() {
<span class="fc" id="L224">        final double x = getPreferredEntryValue();</span>
<span class="fc" id="L225">        final double[] data = {x, 1d, 2d, x, x};</span>
<span class="fc" id="L226">        final double[] expected = MathArrays.copyOf(data);</span>
<span class="fc" id="L227">        final RealVector actual = create(data);</span>

        /*
         * Try setting to any value.
         */
<span class="fc bfc" id="L232" title="All 2 branches covered.">        for (int i = 0; i &lt; data.length; i++) {</span>
<span class="fc" id="L233">            final double oldValue = data[i];</span>
<span class="fc" id="L234">            final double newValue = oldValue + 1d;</span>
<span class="fc" id="L235">            expected[i] = newValue;</span>
<span class="fc" id="L236">            actual.setEntry(i, newValue);</span>
<span class="fc" id="L237">            TestUtils.assertEquals(&quot;while setting entry #&quot; + i, expected,</span>
                actual, 0d);
<span class="fc" id="L239">            expected[i] = oldValue;</span>
<span class="fc" id="L240">            actual.setEntry(i, oldValue);</span>
        }

        /*
         * Try setting to the preferred value.
         */
<span class="fc bfc" id="L246" title="All 2 branches covered.">        for (int i = 0; i &lt; data.length; i++) {</span>
<span class="fc" id="L247">            final double oldValue = data[i];</span>
<span class="fc" id="L248">            final double newValue = x;</span>
<span class="fc" id="L249">            expected[i] = newValue;</span>
<span class="fc" id="L250">            actual.setEntry(i, newValue);</span>
<span class="fc" id="L251">            TestUtils.assertEquals(&quot;while setting entry #&quot; + i, expected,</span>
                actual, 0d);
<span class="fc" id="L253">            expected[i] = oldValue;</span>
<span class="fc" id="L254">            actual.setEntry(i, oldValue);</span>
        }
<span class="fc" id="L256">    }</span>

    @Test(expected=OutOfRangeException.class)
    public void testSetEntryInvalidIndex1() {
<span class="nc" id="L260">        create(new double[4]).setEntry(-1, getPreferredEntryValue());</span>
<span class="nc" id="L261">    }</span>

    @Test(expected=OutOfRangeException.class)
    public void testSetEntryInvalidIndex2() {
<span class="nc" id="L265">        create(new double[4]).setEntry(4, getPreferredEntryValue());</span>
<span class="nc" id="L266">    }</span>

    @Test
    public void testAddToEntry() {
<span class="fc" id="L270">        final double x = getPreferredEntryValue();</span>
<span class="fc" id="L271">        final double[] data1 = {x, 1d, 2d, x, x};</span>

<span class="fc" id="L273">        final double[] expected = MathArrays.copyOf(data1);</span>
<span class="fc" id="L274">        final RealVector actual = create(data1);</span>

        /*
         * Try adding any value.
         */
<span class="fc" id="L279">        double increment = 1d;</span>
<span class="fc bfc" id="L280" title="All 2 branches covered.">        for (int i = 0; i &lt; data1.length; i++) {</span>
<span class="fc" id="L281">            final double oldValue = data1[i];</span>
<span class="fc" id="L282">            expected[i] += increment;</span>
<span class="fc" id="L283">            actual.addToEntry(i, increment);</span>
<span class="fc" id="L284">            TestUtils.assertEquals(&quot;while incrementing entry #&quot; + i, expected,</span>
                actual, 0d);
<span class="fc" id="L286">            expected[i] = oldValue;</span>
<span class="fc" id="L287">            actual.setEntry(i, oldValue);</span>
        }

        /*
         * Try incrementing so that result is equal to preferred value.
         */
<span class="fc bfc" id="L293" title="All 2 branches covered.">        for (int i = 0; i &lt; data1.length; i++) {</span>
<span class="fc" id="L294">            final double oldValue = data1[i];</span>
<span class="fc" id="L295">            increment = x - oldValue;</span>
<span class="fc" id="L296">            expected[i] = x;</span>
<span class="fc" id="L297">            actual.addToEntry(i, increment);</span>
<span class="fc" id="L298">            TestUtils.assertEquals(&quot;while incrementing entry #&quot; + i, expected,</span>
                actual, 0d);
<span class="fc" id="L300">            expected[i] = oldValue;</span>
<span class="fc" id="L301">            actual.setEntry(i, oldValue);</span>
        }
<span class="fc" id="L303">    }</span>

    @Test(expected=OutOfRangeException.class)
    public void testAddToEntryInvalidIndex1() {
<span class="nc" id="L307">        create(new double[3]).addToEntry(-1, getPreferredEntryValue());</span>
<span class="nc" id="L308">    }</span>

    @Test(expected=OutOfRangeException.class)
    public void testAddToEntryInvalidIndex2() {
<span class="nc" id="L312">        create(new double[3]).addToEntry(4, getPreferredEntryValue());</span>
<span class="nc" id="L313">    }</span>

    private void doTestAppendVector(final String message, final RealVector v1,
        final RealVector v2, final double delta) {

<span class="fc" id="L318">        final int n1 = v1.getDimension();</span>
<span class="fc" id="L319">        final int n2 = v2.getDimension();</span>
<span class="fc" id="L320">        final RealVector v = v1.append(v2);</span>
<span class="fc" id="L321">        Assert.assertEquals(message, n1 + n2, v.getDimension());</span>
<span class="fc bfc" id="L322" title="All 2 branches covered.">        for (int i = 0; i &lt; n1; i++) {</span>
<span class="fc" id="L323">            final String msg = message + &quot;, entry #&quot; + i;</span>
<span class="fc" id="L324">            Assert.assertEquals(msg, v1.getEntry(i), v.getEntry(i), delta);</span>
        }
<span class="fc bfc" id="L326" title="All 2 branches covered.">        for (int i = 0; i &lt; n2; i++) {</span>
<span class="fc" id="L327">            final String msg = message + &quot;, entry #&quot; + (n1 + i);</span>
<span class="fc" id="L328">            Assert.assertEquals(msg, v2.getEntry(i), v.getEntry(n1 + i), delta);</span>
        }
<span class="fc" id="L330">    }</span>

    @Test
    public void testAppendVector() {
<span class="fc" id="L334">        final double x = getPreferredEntryValue();</span>
<span class="fc" id="L335">        final double[] data1 =  {x, 1d, 2d, x, x};</span>
<span class="fc" id="L336">        final double[] data2 =  {x, x, 3d, x, 4d, x};</span>

<span class="fc" id="L338">        doTestAppendVector(&quot;same type&quot;, create(data1), create(data2), 0d);</span>
<span class="fc" id="L339">        doTestAppendVector(&quot;mixed types&quot;, create(data1), createAlien(data2), 0d);</span>
<span class="fc" id="L340">    }</span>

    private void doTestAppendScalar(final String message, final RealVector v,
        final double d, final double delta) {

<span class="fc" id="L345">        final int n = v.getDimension();</span>
<span class="fc" id="L346">        final RealVector w = v.append(d);</span>
<span class="fc" id="L347">        Assert.assertEquals(message, n + 1, w.getDimension());</span>
<span class="fc bfc" id="L348" title="All 2 branches covered.">        for (int i = 0; i &lt; n; i++) {</span>
<span class="fc" id="L349">            final String msg = message + &quot;, entry #&quot; + i;</span>
<span class="fc" id="L350">            Assert.assertEquals(msg, v.getEntry(i), w.getEntry(i), delta);</span>
        }
<span class="fc" id="L352">        final String msg = message + &quot;, entry #&quot; + n;</span>
<span class="fc" id="L353">        Assert.assertEquals(msg, d, w.getEntry(n), delta);</span>
<span class="fc" id="L354">    }</span>

    @Test
    public void testAppendScalar() {
<span class="fc" id="L358">        final double x = getPreferredEntryValue();</span>
<span class="fc" id="L359">        final double[] data = new double[] {x, 1d, 2d, x, x};</span>

<span class="fc" id="L361">        doTestAppendScalar(&quot;&quot;, create(data), 1d, 0d);</span>
<span class="fc" id="L362">        doTestAppendScalar(&quot;&quot;, create(data), x, 0d);</span>
<span class="fc" id="L363">    }</span>

    @Test
    public void testGetSubVector() {
<span class="fc" id="L367">        final double x = getPreferredEntryValue();</span>
<span class="fc" id="L368">        final double[] data = {x, x, x, 1d, x, 2d, x, x, 3d, x, x, x, 4d, x, x, x};</span>
<span class="fc" id="L369">        final int index = 1;</span>
<span class="fc" id="L370">        final int n = data.length - 5;</span>
<span class="fc" id="L371">        final RealVector actual = create(data).getSubVector(index, n);</span>
<span class="fc" id="L372">        final double[] expected = new double[n];</span>
<span class="fc" id="L373">        System.arraycopy(data, index, expected, 0, n);</span>
<span class="fc" id="L374">        TestUtils.assertEquals(&quot;&quot;, expected, actual, 0d);</span>
<span class="fc" id="L375">    }</span>

    @Test(expected = OutOfRangeException.class)
    public void testGetSubVectorInvalidIndex1() {
<span class="fc" id="L379">        final int n = 10;</span>
<span class="nc" id="L380">        create(new double[n]).getSubVector(-1, 2);</span>
<span class="nc" id="L381">    }</span>

    @Test(expected = OutOfRangeException.class)
    public void testGetSubVectorInvalidIndex2() {
<span class="fc" id="L385">        final int n = 10;</span>
<span class="nc" id="L386">        create(new double[n]).getSubVector(n, 2);</span>
<span class="nc" id="L387">    }</span>

    @Test(expected = OutOfRangeException.class)
    public void testGetSubVectorInvalidIndex3() {
<span class="fc" id="L391">        final int n = 10;</span>
<span class="nc" id="L392">        create(new double[n]).getSubVector(0, n + 1);</span>
<span class="nc" id="L393">    }</span>

    @Test(expected = NotPositiveException.class)
    public void testGetSubVectorInvalidIndex4() {
<span class="fc" id="L397">        final int n = 10;</span>
<span class="nc" id="L398">        create(new double[n]).getSubVector(3, -2);</span>
<span class="nc" id="L399">    }</span>

    @Test
    public void testSetSubVectorSameType() {
<span class="fc" id="L403">        final double x = getPreferredEntryValue();</span>
<span class="fc" id="L404">        final double[] expected = {x, x, x, 1d, x, 2d, x, x, 3d, x, x, x, 4d, x, x, x};</span>
<span class="fc" id="L405">        final double[] sub = {5d, x, 6d, 7d, 8d};</span>
<span class="fc" id="L406">        final RealVector actual = create(expected);</span>
<span class="fc" id="L407">        final int index = 2;</span>
<span class="fc" id="L408">        actual.setSubVector(index, create(sub));</span>

<span class="fc bfc" id="L410" title="All 2 branches covered.">        for (int i = 0; i &lt; sub.length; i++){</span>
<span class="fc" id="L411">            expected[index + i] = sub[i];</span>
        }
<span class="fc" id="L413">        TestUtils.assertEquals(&quot;&quot;, expected, actual, 0d);</span>
<span class="fc" id="L414">    }</span>

    @Test
    public void testSetSubVectorMixedType() {
<span class="fc" id="L418">        final double x = getPreferredEntryValue();</span>
<span class="fc" id="L419">        final double[] expected = {x, x, x, 1d, x, 2d, x, x, 3d, x, x, x, 4d, x, x, x};</span>
<span class="fc" id="L420">        final double[] sub = {5d, x, 6d, 7d, 8d};</span>
<span class="fc" id="L421">        final RealVector actual = create(expected);</span>
<span class="fc" id="L422">        final int index = 2;</span>
<span class="fc" id="L423">        actual.setSubVector(index, createAlien(sub));</span>

<span class="fc bfc" id="L425" title="All 2 branches covered.">        for (int i = 0; i &lt; sub.length; i++){</span>
<span class="fc" id="L426">            expected[index + i] = sub[i];</span>
        }
<span class="fc" id="L428">        TestUtils.assertEquals(&quot;&quot;, expected, actual, 0d);</span>
<span class="fc" id="L429">    }</span>

    @Test(expected = OutOfRangeException.class)
    public void testSetSubVectorInvalidIndex1() {
<span class="nc" id="L433">        create(new double[10]).setSubVector(-1, create(new double[2]));</span>
<span class="nc" id="L434">    }</span>

    @Test(expected = OutOfRangeException.class)
    public void testSetSubVectorInvalidIndex2() {
<span class="nc" id="L438">        create(new double[10]).setSubVector(10, create(new double[2]));</span>
<span class="nc" id="L439">    }</span>

    @Test(expected = OutOfRangeException.class)
    public void testSetSubVectorInvalidIndex3() {
<span class="nc" id="L443">        create(new double[10]).setSubVector(9, create(new double[2]));</span>
<span class="nc" id="L444">    }</span>

    @Test
    public void testIsNaN() {
<span class="fc" id="L448">        final RealVector v = create(new double[] {0, 1, 2});</span>

<span class="fc" id="L450">        Assert.assertFalse(v.isNaN());</span>
<span class="fc" id="L451">        v.setEntry(1, Double.NaN);</span>
<span class="fc" id="L452">        Assert.assertTrue(v.isNaN());</span>
<span class="fc" id="L453">    }</span>

    @Test
    public void testIsInfinite() {
<span class="fc" id="L457">        final RealVector v = create(new double[] { 0, 1, 2 });</span>

<span class="fc" id="L459">        Assert.assertFalse(v.isInfinite());</span>
<span class="fc" id="L460">        v.setEntry(0, Double.POSITIVE_INFINITY);</span>
<span class="fc" id="L461">        Assert.assertTrue(v.isInfinite());</span>
<span class="fc" id="L462">        v.setEntry(1, Double.NaN);</span>
<span class="fc" id="L463">        Assert.assertFalse(v.isInfinite());</span>
<span class="fc" id="L464">    }</span>

    protected void doTestEbeBinaryOperation(final BinaryOperation op, final boolean mixed, boolean ignoreSpecial) {
<span class="fc" id="L467">        final double[] data1 = new double[values.length * values.length];</span>
<span class="fc" id="L468">        final double[] data2 = new double[values.length * values.length];</span>
<span class="fc" id="L469">        int k = 0;</span>
<span class="fc bfc" id="L470" title="All 2 branches covered.">        for (int i = 0; i &lt; values.length; i++) {</span>
<span class="fc bfc" id="L471" title="All 2 branches covered.">            for (int j = 0; j &lt; values.length; j++) {</span>
<span class="fc" id="L472">                data1[k] = values[i];</span>
<span class="fc" id="L473">                data2[k] = values[j];</span>
<span class="fc" id="L474">                ++k;</span>
            }
        }
<span class="fc" id="L477">        final RealVector v1 = create(data1);</span>
<span class="fc bfc" id="L478" title="All 2 branches covered.">        final RealVector v2 = mixed ? createAlien(data2) : create(data2);</span>
        final RealVector actual;
<span class="pc bpc" id="L480" title="1 of 5 branches missed.">        switch (op) {</span>
            case ADD:
<span class="fc" id="L482">                actual = v1.add(v2);</span>
<span class="fc" id="L483">                break;</span>
            case SUB:
<span class="fc" id="L485">                actual = v1.subtract(v2);</span>
<span class="fc" id="L486">                break;</span>
            case MUL:
<span class="fc" id="L488">                actual = v1.ebeMultiply(v2);</span>
<span class="fc" id="L489">                break;</span>
            case DIV:
<span class="fc" id="L491">                actual = v1.ebeDivide(v2);</span>
<span class="fc" id="L492">                break;</span>
            default:
<span class="nc" id="L494">                throw new AssertionError(&quot;unexpected value&quot;);</span>
        }
<span class="fc" id="L496">        final double[] expected = new double[data1.length];</span>
<span class="fc bfc" id="L497" title="All 2 branches covered.">        for (int i = 0; i &lt; expected.length; i++) {</span>
<span class="pc bpc" id="L498" title="1 of 5 branches missed.">            switch (op) {</span>
                case ADD:
<span class="fc" id="L500">                    expected[i] = data1[i] + data2[i];</span>
<span class="fc" id="L501">                    break;</span>
                case SUB:
<span class="fc" id="L503">                    expected[i] = data1[i] - data2[i];</span>
<span class="fc" id="L504">                    break;</span>
                case MUL:
<span class="fc" id="L506">                    expected[i] = data1[i] * data2[i];</span>
<span class="fc" id="L507">                    break;</span>
                case DIV:
<span class="fc" id="L509">                    expected[i] = data1[i] / data2[i];</span>
<span class="fc" id="L510">                    break;</span>
                default:
<span class="nc" id="L512">                    throw new AssertionError(&quot;unexpected value&quot;);</span>
            }
        }
<span class="fc bfc" id="L515" title="All 2 branches covered.">        for (int i = 0; i &lt; expected.length; i++) {</span>
<span class="fc bfc" id="L516" title="All 4 branches covered.">            boolean isSpecial = Double.isNaN(expected[i]) || Double.isInfinite(expected[i]);</span>
<span class="fc bfc" id="L517" title="All 4 branches covered.">            if (!(isSpecial &amp;&amp; ignoreSpecial)) {</span>
<span class="fc" id="L518">                final String msg = &quot;entry #&quot;+i+&quot;, left = &quot;+data1[i]+&quot;, right = &quot; + data2[i];</span>
<span class="fc" id="L519">                Assert.assertEquals(msg, expected[i], actual.getEntry(i), 0.0);</span>
            }
        }
<span class="fc" id="L522">    }</span>

    private void doTestEbeBinaryOperationDimensionMismatch(final BinaryOperation op) {
<span class="fc" id="L525">        final int n = 10;</span>
<span class="nc bnc" id="L526" title="All 5 branches missed.">        switch (op) {</span>
            case ADD:
<span class="nc" id="L528">                create(new double[n]).add(create(new double[n + 1]));</span>
<span class="nc" id="L529">                break;</span>
            case SUB:
<span class="nc" id="L531">                create(new double[n]).subtract(create(new double[n + 1]));</span>
<span class="nc" id="L532">                break;</span>
            case MUL:
<span class="nc" id="L534">                create(new double[n]).ebeMultiply(create(new double[n + 1]));</span>
<span class="nc" id="L535">                break;</span>
            case DIV:
<span class="nc" id="L537">                create(new double[n]).ebeDivide(create(new double[n + 1]));</span>
<span class="nc" id="L538">                break;</span>
            default:
<span class="nc" id="L540">                throw new AssertionError(&quot;unexpected value&quot;);</span>
        }
<span class="nc" id="L542">    }</span>

    @Test
    public void testAddSameType() {
<span class="fc" id="L546">        doTestEbeBinaryOperation(BinaryOperation.ADD, false, false);</span>
<span class="fc" id="L547">    }</span>

    @Test
    public void testAddMixedTypes() {
<span class="fc" id="L551">        doTestEbeBinaryOperation(BinaryOperation.ADD, true, false);</span>
<span class="fc" id="L552">    }</span>

    @Test(expected = DimensionMismatchException.class)
    public void testAddDimensionMismatch() {
<span class="nc" id="L556">        doTestEbeBinaryOperationDimensionMismatch(BinaryOperation.ADD);</span>
<span class="nc" id="L557">    }</span>

    @Test
    public void testSubtractSameType() {
<span class="fc" id="L561">        doTestEbeBinaryOperation(BinaryOperation.SUB, false, false);</span>
<span class="fc" id="L562">    }</span>

    @Test
    public void testSubtractMixedTypes() {
<span class="fc" id="L566">        doTestEbeBinaryOperation(BinaryOperation.SUB, true, false);</span>
<span class="fc" id="L567">    }</span>

    @Test(expected = DimensionMismatchException.class)
    public void testSubtractDimensionMismatch() {
<span class="nc" id="L571">        doTestEbeBinaryOperationDimensionMismatch(BinaryOperation.SUB);</span>
<span class="nc" id="L572">    }</span>

    @Test
    public void testEbeMultiplySameType() {
<span class="fc" id="L576">        doTestEbeBinaryOperation(BinaryOperation.MUL, false, false);</span>
<span class="fc" id="L577">    }</span>

    @Test
    public void testEbeMultiplyMixedTypes() {
<span class="fc" id="L581">        doTestEbeBinaryOperation(BinaryOperation.MUL, true, false);</span>
<span class="fc" id="L582">    }</span>

    @Test(expected = DimensionMismatchException.class)
    public void testEbeMultiplyDimensionMismatch() {
<span class="nc" id="L586">        doTestEbeBinaryOperationDimensionMismatch(BinaryOperation.MUL);</span>
<span class="nc" id="L587">    }</span>

    @Test
    public void testEbeDivideSameType() {
<span class="fc" id="L591">        doTestEbeBinaryOperation(BinaryOperation.DIV, false, false);</span>
<span class="fc" id="L592">    }</span>

   @Test
    public void testEbeDivideMixedTypes() {
<span class="fc" id="L596">        doTestEbeBinaryOperation(BinaryOperation.DIV, true, false);</span>
<span class="fc" id="L597">    }</span>

    @Test(expected = DimensionMismatchException.class)
    public void testEbeDivideDimensionMismatch() {
<span class="nc" id="L601">        doTestEbeBinaryOperationDimensionMismatch(BinaryOperation.DIV);</span>
<span class="nc" id="L602">    }</span>

    private void doTestGetDistance(final boolean mixed) {
<span class="fc" id="L605">        final double x = getPreferredEntryValue();</span>
<span class="fc" id="L606">        final double[] data1 = new double[] { x, x, 1d, x, 2d, x, x, 3d, x };</span>
<span class="fc" id="L607">        final double[] data2 = new double[] { 4d, x, x, 5d, 6d, 7d, x, x, 8d };</span>
<span class="fc" id="L608">        final RealVector v1 = create(data1);</span>
        final RealVector v2;
<span class="fc bfc" id="L610" title="All 2 branches covered.">        if (mixed) {</span>
<span class="fc" id="L611">            v2 = createAlien(data2);</span>
        } else {
<span class="fc" id="L613">            v2 = create(data2);</span>
        }
<span class="fc" id="L615">        final double actual = v1.getDistance(v2);</span>
<span class="fc" id="L616">        double expected = 0d;</span>
<span class="fc bfc" id="L617" title="All 2 branches covered.">        for (int i = 0; i &lt; data1.length; i++) {</span>
<span class="fc" id="L618">            final double delta = data2[i] - data1[i];</span>
<span class="fc" id="L619">            expected += delta * delta;</span>
        }
<span class="fc" id="L621">        expected = FastMath.sqrt(expected);</span>
<span class="fc" id="L622">        Assert.assertEquals(&quot;&quot;, expected, actual, 0d);</span>
<span class="fc" id="L623">    }</span>

    @Test
    public void testGetDistanceSameType() {
<span class="fc" id="L627">        doTestGetDistance(false);</span>
<span class="fc" id="L628">    }</span>

    @Test
    public void testGetDistanceMixedTypes() {
<span class="fc" id="L632">        doTestGetDistance(true);</span>
<span class="fc" id="L633">    }</span>

    @Test(expected = DimensionMismatchException.class)
    public void testGetDistanceDimensionMismatch() {
<span class="nc" id="L637">        create(new double[4]).getDistance(createAlien(new double[5]));</span>
<span class="nc" id="L638">    }</span>

    @Test
    public void testGetNorm() {
<span class="fc" id="L642">        final double x = getPreferredEntryValue();</span>
<span class="fc" id="L643">        final double[] data = new double[] { x, x, 1d, x, 2d, x, x, 3d, x };</span>
<span class="fc" id="L644">        final RealVector v = create(data);</span>
<span class="fc" id="L645">        final double actual = v.getNorm();</span>
<span class="fc" id="L646">        double expected = 0d;</span>
<span class="fc bfc" id="L647" title="All 2 branches covered.">        for (int i = 0; i &lt; data.length; i++) {</span>
<span class="fc" id="L648">            expected += data[i] * data[i];</span>
        }
<span class="fc" id="L650">        expected = FastMath.sqrt(expected);</span>
<span class="fc" id="L651">        Assert.assertEquals(&quot;&quot;, expected, actual, 0d);</span>
<span class="fc" id="L652">    }</span>

    private void doTestGetL1Distance(final boolean mixed) {
<span class="fc" id="L655">        final double x = getPreferredEntryValue();</span>
<span class="fc" id="L656">        final double[] data1 = new double[] { x, x, 1d, x, 2d, x, x, 3d, x };</span>
<span class="fc" id="L657">        final double[] data2 = new double[] { 4d, x, x, 5d, 6d, 7d, x, x, 8d };</span>
<span class="fc" id="L658">        final RealVector v1 = create(data1);</span>
        final RealVector v2;
<span class="fc bfc" id="L660" title="All 2 branches covered.">        if (mixed) {</span>
<span class="fc" id="L661">            v2 = createAlien(data2);</span>
        } else {
<span class="fc" id="L663">            v2 = create(data2);</span>
        }
<span class="fc" id="L665">        final double actual = v1.getL1Distance(v2);</span>
<span class="fc" id="L666">        double expected = 0d;</span>
<span class="fc bfc" id="L667" title="All 2 branches covered.">        for (int i = 0; i &lt; data1.length; i++) {</span>
<span class="fc" id="L668">            final double delta = data2[i] - data1[i];</span>
<span class="fc" id="L669">            expected += FastMath.abs(delta);</span>
        }
<span class="fc" id="L671">        Assert.assertEquals(&quot;&quot;, expected, actual, 0d);</span>
<span class="fc" id="L672">    }</span>

    @Test
    public void testGetL1DistanceSameType() {
<span class="fc" id="L676">        doTestGetL1Distance(false);</span>
<span class="fc" id="L677">    }</span>

    @Test
    public void testGetL1DistanceMixedTypes() {
<span class="fc" id="L681">        doTestGetL1Distance(true);</span>
<span class="fc" id="L682">    }</span>

    @Test(expected = DimensionMismatchException.class)
    public void testGetL1DistanceDimensionMismatch() {
<span class="nc" id="L686">        create(new double[4]).getL1Distance(createAlien(new double[5]));</span>
<span class="nc" id="L687">    }</span>

    @Test
    public void testGetL1Norm() {
<span class="fc" id="L691">        final double x = getPreferredEntryValue();</span>
<span class="fc" id="L692">        final double[] data = new double[] { x, x, 1d, x, 2d, x, x, 3d, x };</span>
<span class="fc" id="L693">        final RealVector v = create(data);</span>
<span class="fc" id="L694">        final double actual = v.getL1Norm();</span>
<span class="fc" id="L695">        double expected = 0d;</span>
<span class="fc bfc" id="L696" title="All 2 branches covered.">        for (int i = 0; i &lt; data.length; i++) {</span>
<span class="fc" id="L697">            expected += FastMath.abs(data[i]);</span>
        }
<span class="fc" id="L699">        Assert.assertEquals(&quot;&quot;, expected, actual, 0d);</span>

<span class="fc" id="L701">    }</span>

    private void doTestGetLInfDistance(final boolean mixed) {
<span class="fc" id="L704">        final double x = getPreferredEntryValue();</span>
<span class="fc" id="L705">        final double[] data1 = new double[] { x, x, 1d, x, 2d, x, x, 3d, x };</span>
<span class="fc" id="L706">        final double[] data2 = new double[] { 4d, x, x, 5d, 6d, 7d, x, x, 8d };</span>
<span class="fc" id="L707">        final RealVector v1 = create(data1);</span>
        final RealVector v2;
<span class="fc bfc" id="L709" title="All 2 branches covered.">        if (mixed) {</span>
<span class="fc" id="L710">            v2 = createAlien(data2);</span>
        } else {
<span class="fc" id="L712">            v2 = create(data2);</span>
        }
<span class="fc" id="L714">        final double actual = v1.getLInfDistance(v2);</span>
<span class="fc" id="L715">        double expected = 0d;</span>
<span class="fc bfc" id="L716" title="All 2 branches covered.">        for (int i = 0; i &lt; data1.length; i++) {</span>
<span class="fc" id="L717">            final double delta = data2[i] - data1[i];</span>
<span class="fc" id="L718">            expected = FastMath.max(expected, FastMath.abs(delta));</span>
        }
<span class="fc" id="L720">        Assert.assertEquals(&quot;&quot;, expected, actual, 0d);</span>
<span class="fc" id="L721">    }</span>

    @Test
    public void testGetLInfDistanceSameType() {
<span class="fc" id="L725">        doTestGetLInfDistance(false);</span>
<span class="fc" id="L726">    }</span>

    @Test
    public void testGetLInfDistanceMixedTypes() {
<span class="fc" id="L730">        doTestGetLInfDistance(true);</span>
<span class="fc" id="L731">    }</span>

    @Test(expected = DimensionMismatchException.class)
    public void testGetLInfDistanceDimensionMismatch() {
<span class="nc" id="L735">        create(new double[4]).getLInfDistance(createAlien(new double[5]));</span>
<span class="nc" id="L736">    }</span>

    @Test
    public void testGetLInfNorm() {
<span class="fc" id="L740">        final double x = getPreferredEntryValue();</span>
<span class="fc" id="L741">        final double[] data = new double[] { x, x, 1d, x, 2d, x, x, 3d, x };</span>
<span class="fc" id="L742">        final RealVector v = create(data);</span>
<span class="fc" id="L743">        final double actual = v.getLInfNorm();</span>
<span class="fc" id="L744">        double expected = 0d;</span>
<span class="fc bfc" id="L745" title="All 2 branches covered.">        for (int i = 0; i &lt; data.length; i++) {</span>
<span class="fc" id="L746">            expected = FastMath.max(expected, FastMath.abs(data[i]));</span>
        }
<span class="fc" id="L748">        Assert.assertEquals(&quot;&quot;, expected, actual, 0d);</span>

<span class="fc" id="L750">    }</span>

    private void doTestMapBinaryOperation(final BinaryOperation op, final boolean inPlace) {
<span class="fc" id="L753">        final double[] expected = new double[values.length];</span>
<span class="fc bfc" id="L754" title="All 2 branches covered.">        for (int i = 0; i &lt; values.length; i++) {</span>
<span class="fc" id="L755">            final double d = values[i];</span>
<span class="fc bfc" id="L756" title="All 2 branches covered.">            for (int j = 0; j &lt; expected.length; j++) {</span>
<span class="pc bpc" id="L757" title="1 of 5 branches missed.">                switch (op) {</span>
                    case ADD:
<span class="fc" id="L759">                        expected[j] = values[j] + d;</span>
<span class="fc" id="L760">                        break;</span>
                    case SUB:
<span class="fc" id="L762">                        expected[j] = values[j] - d;</span>
<span class="fc" id="L763">                        break;</span>
                    case MUL:
<span class="fc" id="L765">                        expected[j] = values[j] * d;</span>
<span class="fc" id="L766">                        break;</span>
                    case DIV:
<span class="fc" id="L768">                        expected[j] = values[j] / d;</span>
<span class="fc" id="L769">                        break;</span>
                    default:
<span class="nc" id="L771">                        throw new AssertionError(&quot;unexpected value&quot;);</span>
                }
            }
<span class="fc" id="L774">            final RealVector v = create(values);</span>
            final RealVector actual;
<span class="fc bfc" id="L776" title="All 2 branches covered.">            if (inPlace) {</span>
<span class="pc bpc" id="L777" title="1 of 5 branches missed.">                switch (op) {</span>
                    case ADD:
<span class="fc" id="L779">                        actual = v.mapAddToSelf(d);</span>
<span class="fc" id="L780">                        break;</span>
                    case SUB:
<span class="fc" id="L782">                        actual = v.mapSubtractToSelf(d);</span>
<span class="fc" id="L783">                        break;</span>
                    case MUL:
<span class="fc" id="L785">                        actual = v.mapMultiplyToSelf(d);</span>
<span class="fc" id="L786">                        break;</span>
                    case DIV:
<span class="fc" id="L788">                        actual = v.mapDivideToSelf(d);</span>
<span class="fc" id="L789">                        break;</span>
                    default:
<span class="nc" id="L791">                        throw new AssertionError(&quot;unexpected value&quot;);</span>
                }
            } else {
<span class="pc bpc" id="L794" title="1 of 5 branches missed.">                switch (op) {</span>
                    case ADD:
<span class="fc" id="L796">                        actual = v.mapAdd(d);</span>
<span class="fc" id="L797">                        break;</span>
                    case SUB:
<span class="fc" id="L799">                        actual = v.mapSubtract(d);</span>
<span class="fc" id="L800">                        break;</span>
                    case MUL:
<span class="fc" id="L802">                        actual = v.mapMultiply(d);</span>
<span class="fc" id="L803">                        break;</span>
                    case DIV:
<span class="fc" id="L805">                        actual = v.mapDivide(d);</span>
<span class="fc" id="L806">                        break;</span>
                    default:
<span class="nc" id="L808">                        throw new AssertionError(&quot;unexpected value&quot;);</span>
                }
            }
<span class="fc" id="L811">            TestUtils.assertEquals(Double.toString(d), expected, actual, 0d);</span>
        }
<span class="fc" id="L813">    }</span>

    @Test
    public void testMapAdd() {
<span class="fc" id="L817">        doTestMapBinaryOperation(BinaryOperation.ADD, false);</span>
<span class="fc" id="L818">    }</span>

    @Test
    public void testMapAddToSelf() {
<span class="fc" id="L822">        doTestMapBinaryOperation(BinaryOperation.ADD, true);</span>
<span class="fc" id="L823">    }</span>

    @Test
    public void testMapSubtract() {
<span class="fc" id="L827">        doTestMapBinaryOperation(BinaryOperation.SUB, false);</span>
<span class="fc" id="L828">    }</span>

    @Test
    public void testMapSubtractToSelf() {
<span class="fc" id="L832">        doTestMapBinaryOperation(BinaryOperation.SUB, true);</span>
<span class="fc" id="L833">    }</span>

    @Test
    public void testMapMultiply() {
<span class="fc" id="L837">        doTestMapBinaryOperation(BinaryOperation.MUL, false);</span>
<span class="fc" id="L838">    }</span>

    @Test
    public void testMapMultiplyToSelf() {
<span class="fc" id="L842">        doTestMapBinaryOperation(BinaryOperation.MUL, true);</span>
<span class="fc" id="L843">    }</span>

    @Test
    public void testMapDivide() {
<span class="fc" id="L847">        doTestMapBinaryOperation(BinaryOperation.DIV, false);</span>
<span class="fc" id="L848">    }</span>

    @Test
    public void testMapDivideToSelf() {
<span class="fc" id="L852">        doTestMapBinaryOperation(BinaryOperation.DIV, true);</span>
<span class="fc" id="L853">    }</span>

    private void doTestMapFunction(final UnivariateFunction f,
        final boolean inPlace) {
<span class="fc" id="L857">        final double[] data = new double[values.length + 6];</span>
<span class="fc" id="L858">        System.arraycopy(values, 0, data, 0, values.length);</span>
<span class="fc" id="L859">        data[values.length + 0] = 0.5 * FastMath.PI;</span>
<span class="fc" id="L860">        data[values.length + 1] = -0.5 * FastMath.PI;</span>
<span class="fc" id="L861">        data[values.length + 2] = FastMath.E;</span>
<span class="fc" id="L862">        data[values.length + 3] = -FastMath.E;</span>
<span class="fc" id="L863">        data[values.length + 4] = 1.0;</span>
<span class="fc" id="L864">        data[values.length + 5] = -1.0;</span>
<span class="fc" id="L865">        final double[] expected = new double[data.length];</span>
<span class="fc bfc" id="L866" title="All 2 branches covered.">        for (int i = 0; i &lt; data.length; i++) {</span>
<span class="fc" id="L867">            expected[i] = f.value(data[i]);</span>
        }
<span class="fc" id="L869">        final RealVector v = create(data);</span>
        final RealVector actual;
<span class="fc bfc" id="L871" title="All 2 branches covered.">        if (inPlace) {</span>
<span class="fc" id="L872">            actual = v.mapToSelf(f);</span>
<span class="fc" id="L873">            Assert.assertSame(v, actual);</span>
        } else {
<span class="fc" id="L875">            actual = v.map(f);</span>
        }
<span class="fc" id="L877">        TestUtils.assertEquals(f.getClass().getSimpleName(), expected, actual, 1E-16);</span>
<span class="fc" id="L878">    }</span>

    protected UnivariateFunction[] createFunctions() {
<span class="fc" id="L881">        return new UnivariateFunction[] {</span>
            new Power(2.0), new Exp(), new Expm1(), new Log(), new Log10(),
            new Log1p(), new Cosh(), new Sinh(), new Tanh(), new Cos(),
            new Sin(), new Tan(), new Acos(), new Asin(), new Atan(),
            new Inverse(), new Abs(), new Sqrt(), new Cbrt(), new Ceil(),
            new Floor(), new Rint(), new Signum(), new Ulp()
        };
    }

    @Test
    public void testMap() {
<span class="fc" id="L892">        final UnivariateFunction[] functions = createFunctions();</span>
<span class="fc bfc" id="L893" title="All 2 branches covered.">        for (UnivariateFunction f : functions) {</span>
<span class="fc" id="L894">            doTestMapFunction(f, false);</span>
        }
<span class="fc" id="L896">    }</span>

    @Test
    public void testMapToSelf() {
<span class="fc" id="L900">        final UnivariateFunction[] functions = createFunctions();</span>
<span class="fc bfc" id="L901" title="All 2 branches covered.">        for (UnivariateFunction f : functions) {</span>
<span class="fc" id="L902">            doTestMapFunction(f, true);</span>
        }
<span class="fc" id="L904">    }</span>

    private void doTestOuterProduct(final boolean mixed) {
<span class="fc" id="L907">        final double[] dataU = values;</span>
<span class="fc" id="L908">        final RealVector u = create(dataU);</span>
<span class="fc" id="L909">        final double[] dataV = new double[values.length + 3];</span>
<span class="fc" id="L910">        System.arraycopy(values, 0, dataV, 0, values.length);</span>
<span class="fc" id="L911">        dataV[values.length] = 1d;</span>
<span class="fc" id="L912">        dataV[values.length] = -2d;</span>
<span class="fc" id="L913">        dataV[values.length] = 3d;</span>
        final RealVector v;
<span class="fc bfc" id="L915" title="All 2 branches covered.">        if (mixed) {</span>
<span class="fc" id="L916">            v = createAlien(dataV);</span>
        } else {
<span class="fc" id="L918">            v = create(dataV);</span>
        }
<span class="fc" id="L920">        final RealMatrix uv = u.outerProduct(v);</span>
<span class="fc" id="L921">        Assert.assertEquals(&quot;number of rows&quot;, dataU.length, uv</span>
<span class="fc" id="L922">            .getRowDimension());</span>
<span class="fc" id="L923">        Assert.assertEquals(&quot;number of columns&quot;, dataV.length, uv</span>
<span class="fc" id="L924">            .getColumnDimension());</span>
<span class="fc bfc" id="L925" title="All 2 branches covered.">        for (int i = 0; i &lt; dataU.length; i++) {</span>
<span class="fc bfc" id="L926" title="All 2 branches covered.">            for (int j = 0; j &lt; dataV.length; j++) {</span>
<span class="fc" id="L927">                final double expected = dataU[i] * dataV[j];</span>
<span class="fc" id="L928">                final double actual = uv.getEntry(i, j);</span>
<span class="fc" id="L929">                Assert.assertEquals(dataU[i] + &quot; * &quot; + dataV[j], expected, actual, 0d);</span>
            }
        }
<span class="fc" id="L932">    }</span>

    @Test
    public void testOuterProductSameType() {
<span class="fc" id="L936">        doTestOuterProduct(false);</span>
<span class="fc" id="L937">    }</span>

    @Test
    public void testOuterProductMixedTypes() {
<span class="fc" id="L941">        doTestOuterProduct(true);</span>
<span class="fc" id="L942">    }</span>

    private void doTestProjection(final boolean mixed) {
<span class="fc" id="L945">        final double x = getPreferredEntryValue();</span>
<span class="fc" id="L946">        final double[] data1 = {</span>
            x, 1d, x, x, 2d, x, x, x, 3d, x, x, x, x
        };
<span class="fc" id="L949">        final double[] data2 = {</span>
            5d, -6d, 7d, x, x, -8d, -9d, 10d, 11d, x, 12d, 13d, -15d
        };
<span class="fc" id="L952">        double dotProduct = 0d;</span>
<span class="fc" id="L953">        double norm2 = 0d;</span>
<span class="fc bfc" id="L954" title="All 2 branches covered.">        for (int i = 0; i &lt; data1.length; i++){</span>
<span class="fc" id="L955">            dotProduct += data1[i] * data2[i];</span>
<span class="fc" id="L956">            norm2 += data2[i] * data2[i];</span>
        }
<span class="fc" id="L958">        final double s = dotProduct / norm2;</span>
<span class="fc" id="L959">        final double[] expected = new double[data1.length];</span>
<span class="fc bfc" id="L960" title="All 2 branches covered.">        for (int i = 0; i &lt; data2.length; i++) {</span>
<span class="fc" id="L961">            expected[i] = s * data2[i];</span>
        }
<span class="fc" id="L963">        final RealVector v1 = create(data1);</span>
        final RealVector v2;
<span class="fc bfc" id="L965" title="All 2 branches covered.">        if (mixed) {</span>
<span class="fc" id="L966">            v2 = createAlien(data2);</span>
        } else {
<span class="fc" id="L968">            v2 = create(data2);</span>
        }
<span class="fc" id="L970">        final RealVector actual = v1.projection(v2);</span>
<span class="fc" id="L971">        TestUtils.assertEquals(&quot;&quot;, expected, actual, 0d);</span>
<span class="fc" id="L972">    }</span>

    @Test
    public void testProjectionSameType() {
<span class="fc" id="L976">        doTestProjection(false);</span>
<span class="fc" id="L977">    }</span>

    @Test
    public void testProjectionMixedTypes() {
<span class="fc" id="L981">        doTestProjection(true);</span>
<span class="fc" id="L982">    }</span>

    @Test(expected = MathArithmeticException.class)
    public void testProjectionNullVector() {
<span class="nc" id="L986">        create(new double[4]).projection(create(new double[4]));</span>
<span class="nc" id="L987">    }</span>

    @Test(expected = DimensionMismatchException.class)
    public void testProjectionDimensionMismatch() {
<span class="fc" id="L991">        final RealVector v1 = create(new double[4]);</span>
<span class="fc" id="L992">        final RealVector v2 = create(new double[5]);</span>
<span class="fc" id="L993">        v2.set(1.0);</span>
<span class="nc" id="L994">        v1.projection(v2);</span>
<span class="nc" id="L995">    }</span>

    @Test
    public void testSet() {
<span class="fc bfc" id="L999" title="All 2 branches covered.">        for (int i = 0; i &lt; values.length; i++) {</span>
<span class="fc" id="L1000">            final double expected = values[i];</span>
<span class="fc" id="L1001">            final RealVector v = create(values);</span>
<span class="fc" id="L1002">            v.set(expected);</span>
<span class="fc bfc" id="L1003" title="All 2 branches covered.">            for (int j = 0; j &lt; values.length; j++) {</span>
<span class="fc" id="L1004">                Assert.assertEquals(&quot;entry #&quot; + j, expected, v.getEntry(j), 0);</span>
            }
        }
<span class="fc" id="L1007">    }</span>

    @Test
    public void testToArray() {
<span class="fc" id="L1011">        final double[] data = create(values).toArray();</span>
<span class="fc" id="L1012">        Assert.assertNotSame(values, data);</span>
<span class="fc bfc" id="L1013" title="All 2 branches covered.">        for (int i = 0; i &lt; values.length; i++) {</span>
<span class="fc" id="L1014">            Assert.assertEquals(&quot;entry #&quot; + i, values[i], data[i], 0);</span>
        }
<span class="fc" id="L1016">    }</span>

    private void doTestUnitVector(final boolean inPlace) {
<span class="fc" id="L1019">        final double x = getPreferredEntryValue();</span>
<span class="fc" id="L1020">        final double[] data = {</span>
            x, 1d, x, x, 2d, x, x, x, 3d, x, x, x, x
        };
<span class="fc" id="L1023">        double norm = 0d;</span>
<span class="fc bfc" id="L1024" title="All 2 branches covered.">        for (int i = 0; i &lt; data.length; i++) {</span>
<span class="fc" id="L1025">            norm += data[i] * data[i];</span>
        }
<span class="fc" id="L1027">        norm = FastMath.sqrt(norm);</span>
<span class="fc" id="L1028">        final double[] expected = new double[data.length];</span>
<span class="fc bfc" id="L1029" title="All 2 branches covered.">        for (int i = 0; i &lt; expected.length; i++) {</span>
<span class="fc" id="L1030">            expected[i] = data[i] / norm;</span>
        }
<span class="fc" id="L1032">        final RealVector v = create(data);</span>
        final RealVector actual;
<span class="fc bfc" id="L1034" title="All 2 branches covered.">        if (inPlace) {</span>
<span class="fc" id="L1035">            v.unitize();</span>
<span class="fc" id="L1036">            actual = v;</span>
        } else {
<span class="fc" id="L1038">            actual = v.unitVector();</span>
<span class="fc" id="L1039">            Assert.assertNotSame(v, actual);</span>
        }
<span class="fc" id="L1041">        TestUtils.assertEquals(&quot;&quot;, expected, actual, 0d);</span>
<span class="fc" id="L1042">    }</span>

    @Test
    public void testUnitVector() {
<span class="fc" id="L1046">        doTestUnitVector(false);</span>
<span class="fc" id="L1047">    }</span>

    @Test
    public void testUnitize() {
<span class="fc" id="L1051">        doTestUnitVector(true);</span>
<span class="fc" id="L1052">    }</span>

    private void doTestUnitVectorNullVector(final boolean inPlace) {
<span class="fc" id="L1055">        final double[] data = {</span>
            0d, 0d, 0d, 0d, 0d
        };
<span class="pc bpc" id="L1058" title="1 of 2 branches missed.">        if (inPlace) {</span>
<span class="nc" id="L1059">            create(data).unitize();</span>
        } else {
<span class="nc" id="L1061">            create(data).unitVector();</span>
        }
<span class="nc" id="L1063">    }</span>

    @Test(expected=MathArithmeticException.class)
    public void testUnitVectorNullVector() {
<span class="nc" id="L1067">        doTestUnitVectorNullVector(false);</span>
<span class="nc" id="L1068">    }</span>

    @Test(expected=MathArithmeticException.class)
    public void testUnitizeNullVector() {
<span class="nc" id="L1072">        doTestUnitVectorNullVector(true);</span>
<span class="nc" id="L1073">    }</span>

    @Test
    public void testIterator() {
<span class="fc" id="L1077">        final RealVector v = create(values);</span>
<span class="fc" id="L1078">        final Iterator&lt;RealVector.Entry&gt; it = v.iterator();</span>
<span class="fc bfc" id="L1079" title="All 2 branches covered.">        for (int i = 0; i &lt; values.length; i++) {</span>
<span class="fc" id="L1080">            Assert.assertTrue(&quot;entry #&quot; + i, it.hasNext());</span>
<span class="fc" id="L1081">            final RealVector.Entry e = it.next();</span>
<span class="fc" id="L1082">            Assert.assertEquals(&quot;&quot;, i, e.getIndex());</span>
<span class="fc" id="L1083">            Assert.assertEquals(&quot;&quot;, values[i], e.getValue(), 0d);</span>
            try {
<span class="nc" id="L1085">                it.remove();</span>
<span class="nc" id="L1086">                Assert.fail(&quot;MathUnsupportedOperationException should have been thrown&quot;);</span>
<span class="fc" id="L1087">            } catch (MathUnsupportedOperationException exc) {</span>
                // Expected behavior
<span class="nc" id="L1089">            }</span>
        }
<span class="fc" id="L1091">        Assert.assertFalse(it.hasNext());</span>
        try {
<span class="nc" id="L1093">            it.next();</span>
<span class="nc" id="L1094">            Assert.fail(&quot;NoSuchElementException should have been thrown&quot;);</span>
<span class="fc" id="L1095">        } catch (NoSuchElementException e) {</span>
            // Expected behavior
<span class="nc" id="L1097">        }</span>
<span class="fc" id="L1098">    }</span>

    private void doTestCombine(final boolean inPlace, final boolean mixed) {
<span class="fc" id="L1101">        final int n = values.length * values.length;</span>
<span class="fc" id="L1102">        final double[] data1 = new double[n];</span>
<span class="fc" id="L1103">        final double[] data2 = new double[n];</span>
<span class="fc bfc" id="L1104" title="All 2 branches covered.">        for (int i = 0; i &lt; values.length; i++) {</span>
<span class="fc bfc" id="L1105" title="All 2 branches covered.">            for (int j = 0; j &lt; values.length; j++) {</span>
<span class="fc" id="L1106">                final int index = values.length * i + j;</span>
<span class="fc" id="L1107">                data1[index] = values[i];</span>
<span class="fc" id="L1108">                data2[index] = values[j];</span>
            }
        }
<span class="fc" id="L1111">        final RealVector v1 = create(data1);</span>
<span class="fc bfc" id="L1112" title="All 2 branches covered.">        final RealVector v2 = mixed ? createAlien(data2) : create(data2);</span>
<span class="fc" id="L1113">        final double[] expected = new double[n];</span>
<span class="fc bfc" id="L1114" title="All 2 branches covered.">        for (int i = 0; i &lt; values.length; i++) {</span>
<span class="fc" id="L1115">            final double a1 = values[i];</span>
<span class="fc bfc" id="L1116" title="All 2 branches covered.">            for (int j = 0; j &lt; values.length; j++) {</span>
<span class="fc" id="L1117">                final double a2 = values[j];</span>
<span class="fc bfc" id="L1118" title="All 2 branches covered.">                for (int k = 0; k &lt; n; k++) {</span>
<span class="fc" id="L1119">                    expected[k] = a1 * data1[k] + a2 * data2[k];</span>
                }
                final RealVector actual;
<span class="fc bfc" id="L1122" title="All 2 branches covered.">                if (inPlace) {</span>
<span class="fc" id="L1123">                    final RealVector v1bis = v1.copy();</span>
<span class="fc" id="L1124">                    actual = v1bis.combineToSelf(a1, a2, v2);</span>
<span class="fc" id="L1125">                    Assert.assertSame(v1bis, actual);</span>
<span class="fc" id="L1126">                } else {</span>
<span class="fc" id="L1127">                    actual = v1.combine(a1, a2, v2);</span>
                }
<span class="fc" id="L1129">                TestUtils.assertEquals(&quot;a1 = &quot; + a1 + &quot;, a2 = &quot; + a2, expected,</span>
                    actual, 0.);
            }
        }
<span class="fc" id="L1133">    }</span>

    private void doTestCombineDimensionMismatch(final boolean inPlace, final boolean mixed) {
<span class="fc" id="L1136">        final RealVector v1 = create(new double[10]);</span>
        final RealVector v2;
<span class="fc bfc" id="L1138" title="All 2 branches covered.">        if (mixed) {</span>
<span class="fc" id="L1139">            v2 = createAlien(new double[15]);</span>
        } else {
<span class="fc" id="L1141">            v2 = create(new double[15]);</span>
        }
<span class="pc bpc" id="L1143" title="1 of 2 branches missed.">        if (inPlace) {</span>
<span class="nc" id="L1144">            v1.combineToSelf(1.0, 1.0, v2);</span>
        } else {
<span class="nc" id="L1146">            v1.combine(1.0, 1.0, v2);</span>
        }
<span class="nc" id="L1148">    }</span>

    @Test
    public void testCombineSameType() {
<span class="fc" id="L1152">        doTestCombine(false, false);</span>
<span class="fc" id="L1153">    }</span>

    @Test
    public void testCombineMixedTypes() {
<span class="fc" id="L1157">        doTestCombine(false, true);</span>
<span class="fc" id="L1158">    }</span>

    @Test(expected = DimensionMismatchException.class)
    public void testCombineDimensionMismatchSameType() {
<span class="nc" id="L1162">        doTestCombineDimensionMismatch(false, false);</span>
<span class="nc" id="L1163">    }</span>

    @Test(expected = DimensionMismatchException.class)
    public void testCombineDimensionMismatchMixedTypes() {
<span class="nc" id="L1167">        doTestCombineDimensionMismatch(false, true);</span>
<span class="nc" id="L1168">    }</span>

    @Test
    public void testCombineToSelfSameType() {
<span class="fc" id="L1172">        doTestCombine(true, false);</span>
<span class="fc" id="L1173">    }</span>

    @Test
    public void testCombineToSelfMixedTypes() {
<span class="fc" id="L1177">        doTestCombine(true, true);</span>
<span class="fc" id="L1178">    }</span>

    @Test(expected = DimensionMismatchException.class)
    public void testCombineToSelfDimensionMismatchSameType() {
<span class="nc" id="L1182">        doTestCombineDimensionMismatch(true, false);</span>
<span class="nc" id="L1183">    }</span>

    @Test(expected = DimensionMismatchException.class)
    public void testCombineToSelfDimensionMismatchMixedTypes() {
<span class="nc" id="L1187">        doTestCombineDimensionMismatch(true, true);</span>
<span class="nc" id="L1188">    }</span>

    @Test
    public void testCopy() {
<span class="fc" id="L1192">        final RealVector v = create(values);</span>
<span class="fc" id="L1193">        final RealVector w = v.copy();</span>
<span class="fc" id="L1194">        Assert.assertNotSame(v, w);</span>
<span class="fc" id="L1195">        TestUtils.assertEquals(&quot;&quot;, values, w, 0d);</span>
<span class="fc" id="L1196">    }</span>

    private void doTestDotProductRegularValues(final boolean mixed) {
<span class="fc" id="L1199">        final double x = getPreferredEntryValue();</span>
<span class="fc" id="L1200">        final double[] data1 = {</span>
            x, 1d, x, x, 2d, x, x, x, 3d, x, x, x, x
        };
<span class="fc" id="L1203">        final double[] data2 = {</span>
            5d, -6d, 7d, x, x, -8d, -9d, 10d, 11d, x, 12d, 13d, -15d
        };
<span class="fc" id="L1206">        double expected = 0d;</span>
<span class="fc bfc" id="L1207" title="All 2 branches covered.">        for (int i = 0; i &lt; data1.length; i++){</span>
<span class="fc" id="L1208">            expected += data1[i] * data2[i];</span>
        }
<span class="fc" id="L1210">        final RealVector v1 = create(data1);</span>
        final RealVector v2;
<span class="fc bfc" id="L1212" title="All 2 branches covered.">        if (mixed) {</span>
<span class="fc" id="L1213">            v2 = createAlien(data2);</span>
        } else {
<span class="fc" id="L1215">            v2 = create(data2);</span>
        }
<span class="fc" id="L1217">        final double actual = v1.dotProduct(v2);</span>
<span class="fc" id="L1218">        Assert.assertEquals(&quot;&quot;, expected, actual, 0d);</span>
<span class="fc" id="L1219">    }</span>

    private void doTestDotProductSpecialValues(final boolean mixed) {
<span class="fc bfc" id="L1222" title="All 2 branches covered.">        for (int i = 0; i &lt; values.length; i++) {</span>
<span class="fc" id="L1223">            final double[] data1 = {</span>
                values[i]
            };
<span class="fc" id="L1226">            final RealVector v1 = create(data1);</span>
<span class="fc bfc" id="L1227" title="All 2 branches covered.">            for (int j = 0; j &lt; values.length; j++) {</span>
<span class="fc" id="L1228">                final double[] data2 = {</span>
                    values[j]
                };
                final RealVector v2;
<span class="fc bfc" id="L1232" title="All 2 branches covered.">                if (mixed) {</span>
<span class="fc" id="L1233">                    v2 = createAlien(data2);</span>
                } else {
<span class="fc" id="L1235">                    v2 = create(data2);</span>
                }
<span class="fc" id="L1237">                final double expected = data1[0] * data2[0];</span>
<span class="fc" id="L1238">                final double actual = v1.dotProduct(v2);</span>
<span class="fc" id="L1239">                Assert.assertEquals(data1[0] + &quot; * &quot; + data2[0], expected,</span>
                    actual, 0d);
            }
        }
<span class="fc" id="L1243">    }</span>

    private void doTestDotProductDimensionMismatch(final boolean mixed) {
<span class="fc" id="L1246">        final double[] data1 = new double[10];</span>
<span class="fc" id="L1247">        final double[] data2 = new double[data1.length + 1];</span>
<span class="fc" id="L1248">        final RealVector v1 = create(data1);</span>
        final RealVector v2;
<span class="fc bfc" id="L1250" title="All 2 branches covered.">        if (mixed) {</span>
<span class="fc" id="L1251">            v2 = createAlien(data2);</span>
        } else {
<span class="fc" id="L1253">            v2 = create(data2);</span>
        }
<span class="nc" id="L1255">        v1.dotProduct(v2);</span>
<span class="nc" id="L1256">    }</span>

    @Test
    public void testDotProductSameType() {
<span class="fc" id="L1260">        doTestDotProductRegularValues(false);</span>
<span class="fc" id="L1261">        doTestDotProductSpecialValues(false);</span>
<span class="fc" id="L1262">    }</span>

    @Test(expected=DimensionMismatchException.class)
    public void testDotProductDimensionMismatchSameType() {
<span class="nc" id="L1266">        doTestDotProductDimensionMismatch(false);</span>
<span class="nc" id="L1267">    }</span>

    @Test
    public void testDotProductMixedTypes() {
<span class="fc" id="L1271">        doTestDotProductRegularValues(true);</span>
<span class="fc" id="L1272">        doTestDotProductSpecialValues(true);</span>
<span class="fc" id="L1273">    }</span>

    @Test(expected=DimensionMismatchException.class)
    public void testDotProductDimensionMismatchMixedTypes() {
<span class="nc" id="L1277">        doTestDotProductDimensionMismatch(true);</span>
<span class="nc" id="L1278">    }</span>

    private void doTestCosine(final boolean mixed) {
<span class="fc" id="L1281">        final double x = getPreferredEntryValue();</span>
<span class="fc" id="L1282">        final double[] data1 = {</span>
            x, 1d, x, x, 2d, x, x, x, 3d, x, x, x, x
        };
<span class="fc" id="L1285">        final double[] data2 = {</span>
            5d, -6d, 7d, x, x, -8d, -9d, 10d, 11d, x, 12d, 13d, -15d
        };
<span class="fc" id="L1288">        double norm1 = 0d;</span>
<span class="fc" id="L1289">        double norm2 = 0d;</span>
<span class="fc" id="L1290">        double dotProduct = 0d;</span>
<span class="fc bfc" id="L1291" title="All 2 branches covered.">        for (int i = 0; i &lt; data1.length; i++){</span>
<span class="fc" id="L1292">            norm1 += data1[i] * data1[i];</span>
<span class="fc" id="L1293">            norm2 += data2[i] * data2[i];</span>
<span class="fc" id="L1294">            dotProduct += data1[i] * data2[i];</span>
        }
<span class="fc" id="L1296">        norm1 = FastMath.sqrt(norm1);</span>
<span class="fc" id="L1297">        norm2 = FastMath.sqrt(norm2);</span>
<span class="fc" id="L1298">        final double expected = dotProduct / (norm1 * norm2);</span>
<span class="fc" id="L1299">        final RealVector v1 = create(data1);</span>
        final RealVector v2;
<span class="fc bfc" id="L1301" title="All 2 branches covered.">        if (mixed) {</span>
<span class="fc" id="L1302">            v2 = createAlien(data2);</span>
        } else {
<span class="fc" id="L1304">            v2 = create(data2);</span>
        }
<span class="fc" id="L1306">        final double actual = v1.cosine(v2);</span>
<span class="fc" id="L1307">        Assert.assertEquals(&quot;&quot;, expected, actual, 0d);</span>

<span class="fc" id="L1309">    }</span>

    @Test
    public void testCosineSameType() {
<span class="fc" id="L1313">        doTestCosine(false);</span>
<span class="fc" id="L1314">    }</span>

    @Test
    public void testCosineMixedTypes() {
<span class="fc" id="L1318">        doTestCosine(true);</span>
<span class="fc" id="L1319">    }</span>

    @Test(expected=MathArithmeticException.class)
    public void testCosineLeftNullVector() {
<span class="fc" id="L1323">        final RealVector v = create(new double[] {0, 0, 0});</span>
<span class="fc" id="L1324">        final RealVector w = create(new double[] {1, 0, 0});</span>
<span class="nc" id="L1325">        v.cosine(w);</span>
<span class="nc" id="L1326">    }</span>

    @Test(expected=MathArithmeticException.class)
    public void testCosineRightNullVector() {
<span class="fc" id="L1330">        final RealVector v = create(new double[] {0, 0, 0});</span>
<span class="fc" id="L1331">        final RealVector w = create(new double[] {1, 0, 0});</span>
<span class="nc" id="L1332">        w.cosine(v);</span>
<span class="nc" id="L1333">    }</span>

    @Test(expected=DimensionMismatchException.class)
    public void testCosineDimensionMismatch() {
<span class="fc" id="L1337">        final RealVector v = create(new double[] {1, 2, 3});</span>
<span class="fc" id="L1338">        final RealVector w = create(new double[] {1, 2, 3, 4});</span>
<span class="nc" id="L1339">        v.cosine(w);</span>
<span class="nc" id="L1340">    }</span>

    @Test
    public void testEquals() {
<span class="fc" id="L1344">        final RealVector v = create(new double[] { 0, 1, 2 });</span>

<span class="fc" id="L1346">        Assert.assertTrue(v.equals(v));</span>
<span class="fc" id="L1347">        Assert.assertTrue(v.equals(v.copy()));</span>
<span class="fc" id="L1348">        Assert.assertFalse(v.equals(null));</span>
<span class="fc" id="L1349">        Assert.assertFalse(v.equals(v.getSubVector(0, v.getDimension() - 1)));</span>
<span class="fc" id="L1350">        Assert.assertTrue(v.equals(v.getSubVector(0, v.getDimension())));</span>
<span class="fc" id="L1351">    }</span>

    @Test
    public void testSerial()  {
<span class="fc" id="L1355">        RealVector v = create(new double[] { 0, 1, 2 });</span>
<span class="fc" id="L1356">        Assert.assertEquals(v,TestUtils.serializeAndRecover(v));</span>
<span class="fc" id="L1357">    }</span>

    @Test
    public void testMinMax() {
<span class="fc" id="L1361">        final RealVector v1 = create(new double[] {0, -6, 4, 12, 7});</span>
<span class="fc" id="L1362">        Assert.assertEquals(1, v1.getMinIndex());</span>
<span class="fc" id="L1363">        Assert.assertEquals(-6, v1.getMinValue(), 1.0e-12);</span>
<span class="fc" id="L1364">        Assert.assertEquals(3, v1.getMaxIndex());</span>
<span class="fc" id="L1365">        Assert.assertEquals(12, v1.getMaxValue(), 1.0e-12);</span>
<span class="fc" id="L1366">        final RealVector v2 = create(new double[] {Double.NaN, 3, Double.NaN, -2});</span>
<span class="fc" id="L1367">        Assert.assertEquals(3, v2.getMinIndex());</span>
<span class="fc" id="L1368">        Assert.assertEquals(-2, v2.getMinValue(), 1.0e-12);</span>
<span class="fc" id="L1369">        Assert.assertEquals(1, v2.getMaxIndex());</span>
<span class="fc" id="L1370">        Assert.assertEquals(3, v2.getMaxValue(), 1.0e-12);</span>
<span class="fc" id="L1371">        final RealVector v3 = create(new double[] {Double.NaN, Double.NaN});</span>
<span class="fc" id="L1372">        Assert.assertEquals(-1, v3.getMinIndex());</span>
<span class="fc" id="L1373">        Assert.assertTrue(Double.isNaN(v3.getMinValue()));</span>
<span class="fc" id="L1374">        Assert.assertEquals(-1, v3.getMaxIndex());</span>
<span class="fc" id="L1375">        Assert.assertTrue(Double.isNaN(v3.getMaxValue()));</span>
<span class="fc" id="L1376">        final RealVector v4 = create(new double[0]);</span>
<span class="fc" id="L1377">        Assert.assertEquals(-1, v4.getMinIndex());</span>
<span class="fc" id="L1378">        Assert.assertTrue(Double.isNaN(v4.getMinValue()));</span>
<span class="fc" id="L1379">        Assert.assertEquals(-1, v4.getMaxIndex());</span>
<span class="fc" id="L1380">        Assert.assertTrue(Double.isNaN(v4.getMaxValue()));</span>
<span class="fc" id="L1381">    }</span>

    /*
     * TESTS OF THE VISITOR PATTERN
     */

    /** The whole vector is visited. */
    @Test
    public void testWalkInDefaultOrderPreservingVisitor1() {
<span class="fc" id="L1390">        final double[] data = new double[] {</span>
            0d, 1d, 0d, 0d, 2d, 0d, 0d, 0d, 3d
        };
<span class="fc" id="L1393">        final RealVector v = create(data);</span>
        final RealVectorPreservingVisitor visitor;
<span class="fc" id="L1395">        visitor = new RealVectorPreservingVisitor() {</span>

            private int expectedIndex;

            @Override
            public void visit(final int actualIndex, final double actualValue) {
<span class="fc" id="L1401">                Assert.assertEquals(expectedIndex, actualIndex);</span>
<span class="fc" id="L1402">                Assert.assertEquals(Integer.toString(actualIndex),</span>
                                    data[actualIndex], actualValue, 0d);
<span class="fc" id="L1404">                ++expectedIndex;</span>
<span class="fc" id="L1405">            }</span>

            @Override
            public void start(final int actualSize, final int actualStart,
                              final int actualEnd) {
<span class="fc" id="L1410">                Assert.assertEquals(data.length, actualSize);</span>
<span class="fc" id="L1411">                Assert.assertEquals(0, actualStart);</span>
<span class="fc" id="L1412">                Assert.assertEquals(data.length - 1, actualEnd);</span>
<span class="fc" id="L1413">                expectedIndex = 0;</span>
<span class="fc" id="L1414">            }</span>

            @Override
            public double end() {
<span class="fc" id="L1418">                return 0.0;</span>
            }
        };
<span class="fc" id="L1421">        v.walkInDefaultOrder(visitor);</span>
<span class="fc" id="L1422">    }</span>

    /** Visiting an invalid subvector. */
    @Test
    public void testWalkInDefaultOrderPreservingVisitor2() {
<span class="fc" id="L1427">        final RealVector v = create(new double[5]);</span>
        final RealVectorPreservingVisitor visitor;
<span class="fc" id="L1429">        visitor = new RealVectorPreservingVisitor() {</span>

            @Override
            public void visit(int index, double value) {
                // Do nothing
<span class="nc" id="L1434">            }</span>

            @Override
            public void start(int dimension, int start, int end) {
                // Do nothing
<span class="nc" id="L1439">            }</span>

            @Override
            public double end() {
<span class="nc" id="L1443">                return 0.0;</span>
            }
        };
        try {
<span class="nc" id="L1447">            v.walkInDefaultOrder(visitor, -1, 4);</span>
<span class="nc" id="L1448">            Assert.fail();</span>
<span class="fc" id="L1449">        } catch (OutOfRangeException e) {</span>
            // Expected behavior
<span class="nc" id="L1451">        }</span>
        try {
<span class="nc" id="L1453">            v.walkInDefaultOrder(visitor, 5, 4);</span>
<span class="nc" id="L1454">            Assert.fail();</span>
<span class="fc" id="L1455">        } catch (OutOfRangeException e) {</span>
            // Expected behavior
<span class="nc" id="L1457">        }</span>
        try {
<span class="nc" id="L1459">            v.walkInDefaultOrder(visitor, 0, -1);</span>
<span class="nc" id="L1460">            Assert.fail();</span>
<span class="fc" id="L1461">        } catch (OutOfRangeException e) {</span>
            // Expected behavior
<span class="nc" id="L1463">        }</span>
        try {
<span class="nc" id="L1465">            v.walkInDefaultOrder(visitor, 0, 5);</span>
<span class="nc" id="L1466">            Assert.fail();</span>
<span class="fc" id="L1467">        } catch (OutOfRangeException e) {</span>
            // Expected behavior
<span class="nc" id="L1469">        }</span>
        try {
<span class="nc" id="L1471">            v.walkInDefaultOrder(visitor, 4, 0);</span>
<span class="nc" id="L1472">            Assert.fail();</span>
<span class="fc" id="L1473">        } catch (NumberIsTooSmallException e) {</span>
            // Expected behavior
<span class="nc" id="L1475">        }</span>
<span class="fc" id="L1476">    }</span>

    /** Visiting a valid subvector. */
    @Test
    public void testWalkInDefaultOrderPreservingVisitor3() {
<span class="fc" id="L1481">        final double[] data = new double[] {</span>
            0d, 1d, 0d, 0d, 2d, 0d, 0d, 0d, 3d
        };
<span class="fc" id="L1484">        final int expectedStart = 2;</span>
<span class="fc" id="L1485">        final int expectedEnd = 7;</span>
<span class="fc" id="L1486">        final RealVector v = create(data);</span>
        final RealVectorPreservingVisitor visitor;
<span class="fc" id="L1488">        visitor = new RealVectorPreservingVisitor() {</span>

            private int expectedIndex;

            @Override
            public void visit(final int actualIndex, final double actualValue) {
<span class="fc" id="L1494">                Assert.assertEquals(expectedIndex, actualIndex);</span>
<span class="fc" id="L1495">                Assert.assertEquals(Integer.toString(actualIndex),</span>
                                    data[actualIndex], actualValue, 0d);
<span class="fc" id="L1497">                ++expectedIndex;</span>
<span class="fc" id="L1498">            }</span>

            @Override
            public void start(final int actualSize, final int actualStart,
                              final int actualEnd) {
<span class="fc" id="L1503">                Assert.assertEquals(data.length, actualSize);</span>
<span class="fc" id="L1504">                Assert.assertEquals(expectedStart, actualStart);</span>
<span class="fc" id="L1505">                Assert.assertEquals(expectedEnd, actualEnd);</span>
<span class="fc" id="L1506">                expectedIndex = expectedStart;</span>
<span class="fc" id="L1507">            }</span>

            @Override
            public double end() {
<span class="fc" id="L1511">                return 0.0;</span>
            }
        };
<span class="fc" id="L1514">        v.walkInDefaultOrder(visitor, expectedStart, expectedEnd);</span>
<span class="fc" id="L1515">    }</span>

    /** The whole vector is visited. */
    @Test
    public void testWalkInOptimizedOrderPreservingVisitor1() {
<span class="fc" id="L1520">        final double[] data = new double[] {</span>
            0d, 1d, 0d, 0d, 2d, 0d, 0d, 0d, 3d
        };
<span class="fc" id="L1523">        final RealVector v = create(data);</span>
        final RealVectorPreservingVisitor visitor;
<span class="fc" id="L1525">        visitor = new RealVectorPreservingVisitor() {</span>
<span class="fc" id="L1526">            private final boolean[] visited = new boolean[data.length];</span>

            @Override
            public void visit(final int actualIndex, final double actualValue) {
<span class="fc" id="L1530">                visited[actualIndex] = true;</span>
<span class="fc" id="L1531">                Assert.assertEquals(Integer.toString(actualIndex),</span>
                                    data[actualIndex], actualValue, 0d);
<span class="fc" id="L1533">            }</span>

            @Override
            public void start(final int actualSize, final int actualStart,
                              final int actualEnd) {
<span class="fc" id="L1538">                Assert.assertEquals(data.length, actualSize);</span>
<span class="fc" id="L1539">                Assert.assertEquals(0, actualStart);</span>
<span class="fc" id="L1540">                Assert.assertEquals(data.length - 1, actualEnd);</span>
<span class="fc" id="L1541">                Arrays.fill(visited, false);</span>
<span class="fc" id="L1542">            }</span>

            @Override
            public double end() {
<span class="fc bfc" id="L1546" title="All 2 branches covered.">                for (int i = 0; i &lt; data.length; i++) {</span>
<span class="fc" id="L1547">                    Assert.assertTrue(&quot;entry &quot; + i + &quot;has not been visited&quot;,</span>
                                      visited[i]);
                }
<span class="fc" id="L1550">                return 0.0;</span>
            }
        };
<span class="fc" id="L1553">        v.walkInOptimizedOrder(visitor);</span>
<span class="fc" id="L1554">    }</span>

    /** Visiting an invalid subvector. */
    @Test
    public void testWalkInOptimizedOrderPreservingVisitor2() {
<span class="fc" id="L1559">        final RealVector v = create(new double[5]);</span>
        final RealVectorPreservingVisitor visitor;
<span class="fc" id="L1561">        visitor = new RealVectorPreservingVisitor() {</span>

            @Override
            public void visit(int index, double value) {
                // Do nothing
<span class="nc" id="L1566">            }</span>

            @Override
            public void start(int dimension, int start, int end) {
                // Do nothing
<span class="nc" id="L1571">            }</span>

            @Override
            public double end() {
<span class="nc" id="L1575">                return 0.0;</span>
            }
        };
        try {
<span class="nc" id="L1579">            v.walkInOptimizedOrder(visitor, -1, 4);</span>
<span class="nc" id="L1580">            Assert.fail();</span>
<span class="fc" id="L1581">        } catch (OutOfRangeException e) {</span>
            // Expected behavior
<span class="nc" id="L1583">        }</span>
        try {
<span class="nc" id="L1585">            v.walkInOptimizedOrder(visitor, 5, 4);</span>
<span class="nc" id="L1586">            Assert.fail();</span>
<span class="fc" id="L1587">        } catch (OutOfRangeException e) {</span>
            // Expected behavior
<span class="nc" id="L1589">        }</span>
        try {
<span class="nc" id="L1591">            v.walkInOptimizedOrder(visitor, 0, -1);</span>
<span class="nc" id="L1592">            Assert.fail();</span>
<span class="fc" id="L1593">        } catch (OutOfRangeException e) {</span>
            // Expected behavior
<span class="nc" id="L1595">        }</span>
        try {
<span class="nc" id="L1597">            v.walkInOptimizedOrder(visitor, 0, 5);</span>
<span class="nc" id="L1598">            Assert.fail();</span>
<span class="fc" id="L1599">        } catch (OutOfRangeException e) {</span>
            // Expected behavior
<span class="nc" id="L1601">        }</span>
        try {
<span class="nc" id="L1603">            v.walkInOptimizedOrder(visitor, 4, 0);</span>
<span class="nc" id="L1604">            Assert.fail();</span>
<span class="fc" id="L1605">        } catch (NumberIsTooSmallException e) {</span>
            // Expected behavior
<span class="nc" id="L1607">        }</span>
<span class="fc" id="L1608">    }</span>

    /** Visiting a valid subvector. */
    @Test
    public void testWalkInOptimizedOrderPreservingVisitor3() {
<span class="fc" id="L1613">        final double[] data = new double[] {</span>
            0d, 1d, 0d, 0d, 2d, 0d, 0d, 0d, 3d
        };
<span class="fc" id="L1616">        final int expectedStart = 2;</span>
<span class="fc" id="L1617">        final int expectedEnd = 7;</span>
<span class="fc" id="L1618">        final RealVector v = create(data);</span>
        final RealVectorPreservingVisitor visitor;
<span class="fc" id="L1620">        visitor = new RealVectorPreservingVisitor() {</span>
<span class="fc" id="L1621">            private final boolean[] visited = new boolean[data.length];</span>

            @Override
            public void visit(final int actualIndex, final double actualValue) {
<span class="fc" id="L1625">                Assert.assertEquals(Integer.toString(actualIndex),</span>
                                    data[actualIndex], actualValue, 0d);
<span class="fc" id="L1627">                visited[actualIndex] = true;</span>
<span class="fc" id="L1628">            }</span>

            @Override
            public void start(final int actualSize, final int actualStart,
                              final int actualEnd) {
<span class="fc" id="L1633">                Assert.assertEquals(data.length, actualSize);</span>
<span class="fc" id="L1634">                Assert.assertEquals(expectedStart, actualStart);</span>
<span class="fc" id="L1635">                Assert.assertEquals(expectedEnd, actualEnd);</span>
<span class="fc" id="L1636">                Arrays.fill(visited, true);</span>
<span class="fc" id="L1637">            }</span>

            @Override
            public double end() {
<span class="fc bfc" id="L1641" title="All 2 branches covered.">                for (int i = expectedStart; i &lt;= expectedEnd; i++) {</span>
<span class="fc" id="L1642">                    Assert.assertTrue(&quot;entry &quot; + i + &quot;has not been visited&quot;,</span>
                                      visited[i]);
                }
<span class="fc" id="L1645">                return 0.0;</span>
            }
        };
<span class="fc" id="L1648">        v.walkInOptimizedOrder(visitor, expectedStart, expectedEnd);</span>
<span class="fc" id="L1649">    }</span>

    /** The whole vector is visited. */
    @Test
    public void testWalkInDefaultOrderChangingVisitor1() {
<span class="fc" id="L1654">        final double[] data = new double[] {</span>
            0d, 1d, 0d, 0d, 2d, 0d, 0d, 0d, 3d
        };
<span class="fc" id="L1657">        final RealVector v = create(data);</span>
        final RealVectorChangingVisitor visitor;
<span class="fc" id="L1659">        visitor = new RealVectorChangingVisitor() {</span>

            private int expectedIndex;

            @Override
            public double visit(final int actualIndex, final double actualValue) {
<span class="fc" id="L1665">                Assert.assertEquals(expectedIndex, actualIndex);</span>
<span class="fc" id="L1666">                Assert.assertEquals(Integer.toString(actualIndex),</span>
                                    data[actualIndex], actualValue, 0d);
<span class="fc" id="L1668">                ++expectedIndex;</span>
<span class="fc" id="L1669">                return actualIndex + actualValue;</span>
            }

            @Override
            public void start(final int actualSize, final int actualStart,
                              final int actualEnd) {
<span class="fc" id="L1675">                Assert.assertEquals(data.length, actualSize);</span>
<span class="fc" id="L1676">                Assert.assertEquals(0, actualStart);</span>
<span class="fc" id="L1677">                Assert.assertEquals(data.length - 1, actualEnd);</span>
<span class="fc" id="L1678">                expectedIndex = 0;</span>
<span class="fc" id="L1679">            }</span>

            @Override
            public double end() {
<span class="fc" id="L1683">                return 0.0;</span>
            }
        };
<span class="fc" id="L1686">        v.walkInDefaultOrder(visitor);</span>
<span class="fc bfc" id="L1687" title="All 2 branches covered.">        for (int i = 0; i &lt; data.length; i++) {</span>
<span class="fc" id="L1688">            Assert.assertEquals(&quot;entry &quot; + i, i + data[i], v.getEntry(i), 0.0);</span>
        }
<span class="fc" id="L1690">    }</span>

    /** Visiting an invalid subvector. */
    @Test
    public void testWalkInDefaultOrderChangingVisitor2() {
<span class="fc" id="L1695">        final RealVector v = create(new double[5]);</span>
        final RealVectorChangingVisitor visitor;
<span class="fc" id="L1697">        visitor = new RealVectorChangingVisitor() {</span>

            @Override
            public double visit(int index, double value) {
<span class="nc" id="L1701">                return 0.0;</span>
            }

            @Override
            public void start(int dimension, int start, int end) {
                // Do nothing
<span class="nc" id="L1707">            }</span>

            @Override
            public double end() {
<span class="nc" id="L1711">                return 0.0;</span>
            }
        };
        try {
<span class="nc" id="L1715">            v.walkInDefaultOrder(visitor, -1, 4);</span>
<span class="nc" id="L1716">            Assert.fail();</span>
<span class="fc" id="L1717">        } catch (OutOfRangeException e) {</span>
            // Expected behavior
<span class="nc" id="L1719">        }</span>
        try {
<span class="nc" id="L1721">            v.walkInDefaultOrder(visitor, 5, 4);</span>
<span class="nc" id="L1722">            Assert.fail();</span>
<span class="fc" id="L1723">        } catch (OutOfRangeException e) {</span>
            // Expected behavior
<span class="nc" id="L1725">        }</span>
        try {
<span class="nc" id="L1727">            v.walkInDefaultOrder(visitor, 0, -1);</span>
<span class="nc" id="L1728">            Assert.fail();</span>
<span class="fc" id="L1729">        } catch (OutOfRangeException e) {</span>
            // Expected behavior
<span class="nc" id="L1731">        }</span>
        try {
<span class="nc" id="L1733">            v.walkInDefaultOrder(visitor, 0, 5);</span>
<span class="nc" id="L1734">            Assert.fail();</span>
<span class="fc" id="L1735">        } catch (OutOfRangeException e) {</span>
            // Expected behavior
<span class="nc" id="L1737">        }</span>
        try {
<span class="nc" id="L1739">            v.walkInDefaultOrder(visitor, 4, 0);</span>
<span class="nc" id="L1740">            Assert.fail();</span>
<span class="fc" id="L1741">        } catch (NumberIsTooSmallException e) {</span>
            // Expected behavior
<span class="nc" id="L1743">        }</span>
<span class="fc" id="L1744">    }</span>

    /** Visiting a valid subvector. */
    @Test
    public void testWalkInDefaultOrderChangingVisitor3() {
<span class="fc" id="L1749">        final double[] data = new double[] {</span>
            0d, 1d, 0d, 0d, 2d, 0d, 0d, 0d, 3d
        };
<span class="fc" id="L1752">        final int expectedStart = 2;</span>
<span class="fc" id="L1753">        final int expectedEnd = 7;</span>
<span class="fc" id="L1754">        final RealVector v = create(data);</span>
        final RealVectorChangingVisitor visitor;
<span class="fc" id="L1756">        visitor = new RealVectorChangingVisitor() {</span>

            private int expectedIndex;

            @Override
            public double visit(final int actualIndex, final double actualValue) {
<span class="fc" id="L1762">                Assert.assertEquals(expectedIndex, actualIndex);</span>
<span class="fc" id="L1763">                Assert.assertEquals(Integer.toString(actualIndex),</span>
                                    data[actualIndex], actualValue, 0d);
<span class="fc" id="L1765">                ++expectedIndex;</span>
<span class="fc" id="L1766">                return actualIndex + actualValue;</span>
            }

            @Override
            public void start(final int actualSize, final int actualStart,
                              final int actualEnd) {
<span class="fc" id="L1772">                Assert.assertEquals(data.length, actualSize);</span>
<span class="fc" id="L1773">                Assert.assertEquals(expectedStart, actualStart);</span>
<span class="fc" id="L1774">                Assert.assertEquals(expectedEnd, actualEnd);</span>
<span class="fc" id="L1775">                expectedIndex = expectedStart;</span>
<span class="fc" id="L1776">            }</span>

            @Override
            public double end() {
<span class="fc" id="L1780">                return 0.0;</span>
            }
        };
<span class="fc" id="L1783">        v.walkInDefaultOrder(visitor, expectedStart, expectedEnd);</span>
<span class="fc bfc" id="L1784" title="All 2 branches covered.">        for (int i = expectedStart; i &lt;= expectedEnd; i++) {</span>
<span class="fc" id="L1785">            Assert.assertEquals(&quot;entry &quot; + i, i + data[i], v.getEntry(i), 0.0);</span>
        }
<span class="fc" id="L1787">    }</span>

    /** The whole vector is visited. */
    @Test
    public void testWalkInOptimizedOrderChangingVisitor1() {
<span class="fc" id="L1792">        final double[] data = new double[] {</span>
            0d, 1d, 0d, 0d, 2d, 0d, 0d, 0d, 3d
        };
<span class="fc" id="L1795">        final RealVector v = create(data);</span>
        final RealVectorChangingVisitor visitor;
<span class="fc" id="L1797">        visitor = new RealVectorChangingVisitor() {</span>
<span class="fc" id="L1798">            private final boolean[] visited = new boolean[data.length];</span>

            @Override
            public double visit(final int actualIndex, final double actualValue) {
<span class="fc" id="L1802">                visited[actualIndex] = true;</span>
<span class="fc" id="L1803">                Assert.assertEquals(Integer.toString(actualIndex),</span>
                                    data[actualIndex], actualValue, 0d);
<span class="fc" id="L1805">                return actualIndex + actualValue;</span>
            }

            @Override
            public void start(final int actualSize, final int actualStart,
                              final int actualEnd) {
<span class="fc" id="L1811">                Assert.assertEquals(data.length, actualSize);</span>
<span class="fc" id="L1812">                Assert.assertEquals(0, actualStart);</span>
<span class="fc" id="L1813">                Assert.assertEquals(data.length - 1, actualEnd);</span>
<span class="fc" id="L1814">                Arrays.fill(visited, false);</span>
<span class="fc" id="L1815">            }</span>

            @Override
            public double end() {
<span class="fc bfc" id="L1819" title="All 2 branches covered.">                for (int i = 0; i &lt; data.length; i++) {</span>
<span class="fc" id="L1820">                    Assert.assertTrue(&quot;entry &quot; + i + &quot;has not been visited&quot;,</span>
                                      visited[i]);
                }
<span class="fc" id="L1823">                return 0.0;</span>
            }
        };
<span class="fc" id="L1826">        v.walkInOptimizedOrder(visitor);</span>
<span class="fc bfc" id="L1827" title="All 2 branches covered.">        for (int i = 0; i &lt; data.length; i++) {</span>
<span class="fc" id="L1828">            Assert.assertEquals(&quot;entry &quot; + i, i + data[i], v.getEntry(i), 0.0);</span>
        }
<span class="fc" id="L1830">    }</span>

    /** Visiting an invalid subvector. */
    @Test
    public void testWalkInOptimizedOrderChangingVisitor2() {
<span class="fc" id="L1835">        final RealVector v = create(new double[5]);</span>
        final RealVectorChangingVisitor visitor;
<span class="fc" id="L1837">        visitor = new RealVectorChangingVisitor() {</span>

            @Override
            public double visit(int index, double value) {
<span class="nc" id="L1841">                return 0.0;</span>
            }

            @Override
            public void start(int dimension, int start, int end) {
                // Do nothing
<span class="nc" id="L1847">            }</span>

            @Override
            public double end() {
<span class="nc" id="L1851">                return 0.0;</span>
            }
        };
        try {
<span class="nc" id="L1855">            v.walkInOptimizedOrder(visitor, -1, 4);</span>
<span class="nc" id="L1856">            Assert.fail();</span>
<span class="fc" id="L1857">        } catch (OutOfRangeException e) {</span>
            // Expected behavior
<span class="nc" id="L1859">        }</span>
        try {
<span class="nc" id="L1861">            v.walkInOptimizedOrder(visitor, 5, 4);</span>
<span class="nc" id="L1862">            Assert.fail();</span>
<span class="fc" id="L1863">        } catch (OutOfRangeException e) {</span>
            // Expected behavior
<span class="nc" id="L1865">        }</span>
        try {
<span class="nc" id="L1867">            v.walkInOptimizedOrder(visitor, 0, -1);</span>
<span class="nc" id="L1868">            Assert.fail();</span>
<span class="fc" id="L1869">        } catch (OutOfRangeException e) {</span>
            // Expected behavior
<span class="nc" id="L1871">        }</span>
        try {
<span class="nc" id="L1873">            v.walkInOptimizedOrder(visitor, 0, 5);</span>
<span class="nc" id="L1874">            Assert.fail();</span>
<span class="fc" id="L1875">        } catch (OutOfRangeException e) {</span>
            // Expected behavior
<span class="nc" id="L1877">        }</span>
        try {
<span class="nc" id="L1879">            v.walkInOptimizedOrder(visitor, 4, 0);</span>
<span class="nc" id="L1880">            Assert.fail();</span>
<span class="fc" id="L1881">        } catch (NumberIsTooSmallException e) {</span>
            // Expected behavior
<span class="nc" id="L1883">        }</span>
<span class="fc" id="L1884">    }</span>

    /** Visiting a valid subvector. */
    @Test
    public void testWalkInOptimizedOrderChangingVisitor3() {
<span class="fc" id="L1889">        final double[] data = new double[] {</span>
            0d, 1d, 0d, 0d, 2d, 0d, 0d, 0d, 3d
        };
<span class="fc" id="L1892">        final int expectedStart = 2;</span>
<span class="fc" id="L1893">        final int expectedEnd = 7;</span>
<span class="fc" id="L1894">        final RealVector v = create(data);</span>
        final RealVectorChangingVisitor visitor;
<span class="fc" id="L1896">        visitor = new RealVectorChangingVisitor() {</span>
<span class="fc" id="L1897">            private final boolean[] visited = new boolean[data.length];</span>

            @Override
            public double visit(final int actualIndex, final double actualValue) {
<span class="fc" id="L1901">                Assert.assertEquals(Integer.toString(actualIndex),</span>
                                    data[actualIndex], actualValue, 0d);
<span class="fc" id="L1903">                visited[actualIndex] = true;</span>
<span class="fc" id="L1904">                return actualIndex + actualValue;</span>
            }

            @Override
            public void start(final int actualSize, final int actualStart,
                              final int actualEnd) {
<span class="fc" id="L1910">                Assert.assertEquals(data.length, actualSize);</span>
<span class="fc" id="L1911">                Assert.assertEquals(expectedStart, actualStart);</span>
<span class="fc" id="L1912">                Assert.assertEquals(expectedEnd, actualEnd);</span>
<span class="fc" id="L1913">                Arrays.fill(visited, true);</span>
<span class="fc" id="L1914">            }</span>

            @Override
            public double end() {
<span class="fc bfc" id="L1918" title="All 2 branches covered.">                for (int i = expectedStart; i &lt;= expectedEnd; i++) {</span>
<span class="fc" id="L1919">                    Assert.assertTrue(&quot;entry &quot; + i + &quot;has not been visited&quot;,</span>
                                      visited[i]);
                }
<span class="fc" id="L1922">                return 0.0;</span>
            }
        };
<span class="fc" id="L1925">        v.walkInOptimizedOrder(visitor, expectedStart, expectedEnd);</span>
<span class="fc bfc" id="L1926" title="All 2 branches covered.">        for (int i = expectedStart; i &lt;= expectedEnd; i++) {</span>
<span class="fc" id="L1927">            Assert.assertEquals(&quot;entry &quot; + i, i + data[i], v.getEntry(i), 0.0);</span>
        }
<span class="fc" id="L1929">    }</span>

    /**
     * Minimal implementation of the {@link RealVector} abstract class, for
     * mixed types unit tests.
     */
    public static class RealVectorTestImpl extends RealVector
        implements Serializable {

        /** Serializable version identifier. */
        private static final long serialVersionUID = 20120706L;

        /** Entries of the vector. */
        protected double data[];

<span class="fc" id="L1944">        public RealVectorTestImpl(double[] d) {</span>
<span class="fc" id="L1945">            data = d.clone();</span>
<span class="fc" id="L1946">        }</span>

        private UnsupportedOperationException unsupported() {
<span class="nc" id="L1949">            return new UnsupportedOperationException(&quot;Not supported, unneeded for test purposes&quot;);</span>
        }

        @Override
        public RealVector copy() {
<span class="fc" id="L1954">            return new RealVectorTestImpl(data);</span>
        }

        @Override
        public RealVector ebeMultiply(RealVector v) {
<span class="nc" id="L1959">            throw unsupported();</span>
        }

        @Override
        public RealVector ebeDivide(RealVector v) {
<span class="nc" id="L1964">            throw unsupported();</span>
        }

        @Override
        public double getEntry(int index) {
<span class="fc" id="L1969">            checkIndex(index);</span>
<span class="fc" id="L1970">            return data[index];</span>
        }

        @Override
        public int getDimension() {
<span class="fc" id="L1975">            return data.length;</span>
        }

        @Override
        public RealVector append(RealVector v) {
<span class="nc" id="L1980">            throw unsupported();</span>
        }

        @Override
        public RealVector append(double d) {
<span class="nc" id="L1985">            throw unsupported();</span>
        }

        @Override
        public RealVector getSubVector(int index, int n) {
<span class="nc" id="L1990">            throw unsupported();</span>
        }

        @Override
        public void setEntry(int index, double value) {
<span class="fc" id="L1995">            checkIndex(index);</span>
<span class="fc" id="L1996">            data[index] = value;</span>
<span class="fc" id="L1997">        }</span>

        @Override
        public void setSubVector(int index, RealVector v) {
<span class="nc" id="L2001">            throw unsupported();</span>
        }

        @Override
        public boolean isNaN() {
<span class="nc" id="L2006">            throw unsupported();</span>
        }

        @Override
        public boolean isInfinite() {
<span class="nc" id="L2011">            throw unsupported();</span>
        }
    }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.1.201803210924</span></div></body></html>