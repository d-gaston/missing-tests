<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>SymmLQTest.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">commons_math4$All_in_commons_math4.exec</a> &gt; <a href="index.source.html" class="el_package">org.apache.commons.math4.linear</a> &gt; <span class="el_source">SymmLQTest.java</span></div><h1>SymmLQTest.java</h1><pre class="source lang-java linenums">/*
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the &quot;License&quot;); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.commons.math4.linear;

import java.util.Arrays;

import org.apache.commons.math4.exception.DimensionMismatchException;
import org.apache.commons.math4.linear.Array2DRowRealMatrix;
import org.apache.commons.math4.linear.ArrayRealVector;
import org.apache.commons.math4.linear.DecompositionSolver;
import org.apache.commons.math4.linear.IterativeLinearSolver;
import org.apache.commons.math4.linear.IterativeLinearSolverEvent;
import org.apache.commons.math4.linear.JacobiPreconditioner;
import org.apache.commons.math4.linear.LUDecomposition;
import org.apache.commons.math4.linear.NonPositiveDefiniteOperatorException;
import org.apache.commons.math4.linear.NonSelfAdjointOperatorException;
import org.apache.commons.math4.linear.NonSquareOperatorException;
import org.apache.commons.math4.linear.PreconditionedIterativeLinearSolver;
import org.apache.commons.math4.linear.RealLinearOperator;
import org.apache.commons.math4.linear.RealVector;
import org.apache.commons.math4.linear.SymmLQ;
import org.apache.commons.math4.util.FastMath;
import org.apache.commons.math4.util.IterationEvent;
import org.apache.commons.math4.util.IterationListener;
import org.junit.Assert;
import org.junit.Test;

<span class="fc" id="L42">public class SymmLQTest {</span>

    public void saundersTest(final int n, final boolean goodb,
                             final boolean precon, final double shift,
                             final double pertbn) {
<span class="fc" id="L47">        final RealLinearOperator a = new RealLinearOperator() {</span>

            @Override
            public RealVector operate(final RealVector x) {
<span class="pc bpc" id="L51" title="1 of 2 branches missed.">                if (x.getDimension() != n) {</span>
<span class="nc" id="L52">                    throw new DimensionMismatchException(x.getDimension(), n);</span>
                }
<span class="fc" id="L54">                final double[] y = new double[n];</span>
<span class="fc bfc" id="L55" title="All 2 branches covered.">                for (int i = 0; i &lt; n; i++) {</span>
<span class="fc" id="L56">                    y[i] = (i + 1) * 1.1 / n * x.getEntry(i);</span>
                }
<span class="fc" id="L58">                return new ArrayRealVector(y, false);</span>
            }

            @Override
            public int getRowDimension() {
<span class="fc" id="L63">                return n;</span>
            }

            @Override
            public int getColumnDimension() {
<span class="fc" id="L68">                return n;</span>
            }
        };
<span class="fc" id="L71">        final double shiftm = shift;</span>
<span class="fc" id="L72">        final double pertm = FastMath.abs(pertbn);</span>
        final RealLinearOperator minv;
<span class="fc bfc" id="L74" title="All 2 branches covered.">        if (precon) {</span>
<span class="fc" id="L75">            minv = new RealLinearOperator() {</span>
                @Override
                public int getRowDimension() {
<span class="fc" id="L78">                    return n;</span>
                }

                @Override
                public int getColumnDimension() {
<span class="fc" id="L83">                    return n;</span>
                }

                @Override
                public RealVector operate(final RealVector x) {
<span class="pc bpc" id="L88" title="1 of 2 branches missed.">                    if (x.getDimension() != n) {</span>
<span class="nc" id="L89">                        throw new DimensionMismatchException(x.getDimension(),</span>
                                                             n);
                    }
<span class="fc" id="L92">                    final double[] y = new double[n];</span>
<span class="fc bfc" id="L93" title="All 2 branches covered.">                    for (int i = 0; i &lt; n; i++) {</span>
<span class="fc" id="L94">                        double d = (i + 1) * 1.1 / n;</span>
<span class="fc" id="L95">                        d = FastMath.abs(d - shiftm);</span>
<span class="fc bfc" id="L96" title="All 2 branches covered.">                        if (i % 10 == 0) {</span>
<span class="fc" id="L97">                            d += pertm;</span>
                        }
<span class="fc" id="L99">                        y[i] = x.getEntry(i) / d;</span>
                    }
<span class="fc" id="L101">                    return new ArrayRealVector(y, false);</span>
                }
            };
        } else {
<span class="fc" id="L105">            minv = null;</span>
        }
<span class="fc" id="L107">        final RealVector xtrue = new ArrayRealVector(n);</span>
<span class="fc bfc" id="L108" title="All 2 branches covered.">        for (int i = 0; i &lt; n; i++) {</span>
<span class="fc" id="L109">            xtrue.setEntry(i, n - i);</span>
        }
<span class="fc" id="L111">        final RealVector b = a.operate(xtrue);</span>
<span class="fc" id="L112">        b.combineToSelf(1.0, -shift, xtrue);</span>
<span class="fc" id="L113">        final SymmLQ solver = new SymmLQ(2 * n, 1E-12, true);</span>
<span class="fc" id="L114">        final RealVector x = solver.solve(a, minv, b, goodb, shift);</span>
<span class="fc" id="L115">        final RealVector y = a.operate(x);</span>
<span class="fc" id="L116">        final RealVector r1 = new ArrayRealVector(n);</span>
<span class="fc bfc" id="L117" title="All 2 branches covered.">        for (int i = 0; i &lt; n; i++) {</span>
<span class="fc" id="L118">            final double bi = b.getEntry(i);</span>
<span class="fc" id="L119">            final double yi = y.getEntry(i);</span>
<span class="fc" id="L120">            final double xi = x.getEntry(i);</span>
<span class="fc" id="L121">            r1.setEntry(i, bi - yi + shift * xi);</span>
        }
<span class="fc" id="L123">        final double enorm = x.subtract(xtrue).getNorm() / xtrue.getNorm();</span>
<span class="fc" id="L124">        final double etol = 1E-5;</span>
<span class="fc" id="L125">        Assert.assertTrue(&quot;enorm=&quot; + enorm + &quot;, &quot; +</span>
<span class="pc bpc" id="L126" title="1 of 2 branches missed.">        solver.getIterationManager().getIterations(), enorm &lt;= etol);</span>
<span class="fc" id="L127">    }</span>

    @Test
    public void testSolveSaunders1() {
<span class="fc" id="L131">        saundersTest(1, false, false, 0., 0.);</span>
<span class="fc" id="L132">    }</span>

    @Test
    public void testSolveSaunders2() {
<span class="fc" id="L136">        saundersTest(2, false, false, 0., 0.);</span>
<span class="fc" id="L137">    }</span>

    @Test
    public void testSolveSaunders3() {
<span class="fc" id="L141">        saundersTest(1, false, true, 0., 0.);</span>
<span class="fc" id="L142">    }</span>

    @Test
    public void testSolveSaunders4() {
<span class="fc" id="L146">        saundersTest(2, false, true, 0., 0.);</span>
<span class="fc" id="L147">    }</span>

    @Test
    public void testSolveSaunders5() {
<span class="fc" id="L151">        saundersTest(5, false, true, 0., 0.);</span>
<span class="fc" id="L152">    }</span>

    @Test
    public void testSolveSaunders6() {
<span class="fc" id="L156">        saundersTest(5, false, true, 0.25, 0.);</span>
<span class="fc" id="L157">    }</span>

    @Test
    public void testSolveSaunders7() {
<span class="fc" id="L161">        saundersTest(50, false, false, 0., 0.);</span>
<span class="fc" id="L162">    }</span>

    @Test
    public void testSolveSaunders8() {
<span class="fc" id="L166">        saundersTest(50, false, false, 0.25, 0.);</span>
<span class="fc" id="L167">    }</span>

    @Test
    public void testSolveSaunders9() {
<span class="fc" id="L171">        saundersTest(50, false, true, 0., 0.10);</span>
<span class="fc" id="L172">    }</span>

    @Test
    public void testSolveSaunders10() {
<span class="fc" id="L176">        saundersTest(50, false, true, 0.25, 0.10);</span>
<span class="fc" id="L177">    }</span>

    @Test
    public void testSolveSaunders11() {
<span class="fc" id="L181">        saundersTest(1, true, false, 0., 0.);</span>
<span class="fc" id="L182">    }</span>

    @Test
    public void testSolveSaunders12() {
<span class="fc" id="L186">        saundersTest(2, true, false, 0., 0.);</span>
<span class="fc" id="L187">    }</span>

    @Test
    public void testSolveSaunders13() {
<span class="fc" id="L191">        saundersTest(1, true, true, 0., 0.);</span>
<span class="fc" id="L192">    }</span>

    @Test
    public void testSolveSaunders14() {
<span class="fc" id="L196">        saundersTest(2, true, true, 0., 0.);</span>
<span class="fc" id="L197">    }</span>

    @Test
    public void testSolveSaunders15() {
<span class="fc" id="L201">        saundersTest(5, true, true, 0., 0.);</span>
<span class="fc" id="L202">    }</span>

    @Test
    public void testSolveSaunders16() {
<span class="fc" id="L206">        saundersTest(5, true, true, 0.25, 0.);</span>
<span class="fc" id="L207">    }</span>

    @Test
    public void testSolveSaunders17() {
<span class="fc" id="L211">        saundersTest(50, true, false, 0., 0.);</span>
<span class="fc" id="L212">    }</span>

    @Test
    public void testSolveSaunders18() {
<span class="fc" id="L216">        saundersTest(50, true, false, 0.25, 0.);</span>
<span class="fc" id="L217">    }</span>

    @Test
    public void testSolveSaunders19() {
<span class="fc" id="L221">        saundersTest(50, true, true, 0., 0.10);</span>
<span class="fc" id="L222">    }</span>

    @Test
    public void testSolveSaunders20() {
<span class="fc" id="L226">        saundersTest(50, true, true, 0.25, 0.10);</span>
<span class="fc" id="L227">    }</span>

    @Test(expected = NonSquareOperatorException.class)
    public void testNonSquareOperator() {
<span class="fc" id="L231">        final Array2DRowRealMatrix a = new Array2DRowRealMatrix(2, 3);</span>
        final IterativeLinearSolver solver;
<span class="fc" id="L233">        solver = new SymmLQ(10, 0., false);</span>
<span class="fc" id="L234">        final ArrayRealVector b = new ArrayRealVector(a.getRowDimension());</span>
<span class="fc" id="L235">        final ArrayRealVector x = new ArrayRealVector(a.getColumnDimension());</span>
<span class="nc" id="L236">        solver.solve(a, b, x);</span>
<span class="nc" id="L237">    }</span>

    @Test(expected = DimensionMismatchException.class)
    public void testDimensionMismatchRightHandSide() {
<span class="fc" id="L241">        final Array2DRowRealMatrix a = new Array2DRowRealMatrix(3, 3);</span>
        final IterativeLinearSolver solver;
<span class="fc" id="L243">        solver = new SymmLQ(10, 0., false);</span>
<span class="fc" id="L244">        final ArrayRealVector b = new ArrayRealVector(2);</span>
<span class="nc" id="L245">        solver.solve(a, b);</span>
<span class="nc" id="L246">    }</span>

    @Test(expected = DimensionMismatchException.class)
    public void testDimensionMismatchSolution() {
<span class="fc" id="L250">        final Array2DRowRealMatrix a = new Array2DRowRealMatrix(3, 3);</span>
        final IterativeLinearSolver solver;
<span class="fc" id="L252">        solver = new SymmLQ(10, 0., false);</span>
<span class="fc" id="L253">        final ArrayRealVector b = new ArrayRealVector(3);</span>
<span class="fc" id="L254">        final ArrayRealVector x = new ArrayRealVector(2);</span>
<span class="nc" id="L255">        solver.solve(a, b, x);</span>
<span class="nc" id="L256">    }</span>

    @Test
    public void testUnpreconditionedSolution() {
<span class="fc" id="L260">        final int n = 5;</span>
<span class="fc" id="L261">        final int maxIterations = 100;</span>
<span class="fc" id="L262">        final RealLinearOperator a = new HilbertMatrix(n);</span>
<span class="fc" id="L263">        final InverseHilbertMatrix ainv = new InverseHilbertMatrix(n);</span>
        final IterativeLinearSolver solver;
<span class="fc" id="L265">        solver = new SymmLQ(maxIterations, 1E-10, true);</span>
<span class="fc" id="L266">        final RealVector b = new ArrayRealVector(n);</span>
<span class="fc bfc" id="L267" title="All 2 branches covered.">        for (int j = 0; j &lt; n; j++) {</span>
<span class="fc" id="L268">            b.set(0.);</span>
<span class="fc" id="L269">            b.setEntry(j, 1.);</span>
<span class="fc" id="L270">            final RealVector x = solver.solve(a, b);</span>
<span class="fc bfc" id="L271" title="All 2 branches covered.">            for (int i = 0; i &lt; n; i++) {</span>
<span class="fc" id="L272">                final double actual = x.getEntry(i);</span>
<span class="fc" id="L273">                final double expected = ainv.getEntry(i, j);</span>
<span class="fc" id="L274">                final double delta = 1E-6 * FastMath.abs(expected);</span>
<span class="fc" id="L275">                final String msg = String.format(&quot;entry[%d][%d]&quot;, i, j);</span>
<span class="fc" id="L276">                Assert.assertEquals(msg, expected, actual, delta);</span>
            }
        }
<span class="fc" id="L279">    }</span>

    @Test
    public void testUnpreconditionedInPlaceSolutionWithInitialGuess() {
<span class="fc" id="L283">        final int n = 5;</span>
<span class="fc" id="L284">        final int maxIterations = 100;</span>
<span class="fc" id="L285">        final RealLinearOperator a = new HilbertMatrix(n);</span>
<span class="fc" id="L286">        final InverseHilbertMatrix ainv = new InverseHilbertMatrix(n);</span>
        final IterativeLinearSolver solver;
<span class="fc" id="L288">        solver = new SymmLQ(maxIterations, 1E-10, true);</span>
<span class="fc" id="L289">        final RealVector b = new ArrayRealVector(n);</span>
<span class="fc bfc" id="L290" title="All 2 branches covered.">        for (int j = 0; j &lt; n; j++) {</span>
<span class="fc" id="L291">            b.set(0.);</span>
<span class="fc" id="L292">            b.setEntry(j, 1.);</span>
<span class="fc" id="L293">            final RealVector x0 = new ArrayRealVector(n);</span>
<span class="fc" id="L294">            x0.set(1.);</span>
<span class="fc" id="L295">            final RealVector x = solver.solveInPlace(a, b, x0);</span>
<span class="fc" id="L296">            Assert.assertSame(&quot;x should be a reference to x0&quot;, x0, x);</span>
<span class="fc bfc" id="L297" title="All 2 branches covered.">            for (int i = 0; i &lt; n; i++) {</span>
<span class="fc" id="L298">                final double actual = x.getEntry(i);</span>
<span class="fc" id="L299">                final double expected = ainv.getEntry(i, j);</span>
<span class="fc" id="L300">                final double delta = 1E-6 * FastMath.abs(expected);</span>
<span class="fc" id="L301">                final String msg = String.format(&quot;entry[%d][%d)&quot;, i, j);</span>
<span class="fc" id="L302">                Assert.assertEquals(msg, expected, actual, delta);</span>
            }
        }
<span class="fc" id="L305">    }</span>

    @Test
    public void testUnpreconditionedSolutionWithInitialGuess() {
<span class="fc" id="L309">        final int n = 5;</span>
<span class="fc" id="L310">        final int maxIterations = 100;</span>
<span class="fc" id="L311">        final RealLinearOperator a = new HilbertMatrix(n);</span>
<span class="fc" id="L312">        final InverseHilbertMatrix ainv = new InverseHilbertMatrix(n);</span>
        final IterativeLinearSolver solver;
<span class="fc" id="L314">        solver = new SymmLQ(maxIterations, 1E-10, true);</span>
<span class="fc" id="L315">        final RealVector b = new ArrayRealVector(n);</span>
<span class="fc bfc" id="L316" title="All 2 branches covered.">        for (int j = 0; j &lt; n; j++) {</span>
<span class="fc" id="L317">            b.set(0.);</span>
<span class="fc" id="L318">            b.setEntry(j, 1.);</span>
<span class="fc" id="L319">            final RealVector x0 = new ArrayRealVector(n);</span>
<span class="fc" id="L320">            x0.set(1.);</span>
<span class="fc" id="L321">            final RealVector x = solver.solve(a, b, x0);</span>
<span class="fc" id="L322">            Assert.assertNotSame(&quot;x should not be a reference to x0&quot;, x0, x);</span>
<span class="fc bfc" id="L323" title="All 2 branches covered.">            for (int i = 0; i &lt; n; i++) {</span>
<span class="fc" id="L324">                final double actual = x.getEntry(i);</span>
<span class="fc" id="L325">                final double expected = ainv.getEntry(i, j);</span>
<span class="fc" id="L326">                final double delta = 1E-6 * FastMath.abs(expected);</span>
<span class="fc" id="L327">                final String msg = String.format(&quot;entry[%d][%d]&quot;, i, j);</span>
<span class="fc" id="L328">                Assert.assertEquals(msg, expected, actual, delta);</span>
<span class="fc" id="L329">                Assert.assertEquals(msg, x0.getEntry(i), 1., Math.ulp(1.));</span>
            }
        }
<span class="fc" id="L332">    }</span>

    @Test(expected = NonSquareOperatorException.class)
    public void testNonSquarePreconditioner() {
<span class="fc" id="L336">        final Array2DRowRealMatrix a = new Array2DRowRealMatrix(2, 2);</span>
<span class="fc" id="L337">        final RealLinearOperator m = new RealLinearOperator() {</span>

            @Override
            public RealVector operate(final RealVector x) {
<span class="nc" id="L341">                throw new UnsupportedOperationException();</span>
            }

            @Override
            public int getRowDimension() {
<span class="fc" id="L346">                return 2;</span>
            }

            @Override
            public int getColumnDimension() {
<span class="fc" id="L351">                return 3;</span>
            }
        };
        final PreconditionedIterativeLinearSolver solver;
<span class="fc" id="L355">        solver = new SymmLQ(10, 0., false);</span>
<span class="fc" id="L356">        final ArrayRealVector b = new ArrayRealVector(a.getRowDimension());</span>
<span class="nc" id="L357">        solver.solve(a, m, b);</span>
<span class="nc" id="L358">    }</span>

    @Test(expected = DimensionMismatchException.class)
    public void testMismatchedOperatorDimensions() {
<span class="fc" id="L362">        final Array2DRowRealMatrix a = new Array2DRowRealMatrix(2, 2);</span>
<span class="fc" id="L363">        final RealLinearOperator m = new RealLinearOperator() {</span>

            @Override
            public RealVector operate(final RealVector x) {
<span class="nc" id="L367">                throw new UnsupportedOperationException();</span>
            }

            @Override
            public int getRowDimension() {
<span class="fc" id="L372">                return 3;</span>
            }

            @Override
            public int getColumnDimension() {
<span class="fc" id="L377">                return 3;</span>
            }
        };
        final PreconditionedIterativeLinearSolver solver;
<span class="fc" id="L381">        solver = new SymmLQ(10, 0d, false);</span>
<span class="fc" id="L382">        final ArrayRealVector b = new ArrayRealVector(a.getRowDimension());</span>
<span class="nc" id="L383">        solver.solve(a, m, b);</span>
<span class="nc" id="L384">    }</span>

    @Test(expected = NonPositiveDefiniteOperatorException.class)
    public void testNonPositiveDefinitePreconditioner() {
<span class="fc" id="L388">        final Array2DRowRealMatrix a = new Array2DRowRealMatrix(2, 2);</span>
<span class="fc" id="L389">        a.setEntry(0, 0, 1d);</span>
<span class="fc" id="L390">        a.setEntry(0, 1, 2d);</span>
<span class="fc" id="L391">        a.setEntry(1, 0, 3d);</span>
<span class="fc" id="L392">        a.setEntry(1, 1, 4d);</span>
<span class="fc" id="L393">        final RealLinearOperator m = new RealLinearOperator() {</span>

            @Override
            public RealVector operate(final RealVector x) {
<span class="fc" id="L397">                final ArrayRealVector y = new ArrayRealVector(2);</span>
<span class="fc" id="L398">                y.setEntry(0, -x.getEntry(0));</span>
<span class="fc" id="L399">                y.setEntry(1, -x.getEntry(1));</span>
<span class="fc" id="L400">                return y;</span>
            }

            @Override
            public int getRowDimension() {
<span class="fc" id="L405">                return 2;</span>
            }

            @Override
            public int getColumnDimension() {
<span class="fc" id="L410">                return 2;</span>
            }
        };
        final PreconditionedIterativeLinearSolver solver;
<span class="fc" id="L414">        solver = new SymmLQ(10, 0d, true);</span>
<span class="fc" id="L415">        final ArrayRealVector b = new ArrayRealVector(2);</span>
<span class="fc" id="L416">        b.setEntry(0, -1d);</span>
<span class="fc" id="L417">        b.setEntry(1, -1d);</span>
<span class="nc" id="L418">        solver.solve(a, m, b);</span>
<span class="nc" id="L419">    }</span>

    @Test
    public void testPreconditionedSolution() {
<span class="fc" id="L423">        final int n = 8;</span>
<span class="fc" id="L424">        final int maxIterations = 100;</span>
<span class="fc" id="L425">        final RealLinearOperator a = new HilbertMatrix(n);</span>
<span class="fc" id="L426">        final InverseHilbertMatrix ainv = new InverseHilbertMatrix(n);</span>
<span class="fc" id="L427">        final RealLinearOperator m = JacobiPreconditioner.create(a);</span>
        final PreconditionedIterativeLinearSolver solver;
<span class="fc" id="L429">        solver = new SymmLQ(maxIterations, 1E-15, true);</span>
<span class="fc" id="L430">        final RealVector b = new ArrayRealVector(n);</span>
<span class="fc bfc" id="L431" title="All 2 branches covered.">        for (int j = 0; j &lt; n; j++) {</span>
<span class="fc" id="L432">            b.set(0.);</span>
<span class="fc" id="L433">            b.setEntry(j, 1.);</span>
<span class="fc" id="L434">            final RealVector x = solver.solve(a, m, b);</span>
<span class="fc bfc" id="L435" title="All 2 branches covered.">            for (int i = 0; i &lt; n; i++) {</span>
<span class="fc" id="L436">                final double actual = x.getEntry(i);</span>
<span class="fc" id="L437">                final double expected = ainv.getEntry(i, j);</span>
<span class="fc" id="L438">                final double delta = 1E-6 * FastMath.abs(expected);</span>
<span class="fc" id="L439">                final String msg = String.format(&quot;coefficient (%d, %d)&quot;, i, j);</span>
<span class="fc" id="L440">                Assert.assertEquals(msg, expected, actual, delta);</span>
            }
        }
<span class="fc" id="L443">    }</span>

    @Test
    public void testPreconditionedSolution2() {
<span class="fc" id="L447">        final int n = 100;</span>
<span class="fc" id="L448">        final int maxIterations = 100000;</span>
<span class="fc" id="L449">        final Array2DRowRealMatrix a = new Array2DRowRealMatrix(n, n);</span>
<span class="fc" id="L450">        double daux = 1.;</span>
<span class="fc bfc" id="L451" title="All 2 branches covered.">        for (int i = 0; i &lt; n; i++) {</span>
<span class="fc" id="L452">            a.setEntry(i, i, daux);</span>
<span class="fc" id="L453">            daux *= 1.2;</span>
<span class="fc bfc" id="L454" title="All 2 branches covered.">            for (int j = i + 1; j &lt; n; j++) {</span>
<span class="pc bpc" id="L455" title="1 of 2 branches missed.">                if (i == j) {</span>
                } else {
<span class="fc" id="L457">                    final double value = 1.0;</span>
<span class="fc" id="L458">                    a.setEntry(i, j, value);</span>
<span class="fc" id="L459">                    a.setEntry(j, i, value);</span>
                }
            }
        }
<span class="fc" id="L463">        final RealLinearOperator m = JacobiPreconditioner.create(a);</span>
        final PreconditionedIterativeLinearSolver prec;
        final IterativeLinearSolver unprec;
<span class="fc" id="L466">        prec = new SymmLQ(maxIterations, 1E-15, true);</span>
<span class="fc" id="L467">        unprec = new SymmLQ(maxIterations, 1E-15, true);</span>
<span class="fc" id="L468">        final RealVector b = new ArrayRealVector(n);</span>
<span class="fc" id="L469">        final String pattern = &quot;preconditioned SymmLQ (%d iterations) should&quot;</span>
                               + &quot; have been faster than unpreconditioned (%d iterations)&quot;;
        String msg;
<span class="fc bfc" id="L472" title="All 2 branches covered.">        for (int j = 0; j &lt; 1; j++) {</span>
<span class="fc" id="L473">            b.set(0.);</span>
<span class="fc" id="L474">            b.setEntry(j, 1.);</span>
<span class="fc" id="L475">            final RealVector px = prec.solve(a, m, b);</span>
<span class="fc" id="L476">            final RealVector x = unprec.solve(a, b);</span>
<span class="fc" id="L477">            final int np = prec.getIterationManager().getIterations();</span>
<span class="fc" id="L478">            final int nup = unprec.getIterationManager().getIterations();</span>
<span class="fc" id="L479">            msg = String.format(pattern, np, nup);</span>
<span class="fc bfc" id="L480" title="All 2 branches covered.">            for (int i = 0; i &lt; n; i++) {</span>
<span class="fc" id="L481">                msg = String.format(&quot;row %d, column %d&quot;, i, j);</span>
<span class="fc" id="L482">                final double expected = x.getEntry(i);</span>
<span class="fc" id="L483">                final double actual = px.getEntry(i);</span>
<span class="fc" id="L484">                final double delta = 5E-5 * FastMath.abs(expected);</span>
<span class="fc" id="L485">                Assert.assertEquals(msg, expected, actual, delta);</span>
            }
        }
<span class="fc" id="L488">    }</span>

    @Test
    public void testEventManagement() {
<span class="fc" id="L492">        final int n = 5;</span>
<span class="fc" id="L493">        final int maxIterations = 100;</span>
<span class="fc" id="L494">        final RealLinearOperator a = new HilbertMatrix(n);</span>
        final IterativeLinearSolver solver;
        /*
         * count[0] = number of calls to initializationPerformed
         * count[1] = number of calls to iterationStarted
         * count[2] = number of calls to iterationPerformed
         * count[3] = number of calls to terminationPerformed
         */
<span class="fc" id="L502">        final int[] count = new int[] {0, 0, 0, 0};</span>
<span class="fc" id="L503">        final RealVector xFromListener = new ArrayRealVector(n);</span>
<span class="fc" id="L504">        final IterationListener listener = new IterationListener() {</span>

            @Override
            public void initializationPerformed(final IterationEvent e) {
<span class="fc" id="L508">                ++count[0];</span>
<span class="fc" id="L509">            }</span>

            @Override
            public void iterationPerformed(final IterationEvent e) {
<span class="fc" id="L513">                ++count[2];</span>
<span class="fc" id="L514">                Assert.assertEquals(&quot;iteration performed&quot;,</span>
                                    count[2],
<span class="fc" id="L516">                                    e.getIterations() - 1);</span>
<span class="fc" id="L517">            }</span>

            @Override
            public void iterationStarted(final IterationEvent e) {
<span class="fc" id="L521">                ++count[1];</span>
<span class="fc" id="L522">                Assert.assertEquals(&quot;iteration started&quot;,</span>
                                    count[1],
<span class="fc" id="L524">                                    e.getIterations() - 1);</span>
<span class="fc" id="L525">            }</span>

            @Override
            public void terminationPerformed(final IterationEvent e) {
<span class="fc" id="L529">                ++count[3];</span>
                final IterativeLinearSolverEvent ilse;
<span class="fc" id="L531">                ilse = (IterativeLinearSolverEvent) e;</span>
<span class="fc" id="L532">                xFromListener.setSubVector(0, ilse.getSolution());</span>
<span class="fc" id="L533">            }</span>
        };
<span class="fc" id="L535">        solver = new SymmLQ(maxIterations, 1E-10, true);</span>
<span class="fc" id="L536">        solver.getIterationManager().addIterationListener(listener);</span>
<span class="fc" id="L537">        final RealVector b = new ArrayRealVector(n);</span>
<span class="fc bfc" id="L538" title="All 2 branches covered.">        for (int j = 0; j &lt; n; j++) {</span>
<span class="fc" id="L539">            Arrays.fill(count, 0);</span>
<span class="fc" id="L540">            b.set(0.);</span>
<span class="fc" id="L541">            b.setEntry(j, 1.);</span>
<span class="fc" id="L542">            final RealVector xFromSolver = solver.solve(a, b);</span>
<span class="fc" id="L543">            String msg = String.format(&quot;column %d (initialization)&quot;, j);</span>
<span class="fc" id="L544">            Assert.assertEquals(msg, 1, count[0]);</span>
<span class="fc" id="L545">            msg = String.format(&quot;column %d (finalization)&quot;, j);</span>
<span class="fc" id="L546">            Assert.assertEquals(msg, 1, count[3]);</span>
            /*
             *  Check that solution is not &quot;over-refined&quot;. When the last
             *  iteration has occurred, no further refinement should be
             *  performed.
             */
<span class="fc bfc" id="L552" title="All 2 branches covered.">            for (int i = 0; i &lt; n; i++){</span>
<span class="fc" id="L553">                msg = String.format(&quot;row %d, column %d&quot;, i, j);</span>
<span class="fc" id="L554">                final double expected = xFromSolver.getEntry(i);</span>
<span class="fc" id="L555">                final double actual = xFromListener.getEntry(i);</span>
<span class="fc" id="L556">                Assert.assertEquals(msg, expected, actual, 0.0);</span>
            }
        }
<span class="fc" id="L559">    }</span>

    @Test(expected = NonSelfAdjointOperatorException.class)
    public void testNonSelfAdjointOperator() {
        final RealLinearOperator a;
<span class="fc" id="L564">        a = new Array2DRowRealMatrix(new double[][] {</span>
            {1., 2., 3.},
            {2., 4., 5.},
            {2.999, 5., 6.}
        });
        final RealVector b;
<span class="fc" id="L570">        b = new ArrayRealVector(new double[] {1., 1., 1.});</span>
<span class="nc" id="L571">        new SymmLQ(100, 1., true).solve(a, b);</span>
<span class="nc" id="L572">    }</span>

    @Test(expected = NonSelfAdjointOperatorException.class)
    public void testNonSelfAdjointPreconditioner() {
<span class="fc" id="L576">        final RealLinearOperator a = new Array2DRowRealMatrix(new double[][] {</span>
            {1., 2., 3.},
            {2., 4., 5.},
            {3., 5., 6.}
        });
        final Array2DRowRealMatrix mMat;
<span class="fc" id="L582">        mMat = new Array2DRowRealMatrix(new double[][] {</span>
            {1., 0., 1.},
            {0., 1., 0.},
            {0., 0., 1.}
        });
        final DecompositionSolver mSolver;
<span class="fc" id="L588">        mSolver = new LUDecomposition(mMat).getSolver();</span>
<span class="fc" id="L589">        final RealLinearOperator minv = new RealLinearOperator() {</span>

            @Override
            public RealVector operate(final RealVector x) {
<span class="fc" id="L593">                return mSolver.solve(x);</span>
            }

            @Override
            public int getRowDimension() {
<span class="fc" id="L598">                return mMat.getRowDimension();</span>
            }

            @Override
            public int getColumnDimension() {
<span class="fc" id="L603">                return mMat.getColumnDimension();</span>
            }
        };
<span class="fc" id="L606">        final RealVector b = new ArrayRealVector(new double[] {</span>
            1., 1., 1.
        });
<span class="nc" id="L609">        new SymmLQ(100, 1., true).solve(a, minv, b);</span>
<span class="nc" id="L610">    }</span>

    @Test
    public void testUnpreconditionedNormOfResidual() {
<span class="fc" id="L614">        final int n = 5;</span>
<span class="fc" id="L615">        final int maxIterations = 100;</span>
<span class="fc" id="L616">        final RealLinearOperator a = new HilbertMatrix(n);</span>
        final IterativeLinearSolver solver;
<span class="fc" id="L618">        final IterationListener listener = new IterationListener() {</span>

            private void doTestNormOfResidual(final IterationEvent e) {
                final IterativeLinearSolverEvent evt;
<span class="fc" id="L622">                evt = (IterativeLinearSolverEvent) e;</span>
<span class="fc" id="L623">                final RealVector x = evt.getSolution();</span>
<span class="fc" id="L624">                final RealVector b = evt.getRightHandSideVector();</span>
<span class="fc" id="L625">                final RealVector r = b.subtract(a.operate(x));</span>
<span class="fc" id="L626">                final double rnorm = r.getNorm();</span>
<span class="fc" id="L627">                Assert.assertEquals(&quot;iteration performed (residual)&quot;,</span>
<span class="fc" id="L628">                    rnorm, evt.getNormOfResidual(),</span>
<span class="fc" id="L629">                    FastMath.max(1E-5 * rnorm, 1E-10));</span>
<span class="fc" id="L630">            }</span>

            @Override
            public void initializationPerformed(final IterationEvent e) {
<span class="fc" id="L634">                doTestNormOfResidual(e);</span>
<span class="fc" id="L635">            }</span>

            @Override
            public void iterationPerformed(final IterationEvent e) {
<span class="fc" id="L639">                doTestNormOfResidual(e);</span>
<span class="fc" id="L640">            }</span>

            @Override
            public void iterationStarted(final IterationEvent e) {
<span class="fc" id="L644">                doTestNormOfResidual(e);</span>
<span class="fc" id="L645">            }</span>

            @Override
            public void terminationPerformed(final IterationEvent e) {
<span class="fc" id="L649">                doTestNormOfResidual(e);</span>
<span class="fc" id="L650">            }</span>
        };
<span class="fc" id="L652">        solver = new SymmLQ(maxIterations, 1E-10, true);</span>
<span class="fc" id="L653">        solver.getIterationManager().addIterationListener(listener);</span>
<span class="fc" id="L654">        final RealVector b = new ArrayRealVector(n);</span>
<span class="fc bfc" id="L655" title="All 2 branches covered.">        for (int j = 0; j &lt; n; j++) {</span>
<span class="fc" id="L656">            b.set(0.);</span>
<span class="fc" id="L657">            b.setEntry(j, 1.);</span>
<span class="fc" id="L658">            solver.solve(a, b);</span>
        }
<span class="fc" id="L660">    }</span>

    @Test
    public void testPreconditionedNormOfResidual() {
<span class="fc" id="L664">        final int n = 5;</span>
<span class="fc" id="L665">        final int maxIterations = 100;</span>
<span class="fc" id="L666">        final RealLinearOperator a = new HilbertMatrix(n);</span>
<span class="fc" id="L667">        final JacobiPreconditioner m = JacobiPreconditioner.create(a);</span>
<span class="fc" id="L668">        final RealLinearOperator p = m.sqrt();</span>
        final PreconditionedIterativeLinearSolver solver;
<span class="fc" id="L670">        final IterationListener listener = new IterationListener() {</span>

            private void doTestNormOfResidual(final IterationEvent e) {
                final IterativeLinearSolverEvent evt;
<span class="fc" id="L674">                evt = (IterativeLinearSolverEvent) e;</span>
<span class="fc" id="L675">                final RealVector x = evt.getSolution();</span>
<span class="fc" id="L676">                final RealVector b = evt.getRightHandSideVector();</span>
<span class="fc" id="L677">                final RealVector r = b.subtract(a.operate(x));</span>
<span class="fc" id="L678">                final double rnorm = p.operate(r).getNorm();</span>
<span class="fc" id="L679">                Assert.assertEquals(&quot;iteration performed (residual)&quot;,</span>
<span class="fc" id="L680">                    rnorm, evt.getNormOfResidual(),</span>
<span class="fc" id="L681">                    FastMath.max(1E-5 * rnorm, 1E-10));</span>
<span class="fc" id="L682">            }</span>

            @Override
            public void initializationPerformed(final IterationEvent e) {
<span class="fc" id="L686">                doTestNormOfResidual(e);</span>
<span class="fc" id="L687">            }</span>

            @Override
            public void iterationPerformed(final IterationEvent e) {
<span class="fc" id="L691">                doTestNormOfResidual(e);</span>
<span class="fc" id="L692">            }</span>

            @Override
            public void iterationStarted(final IterationEvent e) {
<span class="fc" id="L696">                doTestNormOfResidual(e);</span>
<span class="fc" id="L697">            }</span>

            @Override
            public void terminationPerformed(final IterationEvent e) {
<span class="fc" id="L701">                doTestNormOfResidual(e);</span>
<span class="fc" id="L702">            }</span>
        };
<span class="fc" id="L704">        solver = new SymmLQ(maxIterations, 1E-10, true);</span>
<span class="fc" id="L705">        solver.getIterationManager().addIterationListener(listener);</span>
<span class="fc" id="L706">        final RealVector b = new ArrayRealVector(n);</span>
<span class="fc bfc" id="L707" title="All 2 branches covered.">        for (int j = 0; j &lt; n; j++) {</span>
<span class="fc" id="L708">            b.set(0.);</span>
<span class="fc" id="L709">            b.setEntry(j, 1.);</span>
<span class="fc" id="L710">            solver.solve(a, m, b);</span>
        }
<span class="fc" id="L712">    }</span>
}

</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.1.201803210924</span></div></body></html>