<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>RungeKuttaFieldIntegratorAbstractTest.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">commons_math4$All_in_commons_math4.exec</a> &gt; <a href="index.source.html" class="el_package">org.apache.commons.math4.ode.nonstiff</a> &gt; <span class="el_source">RungeKuttaFieldIntegratorAbstractTest.java</span></div><h1>RungeKuttaFieldIntegratorAbstractTest.java</h1><pre class="source lang-java linenums">/*
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the &quot;License&quot;); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package org.apache.commons.math4.ode.nonstiff;


import java.lang.reflect.Array;

import org.apache.commons.math4.Field;
import org.apache.commons.math4.RealFieldElement;
import org.apache.commons.math4.analysis.differentiation.DerivativeStructure;
import org.apache.commons.math4.exception.DimensionMismatchException;
import org.apache.commons.math4.exception.MaxCountExceededException;
import org.apache.commons.math4.exception.NoBracketingException;
import org.apache.commons.math4.exception.NumberIsTooSmallException;
import org.apache.commons.math4.ode.FieldExpandableODE;
import org.apache.commons.math4.ode.FirstOrderFieldDifferentialEquations;
import org.apache.commons.math4.ode.FieldODEState;
import org.apache.commons.math4.ode.FieldODEStateAndDerivative;
import org.apache.commons.math4.ode.TestFieldProblem1;
import org.apache.commons.math4.ode.TestFieldProblem2;
import org.apache.commons.math4.ode.TestFieldProblem3;
import org.apache.commons.math4.ode.TestFieldProblem4;
import org.apache.commons.math4.ode.TestFieldProblem5;
import org.apache.commons.math4.ode.TestFieldProblem6;
import org.apache.commons.math4.ode.TestFieldProblemAbstract;
import org.apache.commons.math4.ode.TestFieldProblemHandler;
import org.apache.commons.math4.ode.events.Action;
import org.apache.commons.math4.ode.events.FieldEventHandler;
import org.apache.commons.math4.ode.sampling.FieldStepHandler;
import org.apache.commons.math4.ode.sampling.FieldStepInterpolator;
import org.apache.commons.math4.ode.sampling.StepInterpolatorTestUtils;
import org.apache.commons.math4.util.FastMath;
import org.apache.commons.math4.util.MathArrays;
import org.junit.Assert;
import org.junit.Test;

<span class="fc" id="L52">public abstract class RungeKuttaFieldIntegratorAbstractTest {</span>

    protected abstract &lt;T extends RealFieldElement&lt;T&gt;&gt; RungeKuttaFieldIntegrator&lt;T&gt;
        createIntegrator(Field&lt;T&gt; field, T step);

    @Test
    public abstract void testNonFieldIntegratorConsistency();

    protected &lt;T extends RealFieldElement&lt;T&gt;&gt; void doTestNonFieldIntegratorConsistency(final Field&lt;T&gt; field) {
        try {

            // get the Butcher arrays from the field integrator
<span class="fc" id="L64">            RungeKuttaFieldIntegrator&lt;T&gt; fieldIntegrator = createIntegrator(field, field.getZero().add(1));</span>
<span class="fc" id="L65">            T[][] fieldA = fieldIntegrator.getA();</span>
<span class="fc" id="L66">            T[]   fieldB = fieldIntegrator.getB();</span>
<span class="fc" id="L67">            T[]   fieldC = fieldIntegrator.getC();</span>

<span class="fc" id="L69">            String fieldName   = fieldIntegrator.getClass().getName();</span>
<span class="fc" id="L70">            String regularName = fieldName.replaceAll(&quot;Field&quot;, &quot;&quot;);</span>

            // get the Butcher arrays from the regular integrator
            @SuppressWarnings(&quot;unchecked&quot;)
<span class="fc" id="L74">            Class&lt;RungeKuttaIntegrator&gt; c = (Class&lt;RungeKuttaIntegrator&gt;) Class.forName(regularName);</span>
<span class="fc" id="L75">            java.lang.reflect.Field jlrFieldA = c.getDeclaredField(&quot;STATIC_A&quot;);</span>
<span class="fc" id="L76">            jlrFieldA.setAccessible(true);</span>
<span class="fc" id="L77">            double[][] regularA = (double[][]) jlrFieldA.get(null);</span>
<span class="fc" id="L78">            java.lang.reflect.Field jlrFieldB = c.getDeclaredField(&quot;STATIC_B&quot;);</span>
<span class="fc" id="L79">            jlrFieldB.setAccessible(true);</span>
<span class="fc" id="L80">            double[]   regularB = (double[])   jlrFieldB.get(null);</span>
<span class="fc" id="L81">            java.lang.reflect.Field jlrFieldC = c.getDeclaredField(&quot;STATIC_C&quot;);</span>
<span class="fc" id="L82">            jlrFieldC.setAccessible(true);</span>
<span class="fc" id="L83">            double[]   regularC = (double[])   jlrFieldC.get(null);</span>

<span class="fc" id="L85">            Assert.assertEquals(regularA.length, fieldA.length);</span>
<span class="fc bfc" id="L86" title="All 2 branches covered.">            for (int i = 0; i &lt; regularA.length; ++i) {</span>
<span class="fc" id="L87">                checkArray(regularA[i], fieldA[i]);</span>
            }
<span class="fc" id="L89">            checkArray(regularB, fieldB);</span>
<span class="fc" id="L90">            checkArray(regularC, fieldC);</span>

<span class="nc" id="L92">        } catch (ClassNotFoundException cnfe) {</span>
<span class="nc" id="L93">            Assert.fail(cnfe.getLocalizedMessage());</span>
<span class="nc" id="L94">        } catch (IllegalAccessException iae) {</span>
<span class="nc" id="L95">            Assert.fail(iae.getLocalizedMessage());</span>
<span class="nc" id="L96">        } catch (IllegalArgumentException iae) {</span>
<span class="nc" id="L97">            Assert.fail(iae.getLocalizedMessage());</span>
<span class="nc" id="L98">        } catch (SecurityException se) {</span>
<span class="nc" id="L99">            Assert.fail(se.getLocalizedMessage());</span>
<span class="nc" id="L100">        } catch (NoSuchFieldException nsfe) {</span>
<span class="nc" id="L101">            Assert.fail(nsfe.getLocalizedMessage());</span>
<span class="pc" id="L102">        }</span>
<span class="fc" id="L103">    }</span>

    private &lt;T extends RealFieldElement&lt;T&gt;&gt; void checkArray(double[] regularArray, T[] fieldArray) {
<span class="fc" id="L106">        Assert.assertEquals(regularArray.length, fieldArray.length);</span>
<span class="fc bfc" id="L107" title="All 2 branches covered.">        for (int i = 0; i &lt; regularArray.length; ++i) {</span>
<span class="fc bfc" id="L108" title="All 2 branches covered.">            if (regularArray[i] == 0) {</span>
<span class="pc bpc" id="L109" title="1 of 2 branches missed.">                Assert.assertTrue(0.0 == fieldArray[i].getReal());</span>
            } else {
<span class="fc" id="L111">                Assert.assertEquals(regularArray[i], fieldArray[i].getReal(), FastMath.ulp(regularArray[i]));</span>
            }
        }
<span class="fc" id="L114">    }</span>

    @Test
    public abstract void testMissedEndEvent();

    protected &lt;T extends RealFieldElement&lt;T&gt;&gt; void doTestMissedEndEvent(final Field&lt;T&gt; field,
                                                                        final double epsilonT, final double epsilonY)
        throws DimensionMismatchException, NumberIsTooSmallException,
            MaxCountExceededException, NoBracketingException {
<span class="fc" id="L123">        final T   t0     = field.getZero().add(1878250320.0000029);</span>
<span class="fc" id="L124">        final T   tEvent = field.getZero().add(1878250379.9999986);</span>
<span class="fc" id="L125">        final T[] k      = MathArrays.buildArray(field, 3);</span>
<span class="fc" id="L126">        k[0] = field.getZero().add(1.0e-4);</span>
<span class="fc" id="L127">        k[1] = field.getZero().add(1.0e-5);</span>
<span class="fc" id="L128">        k[2] = field.getZero().add(1.0e-6);</span>
<span class="fc" id="L129">        FirstOrderFieldDifferentialEquations&lt;T&gt; ode = new FirstOrderFieldDifferentialEquations&lt;T&gt;() {</span>

            @Override
            public int getDimension() {
<span class="fc" id="L133">                return k.length;</span>
            }

            @Override
            public void init(T t0, T[] y0, T t) {
<span class="fc" id="L138">            }</span>

            @Override
            public T[] computeDerivatives(T t, T[] y) {
<span class="fc" id="L142">                T[] yDot = MathArrays.buildArray(field, k.length);</span>
<span class="fc bfc" id="L143" title="All 2 branches covered.">                for (int i = 0; i &lt; y.length; ++i) {</span>
<span class="fc" id="L144">                    yDot[i] = k[i].multiply(y[i]);</span>
                }
<span class="fc" id="L146">                return yDot;</span>
            }
        };

<span class="fc" id="L150">        RungeKuttaFieldIntegrator&lt;T&gt; integrator = createIntegrator(field, field.getZero().add(60.0));</span>

<span class="fc" id="L152">        T[] y0   = MathArrays.buildArray(field, k.length);</span>
<span class="fc bfc" id="L153" title="All 2 branches covered.">        for (int i = 0; i &lt; y0.length; ++i) {</span>
<span class="fc" id="L154">            y0[i] = field.getOne().add(i);</span>
        }

<span class="fc" id="L157">        FieldODEStateAndDerivative&lt;T&gt; result = integrator.integrate(new FieldExpandableODE&lt;&gt;(ode),</span>
                                                                    new FieldODEState&lt;&gt;(t0, y0),
                                                                    tEvent);
<span class="fc" id="L160">        Assert.assertEquals(tEvent.getReal(), result.getTime().getReal(), epsilonT);</span>
<span class="fc" id="L161">        T[] y = result.getState();</span>
<span class="fc bfc" id="L162" title="All 2 branches covered.">        for (int i = 0; i &lt; y.length; ++i) {</span>
<span class="fc" id="L163">            Assert.assertEquals(y0[i].multiply(k[i].multiply(result.getTime().subtract(t0)).exp()).getReal(),</span>
<span class="fc" id="L164">                                y[i].getReal(),</span>
                                epsilonY);
        }

<span class="fc" id="L168">        integrator.addEventHandler(new FieldEventHandler&lt;T&gt;() {</span>

            @Override
            public void init(FieldODEStateAndDerivative&lt;T&gt; state0, T t) {
<span class="fc" id="L172">            }</span>

            @Override
            public FieldODEState&lt;T&gt; resetState(FieldODEStateAndDerivative&lt;T&gt; state) {
<span class="nc" id="L176">                return state;</span>
            }

            @Override
            public T g(FieldODEStateAndDerivative&lt;T&gt; state) {
<span class="fc" id="L181">                return state.getTime().subtract(tEvent);</span>
            }

            @Override
            public Action eventOccurred(FieldODEStateAndDerivative&lt;T&gt; state, boolean increasing) {
<span class="fc" id="L186">                Assert.assertEquals(tEvent.getReal(), state.getTime().getReal(), epsilonT);</span>
<span class="fc" id="L187">                return Action.CONTINUE;</span>
            }
        }, Double.POSITIVE_INFINITY, 1.0e-20, 100);
<span class="fc" id="L190">        result = integrator.integrate(new FieldExpandableODE&lt;&gt;(ode),</span>
                                      new FieldODEState&lt;&gt;(t0, y0),
<span class="fc" id="L192">                                      tEvent.add(120));</span>
<span class="fc" id="L193">        Assert.assertEquals(tEvent.add(120).getReal(), result.getTime().getReal(), epsilonT);</span>
<span class="fc" id="L194">        y = result.getState();</span>
<span class="fc bfc" id="L195" title="All 2 branches covered.">        for (int i = 0; i &lt; y.length; ++i) {</span>
<span class="fc" id="L196">            Assert.assertEquals(y0[i].multiply(k[i].multiply(result.getTime().subtract(t0)).exp()).getReal(),</span>
<span class="fc" id="L197">                                y[i].getReal(),</span>
                                epsilonY);
        }

<span class="fc" id="L201">    }</span>

    @Test
    public abstract void testSanityChecks();

    protected &lt;T extends RealFieldElement&lt;T&gt;&gt; void doTestSanityChecks(Field&lt;T&gt; field)
        throws DimensionMismatchException, NumberIsTooSmallException,
               MaxCountExceededException, NoBracketingException {
<span class="fc" id="L209">        RungeKuttaFieldIntegrator&lt;T&gt; integrator = createIntegrator(field, field.getZero().add(0.01));</span>
        try  {
<span class="fc" id="L211">            TestFieldProblem1&lt;T&gt; pb = new TestFieldProblem1&lt;&gt;(field);</span>
<span class="pc" id="L212">            integrator.integrate(new FieldExpandableODE&lt;&gt;(pb),</span>
<span class="fc" id="L213">                                 new FieldODEState&lt;&gt;(field.getZero(), MathArrays.buildArray(field, pb.getDimension() + 10)),</span>
<span class="fc" id="L214">                                 field.getOne());</span>
<span class="nc" id="L215">            Assert.fail(&quot;an exception should have been thrown&quot;);</span>
<span class="fc" id="L216">        } catch(DimensionMismatchException ie) {</span>
<span class="nc" id="L217">        }</span>
        try  {
<span class="fc" id="L219">            TestFieldProblem1&lt;T&gt; pb = new TestFieldProblem1&lt;&gt;(field);</span>
<span class="pc" id="L220">            integrator.integrate(new FieldExpandableODE&lt;&gt;(pb),</span>
<span class="fc" id="L221">                                 new FieldODEState&lt;&gt;(field.getZero(), MathArrays.buildArray(field, pb.getDimension())),</span>
<span class="fc" id="L222">                                 field.getZero());</span>
<span class="nc" id="L223">            Assert.fail(&quot;an exception should have been thrown&quot;);</span>
<span class="fc" id="L224">        } catch(NumberIsTooSmallException ie) {</span>
<span class="nc" id="L225">        }</span>
<span class="fc" id="L226">    }</span>

    @Test
    public abstract void testDecreasingSteps();

    protected &lt;T extends RealFieldElement&lt;T&gt;&gt; void doTestDecreasingSteps(Field&lt;T&gt; field,
                                                                         final double safetyValueFactor,
                                                                         final double safetyTimeFactor,
                                                                         final double epsilonT)
        throws DimensionMismatchException, NumberIsTooSmallException,
               MaxCountExceededException, NoBracketingException {

        @SuppressWarnings(&quot;unchecked&quot;)
<span class="fc" id="L239">        TestFieldProblemAbstract&lt;T&gt;[] allProblems =</span>
<span class="fc" id="L240">                        (TestFieldProblemAbstract&lt;T&gt;[]) Array.newInstance(TestFieldProblemAbstract.class, 6);</span>
<span class="fc" id="L241">        allProblems[0] = new TestFieldProblem1&lt;&gt;(field);</span>
<span class="fc" id="L242">        allProblems[1] = new TestFieldProblem2&lt;&gt;(field);</span>
<span class="fc" id="L243">        allProblems[2] = new TestFieldProblem3&lt;&gt;(field);</span>
<span class="fc" id="L244">        allProblems[3] = new TestFieldProblem4&lt;&gt;(field);</span>
<span class="fc" id="L245">        allProblems[4] = new TestFieldProblem5&lt;&gt;(field);</span>
<span class="fc" id="L246">        allProblems[5] = new TestFieldProblem6&lt;&gt;(field);</span>
<span class="fc bfc" id="L247" title="All 2 branches covered.">        for (TestFieldProblemAbstract&lt;T&gt; pb :  allProblems) {</span>

<span class="fc" id="L249">            T previousValueError = null;</span>
<span class="fc" id="L250">            T previousTimeError  = null;</span>
<span class="fc bfc" id="L251" title="All 2 branches covered.">            for (int i = 4; i &lt; 10; ++i) {</span>

<span class="fc" id="L253">                T step = pb.getFinalTime().subtract(pb.getInitialState().getTime()).multiply(FastMath.pow(2.0, -i));</span>

<span class="fc" id="L255">                RungeKuttaFieldIntegrator&lt;T&gt; integ = createIntegrator(field, step);</span>
<span class="fc" id="L256">                TestFieldProblemHandler&lt;T&gt; handler = new TestFieldProblemHandler&lt;&gt;(pb, integ);</span>
<span class="fc" id="L257">                integ.addStepHandler(handler);</span>
<span class="fc" id="L258">                FieldEventHandler&lt;T&gt;[] functions = pb.getEventsHandlers();</span>
<span class="fc bfc" id="L259" title="All 2 branches covered.">                for (int l = 0; l &lt; functions.length; ++l) {</span>
<span class="fc" id="L260">                    integ.addEventHandler(functions[l],</span>
<span class="fc" id="L261">                                          Double.POSITIVE_INFINITY, 1.0e-6 * step.getReal(), 1000);</span>
                }
<span class="fc" id="L263">                Assert.assertEquals(functions.length, integ.getEventHandlers().size());</span>
<span class="fc" id="L264">                FieldODEStateAndDerivative&lt;T&gt; stop = integ.integrate(new FieldExpandableODE&lt;&gt;(pb),</span>
<span class="fc" id="L265">                                                                     pb.getInitialState(),</span>
<span class="fc" id="L266">                                                                     pb.getFinalTime());</span>
<span class="fc bfc" id="L267" title="All 2 branches covered.">                if (functions.length == 0) {</span>
<span class="fc" id="L268">                    Assert.assertEquals(pb.getFinalTime().getReal(), stop.getTime().getReal(), epsilonT);</span>
                }

<span class="fc" id="L271">                T error = handler.getMaximalValueError();</span>
<span class="fc bfc" id="L272" title="All 2 branches covered.">                if (i &gt; 4) {</span>
<span class="pc bpc" id="L273" title="1 of 2 branches missed.">                    Assert.assertTrue(error.subtract(previousValueError.abs().multiply(safetyValueFactor)).getReal() &lt; 0);</span>
                }
<span class="fc" id="L275">                previousValueError = error;</span>

<span class="fc" id="L277">                T timeError = handler.getMaximalTimeError();</span>
<span class="fc bfc" id="L278" title="All 2 branches covered.">                if (i &gt; 4) {</span>
<span class="pc bpc" id="L279" title="1 of 2 branches missed.">                    Assert.assertTrue(timeError.subtract(previousTimeError.abs().multiply(safetyTimeFactor)).getReal() &lt;= 0);</span>
                }
<span class="fc" id="L281">                previousTimeError = timeError;</span>

<span class="fc" id="L283">                integ.clearEventHandlers();</span>
<span class="fc" id="L284">                Assert.assertEquals(0, integ.getEventHandlers().size());</span>
            }

        }

<span class="fc" id="L289">    }</span>

    @Test
    public abstract void testSmallStep();

    protected &lt;T extends RealFieldElement&lt;T&gt;&gt; void doTestSmallStep(Field&lt;T&gt; field,
                                                                   final double epsilonLast,
                                                                   final double epsilonMaxValue,
                                                                   final double epsilonMaxTime,
                                                                   final String name)
         throws DimensionMismatchException, NumberIsTooSmallException,
                MaxCountExceededException, NoBracketingException {

<span class="fc" id="L302">        TestFieldProblem1&lt;T&gt; pb = new TestFieldProblem1&lt;&gt;(field);</span>
<span class="fc" id="L303">        T step = pb.getFinalTime().subtract(pb.getInitialState().getTime()).multiply(0.001);</span>

<span class="fc" id="L305">        RungeKuttaFieldIntegrator&lt;T&gt; integ = createIntegrator(field, step);</span>
<span class="fc" id="L306">        TestFieldProblemHandler&lt;T&gt; handler = new TestFieldProblemHandler&lt;&gt;(pb, integ);</span>
<span class="fc" id="L307">        integ.addStepHandler(handler);</span>
<span class="fc" id="L308">        integ.integrate(new FieldExpandableODE&lt;&gt;(pb), pb.getInitialState(), pb.getFinalTime());</span>

<span class="fc" id="L310">        Assert.assertEquals(0, handler.getLastError().getReal(),         epsilonLast);</span>
<span class="fc" id="L311">        Assert.assertEquals(0, handler.getMaximalValueError().getReal(), epsilonMaxValue);</span>
<span class="fc" id="L312">        Assert.assertEquals(0, handler.getMaximalTimeError().getReal(),  epsilonMaxTime);</span>
<span class="fc" id="L313">        Assert.assertEquals(name, integ.getName());</span>

<span class="fc" id="L315">    }</span>

    @Test
    public abstract void testBigStep();

    protected &lt;T extends RealFieldElement&lt;T&gt;&gt; void doTestBigStep(Field&lt;T&gt; field,
                                                                 final double belowLast,
                                                                 final double belowMaxValue,
                                                                 final double epsilonMaxTime,
                                                                 final String name)
        throws DimensionMismatchException, NumberIsTooSmallException,
               MaxCountExceededException, NoBracketingException {

<span class="fc" id="L328">        TestFieldProblem1&lt;T&gt; pb = new TestFieldProblem1&lt;&gt;(field);</span>
<span class="fc" id="L329">        T step = pb.getFinalTime().subtract(pb.getInitialState().getTime()).multiply(0.2);</span>

<span class="fc" id="L331">        RungeKuttaFieldIntegrator&lt;T&gt; integ = createIntegrator(field, step);</span>
<span class="fc" id="L332">        TestFieldProblemHandler&lt;T&gt; handler = new TestFieldProblemHandler&lt;&gt;(pb, integ);</span>
<span class="fc" id="L333">        integ.addStepHandler(handler);</span>
<span class="fc" id="L334">        integ.integrate(new FieldExpandableODE&lt;&gt;(pb), pb.getInitialState(), pb.getFinalTime());</span>

<span class="pc bpc" id="L336" title="1 of 2 branches missed.">        Assert.assertTrue(handler.getLastError().getReal()         &gt; belowLast);</span>
<span class="pc bpc" id="L337" title="1 of 2 branches missed.">        Assert.assertTrue(handler.getMaximalValueError().getReal() &gt; belowMaxValue);</span>
<span class="fc" id="L338">        Assert.assertEquals(0, handler.getMaximalTimeError().getReal(),  epsilonMaxTime);</span>
<span class="fc" id="L339">        Assert.assertEquals(name, integ.getName());</span>

<span class="fc" id="L341">    }</span>

    @Test
    public abstract void testBackward();

    protected &lt;T extends RealFieldElement&lt;T&gt;&gt; void doTestBackward(Field&lt;T&gt; field,
                                                                  final double epsilonLast,
                                                                  final double epsilonMaxValue,
                                                                  final double epsilonMaxTime,
                                                                  final String name)
        throws DimensionMismatchException, NumberIsTooSmallException,
               MaxCountExceededException, NoBracketingException {

<span class="fc" id="L354">        TestFieldProblem5&lt;T&gt; pb = new TestFieldProblem5&lt;&gt;(field);</span>
<span class="fc" id="L355">        T step = pb.getFinalTime().subtract(pb.getInitialState().getTime()).multiply(0.001).abs();</span>

<span class="fc" id="L357">        RungeKuttaFieldIntegrator&lt;T&gt; integ = createIntegrator(field, step);</span>
<span class="fc" id="L358">        TestFieldProblemHandler&lt;T&gt; handler = new TestFieldProblemHandler&lt;&gt;(pb, integ);</span>
<span class="fc" id="L359">        integ.addStepHandler(handler);</span>
<span class="fc" id="L360">        integ.integrate(new FieldExpandableODE&lt;&gt;(pb), pb.getInitialState(), pb.getFinalTime());</span>

<span class="fc" id="L362">        Assert.assertEquals(0, handler.getLastError().getReal(),         epsilonLast);</span>
<span class="fc" id="L363">        Assert.assertEquals(0, handler.getMaximalValueError().getReal(), epsilonMaxValue);</span>
<span class="fc" id="L364">        Assert.assertEquals(0, handler.getMaximalTimeError().getReal(),  epsilonMaxTime);</span>
<span class="fc" id="L365">        Assert.assertEquals(name, integ.getName());</span>

<span class="fc" id="L367">    }</span>

    @Test
    public abstract void testKepler();

    protected &lt;T extends RealFieldElement&lt;T&gt;&gt; void doTestKepler(Field&lt;T&gt; field, double expectedMaxError, double epsilon)
        throws DimensionMismatchException, NumberIsTooSmallException,
               MaxCountExceededException, NoBracketingException {

<span class="fc" id="L376">        final TestFieldProblem3&lt;T&gt; pb  = new TestFieldProblem3&lt;&gt;(field, field.getZero().add(0.9));</span>
<span class="fc" id="L377">        T step = pb.getFinalTime().subtract(pb.getInitialState().getTime()).multiply(0.0003);</span>

<span class="fc" id="L379">        RungeKuttaFieldIntegrator&lt;T&gt; integ = createIntegrator(field, step);</span>
<span class="fc" id="L380">        integ.addStepHandler(new KeplerHandler&lt;&gt;(pb, expectedMaxError, epsilon));</span>
<span class="fc" id="L381">        integ.integrate(new FieldExpandableODE&lt;&gt;(pb), pb.getInitialState(), pb.getFinalTime());</span>
<span class="fc" id="L382">    }</span>

    private static class KeplerHandler&lt;T extends RealFieldElement&lt;T&gt;&gt; implements FieldStepHandler&lt;T&gt; {
        private T maxError;
        private final TestFieldProblem3&lt;T&gt; pb;
        private final double expectedMaxError;
        private final double epsilon;
<span class="fc" id="L389">        public KeplerHandler(TestFieldProblem3&lt;T&gt; pb, double expectedMaxError, double epsilon) {</span>
<span class="fc" id="L390">            this.pb               = pb;</span>
<span class="fc" id="L391">            this.expectedMaxError = expectedMaxError;</span>
<span class="fc" id="L392">            this.epsilon          = epsilon;</span>
<span class="fc" id="L393">            maxError = pb.getField().getZero();</span>
<span class="fc" id="L394">        }</span>
        @Override
        public void init(FieldODEStateAndDerivative&lt;T&gt; state0, T t) {
<span class="fc" id="L397">            maxError = pb.getField().getZero();</span>
<span class="fc" id="L398">        }</span>
        @Override
        public void handleStep(FieldStepInterpolator&lt;T&gt; interpolator, boolean isLast)
                        throws MaxCountExceededException {

<span class="fc" id="L403">            FieldODEStateAndDerivative&lt;T&gt; current = interpolator.getCurrentState();</span>
<span class="fc" id="L404">            T[] theoreticalY  = pb.computeTheoreticalState(current.getTime());</span>
<span class="fc" id="L405">            T dx = current.getState()[0].subtract(theoreticalY[0]);</span>
<span class="fc" id="L406">            T dy = current.getState()[1].subtract(theoreticalY[1]);</span>
<span class="fc" id="L407">            T error = dx.multiply(dx).add(dy.multiply(dy));</span>
<span class="fc bfc" id="L408" title="All 2 branches covered.">            if (error.subtract(maxError).getReal() &gt; 0) {</span>
<span class="fc" id="L409">                maxError = error;</span>
            }
<span class="fc bfc" id="L411" title="All 2 branches covered.">            if (isLast) {</span>
<span class="fc" id="L412">                Assert.assertEquals(expectedMaxError, maxError.getReal(), epsilon);</span>
            }
<span class="fc" id="L414">        }</span>
    }

    @Test
    public abstract void testStepSize();

    protected &lt;T extends RealFieldElement&lt;T&gt;&gt; void doTestStepSize(final Field&lt;T&gt; field, final double epsilon)
        throws DimensionMismatchException, NumberIsTooSmallException,
               MaxCountExceededException, NoBracketingException {
<span class="fc" id="L423">        final T step = field.getZero().add(1.23456);</span>
<span class="fc" id="L424">        RungeKuttaFieldIntegrator&lt;T&gt; integ = createIntegrator(field, step);</span>
<span class="fc" id="L425">        integ.addStepHandler(new FieldStepHandler&lt;T&gt;() {</span>
            @Override
            public void handleStep(FieldStepInterpolator&lt;T&gt; interpolator, boolean isLast) {
<span class="fc bfc" id="L428" title="All 2 branches covered.">                if (! isLast) {</span>
<span class="fc" id="L429">                    Assert.assertEquals(step.getReal(),</span>
<span class="fc" id="L430">                                        interpolator.getCurrentState().getTime().subtract(interpolator.getPreviousState().getTime()).getReal(),</span>
                                        epsilon);
                }
<span class="fc" id="L433">            }</span>
            @Override
            public void init(FieldODEStateAndDerivative&lt;T&gt; s0, T t) {
<span class="fc" id="L436">            }</span>
        });
<span class="fc" id="L438">        integ.integrate(new FieldExpandableODE&lt;&gt;(new FirstOrderFieldDifferentialEquations&lt;T&gt;() {</span>
            @Override
            public void init(T t0, T[] y0, T t) {
<span class="fc" id="L441">            }</span>
            @Override
            public T[] computeDerivatives(T t, T[] y) {
<span class="fc" id="L444">                T[] dot = MathArrays.buildArray(t.getField(), 1);</span>
<span class="fc" id="L445">                dot[0] = t.getField().getOne();</span>
<span class="fc" id="L446">                return dot;</span>
            }
            @Override
            public int getDimension() {
<span class="fc" id="L450">                return 1;</span>
            }
<span class="fc" id="L452">        }), new FieldODEState&lt;&gt;(field.getZero(), MathArrays.buildArray(field, 1)), field.getZero().add(5.0));</span>
<span class="fc" id="L453">    }</span>

    @Test
    public abstract void testSingleStep();

    protected &lt;T extends RealFieldElement&lt;T&gt;&gt; void doTestSingleStep(final Field&lt;T&gt; field, final double epsilon) {

<span class="fc" id="L460">        final TestFieldProblem3&lt;T&gt; pb  = new TestFieldProblem3&lt;&gt;(field, field.getZero().add(0.9));</span>
<span class="fc" id="L461">        T h = pb.getFinalTime().subtract(pb.getInitialState().getTime()).multiply(0.0003);</span>

<span class="fc" id="L463">        RungeKuttaFieldIntegrator&lt;T&gt; integ = createIntegrator(field, field.getZero().add(Double.NaN));</span>
<span class="fc" id="L464">        T   t = pb.getInitialState().getTime();</span>
<span class="fc" id="L465">        T[] y = pb.getInitialState().getState();</span>
<span class="fc bfc" id="L466" title="All 2 branches covered.">        for (int i = 0; i &lt; 100; ++i) {</span>
<span class="fc" id="L467">            y = integ.singleStep(pb, t, y, t.add(h));</span>
<span class="fc" id="L468">            t = t.add(h);</span>
        }
<span class="fc" id="L470">        T[] yth = pb.computeTheoreticalState(t);</span>
<span class="fc" id="L471">        T dx = y[0].subtract(yth[0]);</span>
<span class="fc" id="L472">        T dy = y[1].subtract(yth[1]);</span>
<span class="fc" id="L473">        T error = dx.multiply(dx).add(dy.multiply(dy));</span>
<span class="fc" id="L474">        Assert.assertEquals(0.0, error.getReal(), epsilon);</span>
<span class="fc" id="L475">    }</span>

    @Test
    public abstract void testTooLargeFirstStep();

    protected &lt;T extends RealFieldElement&lt;T&gt;&gt; void doTestTooLargeFirstStep(final Field&lt;T&gt; field) {

<span class="fc" id="L482">        RungeKuttaFieldIntegrator&lt;T&gt; integ = createIntegrator(field, field.getZero().add(0.5));</span>
<span class="fc" id="L483">        final T t0 = field.getZero();</span>
<span class="fc" id="L484">        final T[] y0 = MathArrays.buildArray(field, 1);</span>
<span class="fc" id="L485">        y0[0] = field.getOne();</span>
<span class="fc" id="L486">        final T t   = field.getZero().add(0.001);</span>
<span class="fc" id="L487">        FirstOrderFieldDifferentialEquations&lt;T&gt; equations = new FirstOrderFieldDifferentialEquations&lt;T&gt;() {</span>

            @Override
            public int getDimension() {
<span class="fc" id="L491">                return 1;</span>
            }

            @Override
            public void init(T t0, T[] y0, T t) {
<span class="fc" id="L496">            }</span>

            @Override
            public T[] computeDerivatives(T t, T[] y) {
<span class="pc bpc" id="L500" title="1 of 2 branches missed.">                Assert.assertTrue(t.getReal() &gt;= FastMath.nextAfter(t0.getReal(), Double.NEGATIVE_INFINITY));</span>
<span class="pc bpc" id="L501" title="1 of 2 branches missed.">                Assert.assertTrue(t.getReal() &lt;= FastMath.nextAfter(t.getReal(),   Double.POSITIVE_INFINITY));</span>
<span class="fc" id="L502">                T[] yDot = MathArrays.buildArray(field, 1);</span>
<span class="fc" id="L503">                yDot[0] = y[0].multiply(-100.0);</span>
<span class="fc" id="L504">                return yDot;</span>
            }

        };

<span class="fc" id="L509">        integ.integrate(new FieldExpandableODE&lt;&gt;(equations), new FieldODEState&lt;&gt;(t0, y0), t);</span>

<span class="fc" id="L511">    }</span>

    @Test
    public abstract void testUnstableDerivative();

    protected &lt;T extends RealFieldElement&lt;T&gt;&gt; void doTestUnstableDerivative(Field&lt;T&gt; field, double epsilon) {
<span class="fc" id="L517">      final StepFieldProblem&lt;T&gt; stepProblem = new StepFieldProblem&lt;&gt;(field,</span>
<span class="fc" id="L518">                                                                      field.getZero().add(0.0),</span>
<span class="fc" id="L519">                                                                      field.getZero().add(1.0),</span>
<span class="fc" id="L520">                                                                      field.getZero().add(2.0));</span>
<span class="fc" id="L521">      RungeKuttaFieldIntegrator&lt;T&gt; integ = createIntegrator(field, field.getZero().add(0.3));</span>
<span class="fc" id="L522">      integ.addEventHandler(stepProblem, 1.0, 1.0e-12, 1000);</span>
<span class="fc" id="L523">      FieldODEStateAndDerivative&lt;T&gt; result = integ.integrate(new FieldExpandableODE&lt;&gt;(stepProblem),</span>
<span class="fc" id="L524">                                                             new FieldODEState&lt;&gt;(field.getZero(), MathArrays.buildArray(field, 1)),</span>
<span class="fc" id="L525">                                                             field.getZero().add(10.0));</span>
<span class="fc" id="L526">      Assert.assertEquals(8.0, result.getState()[0].getReal(), epsilon);</span>
<span class="fc" id="L527">    }</span>

    @Test
    public abstract void testDerivativesConsistency();

    protected &lt;T extends RealFieldElement&lt;T&gt;&gt; void doTestDerivativesConsistency(final Field&lt;T&gt; field, double epsilon) {
<span class="fc" id="L533">        TestFieldProblem3&lt;T&gt; pb = new TestFieldProblem3&lt;&gt;(field);</span>
<span class="fc" id="L534">        T step = pb.getFinalTime().subtract(pb.getInitialState().getTime()).multiply(0.001);</span>
<span class="fc" id="L535">        RungeKuttaFieldIntegrator&lt;T&gt; integ = createIntegrator(field, step);</span>
<span class="fc" id="L536">        StepInterpolatorTestUtils.checkDerivativesConsistency(integ, pb, 1.0e-10);</span>
<span class="fc" id="L537">    }</span>

    @Test
    public abstract void testPartialDerivatives();

    protected void doTestPartialDerivatives(final double epsilonY,
                                            final double[] epsilonPartials) {

        // parameters indices
<span class="fc" id="L546">        final int parameters = 5;</span>
<span class="fc" id="L547">        final int order      = 1;</span>
<span class="fc" id="L548">        final int parOmega   = 0;</span>
<span class="fc" id="L549">        final int parTO      = 1;</span>
<span class="fc" id="L550">        final int parY00     = 2;</span>
<span class="fc" id="L551">        final int parY01     = 3;</span>
<span class="fc" id="L552">        final int parT       = 4;</span>

<span class="fc" id="L554">        DerivativeStructure omega = new DerivativeStructure(parameters, order, parOmega, 1.3);</span>
<span class="fc" id="L555">        DerivativeStructure t0    = new DerivativeStructure(parameters, order, parTO, 1.3);</span>
<span class="fc" id="L556">        DerivativeStructure[] y0  = new DerivativeStructure[] {</span>
            new DerivativeStructure(parameters, order, parY00, 3.0),
            new DerivativeStructure(parameters, order, parY01, 4.0)
        };
<span class="fc" id="L560">        DerivativeStructure t     = new DerivativeStructure(parameters, order, parT, 6.0);</span>
<span class="fc" id="L561">        SinCos sinCos = new SinCos(omega);</span>

<span class="fc" id="L563">        RungeKuttaFieldIntegrator&lt;DerivativeStructure&gt; integrator =</span>
<span class="fc" id="L564">                        createIntegrator(omega.getField(), t.subtract(t0).multiply(0.001));</span>
<span class="fc" id="L565">        FieldODEStateAndDerivative&lt;DerivativeStructure&gt; result =</span>
<span class="fc" id="L566">                        integrator.integrate(new FieldExpandableODE&lt;&gt;(sinCos),</span>
                                             new FieldODEState&lt;&gt;(t0, y0),
                                             t);

        // check values
<span class="fc bfc" id="L571" title="All 2 branches covered.">        for (int i = 0; i &lt; sinCos.getDimension(); ++i) {</span>
<span class="fc" id="L572">            Assert.assertEquals(sinCos.theoreticalY(t.getReal())[i], result.getState()[i].getValue(), epsilonY);</span>
        }

        // check derivatives
<span class="fc" id="L576">        final double[][] derivatives = sinCos.getDerivatives(t.getReal());</span>
<span class="fc bfc" id="L577" title="All 2 branches covered.">        for (int i = 0; i &lt; sinCos.getDimension(); ++i) {</span>
<span class="fc bfc" id="L578" title="All 2 branches covered.">            for (int parameter = 0; parameter &lt; parameters; ++parameter) {</span>
<span class="fc" id="L579">                Assert.assertEquals(derivatives[i][parameter],</span>
<span class="fc" id="L580">                                    dYdP(result.getState()[i], parameter),</span>
                                    epsilonPartials[parameter]);
            }
        }

<span class="fc" id="L585">    }</span>

    private double dYdP(final DerivativeStructure y, final int parameter) {
<span class="fc" id="L588">        int[] orders = new int[y.getFreeParameters()];</span>
<span class="fc" id="L589">        orders[parameter] = 1;</span>
<span class="fc" id="L590">        return y.getPartialDerivative(orders);</span>
    }

    private static class SinCos implements FirstOrderFieldDifferentialEquations&lt;DerivativeStructure&gt; {

        private final DerivativeStructure omega;
        private       DerivativeStructure r;
        private       DerivativeStructure alpha;

        private double dRdY00;
        private double dRdY01;
        private double dAlphadOmega;
        private double dAlphadT0;
        private double dAlphadY00;
        private double dAlphadY01;

<span class="fc" id="L606">        protected SinCos(final DerivativeStructure omega) {</span>
<span class="fc" id="L607">            this.omega = omega;</span>
<span class="fc" id="L608">        }</span>

        @Override
        public int getDimension() {
<span class="fc" id="L612">            return 2;</span>
        }

        @Override
        public void init(final DerivativeStructure t0, final DerivativeStructure[] y0,
                         final DerivativeStructure finalTime) {

            // theoretical solution is y(t) = { r * sin(omega * t + alpha), r * cos(omega * t + alpha) }
            // so we retrieve alpha by identification from the initial state
<span class="fc" id="L621">            final DerivativeStructure r2 = y0[0].multiply(y0[0]).add(y0[1].multiply(y0[1]));</span>

<span class="fc" id="L623">            this.r            = r2.sqrt();</span>
<span class="fc" id="L624">            this.dRdY00       = y0[0].divide(r).getReal();</span>
<span class="fc" id="L625">            this.dRdY01       = y0[1].divide(r).getReal();</span>

<span class="fc" id="L627">            this.alpha        = y0[0].atan2(y0[1]).subtract(t0.multiply(omega));</span>
<span class="fc" id="L628">            this.dAlphadOmega = -t0.getReal();</span>
<span class="fc" id="L629">            this.dAlphadT0    = -omega.getReal();</span>
<span class="fc" id="L630">            this.dAlphadY00   = y0[1].divide(r2).getReal();</span>
<span class="fc" id="L631">            this.dAlphadY01   = y0[0].negate().divide(r2).getReal();</span>

<span class="fc" id="L633">        }</span>

        @Override
        public DerivativeStructure[] computeDerivatives(final DerivativeStructure t, final DerivativeStructure[] y) {
<span class="fc" id="L637">            return new DerivativeStructure[] {</span>
<span class="fc" id="L638">                omega.multiply(y[1]),</span>
<span class="fc" id="L639">                omega.multiply(y[0]).negate()</span>
            };
        }

        public double[] theoreticalY(final double t) {
<span class="fc" id="L644">            final double theta = omega.getReal() * t + alpha.getReal();</span>
<span class="fc" id="L645">            return new double[] {</span>
<span class="fc" id="L646">                r.getReal() * FastMath.sin(theta), r.getReal() * FastMath.cos(theta)</span>
            };
        }

        public double[][] getDerivatives(final double t) {

            // intermediate angle and state
<span class="fc" id="L653">            final double theta        = omega.getReal() * t + alpha.getReal();</span>
<span class="fc" id="L654">            final double sin          = FastMath.sin(theta);</span>
<span class="fc" id="L655">            final double cos          = FastMath.cos(theta);</span>
<span class="fc" id="L656">            final double y0           = r.getReal() * sin;</span>
<span class="fc" id="L657">            final double y1           = r.getReal() * cos;</span>

            // partial derivatives of the state first component
<span class="fc" id="L660">            final double dY0dOmega    =                y1 * (t + dAlphadOmega);</span>
<span class="fc" id="L661">            final double dY0dT0       =                y1 * dAlphadT0;</span>
<span class="fc" id="L662">            final double dY0dY00      = dRdY00 * sin + y1 * dAlphadY00;</span>
<span class="fc" id="L663">            final double dY0dY01      = dRdY01 * sin + y1 * dAlphadY01;</span>
<span class="fc" id="L664">            final double dY0dT        =                y1 * omega.getReal();</span>

            // partial derivatives of the state second component
<span class="fc" id="L667">            final double dY1dOmega    =              - y0 * (t + dAlphadOmega);</span>
<span class="fc" id="L668">            final double dY1dT0       =              - y0 * dAlphadT0;</span>
<span class="fc" id="L669">            final double dY1dY00      = dRdY00 * cos - y0 * dAlphadY00;</span>
<span class="fc" id="L670">            final double dY1dY01      = dRdY01 * cos - y0 * dAlphadY01;</span>
<span class="fc" id="L671">            final double dY1dT        =              - y0 * omega.getReal();</span>

<span class="fc" id="L673">            return new double[][] {</span>
                { dY0dOmega, dY0dT0, dY0dY00, dY0dY01, dY0dT },
                { dY1dOmega, dY1dT0, dY1dY00, dY1dY01, dY1dT }
            };

        }

    }

}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.1.201803210924</span></div></body></html>