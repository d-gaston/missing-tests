<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>AbstractEmbeddedRungeKuttaFieldIntegratorTest.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">commons_math4$All_in_commons_math4.exec</a> &gt; <a href="index.source.html" class="el_package">org.apache.commons.math4.ode.nonstiff</a> &gt; <span class="el_source">AbstractEmbeddedRungeKuttaFieldIntegratorTest.java</span></div><h1>AbstractEmbeddedRungeKuttaFieldIntegratorTest.java</h1><pre class="source lang-java linenums">/*
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the &quot;License&quot;); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package org.apache.commons.math4.ode.nonstiff;


import org.apache.commons.math4.Field;
import org.apache.commons.math4.RealFieldElement;
import org.apache.commons.math4.analysis.differentiation.DerivativeStructure;
import org.apache.commons.math4.exception.DimensionMismatchException;
import org.apache.commons.math4.exception.MaxCountExceededException;
import org.apache.commons.math4.exception.NoBracketingException;
import org.apache.commons.math4.exception.NumberIsTooSmallException;
import org.apache.commons.math4.ode.FieldExpandableODE;
import org.apache.commons.math4.ode.FirstOrderFieldDifferentialEquations;
import org.apache.commons.math4.ode.FirstOrderFieldIntegrator;
import org.apache.commons.math4.ode.FieldODEState;
import org.apache.commons.math4.ode.FieldODEStateAndDerivative;
import org.apache.commons.math4.ode.TestFieldProblem1;
import org.apache.commons.math4.ode.TestFieldProblem3;
import org.apache.commons.math4.ode.TestFieldProblem4;
import org.apache.commons.math4.ode.TestFieldProblem5;
import org.apache.commons.math4.ode.TestFieldProblemHandler;
import org.apache.commons.math4.ode.events.Action;
import org.apache.commons.math4.ode.events.FieldEventHandler;
import org.apache.commons.math4.ode.sampling.FieldStepHandler;
import org.apache.commons.math4.ode.sampling.FieldStepInterpolator;
import org.apache.commons.math4.util.FastMath;
import org.apache.commons.math4.util.MathArrays;
import org.junit.Assert;
import org.junit.Test;

<span class="nc" id="L47">public abstract class AbstractEmbeddedRungeKuttaFieldIntegratorTest {</span>

    protected abstract &lt;T extends RealFieldElement&lt;T&gt;&gt; EmbeddedRungeKuttaFieldIntegrator&lt;T&gt;
    createIntegrator(Field&lt;T&gt; field, final double minStep, final double maxStep,
                     final double scalAbsoluteTolerance, final double scalRelativeTolerance);

    protected abstract &lt;T extends RealFieldElement&lt;T&gt;&gt; EmbeddedRungeKuttaFieldIntegrator&lt;T&gt;
    createIntegrator(Field&lt;T&gt; field, final double minStep, final double maxStep,
                     final double[] vecAbsoluteTolerance, final double[] vecRelativeTolerance);

    @Test
    public abstract void testNonFieldIntegratorConsistency();

    protected &lt;T extends RealFieldElement&lt;T&gt;&gt; void doTestNonFieldIntegratorConsistency(final Field&lt;T&gt; field) {
        try {

            // get the Butcher arrays from the field integrator
<span class="nc" id="L64">            EmbeddedRungeKuttaFieldIntegrator&lt;T&gt; fieldIntegrator = createIntegrator(field, 0.001, 1.0, 1.0, 1.0);</span>
<span class="nc" id="L65">            T[][] fieldA = fieldIntegrator.getA();</span>
<span class="nc" id="L66">            T[]   fieldB = fieldIntegrator.getB();</span>
<span class="nc" id="L67">            T[]   fieldC = fieldIntegrator.getC();</span>
<span class="nc bnc" id="L68" title="All 2 branches missed.">            if (fieldIntegrator instanceof DormandPrince853FieldIntegrator) {</span>
                // special case for Dormand-Prince 8(5,3), the array in the regular
                // integrator is smaller because as of 3.X, the interpolation steps
                // are not performed by the integrator itself
<span class="nc" id="L72">                T[][] reducedFieldA = MathArrays.buildArray(field, 12, -1);</span>
<span class="nc" id="L73">                T[]   reducedFieldB = MathArrays.buildArray(field, 13);</span>
<span class="nc" id="L74">                T[]   reducedFieldC = MathArrays.buildArray(field, 12);</span>
<span class="nc" id="L75">                System.arraycopy(fieldA, 0, reducedFieldA, 0, reducedFieldA.length);</span>
<span class="nc" id="L76">                System.arraycopy(fieldB, 0, reducedFieldB, 0, reducedFieldB.length);</span>
<span class="nc" id="L77">                System.arraycopy(fieldC, 0, reducedFieldC, 0, reducedFieldC.length);</span>
<span class="nc" id="L78">                fieldA = reducedFieldA;</span>
<span class="nc" id="L79">                fieldB = reducedFieldB;</span>
<span class="nc" id="L80">                fieldC = reducedFieldC;</span>
            }

<span class="nc" id="L83">            String fieldName   = fieldIntegrator.getClass().getName();</span>
<span class="nc" id="L84">            String regularName = fieldName.replaceAll(&quot;Field&quot;, &quot;&quot;);</span>

            // get the Butcher arrays from the regular integrator
            @SuppressWarnings(&quot;unchecked&quot;)
<span class="nc" id="L88">            Class&lt;RungeKuttaIntegrator&gt; c = (Class&lt;RungeKuttaIntegrator&gt;) Class.forName(regularName);</span>
<span class="nc" id="L89">            java.lang.reflect.Field jlrFieldA = c.getDeclaredField(&quot;STATIC_A&quot;);</span>
<span class="nc" id="L90">            jlrFieldA.setAccessible(true);</span>
<span class="nc" id="L91">            double[][] regularA = (double[][]) jlrFieldA.get(null);</span>
<span class="nc" id="L92">            java.lang.reflect.Field jlrFieldB = c.getDeclaredField(&quot;STATIC_B&quot;);</span>
<span class="nc" id="L93">            jlrFieldB.setAccessible(true);</span>
<span class="nc" id="L94">            double[]   regularB = (double[])   jlrFieldB.get(null);</span>
<span class="nc" id="L95">            java.lang.reflect.Field jlrFieldC = c.getDeclaredField(&quot;STATIC_C&quot;);</span>
<span class="nc" id="L96">            jlrFieldC.setAccessible(true);</span>
<span class="nc" id="L97">            double[]   regularC = (double[])   jlrFieldC.get(null);</span>

<span class="nc" id="L99">            Assert.assertEquals(regularA.length, fieldA.length);</span>
<span class="nc bnc" id="L100" title="All 2 branches missed.">            for (int i = 0; i &lt; regularA.length; ++i) {</span>
<span class="nc" id="L101">                checkArray(regularA[i], fieldA[i]);</span>
            }
<span class="nc" id="L103">            checkArray(regularB, fieldB);</span>
<span class="nc" id="L104">            checkArray(regularC, fieldC);</span>

<span class="nc" id="L106">        } catch (ClassNotFoundException cnfe) {</span>
<span class="nc" id="L107">            Assert.fail(cnfe.getLocalizedMessage());</span>
<span class="nc" id="L108">        } catch (IllegalAccessException iae) {</span>
<span class="nc" id="L109">            Assert.fail(iae.getLocalizedMessage());</span>
<span class="nc" id="L110">        } catch (IllegalArgumentException iae) {</span>
<span class="nc" id="L111">            Assert.fail(iae.getLocalizedMessage());</span>
<span class="nc" id="L112">        } catch (SecurityException se) {</span>
<span class="nc" id="L113">            Assert.fail(se.getLocalizedMessage());</span>
<span class="nc" id="L114">        } catch (NoSuchFieldException nsfe) {</span>
<span class="nc" id="L115">            Assert.fail(nsfe.getLocalizedMessage());</span>
<span class="nc" id="L116">        }</span>
<span class="nc" id="L117">    }</span>

    private &lt;T extends RealFieldElement&lt;T&gt;&gt; void checkArray(double[] regularArray, T[] fieldArray) {
<span class="nc" id="L120">        Assert.assertEquals(regularArray.length, fieldArray.length);</span>
<span class="nc bnc" id="L121" title="All 2 branches missed.">        for (int i = 0; i &lt; regularArray.length; ++i) {</span>
<span class="nc bnc" id="L122" title="All 2 branches missed.">            if (regularArray[i] == 0) {</span>
<span class="nc bnc" id="L123" title="All 2 branches missed.">                Assert.assertTrue(0.0 == fieldArray[i].getReal());</span>
            } else {
<span class="nc" id="L125">                Assert.assertEquals(regularArray[i], fieldArray[i].getReal(), FastMath.ulp(regularArray[i]));</span>
            }
        }
<span class="nc" id="L128">    }</span>

    @Test
    public abstract void testForwardBackwardExceptions();

    protected &lt;T extends RealFieldElement&lt;T&gt;&gt; void doTestForwardBackwardExceptions(final Field&lt;T&gt; field) {
<span class="nc" id="L134">        FirstOrderFieldDifferentialEquations&lt;T&gt; equations = new FirstOrderFieldDifferentialEquations&lt;T&gt;() {</span>

            @Override
            public int getDimension() {
<span class="nc" id="L138">                return 1;</span>
            }

            @Override
            public void init(T t0, T[] y0, T t) {
<span class="nc" id="L143">            }</span>

            @Override
            public T[] computeDerivatives(T t, T[] y) {
<span class="nc bnc" id="L147" title="All 2 branches missed.">                if (t.getReal() &lt; -0.5) {</span>
<span class="nc" id="L148">                    throw new LocalException();</span>
                } else {
<span class="nc" id="L150">                    throw new RuntimeException(&quot;oops&quot;);</span>
                }
            }
        };

<span class="nc" id="L155">        EmbeddedRungeKuttaFieldIntegrator&lt;T&gt; integrator = createIntegrator(field, 0.0, 1.0, 1.0e-10, 1.0e-10);</span>

        try  {
<span class="nc" id="L158">            integrator.integrate(new FieldExpandableODE&lt;&gt;(equations),</span>
<span class="nc" id="L159">                                 new FieldODEState&lt;&gt;(field.getOne().negate(),</span>
<span class="nc" id="L160">                                                      MathArrays.buildArray(field, 1)),</span>
<span class="nc" id="L161">                                 field.getZero());</span>
<span class="nc" id="L162">            Assert.fail(&quot;an exception should have been thrown&quot;);</span>
<span class="nc" id="L163">          } catch(LocalException de) {</span>
            // expected behavior
<span class="nc" id="L165">          }</span>

          try  {
<span class="nc" id="L168">              integrator.integrate(new FieldExpandableODE&lt;&gt;(equations),</span>
<span class="nc" id="L169">                                   new FieldODEState&lt;&gt;(field.getZero(),</span>
<span class="nc" id="L170">                                                        MathArrays.buildArray(field, 1)),</span>
<span class="nc" id="L171">                                   field.getOne());</span>
<span class="nc" id="L172">               Assert.fail(&quot;an exception should have been thrown&quot;);</span>
<span class="nc" id="L173">          } catch(RuntimeException de) {</span>
            // expected behavior
<span class="nc" id="L175">          }</span>
<span class="nc" id="L176">    }</span>

<span class="nc" id="L178">    protected static class LocalException extends RuntimeException {</span>
        private static final long serialVersionUID = 20151208L;
    }

    @Test(expected=NumberIsTooSmallException.class)
    public abstract void testMinStep();

    protected &lt;T extends RealFieldElement&lt;T&gt;&gt; void doTestMinStep(final Field&lt;T&gt; field)
        throws NumberIsTooSmallException {

<span class="nc" id="L188">        TestFieldProblem1&lt;T&gt; pb = new TestFieldProblem1&lt;&gt;(field);</span>
<span class="nc" id="L189">        double minStep = pb.getFinalTime().subtract(pb.getInitialState().getTime()).multiply(0.1).getReal();</span>
<span class="nc" id="L190">        double maxStep = pb.getFinalTime().subtract(pb.getInitialState().getTime()).getReal();</span>
<span class="nc" id="L191">        double[] vecAbsoluteTolerance = { 1.0e-15, 1.0e-16 };</span>
<span class="nc" id="L192">        double[] vecRelativeTolerance = { 1.0e-15, 1.0e-16 };</span>

<span class="nc" id="L194">        FirstOrderFieldIntegrator&lt;T&gt; integ = createIntegrator(field, minStep, maxStep,</span>
                                                              vecAbsoluteTolerance, vecRelativeTolerance);
<span class="nc" id="L196">        TestFieldProblemHandler&lt;T&gt; handler = new TestFieldProblemHandler&lt;&gt;(pb, integ);</span>
<span class="nc" id="L197">        integ.addStepHandler(handler);</span>
<span class="nc" id="L198">        integ.integrate(new FieldExpandableODE&lt;&gt;(pb), pb.getInitialState(), pb.getFinalTime());</span>
<span class="nc" id="L199">        Assert.fail(&quot;an exception should have been thrown&quot;);</span>

<span class="nc" id="L201">    }</span>

    @Test
    public abstract void testIncreasingTolerance();

    protected &lt;T extends RealFieldElement&lt;T&gt;&gt; void doTestIncreasingTolerance(final Field&lt;T&gt; field,
                                                                             double factor,
                                                                             double epsilon) {

<span class="nc" id="L210">        int previousCalls = Integer.MAX_VALUE;</span>
<span class="nc bnc" id="L211" title="All 2 branches missed.">        for (int i = -12; i &lt; -2; ++i) {</span>
<span class="nc" id="L212">            TestFieldProblem1&lt;T&gt; pb = new TestFieldProblem1&lt;&gt;(field);</span>
<span class="nc" id="L213">            double minStep = 0;</span>
<span class="nc" id="L214">            double maxStep = pb.getFinalTime().subtract(pb.getInitialState().getTime()).getReal();</span>
<span class="nc" id="L215">            double scalAbsoluteTolerance = FastMath.pow(10.0, i);</span>
<span class="nc" id="L216">            double scalRelativeTolerance = 0.01 * scalAbsoluteTolerance;</span>

<span class="nc" id="L218">            FirstOrderFieldIntegrator&lt;T&gt; integ = createIntegrator(field, minStep, maxStep,</span>
                                                                  scalAbsoluteTolerance, scalRelativeTolerance);
<span class="nc" id="L220">            TestFieldProblemHandler&lt;T&gt; handler = new TestFieldProblemHandler&lt;&gt;(pb, integ);</span>
<span class="nc" id="L221">            integ.addStepHandler(handler);</span>
<span class="nc" id="L222">            integ.integrate(new FieldExpandableODE&lt;&gt;(pb), pb.getInitialState(), pb.getFinalTime());</span>

<span class="nc bnc" id="L224" title="All 2 branches missed.">            Assert.assertTrue(handler.getMaximalValueError().getReal() &lt; (factor * scalAbsoluteTolerance));</span>
<span class="nc" id="L225">            Assert.assertEquals(0, handler.getMaximalTimeError().getReal(), epsilon);</span>

<span class="nc" id="L227">            int calls = pb.getCalls();</span>
<span class="nc" id="L228">            Assert.assertEquals(integ.getEvaluations(), calls);</span>
<span class="nc bnc" id="L229" title="All 2 branches missed.">            Assert.assertTrue(calls &lt;= previousCalls);</span>
<span class="nc" id="L230">            previousCalls = calls;</span>

        }

<span class="nc" id="L234">    }</span>

    @Test
    public abstract void testEvents();

    protected &lt;T extends RealFieldElement&lt;T&gt;&gt; void doTestEvents(final Field&lt;T&gt; field,
                                                                final double epsilonMaxValue,
                                                                final String name) {

<span class="nc" id="L243">      TestFieldProblem4&lt;T&gt; pb = new TestFieldProblem4&lt;&gt;(field);</span>
<span class="nc" id="L244">      double minStep = 0;</span>
<span class="nc" id="L245">      double maxStep = pb.getFinalTime().subtract(pb.getInitialState().getTime()).getReal();</span>
<span class="nc" id="L246">      double scalAbsoluteTolerance = 1.0e-8;</span>
<span class="nc" id="L247">      double scalRelativeTolerance = 0.01 * scalAbsoluteTolerance;</span>

<span class="nc" id="L249">      FirstOrderFieldIntegrator&lt;T&gt; integ = createIntegrator(field, minStep, maxStep,</span>
                                                            scalAbsoluteTolerance, scalRelativeTolerance);
<span class="nc" id="L251">      TestFieldProblemHandler&lt;T&gt; handler = new TestFieldProblemHandler&lt;&gt;(pb, integ);</span>
<span class="nc" id="L252">      integ.addStepHandler(handler);</span>
<span class="nc" id="L253">      FieldEventHandler&lt;T&gt;[] functions = pb.getEventsHandlers();</span>
<span class="nc" id="L254">      double convergence = 1.0e-8 * maxStep;</span>
<span class="nc bnc" id="L255" title="All 2 branches missed.">      for (int l = 0; l &lt; functions.length; ++l) {</span>
<span class="nc" id="L256">          integ.addEventHandler(functions[l], Double.POSITIVE_INFINITY, convergence, 1000);</span>
      }
<span class="nc" id="L258">      Assert.assertEquals(functions.length, integ.getEventHandlers().size());</span>
<span class="nc" id="L259">      integ.integrate(new FieldExpandableODE&lt;&gt;(pb), pb.getInitialState(), pb.getFinalTime());</span>

<span class="nc" id="L261">      Assert.assertEquals(0, handler.getMaximalValueError().getReal(), epsilonMaxValue);</span>
<span class="nc" id="L262">      Assert.assertEquals(0, handler.getMaximalTimeError().getReal(), convergence);</span>
<span class="nc" id="L263">      Assert.assertEquals(12.0, handler.getLastTime().getReal(), convergence);</span>
<span class="nc" id="L264">      Assert.assertEquals(name, integ.getName());</span>
<span class="nc" id="L265">      integ.clearEventHandlers();</span>
<span class="nc" id="L266">      Assert.assertEquals(0, integ.getEventHandlers().size());</span>

<span class="nc" id="L268">    }</span>

    @Test(expected=LocalException.class)
    public abstract void testEventsErrors();

    protected &lt;T extends RealFieldElement&lt;T&gt;&gt; void doTestEventsErrors(final Field&lt;T&gt; field)
        throws LocalException {
<span class="nc" id="L275">        final TestFieldProblem1&lt;T&gt; pb = new TestFieldProblem1&lt;&gt;(field);</span>
<span class="nc" id="L276">        double minStep = 0;</span>
<span class="nc" id="L277">        double maxStep = pb.getFinalTime().subtract(pb.getInitialState().getTime()).getReal();</span>
<span class="nc" id="L278">        double scalAbsoluteTolerance = 1.0e-8;</span>
<span class="nc" id="L279">        double scalRelativeTolerance = 0.01 * scalAbsoluteTolerance;</span>

<span class="nc" id="L281">        FirstOrderFieldIntegrator&lt;T&gt; integ = createIntegrator(field, minStep, maxStep,</span>
                                                              scalAbsoluteTolerance, scalRelativeTolerance);
<span class="nc" id="L283">        TestFieldProblemHandler&lt;T&gt; handler = new TestFieldProblemHandler&lt;&gt;(pb, integ);</span>
<span class="nc" id="L284">        integ.addStepHandler(handler);</span>

<span class="nc" id="L286">        integ.addEventHandler(new FieldEventHandler&lt;T&gt;() {</span>
          @Override
        public void init(FieldODEStateAndDerivative&lt;T&gt; state0, T t) {
<span class="nc" id="L289">          }</span>
          @Override
        public Action eventOccurred(FieldODEStateAndDerivative&lt;T&gt; state, boolean increasing) {
<span class="nc" id="L292">            return Action.CONTINUE;</span>
          }
          @Override
        public T g(FieldODEStateAndDerivative&lt;T&gt; state) {
<span class="nc" id="L296">            T middle = pb.getInitialState().getTime().add(pb.getFinalTime()).multiply(0.5);</span>
<span class="nc" id="L297">            T offset = state.getTime().subtract(middle);</span>
<span class="nc bnc" id="L298" title="All 2 branches missed.">            if (offset.getReal() &gt; 0) {</span>
<span class="nc" id="L299">              throw new LocalException();</span>
            }
<span class="nc" id="L301">            return offset;</span>
          }
          @Override
        public FieldODEState&lt;T&gt; resetState(FieldODEStateAndDerivative&lt;T&gt; state) {
<span class="nc" id="L305">              return state;</span>
          }
        }, Double.POSITIVE_INFINITY, 1.0e-8 * maxStep, 1000);

<span class="nc" id="L309">        integ.integrate(new FieldExpandableODE&lt;&gt;(pb), pb.getInitialState(), pb.getFinalTime());</span>

<span class="nc" id="L311">    }</span>

    @Test
    public abstract void testEventsNoConvergence();

    protected &lt;T extends RealFieldElement&lt;T&gt;&gt; void doTestEventsNoConvergence(final Field&lt;T&gt; field){

<span class="nc" id="L318">        final TestFieldProblem1&lt;T&gt; pb = new TestFieldProblem1&lt;&gt;(field);</span>
<span class="nc" id="L319">        double minStep = 0;</span>
<span class="nc" id="L320">        double maxStep = pb.getFinalTime().subtract(pb.getInitialState().getTime()).getReal();</span>
<span class="nc" id="L321">        double scalAbsoluteTolerance = 1.0e-8;</span>
<span class="nc" id="L322">        double scalRelativeTolerance = 0.01 * scalAbsoluteTolerance;</span>

<span class="nc" id="L324">        FirstOrderFieldIntegrator&lt;T&gt; integ = createIntegrator(field, minStep, maxStep,</span>
                                                              scalAbsoluteTolerance, scalRelativeTolerance);
<span class="nc" id="L326">        TestFieldProblemHandler&lt;T&gt; handler = new TestFieldProblemHandler&lt;&gt;(pb, integ);</span>
<span class="nc" id="L327">        integ.addStepHandler(handler);</span>

<span class="nc" id="L329">        integ.addEventHandler(new FieldEventHandler&lt;T&gt;() {</span>
            @Override
            public void init(FieldODEStateAndDerivative&lt;T&gt; state0, T t) {
<span class="nc" id="L332">            }</span>
            @Override
            public Action eventOccurred(FieldODEStateAndDerivative&lt;T&gt; state, boolean increasing) {
<span class="nc" id="L335">                return Action.CONTINUE;</span>
            }
            @Override
            public T g(FieldODEStateAndDerivative&lt;T&gt; state) {
<span class="nc" id="L339">                T middle = pb.getInitialState().getTime().add(pb.getFinalTime()).multiply(0.5);</span>
<span class="nc" id="L340">                T offset = state.getTime().subtract(middle);</span>
<span class="nc bnc" id="L341" title="All 2 branches missed.">                return (offset.getReal() &gt; 0) ? offset.add(0.5) : offset.subtract(0.5);</span>
            }
            @Override
            public FieldODEState&lt;T&gt; resetState(FieldODEStateAndDerivative&lt;T&gt; state) {
<span class="nc" id="L345">                return state;</span>
            }
        }, Double.POSITIVE_INFINITY, 1.0e-8 * maxStep, 3);

        try {
<span class="nc" id="L350">            integ.integrate(new FieldExpandableODE&lt;&gt;(pb), pb.getInitialState(), pb.getFinalTime());</span>
<span class="nc" id="L351">            Assert.fail(&quot;an exception should have been thrown&quot;);</span>
<span class="nc" id="L352">        } catch (MaxCountExceededException mcee) {</span>
            // Expected.
<span class="nc" id="L354">        }</span>

<span class="nc" id="L356">    }</span>

    @Test
    public abstract void testSanityChecks();

    protected &lt;T extends RealFieldElement&lt;T&gt;&gt; void doTestSanityChecks(Field&lt;T&gt; field) {
<span class="nc" id="L362">        TestFieldProblem3&lt;T&gt; pb = new TestFieldProblem3&lt;&gt;(field);</span>
        try  {
<span class="nc" id="L364">            EmbeddedRungeKuttaFieldIntegrator&lt;T&gt; integrator = createIntegrator(field, 0,</span>
<span class="nc" id="L365">                                                                               pb.getFinalTime().subtract(pb.getInitialState().getTime()).getReal(),</span>
                                                                               new double[4], new double[4]);
<span class="nc" id="L367">            integrator.integrate(new FieldExpandableODE&lt;&gt;(pb),</span>
<span class="nc" id="L368">                                 new FieldODEState&lt;&gt;(pb.getInitialState().getTime(),</span>
<span class="nc" id="L369">                                                      MathArrays.buildArray(field, 6)),</span>
<span class="nc" id="L370">                                 pb.getFinalTime());</span>
<span class="nc" id="L371">            Assert.fail(&quot;an exception should have been thrown&quot;);</span>
<span class="nc" id="L372">        } catch(DimensionMismatchException ie) {</span>
<span class="nc" id="L373">        }</span>
        try  {
<span class="nc" id="L375">            EmbeddedRungeKuttaFieldIntegrator&lt;T&gt; integrator =</span>
<span class="nc" id="L376">                            createIntegrator(field, 0,</span>
<span class="nc" id="L377">                                             pb.getFinalTime().subtract(pb.getInitialState().getTime()).getReal(),</span>
                                             new double[2], new double[4]);
<span class="nc" id="L379">            integrator.integrate(new FieldExpandableODE&lt;&gt;(pb), pb.getInitialState(), pb.getFinalTime());</span>
<span class="nc" id="L380">            Assert.fail(&quot;an exception should have been thrown&quot;);</span>
<span class="nc" id="L381">        } catch(DimensionMismatchException ie) {</span>
<span class="nc" id="L382">        }</span>
        try  {
<span class="nc" id="L384">            EmbeddedRungeKuttaFieldIntegrator&lt;T&gt; integrator =</span>
<span class="nc" id="L385">                            createIntegrator(field, 0,</span>
<span class="nc" id="L386">                                             pb.getFinalTime().subtract(pb.getInitialState().getTime()).getReal(),</span>
                                             new double[4], new double[4]);
<span class="nc" id="L388">            integrator.integrate(new FieldExpandableODE&lt;&gt;(pb), pb.getInitialState(), pb.getInitialState().getTime());</span>
<span class="nc" id="L389">            Assert.fail(&quot;an exception should have been thrown&quot;);</span>
<span class="nc" id="L390">        } catch(NumberIsTooSmallException ie) {</span>
<span class="nc" id="L391">        }</span>
<span class="nc" id="L392">    }</span>

    @Test
    public abstract void testBackward();

    protected &lt;T extends RealFieldElement&lt;T&gt;&gt; void doTestBackward(Field&lt;T&gt; field,
                                                                  final double epsilonLast,
                                                                  final double epsilonMaxValue,
                                                                  final double epsilonMaxTime,
                                                                  final String name)
        throws DimensionMismatchException, NumberIsTooSmallException,
               MaxCountExceededException, NoBracketingException {

<span class="nc" id="L405">        TestFieldProblem5&lt;T&gt; pb = new TestFieldProblem5&lt;&gt;(field);</span>
<span class="nc" id="L406">        double minStep = 0;</span>
<span class="nc" id="L407">        double maxStep = pb.getFinalTime().subtract(pb.getInitialState().getTime()).abs().getReal();</span>
<span class="nc" id="L408">        double scalAbsoluteTolerance = 1.0e-8;</span>
<span class="nc" id="L409">        double scalRelativeTolerance = 0.01 * scalAbsoluteTolerance;</span>

<span class="nc" id="L411">        EmbeddedRungeKuttaFieldIntegrator&lt;T&gt; integ = createIntegrator(field, minStep, maxStep,</span>
                                                                      scalAbsoluteTolerance,
                                                                      scalRelativeTolerance);
<span class="nc" id="L414">        TestFieldProblemHandler&lt;T&gt; handler = new TestFieldProblemHandler&lt;&gt;(pb, integ);</span>
<span class="nc" id="L415">        integ.addStepHandler(handler);</span>
<span class="nc" id="L416">        integ.integrate(new FieldExpandableODE&lt;&gt;(pb), pb.getInitialState(), pb.getFinalTime());</span>

<span class="nc" id="L418">        Assert.assertEquals(0, handler.getLastError().getReal(),         epsilonLast);</span>
<span class="nc" id="L419">        Assert.assertEquals(0, handler.getMaximalValueError().getReal(), epsilonMaxValue);</span>
<span class="nc" id="L420">        Assert.assertEquals(0, handler.getMaximalTimeError().getReal(),  epsilonMaxTime);</span>
<span class="nc" id="L421">        Assert.assertEquals(name, integ.getName());</span>

<span class="nc" id="L423">    }</span>

    @Test
    public abstract void testKepler();

    protected &lt;T extends RealFieldElement&lt;T&gt;&gt; void doTestKepler(Field&lt;T&gt; field, double epsilon) {

<span class="nc" id="L430">        final TestFieldProblem3&lt;T&gt; pb  = new TestFieldProblem3&lt;&gt;(field, field.getZero().add(0.9));</span>
<span class="nc" id="L431">        double minStep = 0;</span>
<span class="nc" id="L432">        double maxStep = pb.getFinalTime().subtract(pb.getInitialState().getTime()).getReal();</span>
<span class="nc" id="L433">        double[] vecAbsoluteTolerance = { 1.0e-8, 1.0e-8, 1.0e-10, 1.0e-10 };</span>
<span class="nc" id="L434">        double[] vecRelativeTolerance = { 1.0e-10, 1.0e-10, 1.0e-8, 1.0e-8 };</span>

<span class="nc" id="L436">        FirstOrderFieldIntegrator&lt;T&gt; integ = createIntegrator(field, minStep, maxStep,</span>
                                                              vecAbsoluteTolerance, vecRelativeTolerance);
<span class="nc" id="L438">        integ.addStepHandler(new KeplerHandler&lt;&gt;(pb, epsilon));</span>
<span class="nc" id="L439">        integ.integrate(new FieldExpandableODE&lt;&gt;(pb), pb.getInitialState(), pb.getFinalTime());</span>
<span class="nc" id="L440">    }</span>

    private static class KeplerHandler&lt;T extends RealFieldElement&lt;T&gt;&gt; implements FieldStepHandler&lt;T&gt; {
        private T maxError;
        private final TestFieldProblem3&lt;T&gt; pb;
        private final double epsilon;
<span class="nc" id="L446">        public KeplerHandler(TestFieldProblem3&lt;T&gt; pb, double epsilon) {</span>
<span class="nc" id="L447">            this.pb      = pb;</span>
<span class="nc" id="L448">            this.epsilon = epsilon;</span>
<span class="nc" id="L449">            maxError = pb.getField().getZero();</span>
<span class="nc" id="L450">        }</span>
        @Override
        public void init(FieldODEStateAndDerivative&lt;T&gt; state0, T t) {
<span class="nc" id="L453">            maxError = pb.getField().getZero();</span>
<span class="nc" id="L454">        }</span>
        @Override
        public void handleStep(FieldStepInterpolator&lt;T&gt; interpolator, boolean isLast)
                        throws MaxCountExceededException {

<span class="nc" id="L459">            FieldODEStateAndDerivative&lt;T&gt; current = interpolator.getCurrentState();</span>
<span class="nc" id="L460">            T[] theoreticalY  = pb.computeTheoreticalState(current.getTime());</span>
<span class="nc" id="L461">            T dx = current.getState()[0].subtract(theoreticalY[0]);</span>
<span class="nc" id="L462">            T dy = current.getState()[1].subtract(theoreticalY[1]);</span>
<span class="nc" id="L463">            T error = dx.multiply(dx).add(dy.multiply(dy));</span>
<span class="nc bnc" id="L464" title="All 2 branches missed.">            if (error.subtract(maxError).getReal() &gt; 0) {</span>
<span class="nc" id="L465">                maxError = error;</span>
            }
<span class="nc bnc" id="L467" title="All 2 branches missed.">            if (isLast) {</span>
<span class="nc" id="L468">                Assert.assertEquals(0.0, maxError.getReal(), epsilon);</span>
            }
<span class="nc" id="L470">        }</span>
    }

    @Test
    public abstract void testPartialDerivatives();

    protected &lt;T extends RealFieldElement&lt;T&gt;&gt; void doTestPartialDerivatives(final double epsilonY,
                                                                            final double[] epsilonPartials) {

        // parameters indices
<span class="nc" id="L480">        final int parameters = 5;</span>
<span class="nc" id="L481">        final int order      = 1;</span>
<span class="nc" id="L482">        final int parOmega   = 0;</span>
<span class="nc" id="L483">        final int parTO      = 1;</span>
<span class="nc" id="L484">        final int parY00     = 2;</span>
<span class="nc" id="L485">        final int parY01     = 3;</span>
<span class="nc" id="L486">        final int parT       = 4;</span>

<span class="nc" id="L488">        DerivativeStructure omega = new DerivativeStructure(parameters, order, parOmega, 1.3);</span>
<span class="nc" id="L489">        DerivativeStructure t0    = new DerivativeStructure(parameters, order, parTO, 1.3);</span>
<span class="nc" id="L490">        DerivativeStructure[] y0  = new DerivativeStructure[] {</span>
            new DerivativeStructure(parameters, order, parY00, 3.0),
            new DerivativeStructure(parameters, order, parY01, 4.0)
        };
<span class="nc" id="L494">        DerivativeStructure t     = new DerivativeStructure(parameters, order, parT, 6.0);</span>
<span class="nc" id="L495">        SinCos sinCos = new SinCos(omega);</span>

<span class="nc" id="L497">        EmbeddedRungeKuttaFieldIntegrator&lt;DerivativeStructure&gt; integrator =</span>
<span class="nc" id="L498">                        createIntegrator(omega.getField(),</span>
<span class="nc" id="L499">                                         t.subtract(t0).multiply(0.001).getReal(), t.subtract(t0).getReal(),</span>
                                         1.0e-12, 1.0e-12);
<span class="nc" id="L501">        FieldODEStateAndDerivative&lt;DerivativeStructure&gt; result =</span>
<span class="nc" id="L502">                        integrator.integrate(new FieldExpandableODE&lt;&gt;(sinCos),</span>
                                             new FieldODEState&lt;&gt;(t0, y0),
                                             t);

        // check values
<span class="nc bnc" id="L507" title="All 2 branches missed.">        for (int i = 0; i &lt; sinCos.getDimension(); ++i) {</span>
<span class="nc" id="L508">            Assert.assertEquals(sinCos.theoreticalY(t.getReal())[i], result.getState()[i].getValue(), epsilonY);</span>
        }

        // check derivatives
<span class="nc" id="L512">        final double[][] derivatives = sinCos.getDerivatives(t.getReal()); </span>
<span class="nc bnc" id="L513" title="All 2 branches missed.">        for (int i = 0; i &lt; sinCos.getDimension(); ++i) {</span>
<span class="nc bnc" id="L514" title="All 2 branches missed.">            for (int parameter = 0; parameter &lt; parameters; ++parameter) {</span>
<span class="nc" id="L515">                Assert.assertEquals(derivatives[i][parameter], dYdP(result.getState()[i], parameter), epsilonPartials[parameter]);</span>
            }
        }

<span class="nc" id="L519">    }</span>

    private double dYdP(final DerivativeStructure y, final int parameter) {
<span class="nc" id="L522">        int[] orders = new int[y.getFreeParameters()];</span>
<span class="nc" id="L523">        orders[parameter] = 1;</span>
<span class="nc" id="L524">        return y.getPartialDerivative(orders);</span>
    }

    private static class SinCos implements FirstOrderFieldDifferentialEquations&lt;DerivativeStructure&gt; {

        private final DerivativeStructure omega;
        private       DerivativeStructure r;
        private       DerivativeStructure alpha;

        private double dRdY00;
        private double dRdY01;
        private double dAlphadOmega;
        private double dAlphadT0;
        private double dAlphadY00;
        private double dAlphadY01;

<span class="nc" id="L540">        protected SinCos(final DerivativeStructure omega) {</span>
<span class="nc" id="L541">            this.omega = omega;</span>
<span class="nc" id="L542">        }</span>

        @Override
        public int getDimension() {
<span class="nc" id="L546">            return 2;</span>
        }

        @Override
        public void init(final DerivativeStructure t0, final DerivativeStructure[] y0,
                         final DerivativeStructure finalTime) {

            // theoretical solution is y(t) = { r * sin(omega * t + alpha), r * cos(omega * t + alpha) }
            // so we retrieve alpha by identification from the initial state
<span class="nc" id="L555">            final DerivativeStructure r2 = y0[0].multiply(y0[0]).add(y0[1].multiply(y0[1]));</span>

<span class="nc" id="L557">            this.r            = r2.sqrt();</span>
<span class="nc" id="L558">            this.dRdY00       = y0[0].divide(r).getReal();</span>
<span class="nc" id="L559">            this.dRdY01       = y0[1].divide(r).getReal();</span>

<span class="nc" id="L561">            this.alpha        = y0[0].atan2(y0[1]).subtract(t0.multiply(omega));</span>
<span class="nc" id="L562">            this.dAlphadOmega = -t0.getReal();</span>
<span class="nc" id="L563">            this.dAlphadT0    = -omega.getReal();</span>
<span class="nc" id="L564">            this.dAlphadY00   = y0[1].divide(r2).getReal();</span>
<span class="nc" id="L565">            this.dAlphadY01   = y0[0].negate().divide(r2).getReal();</span>

<span class="nc" id="L567">        }</span>

        @Override
        public DerivativeStructure[] computeDerivatives(final DerivativeStructure t, final DerivativeStructure[] y) {
<span class="nc" id="L571">            return new DerivativeStructure[] {</span>
<span class="nc" id="L572">                omega.multiply(y[1]),</span>
<span class="nc" id="L573">                omega.multiply(y[0]).negate()</span>
            };
        }

        public double[] theoreticalY(final double t) {
<span class="nc" id="L578">            final double theta = omega.getReal() * t + alpha.getReal();</span>
<span class="nc" id="L579">            return new double[] {</span>
<span class="nc" id="L580">                r.getReal() * FastMath.sin(theta), r.getReal() * FastMath.cos(theta)</span>
            };
        }

        public double[][] getDerivatives(final double t) {

            // intermediate angle and state
<span class="nc" id="L587">            final double theta        = omega.getReal() * t + alpha.getReal();</span>
<span class="nc" id="L588">            final double sin          = FastMath.sin(theta);</span>
<span class="nc" id="L589">            final double cos          = FastMath.cos(theta);</span>
<span class="nc" id="L590">            final double y0           = r.getReal() * sin;</span>
<span class="nc" id="L591">            final double y1           = r.getReal() * cos;</span>

            // partial derivatives of the state first component
<span class="nc" id="L594">            final double dY0dOmega    =                y1 * (t + dAlphadOmega);</span>
<span class="nc" id="L595">            final double dY0dT0       =                y1 * dAlphadT0;</span>
<span class="nc" id="L596">            final double dY0dY00      = dRdY00 * sin + y1 * dAlphadY00;</span>
<span class="nc" id="L597">            final double dY0dY01      = dRdY01 * sin + y1 * dAlphadY01;</span>
<span class="nc" id="L598">            final double dY0dT        =                y1 * omega.getReal();</span>

            // partial derivatives of the state second component
<span class="nc" id="L601">            final double dY1dOmega    =              - y0 * (t + dAlphadOmega);</span>
<span class="nc" id="L602">            final double dY1dT0       =              - y0 * dAlphadT0;</span>
<span class="nc" id="L603">            final double dY1dY00      = dRdY00 * cos - y0 * dAlphadY00;</span>
<span class="nc" id="L604">            final double dY1dY01      = dRdY01 * cos - y0 * dAlphadY01;</span>
<span class="nc" id="L605">            final double dY1dT        =              - y0 * omega.getReal();</span>

<span class="nc" id="L607">            return new double[][] {</span>
                { dY0dOmega, dY0dT0, dY0dY00, dY0dY01, dY0dT },
                { dY1dOmega, dY1dT0, dY1dY00, dY1dY01, dY1dT }
            };

        }

    }

}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.1.201803210924</span></div></body></html>