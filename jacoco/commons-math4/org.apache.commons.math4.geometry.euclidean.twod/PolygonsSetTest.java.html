<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>PolygonsSetTest.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">commons_math4$All_in_commons_math4.exec</a> &gt; <a href="index.source.html" class="el_package">org.apache.commons.math4.geometry.euclidean.twod</a> &gt; <span class="el_source">PolygonsSetTest.java</span></div><h1>PolygonsSetTest.java</h1><pre class="source lang-java linenums">/*
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the &quot;License&quot;); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.commons.math4.geometry.euclidean.twod;

import java.util.ArrayList;
import java.util.Arrays;
import java.util.List;

import org.apache.commons.math3.util.Precision;
import org.apache.commons.math4.exception.MathIllegalArgumentException;
import org.apache.commons.math4.geometry.GeometryTestUtils;
import org.apache.commons.math4.geometry.euclidean.oned.Cartesian1D;
import org.apache.commons.math4.geometry.euclidean.oned.Interval;
import org.apache.commons.math4.geometry.euclidean.oned.IntervalsSet;
import org.apache.commons.math4.geometry.partitioning.BSPTree;
import org.apache.commons.math4.geometry.partitioning.BSPTreeVisitor;
import org.apache.commons.math4.geometry.partitioning.BoundaryProjection;
import org.apache.commons.math4.geometry.partitioning.Hyperplane;
import org.apache.commons.math4.geometry.partitioning.Region;
import org.apache.commons.math4.geometry.partitioning.Region.Location;
import org.apache.commons.math4.geometry.partitioning.RegionFactory;
import org.apache.commons.math4.geometry.partitioning.SubHyperplane;
import org.apache.commons.math4.util.FastMath;
import org.junit.Assert;
import org.junit.Test;

<span class="fc" id="L41">public class PolygonsSetTest {</span>

    private static final double TEST_TOLERANCE = 1e-10;

    @Test
    public void testFull() {
        // act
<span class="fc" id="L48">        PolygonsSet poly = new PolygonsSet(TEST_TOLERANCE);</span>

        // assert
<span class="fc" id="L51">        Assert.assertEquals(TEST_TOLERANCE, poly.getTolerance(), Precision.EPSILON);</span>
<span class="fc" id="L52">        GeometryTestUtils.assertPositiveInfinity(poly.getSize());</span>
<span class="fc" id="L53">        Assert.assertEquals(0.0, poly.getBoundarySize(), TEST_TOLERANCE);</span>
<span class="fc" id="L54">        Assert.assertEquals(0, poly.getVertices().length);</span>
<span class="fc" id="L55">        Assert.assertFalse(poly.isEmpty());</span>
<span class="fc" id="L56">        Assert.assertTrue(poly.isFull());</span>
<span class="fc" id="L57">        GeometryTestUtils.assertVectorEquals(Cartesian2D.NaN, (Cartesian2D) poly.getBarycenter(), TEST_TOLERANCE);</span>

<span class="fc" id="L59">        checkPoints(Region.Location.INSIDE, poly,</span>
                new Cartesian2D(Double.NEGATIVE_INFINITY, Double.NEGATIVE_INFINITY),
                Cartesian2D.ZERO,
                new Cartesian2D(Double.POSITIVE_INFINITY, Double.POSITIVE_INFINITY));

<span class="fc bfc" id="L64" title="All 2 branches covered.">        for (double y = -1; y &lt; 1; y += 0.1) {</span>
<span class="fc bfc" id="L65" title="All 2 branches covered.">            for (double x = -1; x &lt; 1; x += 0.1) {</span>
<span class="fc" id="L66">                GeometryTestUtils.assertNegativeInfinity(poly.projectToBoundary(new Cartesian2D(x, y)).getOffset());</span>
            }
        }
<span class="fc" id="L69">    }</span>

    @Test
    public void testEmpty() {
        // act
<span class="fc" id="L74">        PolygonsSet poly = (PolygonsSet) new RegionFactory&lt;Euclidean2D&gt;().getComplement(new PolygonsSet(TEST_TOLERANCE));</span>

        // assert
<span class="fc" id="L77">        Assert.assertEquals(TEST_TOLERANCE, poly.getTolerance(), Precision.EPSILON);</span>
<span class="fc" id="L78">        Assert.assertEquals(0.0, poly.getSize(), TEST_TOLERANCE);</span>
<span class="fc" id="L79">        Assert.assertEquals(0.0, poly.getBoundarySize(), TEST_TOLERANCE);</span>
<span class="fc" id="L80">        Assert.assertEquals(0, poly.getVertices().length);</span>
<span class="fc" id="L81">        Assert.assertTrue(poly.isEmpty());</span>
<span class="fc" id="L82">        Assert.assertFalse(poly.isFull());</span>
<span class="fc" id="L83">        GeometryTestUtils.assertVectorEquals(Cartesian2D.NaN, (Cartesian2D) poly.getBarycenter(), TEST_TOLERANCE);</span>

<span class="fc" id="L85">        checkPoints(Region.Location.OUTSIDE, poly,</span>
                new Cartesian2D(Double.NEGATIVE_INFINITY, Double.NEGATIVE_INFINITY),
                Cartesian2D.ZERO,
                new Cartesian2D(Double.POSITIVE_INFINITY, Double.POSITIVE_INFINITY));


<span class="fc bfc" id="L91" title="All 2 branches covered.">        for (double y = -1; y &lt; 1; y += 0.1) {</span>
<span class="fc bfc" id="L92" title="All 2 branches covered.">            for (double x = -1; x &lt; 1; x += 0.1) {</span>
<span class="fc" id="L93">                GeometryTestUtils.assertPositiveInfinity(poly.projectToBoundary(new Cartesian2D(x, y)).getOffset());</span>
            }
        }
<span class="fc" id="L96">    }</span>

    @Test
    public void testInfiniteLines_single() {
        // arrange
<span class="fc" id="L101">        Line line = new Line(new Cartesian2D(0, 0), new Cartesian2D(1, 1), TEST_TOLERANCE);</span>

<span class="fc" id="L103">        List&lt;SubHyperplane&lt;Euclidean2D&gt;&gt; boundaries = new ArrayList&lt;SubHyperplane&lt;Euclidean2D&gt;&gt;();</span>
<span class="fc" id="L104">        boundaries.add(line.wholeHyperplane());</span>

        // act
<span class="fc" id="L107">        PolygonsSet poly = new PolygonsSet(boundaries, TEST_TOLERANCE);</span>

        // assert
<span class="fc" id="L110">        Assert.assertEquals(TEST_TOLERANCE, poly.getTolerance(), Precision.EPSILON);</span>
<span class="fc" id="L111">        GeometryTestUtils.assertPositiveInfinity(poly.getSize());</span>
<span class="fc" id="L112">        GeometryTestUtils.assertPositiveInfinity(poly.getBoundarySize());</span>
<span class="fc" id="L113">        Assert.assertFalse(poly.isEmpty());</span>
<span class="fc" id="L114">        Assert.assertFalse(poly.isFull());</span>
<span class="fc" id="L115">        GeometryTestUtils.assertVectorEquals(Cartesian2D.NaN, (Cartesian2D) poly.getBarycenter(), TEST_TOLERANCE);</span>

<span class="fc" id="L117">        checkVertexLoopsEquivalent(new Cartesian2D[][] {</span>
            {
                null,
<span class="fc" id="L120">                line.toSpace(new Cartesian1D(-Float.MAX_VALUE)),</span>
<span class="fc" id="L121">                line.toSpace(new Cartesian1D(Float.MAX_VALUE))</span>
            }
<span class="fc" id="L123">        }, poly.getVertices());</span>

<span class="fc" id="L125">        checkPoints(Region.Location.OUTSIDE, poly,</span>
                new Cartesian2D(1, -1),
                new Cartesian2D(Double.POSITIVE_INFINITY, Double.NEGATIVE_INFINITY));
<span class="fc" id="L128">        checkPoints(Region.Location.INSIDE, poly,</span>
                new Cartesian2D(-1, 1),
                new Cartesian2D(Double.NEGATIVE_INFINITY, Double.POSITIVE_INFINITY));
<span class="fc" id="L131">        checkPoints(Region.Location.BOUNDARY, poly, Cartesian2D.ZERO);</span>
<span class="fc" id="L132">    }</span>

    @Test
    public void testInfiniteLines_twoIntersecting() {
        // arrange
<span class="fc" id="L137">        Line line1 = new Line(new Cartesian2D(0, 0), new Cartesian2D(1, 1), TEST_TOLERANCE);</span>
<span class="fc" id="L138">        Line line2 = new Line(new Cartesian2D(1, -1), new Cartesian2D(0, 0), TEST_TOLERANCE);</span>

<span class="fc" id="L140">        List&lt;SubHyperplane&lt;Euclidean2D&gt;&gt; boundaries = new ArrayList&lt;SubHyperplane&lt;Euclidean2D&gt;&gt;();</span>
<span class="fc" id="L141">        boundaries.add(line1.wholeHyperplane());</span>
<span class="fc" id="L142">        boundaries.add(line2.wholeHyperplane());</span>

        // act
<span class="fc" id="L145">        PolygonsSet poly = new PolygonsSet(boundaries, TEST_TOLERANCE);</span>

        // assert
<span class="fc" id="L148">        Assert.assertEquals(TEST_TOLERANCE, poly.getTolerance(), Precision.EPSILON);</span>
<span class="fc" id="L149">        GeometryTestUtils.assertPositiveInfinity(poly.getSize());</span>
<span class="fc" id="L150">        GeometryTestUtils.assertPositiveInfinity(poly.getBoundarySize());</span>
<span class="fc" id="L151">        Assert.assertFalse(poly.isEmpty());</span>
<span class="fc" id="L152">        Assert.assertFalse(poly.isFull());</span>
<span class="fc" id="L153">        GeometryTestUtils.assertVectorEquals(Cartesian2D.NaN, (Cartesian2D) poly.getBarycenter(), TEST_TOLERANCE);</span>

<span class="fc" id="L155">        checkVertexLoopsEquivalent(new Cartesian2D[][] {</span>
            {
                null,
<span class="fc" id="L158">                line2.toSpace(new Cartesian1D(-Float.MAX_VALUE)),</span>
<span class="fc" id="L159">                line2.toSpace(new Cartesian1D(Float.MAX_VALUE))</span>
            }
<span class="fc" id="L161">        }, poly.getVertices());</span>

<span class="fc" id="L163">        checkPoints(Region.Location.INSIDE, poly,</span>
                new Cartesian2D(-1, 0),
                new Cartesian2D(-Float.MAX_VALUE, Float.MAX_VALUE / 2.0));
<span class="fc" id="L166">        checkPoints(Region.Location.OUTSIDE, poly,</span>
                new Cartesian2D(1, 0),
                new Cartesian2D(Float.MAX_VALUE, Float.MAX_VALUE / 2.0));
<span class="fc" id="L169">        checkPoints(Region.Location.BOUNDARY, poly, Cartesian2D.ZERO);</span>
<span class="fc" id="L170">    }</span>

    @Test
    public void testInfiniteLines_twoParallel_facingIn() {
        // arrange
<span class="fc" id="L175">        Line line1 = new Line(new Cartesian2D(1, 1), new Cartesian2D(0, 1), TEST_TOLERANCE);</span>
<span class="fc" id="L176">        Line line2 = new Line(new Cartesian2D(0, -1), new Cartesian2D(1, -1), TEST_TOLERANCE);</span>

<span class="fc" id="L178">        List&lt;SubHyperplane&lt;Euclidean2D&gt;&gt; boundaries = new ArrayList&lt;SubHyperplane&lt;Euclidean2D&gt;&gt;();</span>
<span class="fc" id="L179">        boundaries.add(line1.wholeHyperplane());</span>
<span class="fc" id="L180">        boundaries.add(line2.wholeHyperplane());</span>

        // act
<span class="fc" id="L183">        PolygonsSet poly = new PolygonsSet(boundaries, TEST_TOLERANCE);</span>

        // assert
<span class="fc" id="L186">        Assert.assertEquals(TEST_TOLERANCE, poly.getTolerance(), Precision.EPSILON);</span>
<span class="fc" id="L187">        GeometryTestUtils.assertPositiveInfinity(poly.getSize());</span>
<span class="fc" id="L188">        GeometryTestUtils.assertPositiveInfinity(poly.getBoundarySize());</span>
<span class="fc" id="L189">        Assert.assertFalse(poly.isEmpty());</span>
<span class="fc" id="L190">        Assert.assertFalse(poly.isFull());</span>
<span class="fc" id="L191">        GeometryTestUtils.assertVectorEquals(Cartesian2D.NaN, (Cartesian2D) poly.getBarycenter(), TEST_TOLERANCE);</span>

<span class="fc" id="L193">        checkVertexLoopsEquivalent(new Cartesian2D[][] {</span>
            {
                null,
<span class="fc" id="L196">                line1.toSpace(new Cartesian1D(-Float.MAX_VALUE)),</span>
<span class="fc" id="L197">                line1.toSpace(new Cartesian1D(Float.MAX_VALUE))</span>
            },
            {
                null,
<span class="fc" id="L201">                line2.toSpace(new Cartesian1D(-Float.MAX_VALUE)),</span>
<span class="fc" id="L202">                line2.toSpace(new Cartesian1D(Float.MAX_VALUE))</span>
            }
<span class="fc" id="L204">        }, poly.getVertices());</span>

<span class="fc" id="L206">        checkPoints(Region.Location.INSIDE, poly,</span>
                new Cartesian2D(0, 0),
                new Cartesian2D(0, 0.9),
                new Cartesian2D(0, -0.9));
<span class="fc" id="L210">        checkPoints(Region.Location.OUTSIDE, poly,</span>
                new Cartesian2D(0, 1.1),
                new Cartesian2D(0, -1.1));
<span class="fc" id="L213">        checkPoints(Region.Location.BOUNDARY, poly,</span>
                new Cartesian2D(0, 1),
                new Cartesian2D(0, -1));
<span class="fc" id="L216">    }</span>

    @Test
    public void testInfiniteLines_twoParallel_facingOut() {
        // arrange
<span class="fc" id="L221">        Line line1 = new Line(new Cartesian2D(0, 1), new Cartesian2D(1, 1), TEST_TOLERANCE);</span>
<span class="fc" id="L222">        Line line2 = new Line(new Cartesian2D(1, -1), new Cartesian2D(0, -1), TEST_TOLERANCE);</span>

<span class="fc" id="L224">        List&lt;SubHyperplane&lt;Euclidean2D&gt;&gt; boundaries = new ArrayList&lt;SubHyperplane&lt;Euclidean2D&gt;&gt;();</span>
<span class="fc" id="L225">        boundaries.add(line1.wholeHyperplane());</span>
<span class="fc" id="L226">        boundaries.add(line2.wholeHyperplane());</span>

        // act
<span class="fc" id="L229">        PolygonsSet poly = new PolygonsSet(boundaries, TEST_TOLERANCE);</span>

        // assert
<span class="fc" id="L232">        Assert.assertEquals(TEST_TOLERANCE, poly.getTolerance(), Precision.EPSILON);</span>
<span class="fc" id="L233">        GeometryTestUtils.assertPositiveInfinity(poly.getSize());</span>
<span class="fc" id="L234">        GeometryTestUtils.assertPositiveInfinity(poly.getBoundarySize());</span>
<span class="fc" id="L235">        Assert.assertFalse(poly.isEmpty());</span>
<span class="fc" id="L236">        Assert.assertFalse(poly.isFull());</span>
<span class="fc" id="L237">        GeometryTestUtils.assertVectorEquals(Cartesian2D.NaN, (Cartesian2D) poly.getBarycenter(), TEST_TOLERANCE);</span>

<span class="fc" id="L239">        checkVertexLoopsEquivalent(new Cartesian2D[][] {</span>
            {
                null,
<span class="fc" id="L242">                line1.toSpace(new Cartesian1D(-Float.MAX_VALUE)),</span>
<span class="fc" id="L243">                line1.toSpace(new Cartesian1D(Float.MAX_VALUE))</span>
            },
            {
                null,
<span class="fc" id="L247">                line2.toSpace(new Cartesian1D(-Float.MAX_VALUE)),</span>
<span class="fc" id="L248">                line2.toSpace(new Cartesian1D(Float.MAX_VALUE))</span>
            }
<span class="fc" id="L250">        }, poly.getVertices());</span>

<span class="fc" id="L252">        checkPoints(Region.Location.OUTSIDE, poly,</span>
                new Cartesian2D(0, 0),
                new Cartesian2D(0, 0.9),
                new Cartesian2D(0, -0.9));
<span class="fc" id="L256">        checkPoints(Region.Location.INSIDE, poly,</span>
                new Cartesian2D(0, 1.1),
                new Cartesian2D(0, -1.1));
<span class="fc" id="L259">        checkPoints(Region.Location.BOUNDARY, poly,</span>
                new Cartesian2D(0, 1),
                new Cartesian2D(0, -1));
<span class="fc" id="L262">    }</span>

    @Test
    public void testMixedFiniteAndInfiniteLines_explicitInfiniteBoundaries() {
        // arrange
<span class="fc" id="L267">        Line line1 = new Line(new Cartesian2D(3, 3), new Cartesian2D(0, 3), TEST_TOLERANCE);</span>
<span class="fc" id="L268">        Line line2 = new Line(new Cartesian2D(0, -3), new Cartesian2D(3, -3), TEST_TOLERANCE);</span>

<span class="fc" id="L270">        List&lt;SubHyperplane&lt;Euclidean2D&gt;&gt; boundaries = new ArrayList&lt;SubHyperplane&lt;Euclidean2D&gt;&gt;();</span>
<span class="fc" id="L271">        boundaries.add(line1.wholeHyperplane());</span>
<span class="fc" id="L272">        boundaries.add(line2.wholeHyperplane());</span>
<span class="fc" id="L273">        boundaries.add(buildSegment(new Cartesian2D(0, 3), new Cartesian2D(0, -3)));</span>

        // act
<span class="fc" id="L276">        PolygonsSet poly = new PolygonsSet(boundaries, TEST_TOLERANCE);</span>

        // assert
<span class="fc" id="L279">        Assert.assertEquals(TEST_TOLERANCE, poly.getTolerance(), Precision.EPSILON);</span>
<span class="fc" id="L280">        GeometryTestUtils.assertPositiveInfinity(poly.getSize());</span>
<span class="fc" id="L281">        GeometryTestUtils.assertPositiveInfinity(poly.getBoundarySize());</span>
<span class="fc" id="L282">        Assert.assertFalse(poly.isEmpty());</span>
<span class="fc" id="L283">        Assert.assertFalse(poly.isFull());</span>
<span class="fc" id="L284">        GeometryTestUtils.assertVectorEquals(Cartesian2D.NaN, (Cartesian2D) poly.getBarycenter(), TEST_TOLERANCE);</span>

<span class="fc" id="L286">        checkVertexLoopsEquivalent(new Cartesian2D[][] {</span>
            {
                null,
                new Cartesian2D(1, 3), // dummy point
                new Cartesian2D(0, 3),
                new Cartesian2D(0, -3),
                new Cartesian2D(1, -3) // dummy point
            }
<span class="fc" id="L294">        }, poly.getVertices());</span>

<span class="fc" id="L296">        checkPoints(Region.Location.INSIDE, poly,</span>
                new Cartesian2D(0.1, 2.9),
                new Cartesian2D(0.1, 0),
                new Cartesian2D(0.1, -2.9));
<span class="fc" id="L300">        checkPoints(Region.Location.OUTSIDE, poly,</span>
                new Cartesian2D(0, 3.1),
                new Cartesian2D(-0.5, 0),
                new Cartesian2D(0, -3.1));
<span class="fc" id="L304">        checkPoints(Region.Location.BOUNDARY, poly,</span>
                new Cartesian2D(3, 3),
                new Cartesian2D(0, 0),
                new Cartesian2D(3, -3));
<span class="fc" id="L308">    }</span>

    // The polygon in this test is created from finite boundaries but the generated
    // loop still begins and ends with infinite lines. This is because the boundaries
    // used as input do not form a closed region, therefore the region itself is unclosed.
    // In other words, the boundaries used as input only define the region, not the points
    // returned from the getVertices() method.
    @Test
    public void testMixedFiniteAndInfiniteLines_impliedInfiniteBoundaries() {
        // arrange
<span class="fc" id="L318">        Line line = new Line(new Cartesian2D(3, 0), new Cartesian2D(3, 3), TEST_TOLERANCE);</span>

<span class="fc" id="L320">        List&lt;SubHyperplane&lt;Euclidean2D&gt;&gt; boundaries = new ArrayList&lt;SubHyperplane&lt;Euclidean2D&gt;&gt;();</span>
<span class="fc" id="L321">        boundaries.add(buildSegment(new Cartesian2D(0, 3), new Cartesian2D(0, 0)));</span>
<span class="fc" id="L322">        boundaries.add(buildSegment(new Cartesian2D(0, 0), new Cartesian2D(3, 0)));</span>
<span class="fc" id="L323">        boundaries.add(new SubLine(line, new IntervalsSet(0, Double.POSITIVE_INFINITY, TEST_TOLERANCE)));</span>

        // act
<span class="fc" id="L326">        PolygonsSet poly = new PolygonsSet(boundaries, TEST_TOLERANCE);</span>

        // assert
<span class="fc" id="L329">        Assert.assertEquals(TEST_TOLERANCE, poly.getTolerance(), Precision.EPSILON);</span>
<span class="fc" id="L330">        GeometryTestUtils.assertPositiveInfinity(poly.getSize());</span>
<span class="fc" id="L331">        GeometryTestUtils.assertPositiveInfinity(poly.getBoundarySize());</span>
<span class="fc" id="L332">        Assert.assertFalse(poly.isEmpty());</span>
<span class="fc" id="L333">        Assert.assertFalse(poly.isFull());</span>
<span class="fc" id="L334">        GeometryTestUtils.assertVectorEquals(Cartesian2D.NaN, (Cartesian2D) poly.getBarycenter(), TEST_TOLERANCE);</span>

<span class="fc" id="L336">        checkVertexLoopsEquivalent(new Cartesian2D[][] {</span>
            {
                null,
                new Cartesian2D(0, 1), // dummy point
                new Cartesian2D(0, 0),
                new Cartesian2D(3, 0),
                new Cartesian2D(3, 1) // dummy point
            }
<span class="fc" id="L344">        }, poly.getVertices());</span>

<span class="fc" id="L346">        checkPoints(Region.Location.INSIDE, poly,</span>
                new Cartesian2D(0.1, Float.MAX_VALUE),
                new Cartesian2D(0.1, 0.1),
                new Cartesian2D(1.5, 0.1),
                new Cartesian2D(2.9, 0.1),
                new Cartesian2D(2.9, Float.MAX_VALUE));
<span class="fc" id="L352">        checkPoints(Region.Location.OUTSIDE, poly,</span>
                new Cartesian2D(-0.1, Float.MAX_VALUE),
                new Cartesian2D(-0.1, 0.1),
                new Cartesian2D(1.5, -0.1),
                new Cartesian2D(3.1, 0.1),
                new Cartesian2D(3.1, Float.MAX_VALUE));
<span class="fc" id="L358">        checkPoints(Region.Location.BOUNDARY, poly,</span>
                new Cartesian2D(0, 1),
                new Cartesian2D(1, 0),
                new Cartesian2D(3, 1));
<span class="fc" id="L362">    }</span>

    @Test
    public void testBox() {
        // act
<span class="fc" id="L367">        PolygonsSet box = new PolygonsSet(0, 2, -1, 1, TEST_TOLERANCE);</span>

        // assert
<span class="fc" id="L370">        Assert.assertEquals(4.0, box.getSize(), TEST_TOLERANCE);</span>
<span class="fc" id="L371">        Assert.assertEquals(8.0, box.getBoundarySize(), TEST_TOLERANCE);</span>
<span class="fc" id="L372">        Assert.assertFalse(box.isEmpty());</span>
<span class="fc" id="L373">        Assert.assertFalse(box.isFull());</span>
<span class="fc" id="L374">        GeometryTestUtils.assertVectorEquals(new Cartesian2D(1, 0), (Cartesian2D) box.getBarycenter(), TEST_TOLERANCE);</span>

<span class="fc" id="L376">        checkVertexLoopsEquivalent(new Cartesian2D[][] {</span>
            {
                new Cartesian2D(2, -1),
                new Cartesian2D(2, 1),
                new Cartesian2D(0, 1),
                new Cartesian2D(0, -1)
            }
<span class="fc" id="L383">        }, box.getVertices());</span>

<span class="fc" id="L385">        checkPoints(Region.Location.INSIDE, box,</span>
                new Cartesian2D(0.1, 0),
                new Cartesian2D(1.9, 0),
                new Cartesian2D(1, 0.9),
                new Cartesian2D(1, -0.9));
<span class="fc" id="L390">        checkPoints(Region.Location.OUTSIDE, box,</span>
                new Cartesian2D(-0.1, 0),
                new Cartesian2D(2.1, 0),
                new Cartesian2D(1, -1.1),
                new Cartesian2D(1, 1.1));
<span class="fc" id="L395">        checkPoints(Region.Location.BOUNDARY, box,</span>
                new Cartesian2D(0, 0),
                new Cartesian2D(2, 0),
                new Cartesian2D(1, 1),
                new Cartesian2D(1, -1));
<span class="fc" id="L400">    }</span>

    @Test
    public void testInvertedBox() {
        // arrange
<span class="fc" id="L405">        List&lt;SubHyperplane&lt;Euclidean2D&gt;&gt; boundaries = new ArrayList&lt;SubHyperplane&lt;Euclidean2D&gt;&gt;();</span>
<span class="fc" id="L406">        boundaries.add(buildSegment(new Cartesian2D(0, -1), new Cartesian2D(0, 1)));</span>
<span class="fc" id="L407">        boundaries.add(buildSegment(new Cartesian2D(2, 1), new Cartesian2D(2, -1)));</span>
<span class="fc" id="L408">        boundaries.add(buildSegment(new Cartesian2D(0, 1), new Cartesian2D(2, 1)));</span>
<span class="fc" id="L409">        boundaries.add(buildSegment(new Cartesian2D(2, -1), new Cartesian2D(0, -1)));</span>

        // act
<span class="fc" id="L412">        PolygonsSet box = new PolygonsSet(boundaries, TEST_TOLERANCE);</span>

        // assert
<span class="fc" id="L415">        GeometryTestUtils.assertPositiveInfinity(box.getSize());</span>
<span class="fc" id="L416">        Assert.assertEquals(8.0, box.getBoundarySize(), TEST_TOLERANCE);</span>
<span class="fc" id="L417">        Assert.assertFalse(box.isEmpty());</span>
<span class="fc" id="L418">        Assert.assertFalse(box.isFull());</span>
<span class="fc" id="L419">        GeometryTestUtils.assertVectorEquals(Cartesian2D.NaN, (Cartesian2D) box.getBarycenter(), TEST_TOLERANCE);</span>

<span class="fc" id="L421">        checkVertexLoopsEquivalent(new Cartesian2D[][] {</span>
            {
                new Cartesian2D(0, -1),
                new Cartesian2D(0, 1),
                new Cartesian2D(2, 1),
                new Cartesian2D(2, -1)
            }
<span class="fc" id="L428">        }, box.getVertices());</span>

<span class="fc" id="L430">        checkPoints(Region.Location.OUTSIDE, box,</span>
                new Cartesian2D(0.1, 0),
                new Cartesian2D(1.9, 0),
                new Cartesian2D(1, 0.9),
                new Cartesian2D(1, -0.9));
<span class="fc" id="L435">        checkPoints(Region.Location.INSIDE, box,</span>
                new Cartesian2D(-0.1, 0),
                new Cartesian2D(2.1, 0),
                new Cartesian2D(1, -1.1),
                new Cartesian2D(1, 1.1));
<span class="fc" id="L440">        checkPoints(Region.Location.BOUNDARY, box,</span>
                new Cartesian2D(0, 0),
                new Cartesian2D(2, 0),
                new Cartesian2D(1, 1),
                new Cartesian2D(1, -1));
<span class="fc" id="L445">    }</span>

    @Test
    public void testSimplyConnected() {
        // arrange
<span class="fc" id="L450">        Cartesian2D[][] vertices = new Cartesian2D[][] {</span>
            new Cartesian2D[] {
                new Cartesian2D(36.0, 22.0),
                new Cartesian2D(39.0, 32.0),
                new Cartesian2D(19.0, 32.0),
                new Cartesian2D( 6.0, 16.0),
                new Cartesian2D(31.0, 10.0),
                new Cartesian2D(42.0, 16.0),
                new Cartesian2D(34.0, 20.0),
                new Cartesian2D(29.0, 19.0),
                new Cartesian2D(23.0, 22.0),
                new Cartesian2D(33.0, 25.0)
            }
        };

        // act
<span class="fc" id="L466">        PolygonsSet set = buildSet(vertices);</span>

        // assert
<span class="fc" id="L469">        checkPoints(Region.Location.INSIDE, set,</span>
            new Cartesian2D(30.0, 15.0),
            new Cartesian2D(15.0, 20.0),
            new Cartesian2D(24.0, 25.0),
            new Cartesian2D(35.0, 30.0),
            new Cartesian2D(19.0, 17.0));
<span class="fc" id="L475">        checkPoints(Region.Location.OUTSIDE, set,</span>
            new Cartesian2D(50.0, 30.0),
            new Cartesian2D(30.0, 35.0),
            new Cartesian2D(10.0, 25.0),
            new Cartesian2D(10.0, 10.0),
            new Cartesian2D(40.0, 10.0),
            new Cartesian2D(50.0, 15.0),
            new Cartesian2D(30.0, 22.0));
<span class="fc" id="L483">        checkPoints(Region.Location.BOUNDARY, set,</span>
            new Cartesian2D(30.0, 32.0),
            new Cartesian2D(34.0, 20.0));

<span class="fc" id="L487">        checkVertexLoopsEquivalent(vertices, set.getVertices());</span>
<span class="fc" id="L488">    }</span>

    @Test
    public void testStair() {
        // arrange
<span class="fc" id="L493">        Cartesian2D[][] vertices = new Cartesian2D[][] {</span>
            new Cartesian2D[] {
                new Cartesian2D( 0.0, 0.0),
                new Cartesian2D( 0.0, 2.0),
                new Cartesian2D(-0.1, 2.0),
                new Cartesian2D(-0.1, 1.0),
                new Cartesian2D(-0.3, 1.0),
                new Cartesian2D(-0.3, 1.5),
                new Cartesian2D(-1.3, 1.5),
                new Cartesian2D(-1.3, 2.0),
                new Cartesian2D(-1.8, 2.0),
<span class="fc" id="L504">                new Cartesian2D(-1.8 - 1.0 / FastMath.sqrt(2.0),</span>
<span class="fc" id="L505">                            2.0 - 1.0 / FastMath.sqrt(2.0))</span>
            }
        };

        // act
<span class="fc" id="L510">        PolygonsSet set = buildSet(vertices);</span>

        // assert
<span class="fc" id="L513">        checkVertexLoopsEquivalent(vertices, set.getVertices());</span>

<span class="fc" id="L515">        Assert.assertEquals(1.1 + 0.95 * FastMath.sqrt(2.0), set.getSize(), TEST_TOLERANCE);</span>
<span class="fc" id="L516">    }</span>

    @Test
    public void testHole() {
        // arrange
<span class="fc" id="L521">        Cartesian2D[][] vertices = new Cartesian2D[][] {</span>
            new Cartesian2D[] {
                new Cartesian2D(0.0, 0.0),
                new Cartesian2D(3.0, 0.0),
                new Cartesian2D(3.0, 3.0),
                new Cartesian2D(0.0, 3.0)
            }, new Cartesian2D[] {
                new Cartesian2D(1.0, 2.0),
                new Cartesian2D(2.0, 2.0),
                new Cartesian2D(2.0, 1.0),
                new Cartesian2D(1.0, 1.0)
            }
        };

        // act
<span class="fc" id="L536">        PolygonsSet set = buildSet(vertices);</span>

        // assert
<span class="fc" id="L539">        checkPoints(Region.Location.INSIDE, set, new Cartesian2D[] {</span>
            new Cartesian2D(0.5, 0.5),
            new Cartesian2D(1.5, 0.5),
            new Cartesian2D(2.5, 0.5),
            new Cartesian2D(0.5, 1.5),
            new Cartesian2D(2.5, 1.5),
            new Cartesian2D(0.5, 2.5),
            new Cartesian2D(1.5, 2.5),
            new Cartesian2D(2.5, 2.5),
            new Cartesian2D(0.5, 1.0)
        });
<span class="fc" id="L550">        checkPoints(Region.Location.OUTSIDE, set, new Cartesian2D[] {</span>
            new Cartesian2D(1.5, 1.5),
            new Cartesian2D(3.5, 1.0),
            new Cartesian2D(4.0, 1.5),
            new Cartesian2D(6.0, 6.0)
        });
<span class="fc" id="L556">        checkPoints(Region.Location.BOUNDARY, set, new Cartesian2D[] {</span>
            new Cartesian2D(1.0, 1.0),
            new Cartesian2D(1.5, 0.0),
            new Cartesian2D(1.5, 1.0),
            new Cartesian2D(1.5, 2.0),
            new Cartesian2D(1.5, 3.0),
            new Cartesian2D(3.0, 3.0)
        });
<span class="fc" id="L564">        checkVertexLoopsEquivalent(vertices, set.getVertices());</span>

<span class="fc bfc" id="L566" title="All 2 branches covered.">        for (double x = -0.999; x &lt; 3.999; x += 0.11) {</span>
<span class="fc" id="L567">            Cartesian2D v = new Cartesian2D(x, x + 0.5);</span>
<span class="fc" id="L568">            BoundaryProjection&lt;Euclidean2D&gt; projection = set.projectToBoundary(v);</span>
<span class="pc bpc" id="L569" title="1 of 2 branches missed.">            Assert.assertTrue(projection.getOriginal() == v);</span>
<span class="fc" id="L570">            Cartesian2D p = (Cartesian2D) projection.getProjected();</span>
<span class="fc bfc" id="L571" title="All 2 branches covered.">            if (x &lt; -0.5) {</span>
<span class="fc" id="L572">                Assert.assertEquals(0.0,      p.getX(), TEST_TOLERANCE);</span>
<span class="fc" id="L573">                Assert.assertEquals(0.0,      p.getY(), TEST_TOLERANCE);</span>
<span class="fc" id="L574">                Assert.assertEquals(+v.distance(Cartesian2D.ZERO), projection.getOffset(), TEST_TOLERANCE);</span>
<span class="fc bfc" id="L575" title="All 2 branches covered.">            } else if (x &lt; 0.5) {</span>
<span class="fc" id="L576">                Assert.assertEquals(0.0,      p.getX(), TEST_TOLERANCE);</span>
<span class="fc" id="L577">                Assert.assertEquals(v.getY(), p.getY(), TEST_TOLERANCE);</span>
<span class="fc" id="L578">                Assert.assertEquals(-v.getX(), projection.getOffset(), TEST_TOLERANCE);</span>
<span class="fc bfc" id="L579" title="All 2 branches covered.">            } else if (x &lt; 1.25) {</span>
<span class="fc" id="L580">                Assert.assertEquals(1.0,      p.getX(), TEST_TOLERANCE);</span>
<span class="fc" id="L581">                Assert.assertEquals(v.getY(), p.getY(), TEST_TOLERANCE);</span>
<span class="fc" id="L582">                Assert.assertEquals(v.getX() - 1.0, projection.getOffset(), TEST_TOLERANCE);</span>
<span class="fc bfc" id="L583" title="All 2 branches covered.">            } else if (x &lt; 2.0) {</span>
<span class="fc" id="L584">                Assert.assertEquals(v.getX(), p.getX(), TEST_TOLERANCE);</span>
<span class="fc" id="L585">                Assert.assertEquals(2.0,      p.getY(), TEST_TOLERANCE);</span>
<span class="fc" id="L586">                Assert.assertEquals(2.0 - v.getY(), projection.getOffset(), TEST_TOLERANCE);</span>
<span class="fc bfc" id="L587" title="All 2 branches covered.">            } else if (x &lt; 3.0) {</span>
<span class="fc" id="L588">                Assert.assertEquals(v.getX(), p.getX(), TEST_TOLERANCE);</span>
<span class="fc" id="L589">                Assert.assertEquals(3.0,      p.getY(), TEST_TOLERANCE);</span>
<span class="fc" id="L590">                Assert.assertEquals(v.getY() - 3.0, projection.getOffset(), TEST_TOLERANCE);</span>
            } else {
<span class="fc" id="L592">                Assert.assertEquals(3.0,      p.getX(), TEST_TOLERANCE);</span>
<span class="fc" id="L593">                Assert.assertEquals(3.0,      p.getY(), TEST_TOLERANCE);</span>
<span class="fc" id="L594">                Assert.assertEquals(+v.distance(new Cartesian2D(3, 3)), projection.getOffset(), TEST_TOLERANCE);</span>
            }
        }
<span class="fc" id="L597">    }</span>

    @Test
    public void testDisjointPolygons() {
        // arrange
<span class="fc" id="L602">        Cartesian2D[][] vertices = new Cartesian2D[][] {</span>
            new Cartesian2D[] {
                new Cartesian2D(0.0, 1.0),
                new Cartesian2D(2.0, 1.0),
                new Cartesian2D(1.0, 2.0)
            }, new Cartesian2D[] {
                new Cartesian2D(4.0, 0.0),
                new Cartesian2D(5.0, 1.0),
                new Cartesian2D(3.0, 1.0)
            }
        };

        // act
<span class="fc" id="L615">        PolygonsSet set = buildSet(vertices);</span>

        // assert
<span class="fc" id="L618">        Assert.assertEquals(Region.Location.INSIDE, set.checkPoint(new Cartesian2D(1.0, 1.5)));</span>
<span class="fc" id="L619">        checkPoints(Region.Location.INSIDE, set, new Cartesian2D[] {</span>
            new Cartesian2D(1.0, 1.5),
            new Cartesian2D(4.5, 0.8)
        });
<span class="fc" id="L623">        checkPoints(Region.Location.OUTSIDE, set, new Cartesian2D[] {</span>
            new Cartesian2D(1.0, 0.0),
            new Cartesian2D(3.5, 1.2),
            new Cartesian2D(2.5, 1.0),
            new Cartesian2D(3.0, 4.0)
        });
<span class="fc" id="L629">        checkPoints(Region.Location.BOUNDARY, set, new Cartesian2D[] {</span>
            new Cartesian2D(1.0, 1.0),
            new Cartesian2D(3.5, 0.5),
            new Cartesian2D(0.0, 1.0)
        });
<span class="fc" id="L634">        checkVertexLoopsEquivalent(vertices, set.getVertices());</span>
<span class="fc" id="L635">    }</span>

    @Test
    public void testOppositeHyperplanes() {
        // arrange
<span class="fc" id="L640">        Cartesian2D[][] vertices = new Cartesian2D[][] {</span>
            new Cartesian2D[] {
                new Cartesian2D(1.0, 0.0),
                new Cartesian2D(2.0, 1.0),
                new Cartesian2D(3.0, 1.0),
                new Cartesian2D(2.0, 2.0),
                new Cartesian2D(1.0, 1.0),
                new Cartesian2D(0.0, 1.0)
            }
        };

        // act
<span class="fc" id="L652">        PolygonsSet set = buildSet(vertices);</span>

        // assert
<span class="fc" id="L655">        checkVertexLoopsEquivalent(vertices, set.getVertices());</span>
<span class="fc" id="L656">    }</span>

    @Test
    public void testSingularPoint() {
        // arrange
<span class="fc" id="L661">        Cartesian2D[][] vertices = new Cartesian2D[][] {</span>
            new Cartesian2D[] {
                new Cartesian2D( 0.0,  0.0),
                new Cartesian2D( 1.0,  0.0),
                new Cartesian2D( 1.0,  1.0),
                new Cartesian2D( 0.0,  1.0),
                new Cartesian2D( 0.0,  0.0),
                new Cartesian2D(-1.0,  0.0),
                new Cartesian2D(-1.0, -1.0),
                new Cartesian2D( 0.0, -1.0)
            }
        };

        // act
<span class="fc" id="L675">        PolygonsSet set = buildSet(vertices);</span>

        // assert
<span class="fc" id="L678">        checkVertexLoopsEquivalent(new Cartesian2D[][] {</span>
            {
                new Cartesian2D( 0.0,  0.0),
                new Cartesian2D( 1.0,  0.0),
                new Cartesian2D( 1.0,  1.0),
                new Cartesian2D( 0.0,  1.0)
            },
            {
                new Cartesian2D( 0.0,  0.0),
                new Cartesian2D(-1.0,  0.0),
                new Cartesian2D(-1.0, -1.0),
                new Cartesian2D( 0.0, -1.0)
            }
<span class="fc" id="L691">        }, set.getVertices());</span>
<span class="fc" id="L692">    }</span>

    @Test
    public void testLineIntersection() {
        // arrange
<span class="fc" id="L697">        Cartesian2D[][] vertices = new Cartesian2D[][] {</span>
            new Cartesian2D[] {
                new Cartesian2D( 0.0,  0.0),
                new Cartesian2D( 2.0,  0.0),
                new Cartesian2D( 2.0,  1.0),
                new Cartesian2D( 3.0,  1.0),
                new Cartesian2D( 3.0,  3.0),
                new Cartesian2D( 1.0,  3.0),
                new Cartesian2D( 1.0,  2.0),
                new Cartesian2D( 0.0,  2.0)
            }
        };

        // act
<span class="fc" id="L711">        PolygonsSet set = buildSet(vertices);</span>

        // assert
<span class="fc" id="L714">        Line l1 = new Line(new Cartesian2D(-1.5, 0.0), FastMath.PI / 4, TEST_TOLERANCE);</span>
<span class="fc" id="L715">        SubLine s1 = (SubLine) set.intersection(l1.wholeHyperplane());</span>
<span class="fc" id="L716">        List&lt;Interval&gt; i1 = ((IntervalsSet) s1.getRemainingRegion()).asList();</span>
<span class="fc" id="L717">        Assert.assertEquals(2, i1.size());</span>
<span class="fc" id="L718">        Interval v10 = i1.get(0);</span>
<span class="fc" id="L719">        Cartesian2D p10Lower = l1.toSpace(new Cartesian1D(v10.getInf()));</span>
<span class="fc" id="L720">        Assert.assertEquals(0.0, p10Lower.getX(), TEST_TOLERANCE);</span>
<span class="fc" id="L721">        Assert.assertEquals(1.5, p10Lower.getY(), TEST_TOLERANCE);</span>
<span class="fc" id="L722">        Cartesian2D p10Upper = l1.toSpace(new Cartesian1D(v10.getSup()));</span>
<span class="fc" id="L723">        Assert.assertEquals(0.5, p10Upper.getX(), TEST_TOLERANCE);</span>
<span class="fc" id="L724">        Assert.assertEquals(2.0, p10Upper.getY(), TEST_TOLERANCE);</span>
<span class="fc" id="L725">        Interval v11 = i1.get(1);</span>
<span class="fc" id="L726">        Cartesian2D p11Lower = l1.toSpace(new Cartesian1D(v11.getInf()));</span>
<span class="fc" id="L727">        Assert.assertEquals(1.0, p11Lower.getX(), TEST_TOLERANCE);</span>
<span class="fc" id="L728">        Assert.assertEquals(2.5, p11Lower.getY(), TEST_TOLERANCE);</span>
<span class="fc" id="L729">        Cartesian2D p11Upper = l1.toSpace(new Cartesian1D(v11.getSup()));</span>
<span class="fc" id="L730">        Assert.assertEquals(1.5, p11Upper.getX(), TEST_TOLERANCE);</span>
<span class="fc" id="L731">        Assert.assertEquals(3.0, p11Upper.getY(), TEST_TOLERANCE);</span>

<span class="fc" id="L733">        Line l2 = new Line(new Cartesian2D(-1.0, 2.0), 0, TEST_TOLERANCE);</span>
<span class="fc" id="L734">        SubLine s2 = (SubLine) set.intersection(l2.wholeHyperplane());</span>
<span class="fc" id="L735">        List&lt;Interval&gt; i2 = ((IntervalsSet) s2.getRemainingRegion()).asList();</span>
<span class="fc" id="L736">        Assert.assertEquals(1, i2.size());</span>
<span class="fc" id="L737">        Interval v20 = i2.get(0);</span>
<span class="fc" id="L738">        Cartesian2D p20Lower = l2.toSpace(new Cartesian1D(v20.getInf()));</span>
<span class="fc" id="L739">        Assert.assertEquals(1.0, p20Lower.getX(), TEST_TOLERANCE);</span>
<span class="fc" id="L740">        Assert.assertEquals(2.0, p20Lower.getY(), TEST_TOLERANCE);</span>
<span class="fc" id="L741">        Cartesian2D p20Upper = l2.toSpace(new Cartesian1D(v20.getSup()));</span>
<span class="fc" id="L742">        Assert.assertEquals(3.0, p20Upper.getX(), TEST_TOLERANCE);</span>
<span class="fc" id="L743">        Assert.assertEquals(2.0, p20Upper.getY(), TEST_TOLERANCE);</span>
<span class="fc" id="L744">    }</span>

    @Test
    public void testUnlimitedSubHyperplane() {
        // arrange
<span class="fc" id="L749">        Cartesian2D[][] vertices1 = new Cartesian2D[][] {</span>
            new Cartesian2D[] {
                new Cartesian2D(0.0, 0.0),
                new Cartesian2D(4.0, 0.0),
                new Cartesian2D(1.4, 1.5),
                new Cartesian2D(0.0, 3.5)
            }
        };
<span class="fc" id="L757">        PolygonsSet set1 = buildSet(vertices1);</span>
<span class="fc" id="L758">        Cartesian2D[][] vertices2 = new Cartesian2D[][] {</span>
            new Cartesian2D[] {
                new Cartesian2D(1.4,  0.2),
                new Cartesian2D(2.8, -1.2),
                new Cartesian2D(2.5,  0.6)
            }
        };
<span class="fc" id="L765">        PolygonsSet set2 = buildSet(vertices2);</span>

        // act
<span class="fc" id="L768">        PolygonsSet set =</span>
<span class="fc" id="L769">            (PolygonsSet) new RegionFactory&lt;Euclidean2D&gt;().union(set1.copySelf(),</span>
<span class="fc" id="L770">                                                                 set2.copySelf());</span>

        // assert
<span class="fc" id="L773">        checkVertexLoopsEquivalent(vertices1, set1.getVertices());</span>
<span class="fc" id="L774">        checkVertexLoopsEquivalent(vertices2, set2.getVertices());</span>
<span class="fc" id="L775">        checkVertexLoopsEquivalent(new Cartesian2D[][] {</span>
            new Cartesian2D[] {
                new Cartesian2D(0.0,  0.0),
                new Cartesian2D(1.6,  0.0),
                new Cartesian2D(2.8, -1.2),
                new Cartesian2D(2.6,  0.0),
                new Cartesian2D(4.0,  0.0),
                new Cartesian2D(1.4,  1.5),
                new Cartesian2D(0.0,  3.5)
            }
<span class="fc" id="L785">        }, set.getVertices());</span>
<span class="fc" id="L786">    }</span>

    @Test
    public void testUnion() {
        // arrange
<span class="fc" id="L791">        Cartesian2D[][] vertices1 = new Cartesian2D[][] {</span>
            new Cartesian2D[] {
                new Cartesian2D( 0.0,  0.0),
                new Cartesian2D( 2.0,  0.0),
                new Cartesian2D( 2.0,  2.0),
                new Cartesian2D( 0.0,  2.0)
            }
        };
<span class="fc" id="L799">        PolygonsSet set1 = buildSet(vertices1);</span>
<span class="fc" id="L800">        Cartesian2D[][] vertices2 = new Cartesian2D[][] {</span>
            new Cartesian2D[] {
                new Cartesian2D( 1.0,  1.0),
                new Cartesian2D( 3.0,  1.0),
                new Cartesian2D( 3.0,  3.0),
                new Cartesian2D( 1.0,  3.0)
            }
        };
<span class="fc" id="L808">        PolygonsSet set2 = buildSet(vertices2);</span>

        // act
<span class="fc" id="L811">        PolygonsSet set  = (PolygonsSet) new RegionFactory&lt;Euclidean2D&gt;().union(set1.copySelf(),</span>
<span class="fc" id="L812">                                                                                set2.copySelf());</span>

        // assert
<span class="fc" id="L815">        checkVertexLoopsEquivalent(vertices1, set1.getVertices());</span>
<span class="fc" id="L816">        checkVertexLoopsEquivalent(vertices2, set2.getVertices());</span>
<span class="fc" id="L817">        checkVertexLoopsEquivalent(new Cartesian2D[][] {</span>
            new Cartesian2D[] {
                new Cartesian2D( 0.0,  0.0),
                new Cartesian2D( 2.0,  0.0),
                new Cartesian2D( 2.0,  1.0),
                new Cartesian2D( 3.0,  1.0),
                new Cartesian2D( 3.0,  3.0),
                new Cartesian2D( 1.0,  3.0),
                new Cartesian2D( 1.0,  2.0),
                new Cartesian2D( 0.0,  2.0)
            }
<span class="fc" id="L828">        }, set.getVertices());</span>

<span class="fc" id="L830">        checkPoints(Region.Location.INSIDE, set, new Cartesian2D[] {</span>
            new Cartesian2D(1.0, 1.0),
            new Cartesian2D(0.5, 0.5),
            new Cartesian2D(2.0, 2.0),
            new Cartesian2D(2.5, 2.5),
            new Cartesian2D(0.5, 1.5),
            new Cartesian2D(1.5, 1.5),
            new Cartesian2D(1.5, 0.5),
            new Cartesian2D(1.5, 2.5),
            new Cartesian2D(2.5, 1.5),
            new Cartesian2D(2.5, 2.5)
        });
<span class="fc" id="L842">        checkPoints(Region.Location.OUTSIDE, set, new Cartesian2D[] {</span>
            new Cartesian2D(-0.5, 0.5),
            new Cartesian2D( 0.5, 2.5),
            new Cartesian2D( 2.5, 0.5),
            new Cartesian2D( 3.5, 2.5)
        });
<span class="fc" id="L848">        checkPoints(Region.Location.BOUNDARY, set, new Cartesian2D[] {</span>
            new Cartesian2D(0.0, 0.0),
            new Cartesian2D(0.5, 2.0),
            new Cartesian2D(2.0, 0.5),
            new Cartesian2D(2.5, 1.0),
            new Cartesian2D(3.0, 2.5)
        });
<span class="fc" id="L855">    }</span>

    @Test
    public void testIntersection() {
        // arrange
<span class="fc" id="L860">        Cartesian2D[][] vertices1 = new Cartesian2D[][] {</span>
            new Cartesian2D[] {
                new Cartesian2D( 0.0,  0.0),
                new Cartesian2D( 2.0,  0.0),
                new Cartesian2D( 2.0,  2.0),
                new Cartesian2D( 0.0,  2.0)
            }
        };
<span class="fc" id="L868">        PolygonsSet set1 = buildSet(vertices1);</span>
<span class="fc" id="L869">        Cartesian2D[][] vertices2 = new Cartesian2D[][] {</span>
            new Cartesian2D[] {
                new Cartesian2D( 1.0,  1.0),
                new Cartesian2D( 3.0,  1.0),
                new Cartesian2D( 3.0,  3.0),
                new Cartesian2D( 1.0,  3.0)
            }
        };
<span class="fc" id="L877">        PolygonsSet set2 = buildSet(vertices2);</span>

        // act
<span class="fc" id="L880">        PolygonsSet set  = (PolygonsSet) new RegionFactory&lt;Euclidean2D&gt;().intersection(set1.copySelf(),</span>
<span class="fc" id="L881">                                                                                       set2.copySelf());</span>

        // assert
<span class="fc" id="L884">        checkVertexLoopsEquivalent(vertices1, set1.getVertices());</span>
<span class="fc" id="L885">        checkVertexLoopsEquivalent(vertices2, set2.getVertices());</span>
<span class="fc" id="L886">        checkVertexLoopsEquivalent(new Cartesian2D[][] {</span>
            new Cartesian2D[] {
                new Cartesian2D( 1.0,  1.0),
                new Cartesian2D( 2.0,  1.0),
                new Cartesian2D( 2.0,  2.0),
                new Cartesian2D( 1.0,  2.0)
            }
<span class="fc" id="L893">        }, set.getVertices());</span>

<span class="fc" id="L895">        checkPoints(Region.Location.INSIDE, set, new Cartesian2D[] {</span>
            new Cartesian2D(1.5, 1.5)
        });
<span class="fc" id="L898">        checkPoints(Region.Location.OUTSIDE, set, new Cartesian2D[] {</span>
            new Cartesian2D(0.5, 1.5),
            new Cartesian2D(2.5, 1.5),
            new Cartesian2D(1.5, 0.5),
            new Cartesian2D(0.5, 0.5)
        });
<span class="fc" id="L904">        checkPoints(Region.Location.BOUNDARY, set, new Cartesian2D[] {</span>
            new Cartesian2D(1.0, 1.0),
            new Cartesian2D(2.0, 2.0),
            new Cartesian2D(1.0, 1.5),
            new Cartesian2D(1.5, 2.0)
        });
<span class="fc" id="L910">    }</span>

    @Test
    public void testXor() {
        // arrange
<span class="fc" id="L915">        Cartesian2D[][] vertices1 = new Cartesian2D[][] {</span>
            new Cartesian2D[] {
                new Cartesian2D( 0.0,  0.0),
                new Cartesian2D( 2.0,  0.0),
                new Cartesian2D( 2.0,  2.0),
                new Cartesian2D( 0.0,  2.0)
            }
        };
<span class="fc" id="L923">        PolygonsSet set1 = buildSet(vertices1);</span>
<span class="fc" id="L924">        Cartesian2D[][] vertices2 = new Cartesian2D[][] {</span>
            new Cartesian2D[] {
                new Cartesian2D( 1.0,  1.0),
                new Cartesian2D( 3.0,  1.0),
                new Cartesian2D( 3.0,  3.0),
                new Cartesian2D( 1.0,  3.0)
            }
        };
<span class="fc" id="L932">        PolygonsSet set2 = buildSet(vertices2);</span>

        // act
<span class="fc" id="L935">        PolygonsSet set  = (PolygonsSet) new RegionFactory&lt;Euclidean2D&gt;().xor(set1.copySelf(),</span>
<span class="fc" id="L936">                                                                              set2.copySelf());</span>

        // assert
<span class="fc" id="L939">        checkVertexLoopsEquivalent(vertices1, set1.getVertices());</span>
<span class="fc" id="L940">        checkVertexLoopsEquivalent(vertices2, set2.getVertices());</span>
<span class="fc" id="L941">        checkVertexLoopsEquivalent(new Cartesian2D[][] {</span>
            new Cartesian2D[] {
                new Cartesian2D( 0.0,  0.0),
                new Cartesian2D( 2.0,  0.0),
                new Cartesian2D( 2.0,  1.0),
                new Cartesian2D( 3.0,  1.0),
                new Cartesian2D( 3.0,  3.0),
                new Cartesian2D( 1.0,  3.0),
                new Cartesian2D( 1.0,  2.0),
                new Cartesian2D( 0.0,  2.0)
            },
            new Cartesian2D[] {
                new Cartesian2D( 1.0,  1.0),
                new Cartesian2D( 1.0,  2.0),
                new Cartesian2D( 2.0,  2.0),
                new Cartesian2D( 2.0,  1.0)
            }
<span class="fc" id="L958">        }, set.getVertices());</span>

<span class="fc" id="L960">        checkPoints(Region.Location.INSIDE, set, new Cartesian2D[] {</span>
            new Cartesian2D(0.5, 0.5),
            new Cartesian2D(2.5, 2.5),
            new Cartesian2D(0.5, 1.5),
            new Cartesian2D(1.5, 0.5),
            new Cartesian2D(1.5, 2.5),
            new Cartesian2D(2.5, 1.5),
            new Cartesian2D(2.5, 2.5)
        });
<span class="fc" id="L969">        checkPoints(Region.Location.OUTSIDE, set, new Cartesian2D[] {</span>
            new Cartesian2D(-0.5, 0.5),
            new Cartesian2D( 0.5, 2.5),
            new Cartesian2D( 2.5, 0.5),
            new Cartesian2D( 1.5, 1.5),
            new Cartesian2D( 3.5, 2.5)
        });
<span class="fc" id="L976">        checkPoints(Region.Location.BOUNDARY, set, new Cartesian2D[] {</span>
            new Cartesian2D(1.0, 1.0),
            new Cartesian2D(2.0, 2.0),
            new Cartesian2D(1.5, 1.0),
            new Cartesian2D(2.0, 1.5),
            new Cartesian2D(0.0, 0.0),
            new Cartesian2D(0.5, 2.0),
            new Cartesian2D(2.0, 0.5),
            new Cartesian2D(2.5, 1.0),
            new Cartesian2D(3.0, 2.5)
        });
<span class="fc" id="L987">    }</span>

    @Test
    public void testDifference() {
        // arrange
<span class="fc" id="L992">        Cartesian2D[][] vertices1 = new Cartesian2D[][] {</span>
            new Cartesian2D[] {
                new Cartesian2D( 0.0,  0.0),
                new Cartesian2D( 2.0,  0.0),
                new Cartesian2D( 2.0,  2.0),
                new Cartesian2D( 0.0,  2.0)
            }
        };
<span class="fc" id="L1000">        PolygonsSet set1 = buildSet(vertices1);</span>
<span class="fc" id="L1001">        Cartesian2D[][] vertices2 = new Cartesian2D[][] {</span>
            new Cartesian2D[] {
                new Cartesian2D( 1.0,  1.0),
                new Cartesian2D( 3.0,  1.0),
                new Cartesian2D( 3.0,  3.0),
                new Cartesian2D( 1.0,  3.0)
            }
        };
<span class="fc" id="L1009">        PolygonsSet set2 = buildSet(vertices2);</span>

        // act
<span class="fc" id="L1012">        PolygonsSet set  = (PolygonsSet) new RegionFactory&lt;Euclidean2D&gt;().difference(set1.copySelf(),</span>
<span class="fc" id="L1013">                                                                                     set2.copySelf());</span>

        // assert
<span class="fc" id="L1016">        checkVertexLoopsEquivalent(vertices1, set1.getVertices());</span>
<span class="fc" id="L1017">        checkVertexLoopsEquivalent(vertices2, set2.getVertices());</span>
<span class="fc" id="L1018">        checkVertexLoopsEquivalent(new Cartesian2D[][] {</span>
            new Cartesian2D[] {
                new Cartesian2D( 0.0,  0.0),
                new Cartesian2D( 2.0,  0.0),
                new Cartesian2D( 2.0,  1.0),
                new Cartesian2D( 1.0,  1.0),
                new Cartesian2D( 1.0,  2.0),
                new Cartesian2D( 0.0,  2.0)
            }
<span class="fc" id="L1027">        }, set.getVertices());</span>

<span class="fc" id="L1029">        checkPoints(Region.Location.INSIDE, set, new Cartesian2D[] {</span>
            new Cartesian2D(0.5, 0.5),
            new Cartesian2D(0.5, 1.5),
            new Cartesian2D(1.5, 0.5)
        });
<span class="fc" id="L1034">        checkPoints(Region.Location.OUTSIDE, set, new Cartesian2D[] {</span>
            new Cartesian2D( 2.5, 2.5),
            new Cartesian2D(-0.5, 0.5),
            new Cartesian2D( 0.5, 2.5),
            new Cartesian2D( 2.5, 0.5),
            new Cartesian2D( 1.5, 1.5),
            new Cartesian2D( 3.5, 2.5),
            new Cartesian2D( 1.5, 2.5),
            new Cartesian2D( 2.5, 1.5),
            new Cartesian2D( 2.0, 1.5),
            new Cartesian2D( 2.0, 2.0),
            new Cartesian2D( 2.5, 1.0),
            new Cartesian2D( 2.5, 2.5),
            new Cartesian2D( 3.0, 2.5)
        });
<span class="fc" id="L1049">        checkPoints(Region.Location.BOUNDARY, set, new Cartesian2D[] {</span>
            new Cartesian2D(1.0, 1.0),
            new Cartesian2D(1.5, 1.0),
            new Cartesian2D(0.0, 0.0),
            new Cartesian2D(0.5, 2.0),
            new Cartesian2D(2.0, 0.5)
        });
<span class="fc" id="L1056">    }</span>

    @Test
    public void testEmptyDifference() {
        // arrange
<span class="fc" id="L1061">        Cartesian2D[][] vertices1 = new Cartesian2D[][] {</span>
            new Cartesian2D[] {
                new Cartesian2D( 0.5, 3.5),
                new Cartesian2D( 0.5, 4.5),
                new Cartesian2D(-0.5, 4.5),
                new Cartesian2D(-0.5, 3.5)
            }
        };
<span class="fc" id="L1069">        PolygonsSet set1 = buildSet(vertices1);</span>
<span class="fc" id="L1070">        Cartesian2D[][] vertices2 = new Cartesian2D[][] {</span>
            new Cartesian2D[] {
                new Cartesian2D( 1.0, 2.0),
                new Cartesian2D( 1.0, 8.0),
                new Cartesian2D(-1.0, 8.0),
                new Cartesian2D(-1.0, 2.0)
            }
        };
<span class="fc" id="L1078">        PolygonsSet set2 = buildSet(vertices2);</span>

        // act
<span class="fc" id="L1081">        PolygonsSet diff = (PolygonsSet) new RegionFactory&lt;Euclidean2D&gt;().difference(set1.copySelf(), set2.copySelf());</span>

        // assert
<span class="fc" id="L1084">        Assert.assertEquals(0.0, diff.getSize(), TEST_TOLERANCE);</span>
<span class="fc" id="L1085">        Assert.assertTrue(diff.isEmpty());</span>
<span class="fc" id="L1086">    }</span>

    @Test
    public void testChoppedHexagon() {
        // arrange
<span class="fc" id="L1091">        double pi6   = FastMath.PI / 6.0;</span>
<span class="fc" id="L1092">        double sqrt3 = FastMath.sqrt(3.0);</span>
<span class="fc" id="L1093">        SubLine[] hyp = {</span>
<span class="fc" id="L1094">            new Line(new Cartesian2D(   0.0, 1.0),  5 * pi6, TEST_TOLERANCE).wholeHyperplane(),</span>
<span class="fc" id="L1095">            new Line(new Cartesian2D(-sqrt3, 1.0),  7 * pi6, TEST_TOLERANCE).wholeHyperplane(),</span>
<span class="fc" id="L1096">            new Line(new Cartesian2D(-sqrt3, 1.0),  9 * pi6, TEST_TOLERANCE).wholeHyperplane(),</span>
<span class="fc" id="L1097">            new Line(new Cartesian2D(-sqrt3, 0.0), 11 * pi6, TEST_TOLERANCE).wholeHyperplane(),</span>
<span class="fc" id="L1098">            new Line(new Cartesian2D(   0.0, 0.0), 13 * pi6, TEST_TOLERANCE).wholeHyperplane(),</span>
<span class="fc" id="L1099">            new Line(new Cartesian2D(   0.0, 1.0),  3 * pi6, TEST_TOLERANCE).wholeHyperplane(),</span>
<span class="fc" id="L1100">            new Line(new Cartesian2D(-5.0 * sqrt3 / 6.0, 0.0), 9 * pi6, TEST_TOLERANCE).wholeHyperplane()</span>
        };
<span class="fc" id="L1102">        hyp[1] = (SubLine) hyp[1].split(hyp[0].getHyperplane()).getMinus();</span>
<span class="fc" id="L1103">        hyp[2] = (SubLine) hyp[2].split(hyp[1].getHyperplane()).getMinus();</span>
<span class="fc" id="L1104">        hyp[3] = (SubLine) hyp[3].split(hyp[2].getHyperplane()).getMinus();</span>
<span class="fc" id="L1105">        hyp[4] = (SubLine) hyp[4].split(hyp[3].getHyperplane()).getMinus().split(hyp[0].getHyperplane()).getMinus();</span>
<span class="fc" id="L1106">        hyp[5] = (SubLine) hyp[5].split(hyp[4].getHyperplane()).getMinus().split(hyp[0].getHyperplane()).getMinus();</span>
<span class="fc" id="L1107">        hyp[6] = (SubLine) hyp[6].split(hyp[3].getHyperplane()).getMinus().split(hyp[1].getHyperplane()).getMinus();</span>
<span class="fc" id="L1108">        BSPTree&lt;Euclidean2D&gt; tree = new BSPTree&lt;&gt;(Boolean.TRUE);</span>
<span class="fc bfc" id="L1109" title="All 2 branches covered.">        for (int i = hyp.length - 1; i &gt;= 0; --i) {</span>
<span class="fc" id="L1110">            tree = new BSPTree&lt;&gt;(hyp[i], new BSPTree&lt;Euclidean2D&gt;(Boolean.FALSE), tree, null);</span>
        }
<span class="fc" id="L1112">        PolygonsSet set = new PolygonsSet(tree, TEST_TOLERANCE);</span>
<span class="fc" id="L1113">        SubLine splitter =</span>
<span class="fc" id="L1114">            new Line(new Cartesian2D(-2.0 * sqrt3 / 3.0, 0.0), 9 * pi6, TEST_TOLERANCE).wholeHyperplane();</span>

        // act
<span class="fc" id="L1117">        PolygonsSet slice =</span>
            new PolygonsSet(new BSPTree&lt;&gt;(splitter,
<span class="fc" id="L1119">                                                     set.getTree(false).split(splitter).getPlus(),</span>
                                                     new BSPTree&lt;Euclidean2D&gt;(Boolean.FALSE), null),
                            TEST_TOLERANCE);

        // assert
<span class="fc" id="L1124">        Assert.assertEquals(Region.Location.OUTSIDE,</span>
<span class="fc" id="L1125">                            slice.checkPoint(new Cartesian2D(0.1, 0.5)));</span>
<span class="fc" id="L1126">        Assert.assertEquals(11.0 / 3.0, slice.getBoundarySize(), TEST_TOLERANCE);</span>
<span class="fc" id="L1127">    }</span>

    @Test
    public void testConcentric() {
        // arrange
<span class="fc" id="L1132">        double h = FastMath.sqrt(3.0) / 2.0;</span>
<span class="fc" id="L1133">        Cartesian2D[][] vertices1 = new Cartesian2D[][] {</span>
            new Cartesian2D[] {
                new Cartesian2D( 0.00, 0.1 * h),
                new Cartesian2D( 0.05, 0.1 * h),
                new Cartesian2D( 0.10, 0.2 * h),
                new Cartesian2D( 0.05, 0.3 * h),
                new Cartesian2D(-0.05, 0.3 * h),
                new Cartesian2D(-0.10, 0.2 * h),
                new Cartesian2D(-0.05, 0.1 * h)
            }
        };
<span class="fc" id="L1144">        PolygonsSet set1 = buildSet(vertices1);</span>
<span class="fc" id="L1145">        Cartesian2D[][] vertices2 = new Cartesian2D[][] {</span>
            new Cartesian2D[] {
                new Cartesian2D( 0.00, 0.0 * h),
                new Cartesian2D( 0.10, 0.0 * h),
                new Cartesian2D( 0.20, 0.2 * h),
                new Cartesian2D( 0.10, 0.4 * h),
                new Cartesian2D(-0.10, 0.4 * h),
                new Cartesian2D(-0.20, 0.2 * h),
                new Cartesian2D(-0.10, 0.0 * h)
            }
        };
<span class="fc" id="L1156">        PolygonsSet set2 = buildSet(vertices2);</span>

        // act/assert
<span class="fc" id="L1159">        Assert.assertTrue(set2.contains(set1));</span>
<span class="fc" id="L1160">    }</span>

    @Test
    public void testBug20040520() {
        // arrange
<span class="fc" id="L1165">        BSPTree&lt;Euclidean2D&gt; a0 =</span>
<span class="fc" id="L1166">            new BSPTree&lt;&gt;(buildSegment(new Cartesian2D(0.85, -0.05),</span>
                                                  new Cartesian2D(0.90, -0.10)),
                                                  new BSPTree&lt;Euclidean2D&gt;(Boolean.FALSE),
                                                  new BSPTree&lt;Euclidean2D&gt;(Boolean.TRUE),
                                                  null);
<span class="fc" id="L1171">        BSPTree&lt;Euclidean2D&gt; a1 =</span>
<span class="fc" id="L1172">            new BSPTree&lt;&gt;(buildSegment(new Cartesian2D(0.85, -0.10),</span>
                                                  new Cartesian2D(0.90, -0.10)),
                                                  new BSPTree&lt;Euclidean2D&gt;(Boolean.FALSE), a0, null);
<span class="fc" id="L1175">        BSPTree&lt;Euclidean2D&gt; a2 =</span>
<span class="fc" id="L1176">            new BSPTree&lt;&gt;(buildSegment(new Cartesian2D(0.90, -0.05),</span>
                                                  new Cartesian2D(0.85, -0.05)),
                                                  new BSPTree&lt;Euclidean2D&gt;(Boolean.FALSE), a1, null);
<span class="fc" id="L1179">        BSPTree&lt;Euclidean2D&gt; a3 =</span>
<span class="fc" id="L1180">            new BSPTree&lt;&gt;(buildSegment(new Cartesian2D(0.82, -0.05),</span>
                                                  new Cartesian2D(0.82, -0.08)),
                                                  new BSPTree&lt;Euclidean2D&gt;(Boolean.FALSE),
                                                  new BSPTree&lt;Euclidean2D&gt;(Boolean.TRUE),
                                                  null);
<span class="fc" id="L1185">        BSPTree&lt;Euclidean2D&gt; a4 =</span>
<span class="fc" id="L1186">            new BSPTree&lt;&gt;(buildHalfLine(new Cartesian2D(0.85, -0.05),</span>
                                                   new Cartesian2D(0.80, -0.05),
                                                   false),
                                                   new BSPTree&lt;Euclidean2D&gt;(Boolean.FALSE), a3, null);
<span class="fc" id="L1190">        BSPTree&lt;Euclidean2D&gt; a5 =</span>
<span class="fc" id="L1191">            new BSPTree&lt;&gt;(buildSegment(new Cartesian2D(0.82, -0.08),</span>
                                                  new Cartesian2D(0.82, -0.18)),
                                                  new BSPTree&lt;Euclidean2D&gt;(Boolean.FALSE),
                                                  new BSPTree&lt;Euclidean2D&gt;(Boolean.TRUE),
                                                  null);
<span class="fc" id="L1196">        BSPTree&lt;Euclidean2D&gt; a6 =</span>
<span class="fc" id="L1197">            new BSPTree&lt;&gt;(buildHalfLine(new Cartesian2D(0.82, -0.18),</span>
                                                   new Cartesian2D(0.85, -0.15),
                                                   true),
                                                   new BSPTree&lt;Euclidean2D&gt;(Boolean.FALSE), a5, null);
<span class="fc" id="L1201">        BSPTree&lt;Euclidean2D&gt; a7 =</span>
<span class="fc" id="L1202">            new BSPTree&lt;&gt;(buildHalfLine(new Cartesian2D(0.85, -0.05),</span>
                                                   new Cartesian2D(0.82, -0.08),
                                                   false),
                                                   a4, a6, null);
<span class="fc" id="L1206">        BSPTree&lt;Euclidean2D&gt; a8 =</span>
<span class="fc" id="L1207">            new BSPTree&lt;&gt;(buildLine(new Cartesian2D(0.85, -0.25),</span>
                                               new Cartesian2D(0.85,  0.05)),
                                               a2, a7, null);
<span class="fc" id="L1210">        BSPTree&lt;Euclidean2D&gt; a9 =</span>
<span class="fc" id="L1211">            new BSPTree&lt;&gt;(buildLine(new Cartesian2D(0.90,  0.05),</span>
                                               new Cartesian2D(0.90, -0.50)),
                                               a8, new BSPTree&lt;Euclidean2D&gt;(Boolean.FALSE), null);

<span class="fc" id="L1215">        BSPTree&lt;Euclidean2D&gt; b0 =</span>
<span class="fc" id="L1216">            new BSPTree&lt;&gt;(buildSegment(new Cartesian2D(0.92, -0.12),</span>
                                                  new Cartesian2D(0.92, -0.08)),
                                                  new BSPTree&lt;Euclidean2D&gt;(Boolean.FALSE), new BSPTree&lt;Euclidean2D&gt;(Boolean.TRUE),
                                                  null);
<span class="fc" id="L1220">        BSPTree&lt;Euclidean2D&gt; b1 =</span>
<span class="fc" id="L1221">            new BSPTree&lt;&gt;(buildHalfLine(new Cartesian2D(0.92, -0.08),</span>
                                                   new Cartesian2D(0.90, -0.10),
                                                   true),
                                                   new BSPTree&lt;Euclidean2D&gt;(Boolean.FALSE), b0, null);
<span class="fc" id="L1225">        BSPTree&lt;Euclidean2D&gt; b2 =</span>
<span class="fc" id="L1226">            new BSPTree&lt;&gt;(buildSegment(new Cartesian2D(0.92, -0.18),</span>
                                                  new Cartesian2D(0.92, -0.12)),
                                                  new BSPTree&lt;Euclidean2D&gt;(Boolean.FALSE), new BSPTree&lt;Euclidean2D&gt;(Boolean.TRUE),
                                                  null);
<span class="fc" id="L1230">        BSPTree&lt;Euclidean2D&gt; b3 =</span>
<span class="fc" id="L1231">            new BSPTree&lt;&gt;(buildSegment(new Cartesian2D(0.85, -0.15),</span>
                                                  new Cartesian2D(0.90, -0.20)),
                                                  new BSPTree&lt;Euclidean2D&gt;(Boolean.FALSE), b2, null);
<span class="fc" id="L1234">        BSPTree&lt;Euclidean2D&gt; b4 =</span>
<span class="fc" id="L1235">            new BSPTree&lt;&gt;(buildSegment(new Cartesian2D(0.95, -0.15),</span>
                                                  new Cartesian2D(0.85, -0.05)),
                                                  b1, b3, null);
<span class="fc" id="L1238">        BSPTree&lt;Euclidean2D&gt; b5 =</span>
<span class="fc" id="L1239">            new BSPTree&lt;&gt;(buildHalfLine(new Cartesian2D(0.85, -0.05),</span>
                                                   new Cartesian2D(0.85, -0.25),
                                                   true),
                                                   new BSPTree&lt;Euclidean2D&gt;(Boolean.FALSE), b4, null);
<span class="fc" id="L1243">        BSPTree&lt;Euclidean2D&gt; b6 =</span>
<span class="fc" id="L1244">            new BSPTree&lt;&gt;(buildLine(new Cartesian2D(0.0, -1.10),</span>
                                               new Cartesian2D(1.0, -0.10)),
                                               new BSPTree&lt;Euclidean2D&gt;(Boolean.FALSE), b5, null);

        // act
<span class="fc" id="L1249">        PolygonsSet c =</span>
<span class="fc" id="L1250">            (PolygonsSet) new RegionFactory&lt;Euclidean2D&gt;().union(new PolygonsSet(a9, TEST_TOLERANCE),</span>
                                                                 new PolygonsSet(b6, TEST_TOLERANCE));

        // assert
<span class="fc" id="L1254">        checkPoints(Region.Location.INSIDE, c, new Cartesian2D[] {</span>
            new Cartesian2D(0.83, -0.06),
            new Cartesian2D(0.83, -0.15),
            new Cartesian2D(0.88, -0.15),
            new Cartesian2D(0.88, -0.09),
            new Cartesian2D(0.88, -0.07),
            new Cartesian2D(0.91, -0.18),
            new Cartesian2D(0.91, -0.10)
        });

<span class="fc" id="L1264">        checkPoints(Region.Location.OUTSIDE, c, new Cartesian2D[] {</span>
            new Cartesian2D(0.80, -0.10),
            new Cartesian2D(0.83, -0.50),
            new Cartesian2D(0.83, -0.20),
            new Cartesian2D(0.83, -0.02),
            new Cartesian2D(0.87, -0.50),
            new Cartesian2D(0.87, -0.20),
            new Cartesian2D(0.87, -0.02),
            new Cartesian2D(0.91, -0.20),
            new Cartesian2D(0.91, -0.08),
            new Cartesian2D(0.93, -0.15)
        });

<span class="fc" id="L1277">        checkVertexLoopsEquivalent(new Cartesian2D[][] {</span>
            new Cartesian2D[] {
                new Cartesian2D(0.85, -0.15),
                new Cartesian2D(0.90, -0.20),
                new Cartesian2D(0.92, -0.18),
                new Cartesian2D(0.92, -0.08),
                new Cartesian2D(0.90, -0.10),
                new Cartesian2D(0.90, -0.05),
                new Cartesian2D(0.82, -0.05),
                new Cartesian2D(0.82, -0.18),
            }
<span class="fc" id="L1288">        }, c.getVertices());</span>
<span class="fc" id="L1289">    }</span>

    @Test
    public void testBug20041003() {
        // arrange
<span class="fc" id="L1294">        Line[] l = {</span>
            new Line(new Cartesian2D(0.0, 0.625000007541172),
                     new Cartesian2D(1.0, 0.625000007541172), TEST_TOLERANCE),
            new Line(new Cartesian2D(-0.19204433621902645, 0.0),
                     new Cartesian2D(-0.19204433621902645, 1.0), TEST_TOLERANCE),
            new Line(new Cartesian2D(-0.40303524786887,  0.4248364535319128),
                     new Cartesian2D(-1.12851149797877, -0.2634107480798909), TEST_TOLERANCE),
            new Line(new Cartesian2D(0.0, 2.0),
                     new Cartesian2D(1.0, 2.0), TEST_TOLERANCE)
        };

<span class="fc" id="L1305">        BSPTree&lt;Euclidean2D&gt; node1 =</span>
            new BSPTree&lt;&gt;(new SubLine(l[0],
<span class="fc" id="L1307">                                                 new IntervalsSet(intersectionAbscissa(l[0], l[1]),</span>
<span class="fc" id="L1308">                                                                  intersectionAbscissa(l[0], l[2]),</span>
                                                                  TEST_TOLERANCE)),
                                     new BSPTree&lt;Euclidean2D&gt;(Boolean.TRUE),
                                     new BSPTree&lt;Euclidean2D&gt;(Boolean.FALSE),
                                     null);
<span class="fc" id="L1313">        BSPTree&lt;Euclidean2D&gt; node2 =</span>
            new BSPTree&lt;&gt;(new SubLine(l[1],
<span class="fc" id="L1315">                                                 new IntervalsSet(intersectionAbscissa(l[1], l[2]),</span>
<span class="fc" id="L1316">                                                                  intersectionAbscissa(l[1], l[3]),</span>
                                                                  TEST_TOLERANCE)),
                                     node1,
                                     new BSPTree&lt;Euclidean2D&gt;(Boolean.FALSE),
                                     null);
<span class="fc" id="L1321">        BSPTree&lt;Euclidean2D&gt; node3 =</span>
            new BSPTree&lt;&gt;(new SubLine(l[2],
<span class="fc" id="L1323">                                                 new IntervalsSet(intersectionAbscissa(l[2], l[3]),</span>
                                                 Double.POSITIVE_INFINITY, TEST_TOLERANCE)),
                                     node2,
                                     new BSPTree&lt;Euclidean2D&gt;(Boolean.FALSE),
                                     null);
<span class="fc" id="L1328">        BSPTree&lt;Euclidean2D&gt; node4 =</span>
<span class="fc" id="L1329">            new BSPTree&lt;&gt;(l[3].wholeHyperplane(),</span>
                                     node3,
                                     new BSPTree&lt;Euclidean2D&gt;(Boolean.FALSE),
                                     null);

        // act
<span class="fc" id="L1335">        PolygonsSet set = new PolygonsSet(node4, TEST_TOLERANCE);</span>

        // assert
<span class="fc" id="L1338">        Assert.assertEquals(0, set.getVertices().length);</span>
<span class="fc" id="L1339">    }</span>

    @Test
    public void testSqueezedHexa() {
        // act
<span class="fc" id="L1344">        PolygonsSet set = new PolygonsSet(TEST_TOLERANCE,</span>
                                          new Cartesian2D(-6, -4), new Cartesian2D(-8, -8), new Cartesian2D(  8, -8),
                                          new Cartesian2D( 6, -4), new Cartesian2D(10,  4), new Cartesian2D(-10,  4));

        // assert
<span class="fc" id="L1349">        Assert.assertEquals(Location.OUTSIDE, set.checkPoint(new Cartesian2D(0, 6)));</span>
<span class="fc" id="L1350">    }</span>

    @Test
    public void testIssue880Simplified() {
        // arrange
<span class="fc" id="L1355">        Cartesian2D[] vertices1 = new Cartesian2D[] {</span>
            new Cartesian2D( 90.13595870833188,  38.33604606376991),
            new Cartesian2D( 90.14047850603913,  38.34600084496253),
            new Cartesian2D( 90.11045289492762,  38.36801537312368),
            new Cartesian2D( 90.10871471476526,  38.36878044144294),
            new Cartesian2D( 90.10424901707671,  38.374300101757),
            new Cartesian2D( 90.0979455456843,   38.373578376172475),
            new Cartesian2D( 90.09081227075944,  38.37526295920463),
            new Cartesian2D( 90.09081378927135,  38.375193883266434)
        };

        // act
<span class="fc" id="L1367">        PolygonsSet set1 = new PolygonsSet(TEST_TOLERANCE, vertices1);</span>

        // assert
<span class="fc" id="L1370">        Assert.assertEquals(Location.OUTSIDE, set1.checkPoint(new Cartesian2D(90.12,  38.32)));</span>
<span class="fc" id="L1371">        Assert.assertEquals(Location.OUTSIDE, set1.checkPoint(new Cartesian2D(90.135, 38.355)));</span>

<span class="fc" id="L1373">    }</span>

    @Test
    public void testIssue880Complete() {
<span class="fc" id="L1377">        Cartesian2D[] vertices1 = new Cartesian2D[] {</span>
                new Cartesian2D( 90.08714908223715,  38.370299337260235),
                new Cartesian2D( 90.08709517675004,  38.3702895991413),
                new Cartesian2D( 90.08401538704919,  38.368849330127944),
                new Cartesian2D( 90.08258210430711,  38.367634558585564),
                new Cartesian2D( 90.08251455106665,  38.36763409247078),
                new Cartesian2D( 90.08106599752608,  38.36761621664249),
                new Cartesian2D( 90.08249585300035,  38.36753627557965),
                new Cartesian2D( 90.09075743352184,  38.35914647644972),
                new Cartesian2D( 90.09099945896571,  38.35896264724079),
                new Cartesian2D( 90.09269383800086,  38.34595756121246),
                new Cartesian2D( 90.09638631543191,  38.3457988093121),
                new Cartesian2D( 90.09666417351019,  38.34523360999418),
                new Cartesian2D( 90.1297082145872,  38.337670454923625),
                new Cartesian2D( 90.12971687748956,  38.337669827794684),
                new Cartesian2D( 90.1240820219179,  38.34328502001131),
                new Cartesian2D( 90.13084259656404,  38.34017811765017),
                new Cartesian2D( 90.13378567942857,  38.33860579180606),
                new Cartesian2D( 90.13519557833206,  38.33621054663689),
                new Cartesian2D( 90.13545616732307,  38.33614965452864),
                new Cartesian2D( 90.13553111202748,  38.33613962818305),
                new Cartesian2D( 90.1356903436448,  38.33610227127048),
                new Cartesian2D( 90.13576283227428,  38.33609255422783),
                new Cartesian2D( 90.13595870833188,  38.33604606376991),
                new Cartesian2D( 90.1361556630693,  38.3360024198866),
                new Cartesian2D( 90.13622408795709,  38.335987048115726),
                new Cartesian2D( 90.13696189099994,  38.33581914328681),
                new Cartesian2D( 90.13746655304897,  38.33616706665265),
                new Cartesian2D( 90.13845973716064,  38.33650776167099),
                new Cartesian2D( 90.13950901827667,  38.3368469456463),
                new Cartesian2D( 90.14393814424852,  38.337591835857495),
                new Cartesian2D( 90.14483839716831,  38.337076122362475),
                new Cartesian2D( 90.14565474433601,  38.33769000964429),
                new Cartesian2D( 90.14569421179482,  38.3377117256905),
                new Cartesian2D( 90.14577067124333,  38.33770883625908),
                new Cartesian2D( 90.14600350631684,  38.337714326520995),
                new Cartesian2D( 90.14600355139731,  38.33771435193319),
                new Cartesian2D( 90.14600369112401,  38.33771443882085),
                new Cartesian2D( 90.14600382486884,  38.33771453466096),
                new Cartesian2D( 90.14600395205912,  38.33771463904344),
                new Cartesian2D( 90.14600407214999,  38.337714751520764),
                new Cartesian2D( 90.14600418462749,  38.337714871611695),
                new Cartesian2D( 90.14600422249327,  38.337714915811034),
                new Cartesian2D( 90.14867838361471,  38.34113888210675),
                new Cartesian2D( 90.14923750157374,  38.341582537502575),
                new Cartesian2D( 90.14877083250991,  38.34160685841391),
                new Cartesian2D( 90.14816667319519,  38.34244232585684),
                new Cartesian2D( 90.14797696744586,  38.34248455284745),
                new Cartesian2D( 90.14484318014337,  38.34385573215269),
                new Cartesian2D( 90.14477919958296,  38.3453797747614),
                new Cartesian2D( 90.14202393306448,  38.34464324839456),
                new Cartesian2D( 90.14198920640195,  38.344651155237216),
                new Cartesian2D( 90.14155207025175,  38.34486424263724),
                new Cartesian2D( 90.1415196143314,  38.344871730519),
                new Cartesian2D( 90.14128611910814,  38.34500196593859),
                new Cartesian2D( 90.14047850603913,  38.34600084496253),
                new Cartesian2D( 90.14045907000337,  38.34601860032171),
                new Cartesian2D( 90.14039496493928,  38.346223030432384),
                new Cartesian2D( 90.14037626063737,  38.346240203360026),
                new Cartesian2D( 90.14030005823724,  38.34646920000705),
                new Cartesian2D( 90.13799164754806,  38.34903093011013),
                new Cartesian2D( 90.11045289492762,  38.36801537312368),
                new Cartesian2D( 90.10871471476526,  38.36878044144294),
                new Cartesian2D( 90.10424901707671,  38.374300101757),
                new Cartesian2D( 90.10263482039932,  38.37310041316073),
                new Cartesian2D( 90.09834601753448,  38.373615053823414),
                new Cartesian2D( 90.0979455456843,  38.373578376172475),
                new Cartesian2D( 90.09086514328669,  38.37527884194668),
                new Cartesian2D( 90.09084931407364,  38.37590801712463),
                new Cartesian2D( 90.09081227075944,  38.37526295920463),
                new Cartesian2D( 90.09081378927135,  38.375193883266434)
        };
<span class="fc" id="L1449">        PolygonsSet set1 = new PolygonsSet(1.0e-8, vertices1);</span>
<span class="fc" id="L1450">        Assert.assertEquals(Location.OUTSIDE, set1.checkPoint(new Cartesian2D(90.0905,  38.3755)));</span>
<span class="fc" id="L1451">        Assert.assertEquals(Location.INSIDE,  set1.checkPoint(new Cartesian2D(90.09084, 38.3755)));</span>
<span class="fc" id="L1452">        Assert.assertEquals(Location.OUTSIDE, set1.checkPoint(new Cartesian2D(90.0913,  38.3755)));</span>
<span class="fc" id="L1453">        Assert.assertEquals(Location.INSIDE,  set1.checkPoint(new Cartesian2D(90.1042,  38.3739)));</span>
<span class="fc" id="L1454">        Assert.assertEquals(Location.INSIDE,  set1.checkPoint(new Cartesian2D(90.1111,  38.3673)));</span>
<span class="fc" id="L1455">        Assert.assertEquals(Location.OUTSIDE, set1.checkPoint(new Cartesian2D(90.0959,  38.3457)));</span>

<span class="fc" id="L1457">        Cartesian2D[] vertices2 = new Cartesian2D[] {</span>
                new Cartesian2D( 90.13067558880044,  38.36977255037573),
                new Cartesian2D( 90.12907570488,  38.36817308242706),
                new Cartesian2D( 90.1342774136516,  38.356886880294724),
                new Cartesian2D( 90.13090330629757,  38.34664392676211),
                new Cartesian2D( 90.13078571364593,  38.344904617518466),
                new Cartesian2D( 90.1315602208914,  38.3447185040846),
                new Cartesian2D( 90.1316336226821,  38.34470643148342),
                new Cartesian2D( 90.134020944832,  38.340936644972885),
                new Cartesian2D( 90.13912536387306,  38.335497255122334),
                new Cartesian2D( 90.1396178806582,  38.334878075552126),
                new Cartesian2D( 90.14083049696671,  38.33316530644106),
                new Cartesian2D( 90.14145252901329,  38.33152722916191),
                new Cartesian2D( 90.1404779335565,  38.32863516047786),
                new Cartesian2D( 90.14282712131586,  38.327504432532066),
                new Cartesian2D( 90.14616669875488,  38.3237354115015),
                new Cartesian2D( 90.14860976050608,  38.315714862457924),
                new Cartesian2D( 90.14999277782437,  38.3164932507504),
                new Cartesian2D( 90.15005207194997,  38.316534677663356),
                new Cartesian2D( 90.15508513859612,  38.31878731691609),
                new Cartesian2D( 90.15919938519221,  38.31852743183782),
                new Cartesian2D( 90.16093758658837,  38.31880662005153),
                new Cartesian2D( 90.16099420184912,  38.318825953291594),
                new Cartesian2D( 90.1665411125756,  38.31859497874757),
                new Cartesian2D( 90.16999653861313,  38.32505772048029),
                new Cartesian2D( 90.17475243391698,  38.32594398441148),
                new Cartesian2D( 90.17940844844992,  38.327427213761325),
                new Cartesian2D( 90.20951909541378,  38.330616833491774),
                new Cartesian2D( 90.2155400467941,  38.331746223670336),
                new Cartesian2D( 90.21559881391778,  38.33175551425302),
                new Cartesian2D( 90.21916646426041,  38.332584299620805),
                new Cartesian2D( 90.23863749852285,  38.34778978875795),
                new Cartesian2D( 90.25459855175802,  38.357790570608984),
                new Cartesian2D( 90.25964298227257,  38.356918010203174),
                new Cartesian2D( 90.26024593994703,  38.361692743151366),
                new Cartesian2D( 90.26146187570015,  38.36311080550837),
                new Cartesian2D( 90.26614159359622,  38.36510808579902),
                new Cartesian2D( 90.26621342936448,  38.36507942500333),
                new Cartesian2D( 90.26652190211962,  38.36494042196722),
                new Cartesian2D( 90.26621240678867,  38.365113172030874),
                new Cartesian2D( 90.26614057102057,  38.365141832826794),
                new Cartesian2D( 90.26380080055299,  38.3660381760273),
                new Cartesian2D( 90.26315345241,  38.36670658276421),
                new Cartesian2D( 90.26251574942881,  38.367490323488084),
                new Cartesian2D( 90.26247873448426,  38.36755266444749),
                new Cartesian2D( 90.26234628016698,  38.36787989125406),
                new Cartesian2D( 90.26214559424784,  38.36945909356126),
                new Cartesian2D( 90.25861728442555,  38.37200753430875),
                new Cartesian2D( 90.23905557537864,  38.375405314295904),
                new Cartesian2D( 90.22517251874075,  38.38984691662256),
                new Cartesian2D( 90.22549955153215,  38.3911564273979),
                new Cartesian2D( 90.22434386063355,  38.391476432092134),
                new Cartesian2D( 90.22147729457276,  38.39134652252034),
                new Cartesian2D( 90.22142070120117,  38.391349167741964),
                new Cartesian2D( 90.20665060751588,  38.39475580900313),
                new Cartesian2D( 90.20042268367109,  38.39842558622888),
                new Cartesian2D( 90.17423771242085,  38.402727751805344),
                new Cartesian2D( 90.16756796257476,  38.40913898597597),
                new Cartesian2D( 90.16728283954308,  38.411255399912875),
                new Cartesian2D( 90.16703538220418,  38.41136059866693),
                new Cartesian2D( 90.16725865657685,  38.41013618805954),
                new Cartesian2D( 90.16746107640665,  38.40902614307544),
                new Cartesian2D( 90.16122795307462,  38.39773101873203)
        };
<span class="fc" id="L1521">        PolygonsSet set2 = new PolygonsSet(1.0e-8, vertices2);</span>
<span class="fc" id="L1522">        PolygonsSet set  = (PolygonsSet) new</span>
<span class="fc" id="L1523">                RegionFactory&lt;Euclidean2D&gt;().difference(set1.copySelf(),</span>
<span class="fc" id="L1524">                                                        set2.copySelf());</span>

<span class="fc" id="L1526">        Cartesian2D[][] vertices = set.getVertices();</span>
<span class="pc bpc" id="L1527" title="1 of 2 branches missed.">        Assert.assertTrue(vertices[0][0] != null);</span>
<span class="fc" id="L1528">        Assert.assertEquals(1, vertices.length);</span>
<span class="fc" id="L1529">    }</span>

    @Test
    public void testTooThinBox() {
        // act/assert
<span class="fc" id="L1534">        Assert.assertEquals(0.0,</span>
<span class="fc" id="L1535">                            new PolygonsSet(0.0, 0.0, 0.0, 10.3206397147574, TEST_TOLERANCE).getSize(),</span>
                            TEST_TOLERANCE);
<span class="fc" id="L1537">    }</span>

    @Test
    public void testWrongUsage() {
        // the following is a wrong usage of the constructor.
        // as explained in the javadoc, the failure is NOT detected at construction
        // time but occurs later on
<span class="fc" id="L1544">        PolygonsSet ps = new PolygonsSet(new BSPTree&lt;Euclidean2D&gt;(), TEST_TOLERANCE);</span>
<span class="fc" id="L1545">        Assert.assertNotNull(ps);</span>
        try {
<span class="nc" id="L1547">            ps.getSize();</span>
<span class="nc" id="L1548">            Assert.fail(&quot;an exception should have been thrown&quot;);</span>
<span class="fc" id="L1549">        } catch (NullPointerException npe) {</span>
            // this is expected
<span class="nc" id="L1551">        }</span>
<span class="fc" id="L1552">    }</span>

    @Test
    public void testIssue1162() {
        // arrange
<span class="fc" id="L1557">        PolygonsSet p = new PolygonsSet(TEST_TOLERANCE,</span>
                                                new Cartesian2D(4.267199999996532, -11.928637756014894),
                                                new Cartesian2D(4.267200000026445, -14.12360595809307),
                                                new Cartesian2D(9.144000000273694, -14.12360595809307),
                                                new Cartesian2D(9.144000000233383, -11.928637756020067));

<span class="fc" id="L1563">        PolygonsSet w = new PolygonsSet(TEST_TOLERANCE,</span>
                                                new Cartesian2D(2.56735636510452512E-9, -11.933116461089332),
                                                new Cartesian2D(2.56735636510452512E-9, -12.393225665247766),
                                                new Cartesian2D(2.56735636510452512E-9, -27.785625665247778),
                                                new Cartesian2D(4.267200000030211,      -27.785625665247778),
                                                new Cartesian2D(4.267200000030211,      -11.933116461089332));

        // act/assert
<span class="fc" id="L1571">        Assert.assertFalse(p.contains(w));</span>
<span class="fc" id="L1572">    }</span>

    @Test
    public void testThinRectangle_toleranceLessThanWidth_resultIsAccurate() {
        // if tolerance is smaller than rectangle width, the rectangle is computed accurately

        // arrange
<span class="fc" id="L1579">        RegionFactory&lt;Euclidean2D&gt; factory = new RegionFactory&lt;&gt;();</span>
<span class="fc" id="L1580">        Cartesian2D pA = new Cartesian2D(0.0,        1.0);</span>
<span class="fc" id="L1581">        Cartesian2D pB = new Cartesian2D(0.0,        0.0);</span>
<span class="fc" id="L1582">        Cartesian2D pC = new Cartesian2D(1.0 / 64.0, 0.0);</span>
<span class="fc" id="L1583">        Cartesian2D pD = new Cartesian2D(1.0 / 64.0, 1.0);</span>

        // if tolerance is smaller than rectangle width, the rectangle is computed accurately
<span class="fc" id="L1586">        Hyperplane&lt;Euclidean2D&gt;[] h1 = new Line[] {</span>
            new Line(pA, pB, 1.0 / 256),
            new Line(pB, pC, 1.0 / 256),
            new Line(pC, pD, 1.0 / 256),
            new Line(pD, pA, 1.0 / 256)
        };

        // act
<span class="fc" id="L1594">        Region&lt;Euclidean2D&gt; accuratePolygon = factory.buildConvex(h1);</span>

        // assert
<span class="fc" id="L1597">        Assert.assertEquals(1.0 / 64.0, accuratePolygon.getSize(), TEST_TOLERANCE);</span>
<span class="fc" id="L1598">        GeometryTestUtils.assertPositiveInfinity(new RegionFactory&lt;Euclidean2D&gt;().getComplement(accuratePolygon).getSize());</span>
<span class="fc" id="L1599">        Assert.assertEquals(2 * (1.0 + 1.0 / 64.0), accuratePolygon.getBoundarySize(), TEST_TOLERANCE);</span>
<span class="fc" id="L1600">    }</span>

    @Test
    public void testThinRectangle_toleranceGreaterThanWidth_resultIsDegenerate() {
        // if tolerance is larger than rectangle width, the rectangle degenerates
        // as of 3.3, its two long edges cannot be distinguished anymore and this part of the test did fail
        // this has been fixed in 3.4 (issue MATH-1174)

        // arrange
<span class="fc" id="L1609">        RegionFactory&lt;Euclidean2D&gt; factory = new RegionFactory&lt;&gt;();</span>
<span class="fc" id="L1610">        Cartesian2D pA = new Cartesian2D(0.0,        1.0);</span>
<span class="fc" id="L1611">        Cartesian2D pB = new Cartesian2D(0.0,        0.0);</span>
<span class="fc" id="L1612">        Cartesian2D pC = new Cartesian2D(1.0 / 64.0, 0.0);</span>
<span class="fc" id="L1613">        Cartesian2D pD = new Cartesian2D(1.0 / 64.0, 1.0);</span>

<span class="fc" id="L1615">        Hyperplane&lt;Euclidean2D&gt;[] h2 = new Line[] {</span>
                new Line(pA, pB, 1.0 / 16),
                new Line(pB, pC, 1.0 / 16),
                new Line(pC, pD, 1.0 / 16),
                new Line(pD, pA, 1.0 / 16)
            };

        // act
<span class="fc" id="L1623">        Region&lt;Euclidean2D&gt; degeneratedPolygon = factory.buildConvex(h2);</span>

        // assert
<span class="fc" id="L1626">        Assert.assertEquals(0.0, degeneratedPolygon.getSize(), TEST_TOLERANCE);</span>
<span class="fc" id="L1627">        Assert.assertTrue(degeneratedPolygon.isEmpty());</span>
<span class="fc" id="L1628">    }</span>

    @Test(expected = MathIllegalArgumentException.class)
    public void testInconsistentHyperplanes() {
        // act
<span class="fc" id="L1633">        double tolerance = TEST_TOLERANCE;</span>
<span class="nc" id="L1634">        new RegionFactory&lt;Euclidean2D&gt;().buildConvex(new Line(new Cartesian2D(0, 0), new Cartesian2D(0, 1), tolerance),</span>
                                                     new Line(new Cartesian2D(1, 1), new Cartesian2D(1, 0), tolerance));
<span class="nc" id="L1636">    }</span>

    @Test
    public void testBoundarySimplification() {
        // a simple square will result in a 4 cuts and 5 leafs tree
<span class="fc" id="L1641">        PolygonsSet square = new PolygonsSet(TEST_TOLERANCE,</span>
                                             new Cartesian2D(0, 0),
                                             new Cartesian2D(1, 0),
                                             new Cartesian2D(1, 1),
                                             new Cartesian2D(0, 1));
<span class="fc" id="L1646">        Cartesian2D[][] squareBoundary = square.getVertices();</span>
<span class="fc" id="L1647">        Assert.assertEquals(1, squareBoundary.length);</span>
<span class="fc" id="L1648">        Assert.assertEquals(4, squareBoundary[0].length);</span>
<span class="fc" id="L1649">        Counter squareCount = new Counter();</span>
<span class="fc" id="L1650">        squareCount.count(square);</span>
<span class="fc" id="L1651">        Assert.assertEquals(4, squareCount.getInternalNodes());</span>
<span class="fc" id="L1652">        Assert.assertEquals(5, squareCount.getLeafNodes());</span>

        // splitting the square in two halves increases the BSP tree
        // with 3 more cuts and 3 more leaf nodes
<span class="fc" id="L1656">        SubLine cut = new Line(new Cartesian2D(0.5, 0.5), 0.0, square.getTolerance()).wholeHyperplane();</span>
<span class="fc" id="L1657">        PolygonsSet splitSquare = new PolygonsSet(square.getTree(false).split(cut),</span>
<span class="fc" id="L1658">                                                  square.getTolerance());</span>
<span class="fc" id="L1659">        Counter splitSquareCount = new Counter();</span>
<span class="fc" id="L1660">        splitSquareCount.count(splitSquare);</span>
<span class="fc" id="L1661">        Assert.assertEquals(squareCount.getInternalNodes() + 3, splitSquareCount.getInternalNodes());</span>
<span class="fc" id="L1662">        Assert.assertEquals(squareCount.getLeafNodes()     + 3, splitSquareCount.getLeafNodes());</span>

        // the number of vertices should not change, as the intermediate vertices
        // at (0.0, 0.5) and (1.0, 0.5) induced by the top level horizontal split
        // should be removed during the boundary extraction process
<span class="fc" id="L1667">        Cartesian2D[][] splitBoundary = splitSquare.getVertices();</span>
<span class="fc" id="L1668">        Assert.assertEquals(1, splitBoundary.length);</span>
<span class="fc" id="L1669">        Assert.assertEquals(4, splitBoundary[0].length);</span>
<span class="fc" id="L1670">    }</span>

    private static class Counter {

        private int internalNodes;
        private int leafNodes;

        public void count(PolygonsSet polygonsSet) {
<span class="fc" id="L1678">            leafNodes     = 0;</span>
<span class="fc" id="L1679">            internalNodes = 0;</span>
<span class="fc" id="L1680">            polygonsSet.getTree(false).visit(new BSPTreeVisitor&lt;Euclidean2D&gt;() {</span>
                @Override
                public Order visitOrder(BSPTree&lt;Euclidean2D&gt; node) {
<span class="fc" id="L1683">                    return Order.SUB_PLUS_MINUS;</span>
                }
                @Override
                public void visitInternalNode(BSPTree&lt;Euclidean2D&gt; node) {
<span class="fc" id="L1687">                    ++internalNodes;</span>
<span class="fc" id="L1688">                }</span>
                @Override
                public void visitLeafNode(BSPTree&lt;Euclidean2D&gt; node) {
<span class="fc" id="L1691">                    ++leafNodes;</span>
<span class="fc" id="L1692">                }</span>

            });
<span class="fc" id="L1695">        }</span>

        public int getInternalNodes() {
<span class="fc" id="L1698">            return internalNodes;</span>
        }

        public int getLeafNodes() {
<span class="fc" id="L1702">            return leafNodes;</span>
        }
    }

    private PolygonsSet buildSet(Cartesian2D[][] vertices) {
<span class="fc" id="L1707">        ArrayList&lt;SubHyperplane&lt;Euclidean2D&gt;&gt; edges = new ArrayList&lt;&gt;();</span>
<span class="fc bfc" id="L1708" title="All 2 branches covered.">        for (int i = 0; i &lt; vertices.length; ++i) {</span>
<span class="fc" id="L1709">            int l = vertices[i].length;</span>
<span class="fc bfc" id="L1710" title="All 2 branches covered.">            for (int j = 0; j &lt; l; ++j) {</span>
<span class="fc" id="L1711">                edges.add(buildSegment(vertices[i][j], vertices[i][(j + 1) % l]));</span>
            }
        }
<span class="fc" id="L1714">        return new PolygonsSet(edges, TEST_TOLERANCE);</span>
    }

    private SubHyperplane&lt;Euclidean2D&gt; buildLine(Cartesian2D start, Cartesian2D end) {
<span class="fc" id="L1718">        return new Line(start, end, TEST_TOLERANCE).wholeHyperplane();</span>
    }

    private double intersectionAbscissa(Line l0, Line l1) {
<span class="fc" id="L1722">        Cartesian2D p = l0.intersection(l1);</span>
<span class="fc" id="L1723">        return (l0.toSubSpace(p)).getX();</span>
    }

    private SubHyperplane&lt;Euclidean2D&gt; buildHalfLine(Cartesian2D start, Cartesian2D end,
                                                     boolean startIsVirtual) {
<span class="fc" id="L1728">        Line   line  = new Line(start, end, TEST_TOLERANCE);</span>
<span class="fc bfc" id="L1729" title="All 2 branches covered.">        double lower = startIsVirtual ? Double.NEGATIVE_INFINITY : (line.toSubSpace(start)).getX();</span>
<span class="fc bfc" id="L1730" title="All 2 branches covered.">        double upper = startIsVirtual ? (line.toSubSpace(end)).getX() : Double.POSITIVE_INFINITY;</span>
<span class="fc" id="L1731">        return new SubLine(line, new IntervalsSet(lower, upper, TEST_TOLERANCE));</span>
    }

    private SubHyperplane&lt;Euclidean2D&gt; buildSegment(Cartesian2D start, Cartesian2D end) {
<span class="fc" id="L1735">        Line   line  = new Line(start, end, TEST_TOLERANCE);</span>
<span class="fc" id="L1736">        double lower = (line.toSubSpace(start)).getX();</span>
<span class="fc" id="L1737">        double upper = (line.toSubSpace(end)).getX();</span>
<span class="fc" id="L1738">        return new SubLine(line, new IntervalsSet(lower, upper, TEST_TOLERANCE));</span>
    }

    private void checkPoints(Region.Location expected, PolygonsSet poly, Cartesian2D ... points) {
<span class="fc bfc" id="L1742" title="All 2 branches covered.">        for (int i = 0; i &lt; points.length; ++i) {</span>
<span class="fc" id="L1743">            Assert.assertEquals(&quot;Incorrect location for &quot; + points[i], expected, poly.checkPoint(points[i]));</span>
        }
<span class="fc" id="L1745">    }</span>

    /** Asserts that the two arrays of vertex loops have equivalent content.
     * @param expectedLoops
     * @param actualLoops
     */
    private void checkVertexLoopsEquivalent(Cartesian2D[][] expectedLoops, Cartesian2D[][] actualLoops) {
<span class="fc" id="L1752">        Assert.assertEquals(&quot;Expected vertices array to have length of &quot; + expectedLoops.length + &quot; but was &quot; + actualLoops.length,</span>
                expectedLoops.length, actualLoops.length);

        // go through each loop in the expected array and try to find a match in the actual array
<span class="fc bfc" id="L1756" title="All 2 branches covered.">        for (Cartesian2D[] expectedLoop : expectedLoops) {</span>
<span class="fc" id="L1757">            boolean foundMatch = false;</span>
<span class="pc bpc" id="L1758" title="1 of 2 branches missed.">            for (Cartesian2D[] actualLoop : actualLoops) {</span>
<span class="fc bfc" id="L1759" title="All 2 branches covered.">                if (vertexLoopsEquivalent(expectedLoop, actualLoop, TEST_TOLERANCE)) {</span>
<span class="fc" id="L1760">                    foundMatch = true;</span>
<span class="fc" id="L1761">                    break;</span>
                }
            }

<span class="pc bpc" id="L1765" title="1 of 2 branches missed.">            if (!foundMatch) {</span>
<span class="nc" id="L1766">                StringBuilder sb = new StringBuilder();</span>
<span class="nc bnc" id="L1767" title="All 2 branches missed.">                for (Cartesian2D[] actualLoop : actualLoops) {</span>
<span class="nc" id="L1768">                    sb.append(Arrays.toString(actualLoop));</span>
<span class="nc" id="L1769">                    sb.append(&quot;, &quot;);</span>
                }
<span class="nc bnc" id="L1771" title="All 2 branches missed.">                if (sb.length() &gt; 0) {</span>
<span class="nc" id="L1772">                    sb.delete(sb.length() - 2, sb.length());</span>
                }
<span class="nc" id="L1774">                Assert.fail(&quot;Failed to find vertex loop &quot; + Arrays.toString(expectedLoop) + &quot; in loop array [&quot; +</span>
<span class="nc" id="L1775">                        sb.toString() + &quot;].&quot;);</span>
            }
        }
<span class="fc" id="L1778">    }</span>

    /** Returns true if the two sets of vertices can be considered equivalent using the given
     * tolerance. For open loops, (i.e. ones that start with null) this means that the two loops
     * must have the exact same elements in the exact same order. For closed loops, equivalent
     * means that one of the loops can be rotated to match the other (e.g. [3, 1, 2] is equivalent
     * to [1, 2, 3]).
     * @param a
     * @param b
     * @param tolerance
     * @return
     */
    private boolean vertexLoopsEquivalent(Cartesian2D[] a, Cartesian2D[] b, double tolerance) {
<span class="fc bfc" id="L1791" title="All 2 branches covered.">        if (a.length == b.length) {</span>
<span class="pc bpc" id="L1792" title="1 of 2 branches missed.">            if (a.length &lt; 1) {</span>
                // the loops are empty
<span class="nc" id="L1794">                return true;</span>
            }
<span class="pc bpc" id="L1796" title="1 of 4 branches missed.">            if (a[0] == null || b[0] == null) {</span>
                // at least one of the loops is unclosed, so there is only one
                // possible sequence that could match
<span class="fc" id="L1799">                return vertexLoopsEqual(a, 0, b, 0, tolerance);</span>
            }
            else {
                // the loops are closed so they could be equivalent but
                // start at different vertices
<span class="fc bfc" id="L1804" title="All 2 branches covered.">                for (int i=0; i&lt;a.length; ++i) {</span>
<span class="fc bfc" id="L1805" title="All 2 branches covered.">                    if (vertexLoopsEqual(a, 0, b, i, tolerance)) {</span>
<span class="fc" id="L1806">                        return true;</span>
                    }
                }
            }
        }

<span class="fc" id="L1812">        return false;</span>
    }

    /** Returns true if the two vertex loops have the same elements, starting
     * from the given indices and allowing loop-around.
     * @param a
     * @param aStartIdx
     * @param b
     * @param bStartIdx
     * @param tolerance
     * @return
     */
    private boolean vertexLoopsEqual(Cartesian2D[] a, int aStartIdx,
            Cartesian2D[] b, int bStartIdx, double tolerance) {

<span class="fc" id="L1827">        int len = a.length;</span>

        Cartesian2D ptA;
        Cartesian2D ptB;
<span class="fc bfc" id="L1831" title="All 2 branches covered.">        for (int i=0; i&lt;len; ++i) {</span>
<span class="fc" id="L1832">            ptA = a[(i + aStartIdx) % len];</span>
<span class="fc" id="L1833">            ptB = b[(i + bStartIdx) % len];</span>

<span class="pc bpc" id="L1835" title="1 of 4 branches missed.">            if (!((ptA == null &amp;&amp; ptB == null) ||</span>
<span class="fc bfc" id="L1836" title="All 2 branches covered.">                    (Precision.equals(ptA.getX(), ptB.getX(), tolerance) &amp;&amp;</span>
<span class="fc bfc" id="L1837" title="All 2 branches covered.">                     Precision.equals(ptA.getY(), ptB.getY(), tolerance)))) {</span>
<span class="fc" id="L1838">                return false;</span>
            }
        }

<span class="fc" id="L1842">        return true;</span>
    }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.1.201803210924</span></div></body></html>