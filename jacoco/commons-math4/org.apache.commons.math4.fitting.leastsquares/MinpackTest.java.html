<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>MinpackTest.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">commons_math4$All_in_commons_math4.exec</a> &gt; <a href="index.source.html" class="el_package">org.apache.commons.math4.fitting.leastsquares</a> &gt; <span class="el_source">MinpackTest.java</span></div><h1>MinpackTest.java</h1><pre class="source lang-java linenums">/*
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the &quot;License&quot;); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package org.apache.commons.math4.fitting.leastsquares;

import java.util.Arrays;

import org.apache.commons.math4.analysis.MultivariateMatrixFunction;
import org.apache.commons.math4.analysis.MultivariateVectorFunction;
import org.apache.commons.math4.exception.TooManyEvaluationsException;
import org.apache.commons.math4.fitting.leastsquares.LeastSquaresBuilder;
import org.apache.commons.math4.fitting.leastsquares.LeastSquaresProblem;
import org.apache.commons.math4.fitting.leastsquares.LevenbergMarquardtOptimizer;
import org.apache.commons.math4.fitting.leastsquares.LeastSquaresOptimizer.Optimum;
import org.apache.commons.math4.linear.DiagonalMatrix;
import org.apache.commons.math4.util.FastMath;
import org.junit.Assert;
import org.junit.Test;

/**
 * &lt;p&gt;Some of the unit tests are re-implementations of the MINPACK &lt;a
 * href=&quot;http://www.netlib.org/minpack/ex/file17&quot;&gt;file17&lt;/a&gt; and &lt;a
 * href=&quot;http://www.netlib.org/minpack/ex/file22&quot;&gt;file22&lt;/a&gt; test files.
 * The redistribution policy for MINPACK is available &lt;a
 * href=&quot;http://www.netlib.org/minpack/disclaimer&quot;&gt;here&lt;/a&gt;, for
 * convenience, it is reproduced below.&lt;/p&gt;

 * &lt;table border=&quot;0&quot; width=&quot;80%&quot; cellpadding=&quot;10&quot; align=&quot;center&quot; bgcolor=&quot;#E0E0E0&quot;&gt;
 * &lt;tr&gt;&lt;td&gt;
 *    Minpack Copyright Notice (1999) University of Chicago.
 *    All rights reserved
 * &lt;/td&gt;&lt;/tr&gt;
 * &lt;tr&gt;&lt;td&gt;
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * &lt;ol&gt;
 *  &lt;li&gt;Redistributions of source code must retain the above copyright
 *      notice, this list of conditions and the following disclaimer.&lt;/li&gt;
 * &lt;li&gt;Redistributions in binary form must reproduce the above
 *     copyright notice, this list of conditions and the following
 *     disclaimer in the documentation and/or other materials provided
 *     with the distribution.&lt;/li&gt;
 * &lt;li&gt;The end-user documentation included with the redistribution, if any,
 *     must include the following acknowledgment:
 *     &lt;code&gt;This product includes software developed by the University of
 *           Chicago, as Operator of Argonne National Laboratory.&lt;/code&gt;
 *     Alternately, this acknowledgment may appear in the software itself,
 *     if and wherever such third-party acknowledgments normally appear.&lt;/li&gt;
 * &lt;li&gt;&lt;strong&gt;WARRANTY DISCLAIMER. THE SOFTWARE IS SUPPLIED &quot;AS IS&quot;
 *     WITHOUT WARRANTY OF ANY KIND. THE COPYRIGHT HOLDER, THE
 *     UNITED STATES, THE UNITED STATES DEPARTMENT OF ENERGY, AND
 *     THEIR EMPLOYEES: (1) DISCLAIM ANY WARRANTIES, EXPRESS OR
 *     IMPLIED, INCLUDING BUT NOT LIMITED TO ANY IMPLIED WARRANTIES
 *     OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE, TITLE
 *     OR NON-INFRINGEMENT, (2) DO NOT ASSUME ANY LEGAL LIABILITY
 *     OR RESPONSIBILITY FOR THE ACCURACY, COMPLETENESS, OR
 *     USEFULNESS OF THE SOFTWARE, (3) DO NOT REPRESENT THAT USE OF
 *     THE SOFTWARE WOULD NOT INFRINGE PRIVATELY OWNED RIGHTS, (4)
 *     DO NOT WARRANT THAT THE SOFTWARE WILL FUNCTION
 *     UNINTERRUPTED, THAT IT IS ERROR-FREE OR THAT ANY ERRORS WILL
 *     BE CORRECTED.&lt;/strong&gt;&lt;/li&gt;
 * &lt;li&gt;&lt;strong&gt;LIMITATION OF LIABILITY. IN NO EVENT WILL THE COPYRIGHT
 *     HOLDER, THE UNITED STATES, THE UNITED STATES DEPARTMENT OF
 *     ENERGY, OR THEIR EMPLOYEES: BE LIABLE FOR ANY INDIRECT,
 *     INCIDENTAL, CONSEQUENTIAL, SPECIAL OR PUNITIVE DAMAGES OF
 *     ANY KIND OR NATURE, INCLUDING BUT NOT LIMITED TO LOSS OF
 *     PROFITS OR LOSS OF DATA, FOR ANY REASON WHATSOEVER, WHETHER
 *     SUCH LIABILITY IS ASSERTED ON THE BASIS OF CONTRACT, TORT
 *     (INCLUDING NEGLIGENCE OR STRICT LIABILITY), OR OTHERWISE,
 *     EVEN IF ANY OF SAID PARTIES HAS BEEN WARNED OF THE
 *     POSSIBILITY OF SUCH LOSS OR DAMAGES.&lt;/strong&gt;&lt;/li&gt;
 * &lt;ol&gt;&lt;/td&gt;&lt;/tr&gt;
 * &lt;/table&gt;

 * @author Argonne National Laboratory. MINPACK project. March 1980 (original fortran minpack tests)
 * @author Burton S. Garbow (original fortran minpack tests)
 * @author Kenneth E. Hillstrom (original fortran minpack tests)
 * @author Jorge J. More (original fortran minpack tests)
 * @author Luc Maisonobe (non-minpack tests and minpack tests Java translation)
 */
<span class="fc" id="L96">public class MinpackTest {</span>

    @Test
    public void testMinpackLinearFullRank() {
<span class="fc" id="L100">        minpackTest(new LinearFullRankFunction(10, 5, 1.0,</span>
                                               5.0, 2.23606797749979), false);
<span class="fc" id="L102">        minpackTest(new LinearFullRankFunction(50, 5, 1.0,</span>
                                               8.06225774829855, 6.70820393249937), false);
<span class="fc" id="L104">    }</span>

    @Test
    public void testMinpackLinearRank1() {
<span class="fc" id="L108">        minpackTest(new LinearRank1Function(10, 5, 1.0,</span>
                                            291.521868819476, 1.4638501094228), false);
<span class="fc" id="L110">        minpackTest(new LinearRank1Function(50, 5, 1.0,</span>
                                            3101.60039334535, 3.48263016573496), false);
<span class="fc" id="L112">    }</span>

    @Test
    public void testMinpackLinearRank1ZeroColsAndRows() {
<span class="fc" id="L116">        minpackTest(new LinearRank1ZeroColsAndRowsFunction(10, 5, 1.0), false);</span>
<span class="fc" id="L117">        minpackTest(new LinearRank1ZeroColsAndRowsFunction(50, 5, 1.0), false);</span>
<span class="fc" id="L118">    }</span>

    @Test
    public void testMinpackRosenbrok() {
<span class="fc" id="L122">        minpackTest(new RosenbrockFunction(new double[] { -1.2, 1.0 },</span>
<span class="fc" id="L123">                                           FastMath.sqrt(24.2)), false);</span>
<span class="fc" id="L124">        minpackTest(new RosenbrockFunction(new double[] { -12.0, 10.0 },</span>
<span class="fc" id="L125">                                           FastMath.sqrt(1795769.0)), false);</span>
<span class="fc" id="L126">        minpackTest(new RosenbrockFunction(new double[] { -120.0, 100.0 },</span>
<span class="fc" id="L127">                                           11.0 * FastMath.sqrt(169000121.0)), false);</span>
<span class="fc" id="L128">    }</span>

    @Test
    public void testMinpackHelicalValley() {
<span class="fc" id="L132">        minpackTest(new HelicalValleyFunction(new double[] { -1.0, 0.0, 0.0 },</span>
                                              50.0), false);
<span class="fc" id="L134">        minpackTest(new HelicalValleyFunction(new double[] { -10.0, 0.0, 0.0 },</span>
                                              102.95630140987), false);
<span class="fc" id="L136">        minpackTest(new HelicalValleyFunction(new double[] { -100.0, 0.0, 0.0},</span>
                                              991.261822123701), false);
<span class="fc" id="L138">    }</span>

    @Test
    public void testMinpackPowellSingular() {
<span class="fc" id="L142">        minpackTest(new PowellSingularFunction(new double[] { 3.0, -1.0, 0.0, 1.0 },</span>
                                               14.6628782986152), false);
<span class="fc" id="L144">        minpackTest(new PowellSingularFunction(new double[] { 30.0, -10.0, 0.0, 10.0 },</span>
                                               1270.9838708654), false);
<span class="fc" id="L146">        minpackTest(new PowellSingularFunction(new double[] { 300.0, -100.0, 0.0, 100.0 },</span>
                                               126887.903284750), false);
<span class="fc" id="L148">    }</span>

    @Test
    public void testMinpackFreudensteinRoth() {
<span class="fc" id="L152">        minpackTest(new FreudensteinRothFunction(new double[] { 0.5, -2.0 },</span>
                                                 20.0124960961895, 6.99887517584575,
                                                 new double[] {
                                                     11.4124844654993,
                                                     -0.896827913731509
                                                 }), false);
<span class="fc" id="L158">        minpackTest(new FreudensteinRothFunction(new double[] { 5.0, -20.0 },</span>
                                                 12432.833948863, 6.9988751744895,
                                                 new double[] {
                                                     11.41300466147456,
                                                     -0.896796038685959
                                                 }), false);
<span class="fc" id="L164">        minpackTest(new FreudensteinRothFunction(new double[] { 50.0, -200.0 },</span>
                                                 11426454.595762, 6.99887517242903,
                                                 new double[] {
                                                     11.412781785788564,
                                                     -0.8968051074920405
                                                 }), false);
<span class="fc" id="L170">    }</span>

    @Test
    public void testMinpackBard() {
<span class="fc" id="L174">        minpackTest(new BardFunction(1.0, 6.45613629515967, 0.0906359603390466,</span>
                                     new double[] {
                                         0.0824105765758334,
                                         1.1330366534715,
                                         2.34369463894115
                                     }), false);
<span class="fc" id="L180">        minpackTest(new BardFunction(10.0, 36.1418531596785, 4.17476870138539,</span>
                                     new double[] {
                                         0.840666673818329,
                                         -158848033.259565,
                                         -164378671.653535
                                     }), false);
<span class="fc" id="L186">        minpackTest(new BardFunction(100.0, 384.114678637399, 4.17476870135969,</span>
                                     new double[] {
                                         0.840666673867645,
                                         -158946167.205518,
                                         -164464906.857771
                                     }), false);
<span class="fc" id="L192">    }</span>

    @Test
    public void testMinpackKowalikOsborne() {
<span class="fc" id="L196">        minpackTest(new KowalikOsborneFunction(new double[] { 0.25, 0.39, 0.415, 0.39 },</span>
                                               0.0728915102882945,
                                               0.017535837721129,
                                               new double[] {
                                                   0.192807810476249,
                                                   0.191262653354071,
                                                   0.123052801046931,
                                                   0.136053221150517
                                               }), false);
<span class="fc" id="L205">        minpackTest(new KowalikOsborneFunction(new double[] { 2.5, 3.9, 4.15, 3.9 },</span>
                                               2.97937007555202,
                                               0.032052192917937,
                                               new double[] {
                                                   728675.473768287,
                                                   -14.0758803129393,
                                                   -32977797.7841797,
                                                   -20571594.1977912
                                               }), false);
<span class="fc" id="L214">        minpackTest(new KowalikOsborneFunction(new double[] { 25.0, 39.0, 41.5, 39.0 },</span>
                                               29.9590617016037,
                                               0.0175364017658228,
                                               new double[] {
                                                   0.192948328597594,
                                                   0.188053165007911,
                                                   0.122430604321144,
                                                   0.134575665392506
                                               }), false);
<span class="fc" id="L223">    }</span>

    @Test
    public void testMinpackMeyer() {
<span class="fc" id="L227">        minpackTest(new MeyerFunction(new double[] { 0.02, 4000.0, 250.0 },</span>
                                      41153.4665543031, 9.37794514651874,
                                      new double[] {
                                          0.00560963647102661,
                                          6181.34634628659,
                                          345.223634624144
                                      }), false);
<span class="fc" id="L234">        minpackTest(new MeyerFunction(new double[] { 0.2, 40000.0, 2500.0 },</span>
                                      4168216.89130846, 792.917871779501,
                                      new double[] {
                                          1.42367074157994e-11,
                                          33695.7133432541,
                                          901.268527953801
                                      }), true);
<span class="fc" id="L241">    }</span>

    @Test
    public void testMinpackWatson() {
<span class="fc" id="L245">        minpackTest(new WatsonFunction(6, 0.0,</span>
                                       5.47722557505166, 0.0478295939097601,
                                       new double[] {
                                           -0.0157249615083782, 1.01243488232965,
                                           -0.232991722387673,  1.26043101102818,
                                           -1.51373031394421,   0.99299727291842
                                       }), false);
<span class="fc" id="L252">        minpackTest(new WatsonFunction(6, 10.0,</span>
                                       6433.12578950026, 0.0478295939096951,
                                       new double[] {
                                           -0.0157251901386677, 1.01243485860105,
                                           -0.232991545843829,  1.26042932089163,
                                           -1.51372776706575,   0.99299573426328
                                       }), false);
<span class="fc" id="L259">        minpackTest(new WatsonFunction(6, 100.0,</span>
                                       674256.040605213, 0.047829593911544,
                                       new double[] {
                                           -0.0157247019712586, 1.01243490925658,
                                           -0.232991922761641,  1.26043292929555,
                                           -1.51373320452707,   0.99299901922322
                                       }), false);
<span class="fc" id="L266">        minpackTest(new WatsonFunction(9, 0.0,</span>
                                       5.47722557505166, 0.00118311459212420,
                                       new double[] {
                                           -0.153070644166722e-4, 0.999789703934597,
                                           0.0147639634910978,   0.146342330145992,
                                           1.00082109454817,    -2.61773112070507,
                                           4.10440313943354,    -3.14361226236241,
                                           1.05262640378759
                                       }), false);
<span class="fc" id="L275">        minpackTest(new WatsonFunction(9, 10.0,</span>
                                       12088.127069307, 0.00118311459212513,
                                       new double[] {
                                           -0.153071334849279e-4, 0.999789703941234,
                                           0.0147639629786217,   0.146342334818836,
                                           1.00082107321386,    -2.61773107084722,
                                           4.10440307655564,    -3.14361222178686,
                                           1.05262639322589
                                       }), false);
<span class="fc" id="L284">        minpackTest(new WatsonFunction(9, 100.0,</span>
                                       1269109.29043834, 0.00118311459212384,
                                       new double[] {
                                           -0.153069523352176e-4, 0.999789703958371,
                                           0.0147639625185392,   0.146342341096326,
                                           1.00082104729164,    -2.61773101573645,
                                           4.10440301427286,    -3.14361218602503,
                                           1.05262638516774
                                       }), false);
<span class="fc" id="L293">        minpackTest(new WatsonFunction(12, 0.0,</span>
                                       5.47722557505166, 0.217310402535861e-4,
                                       new double[] {
                                           -0.660266001396382e-8, 1.00000164411833,
                                           -0.000563932146980154, 0.347820540050756,
                                           -0.156731500244233,    1.05281515825593,
                                           -3.24727109519451,     7.2884347837505,
                                           -10.271848098614,       9.07411353715783,
                                           -4.54137541918194,     1.01201187975044
                                       }), false);
<span class="fc" id="L303">        minpackTest(new WatsonFunction(12, 10.0,</span>
                                       19220.7589790951, 0.217310402518509e-4,
                                       new double[] {
                                           -0.663710223017410e-8, 1.00000164411787,
                                           -0.000563932208347327, 0.347820540486998,
                                           -0.156731503955652,    1.05281517654573,
                                           -3.2472711515214,      7.28843489430665,
                                           -10.2718482369638,      9.07411364383733,
                                           -4.54137546533666,     1.01201188830857
                                       }), false);
<span class="fc" id="L313">        minpackTest(new WatsonFunction(12, 100.0,</span>
                                       2018918.04462367, 0.217310402539845e-4,
                                       new double[] {
                                           -0.663806046485249e-8, 1.00000164411786,
                                           -0.000563932210324959, 0.347820540503588,
                                           -0.156731504091375,    1.05281517718031,
                                           -3.24727115337025,     7.28843489775302,
                                           -10.2718482410813,      9.07411364688464,
                                           -4.54137546660822,     1.0120118885369
                                       }), false);
<span class="fc" id="L323">    }</span>

    @Test
    public void testMinpackBox3Dimensional() {
<span class="fc" id="L327">        minpackTest(new Box3DimensionalFunction(10, new double[] { 0.0, 10.0, 20.0 },</span>
                                                32.1115837449572), false);
<span class="fc" id="L329">    }</span>

    @Test
    public void testMinpackJennrichSampson() {
<span class="fc" id="L333">        minpackTest(new JennrichSampsonFunction(10, new double[] { 0.3, 0.4 },</span>
                                                64.5856498144943, 11.1517793413499,
                                                new double[] {
//                                                     0.2578330049, 0.257829976764542
                                                    0.2578199266368004, 0.25782997676455244
                                                }), false);
<span class="fc" id="L339">    }</span>

    @Test
    public void testMinpackBrownDennis() {
<span class="fc" id="L343">        minpackTest(new BrownDennisFunction(20,</span>
                                            new double[] { 25.0, 5.0, -5.0, -1.0 },
                                            2815.43839161816, 292.954288244866,
                                            new double[] {
                                                -11.59125141003, 13.2024883984741,
                                                -0.403574643314272, 0.236736269844604
                                            }), false);
<span class="fc" id="L350">        minpackTest(new BrownDennisFunction(20,</span>
                                            new double[] { 250.0, 50.0, -50.0, -10.0 },
                                            555073.354173069, 292.954270581415,
                                            new double[] {
                                                -11.5959274272203, 13.2041866926242,
                                                -0.403417362841545, 0.236771143410386
                                            }), false);
<span class="fc" id="L357">        minpackTest(new BrownDennisFunction(20,</span>
                                            new double[] { 2500.0, 500.0, -500.0, -100.0 },
                                            61211252.2338581, 292.954306151134,
                                            new double[] {
                                                -11.5902596937374, 13.2020628854665,
                                                -0.403688070279258, 0.236665033746463
                                            }), false);
<span class="fc" id="L364">    }</span>

    @Test
    public void testMinpackChebyquad() {
<span class="fc" id="L368">        minpackTest(new ChebyquadFunction(1, 8, 1.0,</span>
                                          1.88623796907732, 1.88623796907732,
                                          new double[] { 0.5 }), false);
<span class="fc" id="L371">        minpackTest(new ChebyquadFunction(1, 8, 10.0,</span>
                                          5383344372.34005, 1.88424820499951,
                                          new double[] { 0.9817314924684 }), false);
<span class="fc" id="L374">        minpackTest(new ChebyquadFunction(1, 8, 100.0,</span>
                                          0.118088726698392e19, 1.88424820499347,
                                          new double[] { 0.9817314852934 }), false);
<span class="fc" id="L377">        minpackTest(new ChebyquadFunction(8, 8, 1.0,</span>
                                          0.196513862833975, 0.0593032355046727,
                                          new double[] {
                                              0.0431536648587336, 0.193091637843267,
                                              0.266328593812698,  0.499999334628884,
                                              0.500000665371116,  0.733671406187302,
                                              0.806908362156733,  0.956846335141266
                                          }), false);
<span class="fc" id="L385">        minpackTest(new ChebyquadFunction(9, 9, 1.0,</span>
                                          0.16994993465202, 0.0,
                                          new double[] {
                                              0.0442053461357828, 0.199490672309881,
                                              0.23561910847106,   0.416046907892598,
                                              0.5,                0.583953092107402,
                                              0.764380891528940,  0.800509327690119,
                                              0.955794653864217
                                          }), false);
<span class="fc" id="L394">        minpackTest(new ChebyquadFunction(10, 10, 1.0,</span>
                                          0.183747831178711, 0.0806471004038253,
                                          new double[] {
                                              0.0596202671753563, 0.166708783805937,
                                              0.239171018813509,  0.398885290346268,
                                              0.398883667870681,  0.601116332129320,
                                              0.60111470965373,   0.760828981186491,
                                              0.833291216194063,  0.940379732824644
                                          }), false);
<span class="fc" id="L403">    }</span>

    @Test
    public void testMinpackBrownAlmostLinear() {
<span class="fc" id="L407">        minpackTest(new BrownAlmostLinearFunction(10, 0.5,</span>
                                                  16.5302162063499, 0.0,
                                                  new double[] {
                                                      0.979430303349862, 0.979430303349862,
                                                      0.979430303349862, 0.979430303349862,
                                                      0.979430303349862, 0.979430303349862,
                                                      0.979430303349862, 0.979430303349862,
                                                      0.979430303349862, 1.20569696650138
                                                  }), false);
<span class="fc" id="L416">        minpackTest(new BrownAlmostLinearFunction(10, 5.0,</span>
                                                  9765624.00089211, 0.0,
                                                  new double[] {
                                                      0.979430303349865, 0.979430303349865,
                                                      0.979430303349865, 0.979430303349865,
                                                      0.979430303349865, 0.979430303349865,
                                                      0.979430303349865, 0.979430303349865,
                                                      0.979430303349865, 1.20569696650135
                                                  }), false);
<span class="fc" id="L425">        minpackTest(new BrownAlmostLinearFunction(10, 50.0,</span>
                                                  0.9765625e17, 0.0,
                                                  new double[] {
                                                      1.0, 1.0, 1.0, 1.0, 1.0,
                                                      1.0, 1.0, 1.0, 1.0, 1.0
                                                  }), false);
<span class="fc" id="L431">        minpackTest(new BrownAlmostLinearFunction(30, 0.5,</span>
                                                  83.476044467848, 0.0,
                                                  new double[] {
                                                      0.997754216442807, 0.997754216442807,
                                                      0.997754216442807, 0.997754216442807,
                                                      0.997754216442807, 0.997754216442807,
                                                      0.997754216442807, 0.997754216442807,
                                                      0.997754216442807, 0.997754216442807,
                                                      0.997754216442807, 0.997754216442807,
                                                      0.997754216442807, 0.997754216442807,
                                                      0.997754216442807, 0.997754216442807,
                                                      0.997754216442807, 0.997754216442807,
                                                      0.997754216442807, 0.997754216442807,
                                                      0.997754216442807, 0.997754216442807,
                                                      0.997754216442807, 0.997754216442807,
                                                      0.997754216442807, 0.997754216442807,
                                                      0.997754216442807, 0.997754216442807,
                                                      0.997754216442807, 1.06737350671578
                                                  }), false);
<span class="fc" id="L450">        minpackTest(new BrownAlmostLinearFunction(40, 0.5,</span>
                                                  128.026364472323, 0.0,
                                                  new double[] {
                                                      1.00000000000002, 1.00000000000002,
                                                      1.00000000000002, 1.00000000000002,
                                                      1.00000000000002, 1.00000000000002,
                                                      1.00000000000002, 1.00000000000002,
                                                      1.00000000000002, 1.00000000000002,
                                                      1.00000000000002, 1.00000000000002,
                                                      1.00000000000002, 1.00000000000002,
                                                      1.00000000000002, 1.00000000000002,
                                                      1.00000000000002, 1.00000000000002,
                                                      1.00000000000002, 1.00000000000002,
                                                      1.00000000000002, 1.00000000000002,
                                                      1.00000000000002, 1.00000000000002,
                                                      1.00000000000002, 1.00000000000002,
                                                      1.00000000000002, 1.00000000000002,
                                                      1.00000000000002, 1.00000000000002,
                                                      1.00000000000002, 1.00000000000002,
                                                      1.00000000000002, 1.00000000000002,
                                                      0.999999999999121
                                                  }), false);
<span class="fc" id="L472">    }</span>

    @Test
    public void testMinpackOsborne1() {
<span class="fc" id="L476">        minpackTest(new Osborne1Function(new double[] { 0.5, 1.5, -1.0, 0.01, 0.02, },</span>
                                         0.937564021037838, 0.00739249260904843,
                                         new double[] {
                                             0.375410049244025, 1.93584654543108,
                                             -1.46468676748716, 0.0128675339110439,
                                             0.0221227011813076
                                         }), false);
<span class="fc" id="L483">    }</span>

    @Test
    public void testMinpackOsborne2() {
<span class="fc" id="L487">        minpackTest(new Osborne2Function(new double[] {</span>
                    1.3, 0.65, 0.65, 0.7, 0.6,
                    3.0, 5.0, 7.0, 2.0, 4.5, 5.5
                },
                1.44686540984712, 0.20034404483314,
                new double[] {
                    1.30997663810096,  0.43155248076,
                    0.633661261602859, 0.599428560991695,
                    0.754179768272449, 0.904300082378518,
                    1.36579949521007, 4.82373199748107,
                    2.39868475104871, 4.56887554791452,
                    5.67534206273052
                }), false);
<span class="fc" id="L500">    }</span>

    private void minpackTest(MinpackFunction function, boolean exceptionExpected) {
<span class="fc" id="L503">        final double tol = 2.22044604926e-16;</span>
<span class="fc" id="L504">        final double sqrtTol = FastMath.sqrt(tol);</span>

<span class="fc" id="L506">        LevenbergMarquardtOptimizer optimizer = new LevenbergMarquardtOptimizer()</span>
<span class="fc" id="L507">            .withCostRelativeTolerance(sqrtTol)</span>
<span class="fc" id="L508">            .withParameterRelativeTolerance(sqrtTol)</span>
<span class="fc" id="L509">            .withOrthoTolerance(tol);</span>

<span class="fc" id="L511">        LeastSquaresProblem problem = new LeastSquaresBuilder()</span>
<span class="fc" id="L512">                .maxEvaluations(400 * (function.getN() + 1))</span>
<span class="fc" id="L513">                .maxIterations(2000)</span>
<span class="fc" id="L514">                .model(function.getModelFunction(), function.getModelFunctionJacobian())</span>
<span class="fc" id="L515">                .target(function.getTarget())</span>
<span class="fc" id="L516">                .weight(new DiagonalMatrix(function.getWeight()))</span>
<span class="fc" id="L517">                .start(function.getStartPoint())</span>
<span class="fc" id="L518">                .build();</span>

        try {
<span class="fc" id="L521">            final Optimum optimum = optimizer.optimize(problem);</span>
<span class="fc" id="L522">            Assert.assertFalse(exceptionExpected);</span>
<span class="fc" id="L523">            function.checkTheoreticalMinCost(optimum.getRMS());</span>
<span class="fc" id="L524">            function.checkTheoreticalMinParams(optimum.getPoint().toArray());</span>
<span class="fc" id="L525">        } catch (TooManyEvaluationsException e) {</span>
<span class="fc" id="L526">            Assert.assertTrue(exceptionExpected);</span>
<span class="fc" id="L527">        }</span>
<span class="fc" id="L528">    }</span>

    private static abstract class MinpackFunction {
        protected int      n;
        protected int      m;
        protected double[] startParams;
        protected double   theoreticalMinCost;
        protected double[] theoreticalMinParams;
        protected double   costAccuracy;
        protected double   paramsAccuracy;

        protected MinpackFunction(int m, double[] startParams,
                                  double theoreticalMinCost,
<span class="fc" id="L541">                                  double[] theoreticalMinParams) {</span>
<span class="fc" id="L542">            this.m = m;</span>
<span class="fc" id="L543">            this.n = startParams.length;</span>
<span class="fc" id="L544">            this.startParams          = startParams.clone();</span>
<span class="fc" id="L545">            this.theoreticalMinCost   = theoreticalMinCost;</span>
<span class="fc" id="L546">            this.theoreticalMinParams = theoreticalMinParams;</span>
<span class="fc" id="L547">            this.costAccuracy         = 1.0e-8;</span>
<span class="fc" id="L548">            this.paramsAccuracy       = 1.0e-5;</span>
<span class="fc" id="L549">        }</span>

        protected static double[] buildArray(int n, double x) {
<span class="fc" id="L552">            double[] array = new double[n];</span>
<span class="fc" id="L553">            Arrays.fill(array, x);</span>
<span class="fc" id="L554">            return array;</span>
        }

        public double[] getTarget() {
<span class="fc" id="L558">            return buildArray(m, 0.0);</span>
        }

        public double[] getWeight() {
<span class="fc" id="L562">            return buildArray(m, 1.0);</span>
        }

        public double[] getStartPoint() {
<span class="fc" id="L566">            return startParams.clone();</span>
        }

        protected void setCostAccuracy(double costAccuracy) {
<span class="fc" id="L570">            this.costAccuracy = costAccuracy;</span>
<span class="fc" id="L571">        }</span>

        protected void setParamsAccuracy(double paramsAccuracy) {
<span class="fc" id="L574">            this.paramsAccuracy = paramsAccuracy;</span>
<span class="fc" id="L575">        }</span>

        public int getN() {
<span class="fc" id="L578">            return startParams.length;</span>
        }

        public void checkTheoreticalMinCost(double rms) {
<span class="fc" id="L582">            double threshold = costAccuracy * (1.0 + theoreticalMinCost);</span>
<span class="fc" id="L583">            Assert.assertEquals(theoreticalMinCost, FastMath.sqrt(m) * rms, threshold);</span>
<span class="fc" id="L584">        }</span>

        public void checkTheoreticalMinParams(double[] params) {
<span class="fc bfc" id="L587" title="All 2 branches covered.">            if (theoreticalMinParams != null) {</span>
<span class="fc bfc" id="L588" title="All 2 branches covered.">                for (int i = 0; i &lt; theoreticalMinParams.length; ++i) {</span>
<span class="fc" id="L589">                    double mi = theoreticalMinParams[i];</span>
<span class="fc" id="L590">                    double vi = params[i];</span>
<span class="fc" id="L591">                    Assert.assertEquals(mi, vi, paramsAccuracy * (1.0 + FastMath.abs(mi)));</span>
                }
            }
<span class="fc" id="L594">        }</span>

        public MultivariateVectorFunction getModelFunction() {
<span class="fc" id="L597">            return new MultivariateVectorFunction() {</span>
                @Override
                public double[] value(double[] point) {
<span class="fc" id="L600">                    return computeValue(point);</span>
                }
            };
        }

        public MultivariateMatrixFunction getModelFunctionJacobian() {
<span class="fc" id="L606">            return new MultivariateMatrixFunction() {</span>
                @Override
                public double[][] value(double[] point) {
<span class="fc" id="L609">                    return computeJacobian(point);</span>
                }
            };
        }

        public abstract double[][] computeJacobian(double[] variables);
        public abstract double[] computeValue(double[] variables);
    }

    private static class LinearFullRankFunction extends MinpackFunction {

        public LinearFullRankFunction(int m, int n, double x0,
                                      double theoreticalStartCost,
                                      double theoreticalMinCost) {
<span class="fc" id="L623">            super(m, buildArray(n, x0), theoreticalMinCost,</span>
<span class="fc" id="L624">                  buildArray(n, -1.0));</span>
<span class="fc" id="L625">        }</span>

        @Override
        public double[][] computeJacobian(double[] variables) {
<span class="fc" id="L629">            double t = 2.0 / m;</span>
<span class="fc" id="L630">            double[][] jacobian = new double[m][];</span>
<span class="fc bfc" id="L631" title="All 2 branches covered.">            for (int i = 0; i &lt; m; ++i) {</span>
<span class="fc" id="L632">                jacobian[i] = new double[n];</span>
<span class="fc bfc" id="L633" title="All 2 branches covered.">                for (int j = 0; j &lt; n; ++j) {</span>
<span class="fc bfc" id="L634" title="All 2 branches covered.">                    jacobian[i][j] = (i == j) ? (1 - t) : -t;</span>
                }
            }
<span class="fc" id="L637">            return jacobian;</span>
        }

        @Override
        public double[] computeValue(double[] variables) {
<span class="fc" id="L642">            double sum = 0;</span>
<span class="fc bfc" id="L643" title="All 2 branches covered.">            for (int i = 0; i &lt; n; ++i) {</span>
<span class="fc" id="L644">                sum += variables[i];</span>
            }
<span class="fc" id="L646">            double t  = 1 + 2 * sum / m;</span>
<span class="fc" id="L647">            double[] f = new double[m];</span>
<span class="fc bfc" id="L648" title="All 2 branches covered.">            for (int i = 0; i &lt; n; ++i) {</span>
<span class="fc" id="L649">                f[i] = variables[i] - t;</span>
            }
<span class="fc" id="L651">            Arrays.fill(f, n, m, -t);</span>
<span class="fc" id="L652">            return f;</span>
        }
    }

    private static class LinearRank1Function extends MinpackFunction {

        public LinearRank1Function(int m, int n, double x0,
                                   double theoreticalStartCost,
                                   double theoreticalMinCost) {
<span class="fc" id="L661">            super(m, buildArray(n, x0), theoreticalMinCost, null);</span>
<span class="fc" id="L662">        }</span>

        @Override
        public double[][] computeJacobian(double[] variables) {
<span class="fc" id="L666">            double[][] jacobian = new double[m][];</span>
<span class="fc bfc" id="L667" title="All 2 branches covered.">            for (int i = 0; i &lt; m; ++i) {</span>
<span class="fc" id="L668">                jacobian[i] = new double[n];</span>
<span class="fc bfc" id="L669" title="All 2 branches covered.">                for (int j = 0; j &lt; n; ++j) {</span>
<span class="fc" id="L670">                    jacobian[i][j] = (i + 1) * (j + 1);</span>
                }
            }
<span class="fc" id="L673">            return jacobian;</span>
        }

        @Override
        public double[] computeValue(double[] variables) {
<span class="fc" id="L678">            double[] f = new double[m];</span>
<span class="fc" id="L679">            double sum = 0;</span>
<span class="fc bfc" id="L680" title="All 2 branches covered.">            for (int i = 0; i &lt; n; ++i) {</span>
<span class="fc" id="L681">                sum += (i + 1) * variables[i];</span>
            }
<span class="fc bfc" id="L683" title="All 2 branches covered.">            for (int i = 0; i &lt; m; ++i) {</span>
<span class="fc" id="L684">                f[i] = (i + 1) * sum - 1;</span>
            }
<span class="fc" id="L686">            return f;</span>
        }
    }

    private static class LinearRank1ZeroColsAndRowsFunction extends MinpackFunction {

        public LinearRank1ZeroColsAndRowsFunction(int m, int n, double x0) {
<span class="fc" id="L693">            super(m, buildArray(n, x0),</span>
<span class="fc" id="L694">                  FastMath.sqrt((m * (m + 3) - 6) / (2.0 * (2 * m - 3))),</span>
                  null);
<span class="fc" id="L696">        }</span>

        @Override
        public double[][] computeJacobian(double[] variables) {
<span class="fc" id="L700">            double[][] jacobian = new double[m][];</span>
<span class="fc bfc" id="L701" title="All 2 branches covered.">            for (int i = 0; i &lt; m; ++i) {</span>
<span class="fc" id="L702">                jacobian[i] = new double[n];</span>
<span class="fc" id="L703">                jacobian[i][0] = 0;</span>
<span class="fc bfc" id="L704" title="All 2 branches covered.">                for (int j = 1; j &lt; (n - 1); ++j) {</span>
<span class="fc bfc" id="L705" title="All 2 branches covered.">                    if (i == 0) {</span>
<span class="fc" id="L706">                        jacobian[i][j] = 0;</span>
<span class="fc bfc" id="L707" title="All 2 branches covered.">                    } else if (i != (m - 1)) {</span>
<span class="fc" id="L708">                        jacobian[i][j] = i * (j + 1);</span>
                    } else {
<span class="fc" id="L710">                        jacobian[i][j] = 0;</span>
                    }
                }
<span class="fc" id="L713">                jacobian[i][n - 1] = 0;</span>
            }
<span class="fc" id="L715">            return jacobian;</span>
        }

        @Override
        public double[] computeValue(double[] variables) {
<span class="fc" id="L720">            double[] f = new double[m];</span>
<span class="fc" id="L721">            double sum = 0;</span>
<span class="fc bfc" id="L722" title="All 2 branches covered.">            for (int i = 1; i &lt; (n - 1); ++i) {</span>
<span class="fc" id="L723">                sum += (i + 1) * variables[i];</span>
            }
<span class="fc bfc" id="L725" title="All 2 branches covered.">            for (int i = 0; i &lt; (m - 1); ++i) {</span>
<span class="fc" id="L726">                f[i] = i * sum - 1;</span>
            }
<span class="fc" id="L728">            f[m - 1] = -1;</span>
<span class="fc" id="L729">            return f;</span>
        }
    }

    private static class RosenbrockFunction extends MinpackFunction {
        public RosenbrockFunction(double[] startParams, double theoreticalStartCost) {
<span class="fc" id="L735">            super(2, startParams, 0.0, buildArray(2, 1.0));</span>
<span class="fc" id="L736">        }</span>

        @Override
        public double[][] computeJacobian(double[] variables) {
<span class="fc" id="L740">            double x1 = variables[0];</span>
<span class="fc" id="L741">            return new double[][] { { -20 * x1, 10 }, { -1, 0 } };</span>
        }

        @Override
        public double[] computeValue(double[] variables) {
<span class="fc" id="L746">            double x1 = variables[0];</span>
<span class="fc" id="L747">            double x2 = variables[1];</span>
<span class="fc" id="L748">            return new double[] { 10 * (x2 - x1 * x1), 1 - x1 };</span>
        }
    }

    private static class HelicalValleyFunction extends MinpackFunction {
        public HelicalValleyFunction(double[] startParams,
                                     double theoreticalStartCost) {
<span class="fc" id="L755">            super(3, startParams, 0.0, new double[] { 1.0, 0.0, 0.0 });</span>
<span class="fc" id="L756">        }</span>

        @Override
        public double[][] computeJacobian(double[] variables) {
<span class="fc" id="L760">            double x1 = variables[0];</span>
<span class="fc" id="L761">            double x2 = variables[1];</span>
<span class="fc" id="L762">            double tmpSquare = x1 * x1 + x2 * x2;</span>
<span class="fc" id="L763">            double tmp1 = twoPi * tmpSquare;</span>
<span class="fc" id="L764">            double tmp2 = FastMath.sqrt(tmpSquare);</span>
<span class="fc" id="L765">            return new double[][] {</span>
                {  100 * x2 / tmp1, -100 * x1 / tmp1, 10 },
                { 10 * x1 / tmp2, 10 * x2 / tmp2, 0 },
                { 0, 0, 1 }
            };
        }

        @Override
        public double[] computeValue(double[] variables) {
<span class="fc" id="L774">            double x1 = variables[0];</span>
<span class="fc" id="L775">            double x2 = variables[1];</span>
<span class="fc" id="L776">            double x3 = variables[2];</span>
            double tmp1;
<span class="pc bpc" id="L778" title="1 of 2 branches missed.">            if (x1 == 0) {</span>
<span class="nc bnc" id="L779" title="All 2 branches missed.">                tmp1 = (x2 &gt;= 0) ? 0.25 : -0.25;</span>
            } else {
<span class="fc" id="L781">                tmp1 = FastMath.atan(x2 / x1) / twoPi;</span>
<span class="fc bfc" id="L782" title="All 2 branches covered.">                if (x1 &lt; 0) {</span>
<span class="fc" id="L783">                    tmp1 += 0.5;</span>
                }
            }
<span class="fc" id="L786">            double tmp2 = FastMath.sqrt(x1 * x1 + x2 * x2);</span>
<span class="fc" id="L787">            return new double[] {</span>
                10.0 * (x3 - 10 * tmp1),
                10.0 * (tmp2 - 1),
                x3
            };
        }

        private static final double twoPi = 2.0 * FastMath.PI;
    }

    private static class PowellSingularFunction extends MinpackFunction {

        public PowellSingularFunction(double[] startParams,
                                      double theoreticalStartCost) {
<span class="fc" id="L801">            super(4, startParams, 0.0, buildArray(4, 0.0));</span>
<span class="fc" id="L802">        }</span>

        @Override
        public double[][] computeJacobian(double[] variables) {
<span class="fc" id="L806">            double x1 = variables[0];</span>
<span class="fc" id="L807">            double x2 = variables[1];</span>
<span class="fc" id="L808">            double x3 = variables[2];</span>
<span class="fc" id="L809">            double x4 = variables[3];</span>
<span class="fc" id="L810">            return new double[][] {</span>
                { 1, 10, 0, 0 },
                { 0, 0, sqrt5, -sqrt5 },
                { 0, 2 * (x2 - 2 * x3), -4 * (x2 - 2 * x3), 0 },
                { 2 * sqrt10 * (x1 - x4), 0, 0, -2 * sqrt10 * (x1 - x4) }
            };
        }

        @Override
        public double[] computeValue(double[] variables) {
<span class="fc" id="L820">            double x1 = variables[0];</span>
<span class="fc" id="L821">            double x2 = variables[1];</span>
<span class="fc" id="L822">            double x3 = variables[2];</span>
<span class="fc" id="L823">            double x4 = variables[3];</span>
<span class="fc" id="L824">            return new double[] {</span>
                x1 + 10 * x2,
                sqrt5 * (x3 - x4),
                (x2 - 2 * x3) * (x2 - 2 * x3),
                sqrt10 * (x1 - x4) * (x1 - x4)
            };
        }

<span class="fc" id="L832">        private static final double sqrt5  = FastMath.sqrt( 5.0);</span>
<span class="fc" id="L833">        private static final double sqrt10 = FastMath.sqrt(10.0);</span>
  }

    private static class FreudensteinRothFunction extends MinpackFunction {

        public FreudensteinRothFunction(double[] startParams,
                                        double theoreticalStartCost,
                                        double theoreticalMinCost,
                                        double[] theoreticalMinParams) {
<span class="fc" id="L842">            super(2, startParams, theoreticalMinCost,</span>
                  theoreticalMinParams);
<span class="fc" id="L844">        }</span>

        @Override
        public double[][] computeJacobian(double[] variables) {
<span class="fc" id="L848">            double x2 = variables[1];</span>
<span class="fc" id="L849">            return new double[][] {</span>
                { 1, x2 * (10 - 3 * x2) -  2 },
                { 1, x2 * ( 2 + 3 * x2) - 14, }
            };
        }

        @Override
        public double[] computeValue(double[] variables) {
<span class="fc" id="L857">            double x1 = variables[0];</span>
<span class="fc" id="L858">            double x2 = variables[1];</span>
<span class="fc" id="L859">            return new double[] {</span>
                -13.0 + x1 + ((5.0 - x2) * x2 -  2.0) * x2,
                -29.0 + x1 + ((1.0 + x2) * x2 - 14.0) * x2
            };
        }
    }

    private static class BardFunction extends MinpackFunction {

        public BardFunction(double x0,
                            double theoreticalStartCost,
                            double theoreticalMinCost,
                            double[] theoreticalMinParams) {
<span class="fc" id="L872">            super(15, buildArray(3, x0), theoreticalMinCost,</span>
                  theoreticalMinParams);
<span class="fc" id="L874">        }</span>

        @Override
        public double[][] computeJacobian(double[] variables) {
<span class="fc" id="L878">            double   x2 = variables[1];</span>
<span class="fc" id="L879">            double   x3 = variables[2];</span>
<span class="fc" id="L880">            double[][] jacobian = new double[m][];</span>
<span class="fc bfc" id="L881" title="All 2 branches covered.">            for (int i = 0; i &lt; m; ++i) {</span>
<span class="fc" id="L882">                double tmp1 = i  + 1;</span>
<span class="fc" id="L883">                double tmp2 = 15 - i;</span>
<span class="fc bfc" id="L884" title="All 2 branches covered.">                double tmp3 = (i &lt;= 7) ? tmp1 : tmp2;</span>
<span class="fc" id="L885">                double tmp4 = x2 * tmp2 + x3 * tmp3;</span>
<span class="fc" id="L886">                tmp4 *= tmp4;</span>
<span class="fc" id="L887">                jacobian[i] = new double[] { -1, tmp1 * tmp2 / tmp4, tmp1 * tmp3 / tmp4 };</span>
            }
<span class="fc" id="L889">            return jacobian;</span>
        }

        @Override
        public double[] computeValue(double[] variables) {
<span class="fc" id="L894">            double   x1 = variables[0];</span>
<span class="fc" id="L895">            double   x2 = variables[1];</span>
<span class="fc" id="L896">            double   x3 = variables[2];</span>
<span class="fc" id="L897">            double[] f = new double[m];</span>
<span class="fc bfc" id="L898" title="All 2 branches covered.">            for (int i = 0; i &lt; m; ++i) {</span>
<span class="fc" id="L899">                double tmp1 = i + 1;</span>
<span class="fc" id="L900">                double tmp2 = 15 - i;</span>
<span class="fc bfc" id="L901" title="All 2 branches covered.">                double tmp3 = (i &lt;= 7) ? tmp1 : tmp2;</span>
<span class="fc" id="L902">                f[i] = y[i] - (x1 + tmp1 / (x2 * tmp2 + x3 * tmp3));</span>
            }
<span class="fc" id="L904">            return f;</span>
        }

<span class="fc" id="L907">        private static final double[] y = {</span>
            0.14, 0.18, 0.22, 0.25, 0.29,
            0.32, 0.35, 0.39, 0.37, 0.58,
            0.73, 0.96, 1.34, 2.10, 4.39
        };
    }

    private static class KowalikOsborneFunction extends MinpackFunction {

        public KowalikOsborneFunction(double[] startParams,
                                      double theoreticalStartCost,
                                      double theoreticalMinCost,
                                      double[] theoreticalMinParams) {
<span class="fc" id="L920">            super(11, startParams, theoreticalMinCost,</span>
                  theoreticalMinParams);
<span class="fc bfc" id="L922" title="All 2 branches covered.">            if (theoreticalStartCost &gt; 20.0) {</span>
<span class="fc" id="L923">                setCostAccuracy(2.0e-4);</span>
<span class="fc" id="L924">                setParamsAccuracy(5.0e-3);</span>
            }
<span class="fc" id="L926">        }</span>

        @Override
        public double[][] computeJacobian(double[] variables) {
<span class="fc" id="L930">            double   x1 = variables[0];</span>
<span class="fc" id="L931">            double   x2 = variables[1];</span>
<span class="fc" id="L932">            double   x3 = variables[2];</span>
<span class="fc" id="L933">            double   x4 = variables[3];</span>
<span class="fc" id="L934">            double[][] jacobian = new double[m][];</span>
<span class="fc bfc" id="L935" title="All 2 branches covered.">            for (int i = 0; i &lt; m; ++i) {</span>
<span class="fc" id="L936">                double tmp = v[i] * (v[i] + x3) + x4;</span>
<span class="fc" id="L937">                double j1  = -v[i] * (v[i] + x2) / tmp;</span>
<span class="fc" id="L938">                double j2  = -v[i] * x1 / tmp;</span>
<span class="fc" id="L939">                double j3  = j1 * j2;</span>
<span class="fc" id="L940">                double j4  = j3 / v[i];</span>
<span class="fc" id="L941">                jacobian[i] = new double[] { j1, j2, j3, j4 };</span>
            }
<span class="fc" id="L943">            return jacobian;</span>
        }

        @Override
        public double[] computeValue(double[] variables) {
<span class="fc" id="L948">            double x1 = variables[0];</span>
<span class="fc" id="L949">            double x2 = variables[1];</span>
<span class="fc" id="L950">            double x3 = variables[2];</span>
<span class="fc" id="L951">            double x4 = variables[3];</span>
<span class="fc" id="L952">            double[] f = new double[m];</span>
<span class="fc bfc" id="L953" title="All 2 branches covered.">            for (int i = 0; i &lt; m; ++i) {</span>
<span class="fc" id="L954">                f[i] = y[i] - x1 * (v[i] * (v[i] + x2)) / (v[i] * (v[i] + x3) + x4);</span>
            }
<span class="fc" id="L956">            return f;</span>
        }

<span class="fc" id="L959">        private static final double[] v = {</span>
            4.0, 2.0, 1.0, 0.5, 0.25, 0.167, 0.125, 0.1, 0.0833, 0.0714, 0.0625
        };

<span class="fc" id="L963">        private static final double[] y = {</span>
            0.1957, 0.1947, 0.1735, 0.1600, 0.0844, 0.0627,
            0.0456, 0.0342, 0.0323, 0.0235, 0.0246
        };
    }

    private static class MeyerFunction extends MinpackFunction {

        public MeyerFunction(double[] startParams,
                             double theoreticalStartCost,
                             double theoreticalMinCost,
                             double[] theoreticalMinParams) {
<span class="fc" id="L975">            super(16, startParams, theoreticalMinCost,</span>
                  theoreticalMinParams);
<span class="fc bfc" id="L977" title="All 2 branches covered.">            if (theoreticalStartCost &gt; 1.0e6) {</span>
<span class="fc" id="L978">                setCostAccuracy(7.0e-3);</span>
<span class="fc" id="L979">                setParamsAccuracy(2.0e-2);</span>
            }
<span class="fc" id="L981">        }</span>

        @Override
        public double[][] computeJacobian(double[] variables) {
<span class="fc" id="L985">            double   x1 = variables[0];</span>
<span class="fc" id="L986">            double   x2 = variables[1];</span>
<span class="fc" id="L987">            double   x3 = variables[2];</span>
<span class="fc" id="L988">            double[][] jacobian = new double[m][];</span>
<span class="fc bfc" id="L989" title="All 2 branches covered.">            for (int i = 0; i &lt; m; ++i) {</span>
<span class="fc" id="L990">                double temp = 5.0 * (i + 1) + 45.0 + x3;</span>
<span class="fc" id="L991">                double tmp1 = x2 / temp;</span>
<span class="fc" id="L992">                double tmp2 = FastMath.exp(tmp1);</span>
<span class="fc" id="L993">                double tmp3 = x1 * tmp2 / temp;</span>
<span class="fc" id="L994">                jacobian[i] = new double[] { tmp2, tmp3, -tmp1 * tmp3 };</span>
            }
<span class="fc" id="L996">            return jacobian;</span>
        }

        @Override
        public double[] computeValue(double[] variables) {
<span class="fc" id="L1001">            double x1 = variables[0];</span>
<span class="fc" id="L1002">            double x2 = variables[1];</span>
<span class="fc" id="L1003">            double x3 = variables[2];</span>
<span class="fc" id="L1004">            double[] f = new double[m];</span>
<span class="fc bfc" id="L1005" title="All 2 branches covered.">            for (int i = 0; i &lt; m; ++i) {</span>
<span class="fc" id="L1006">                f[i] = x1 * FastMath.exp(x2 / (5.0 * (i + 1) + 45.0 + x3)) - y[i];</span>
            }
<span class="fc" id="L1008">            return f;</span>
        }

<span class="fc" id="L1011">        private static final double[] y = {</span>
            34780.0, 28610.0, 23650.0, 19630.0,
            16370.0, 13720.0, 11540.0,  9744.0,
            8261.0,  7030.0,  6005.0,  5147.0,
            4427.0,  3820.0,  3307.0,  2872.0
        };
    }

    private static class WatsonFunction extends MinpackFunction {

        public WatsonFunction(int n, double x0,
                              double theoreticalStartCost,
                              double theoreticalMinCost,
                              double[] theoreticalMinParams) {
<span class="fc" id="L1025">            super(31, buildArray(n, x0), theoreticalMinCost,</span>
                  theoreticalMinParams);
<span class="fc" id="L1027">        }</span>

        @Override
        public double[][] computeJacobian(double[] variables) {
<span class="fc" id="L1031">            double[][] jacobian = new double[m][];</span>

<span class="fc bfc" id="L1033" title="All 2 branches covered.">            for (int i = 0; i &lt; (m - 2); ++i) {</span>
<span class="fc" id="L1034">                double div = (i + 1) / 29.0;</span>
<span class="fc" id="L1035">                double s2  = 0.0;</span>
<span class="fc" id="L1036">                double dx  = 1.0;</span>
<span class="fc bfc" id="L1037" title="All 2 branches covered.">                for (int j = 0; j &lt; n; ++j) {</span>
<span class="fc" id="L1038">                    s2 += dx * variables[j];</span>
<span class="fc" id="L1039">                    dx *= div;</span>
                }
<span class="fc" id="L1041">                double temp= 2 * div * s2;</span>
<span class="fc" id="L1042">                dx = 1.0 / div;</span>
<span class="fc" id="L1043">                jacobian[i] = new double[n];</span>
<span class="fc bfc" id="L1044" title="All 2 branches covered.">                for (int j = 0; j &lt; n; ++j) {</span>
<span class="fc" id="L1045">                    jacobian[i][j] = dx * (j - temp);</span>
<span class="fc" id="L1046">                    dx *= div;</span>
                }
            }

<span class="fc" id="L1050">            jacobian[m - 2]    = new double[n];</span>
<span class="fc" id="L1051">            jacobian[m - 2][0] = 1;</span>

<span class="fc" id="L1053">            jacobian[m - 1]   = new double[n];</span>
<span class="fc" id="L1054">            jacobian[m - 1][0]= -2 * variables[0];</span>
<span class="fc" id="L1055">            jacobian[m - 1][1]= 1;</span>

<span class="fc" id="L1057">            return jacobian;</span>
        }

        @Override
        public double[] computeValue(double[] variables) {
<span class="fc" id="L1062">            double[] f = new double[m];</span>
<span class="fc bfc" id="L1063" title="All 2 branches covered.">            for (int i = 0; i &lt; (m - 2); ++i) {</span>
<span class="fc" id="L1064">                double div = (i + 1) / 29.0;</span>
<span class="fc" id="L1065">                double s1 = 0;</span>
<span class="fc" id="L1066">                double dx = 1;</span>
<span class="fc bfc" id="L1067" title="All 2 branches covered.">                for (int j = 1; j &lt; n; ++j) {</span>
<span class="fc" id="L1068">                    s1 += j * dx * variables[j];</span>
<span class="fc" id="L1069">                    dx *= div;</span>
                }
<span class="fc" id="L1071">                double s2 = 0;</span>
<span class="fc" id="L1072">                dx = 1;</span>
<span class="fc bfc" id="L1073" title="All 2 branches covered.">                for (int j = 0; j &lt; n; ++j) {</span>
<span class="fc" id="L1074">                    s2 += dx * variables[j];</span>
<span class="fc" id="L1075">                    dx *= div;</span>
                }
<span class="fc" id="L1077">                f[i] = s1 - s2 * s2 - 1;</span>
            }

<span class="fc" id="L1080">            double x1 = variables[0];</span>
<span class="fc" id="L1081">            double x2 = variables[1];</span>
<span class="fc" id="L1082">            f[m - 2] = x1;</span>
<span class="fc" id="L1083">            f[m - 1] = x2 - x1 * x1 - 1;</span>

<span class="fc" id="L1085">            return f;</span>
        }
    }

    private static class Box3DimensionalFunction extends MinpackFunction {

        public Box3DimensionalFunction(int m, double[] startParams,
                                       double theoreticalStartCost) {
<span class="fc" id="L1093">            super(m, startParams, 0.0,</span>
                  new double[] { 1.0, 10.0, 1.0 });
<span class="fc" id="L1095">        }</span>

        @Override
        public double[][] computeJacobian(double[] variables) {
<span class="fc" id="L1099">            double   x1 = variables[0];</span>
<span class="fc" id="L1100">            double   x2 = variables[1];</span>
<span class="fc" id="L1101">            double[][] jacobian = new double[m][];</span>
<span class="fc bfc" id="L1102" title="All 2 branches covered.">            for (int i = 0; i &lt; m; ++i) {</span>
<span class="fc" id="L1103">                double tmp = (i + 1) / 10.0;</span>
<span class="fc" id="L1104">                jacobian[i] = new double[] {</span>
<span class="fc" id="L1105">                    -tmp * FastMath.exp(-tmp * x1),</span>
<span class="fc" id="L1106">                    tmp * FastMath.exp(-tmp * x2),</span>
<span class="fc" id="L1107">                    FastMath.exp(-i - 1) - FastMath.exp(-tmp)</span>
                };
            }
<span class="fc" id="L1110">            return jacobian;</span>
        }

        @Override
        public double[] computeValue(double[] variables) {
<span class="fc" id="L1115">            double x1 = variables[0];</span>
<span class="fc" id="L1116">            double x2 = variables[1];</span>
<span class="fc" id="L1117">            double x3 = variables[2];</span>
<span class="fc" id="L1118">            double[] f = new double[m];</span>
<span class="fc bfc" id="L1119" title="All 2 branches covered.">            for (int i = 0; i &lt; m; ++i) {</span>
<span class="fc" id="L1120">                double tmp = (i + 1) / 10.0;</span>
<span class="fc" id="L1121">                f[i] = FastMath.exp(-tmp * x1) - FastMath.exp(-tmp * x2)</span>
<span class="fc" id="L1122">                    + (FastMath.exp(-i - 1) - FastMath.exp(-tmp)) * x3;</span>
            }
<span class="fc" id="L1124">            return f;</span>
        }
    }

    private static class JennrichSampsonFunction extends MinpackFunction {

        public JennrichSampsonFunction(int m, double[] startParams,
                                       double theoreticalStartCost,
                                       double theoreticalMinCost,
                                       double[] theoreticalMinParams) {
<span class="fc" id="L1134">            super(m, startParams, theoreticalMinCost,</span>
                  theoreticalMinParams);
<span class="fc" id="L1136">        }</span>

        @Override
        public double[][] computeJacobian(double[] variables) {
<span class="fc" id="L1140">            double   x1 = variables[0];</span>
<span class="fc" id="L1141">            double   x2 = variables[1];</span>
<span class="fc" id="L1142">            double[][] jacobian = new double[m][];</span>
<span class="fc bfc" id="L1143" title="All 2 branches covered.">            for (int i = 0; i &lt; m; ++i) {</span>
<span class="fc" id="L1144">                double t = i + 1;</span>
<span class="fc" id="L1145">                jacobian[i] = new double[] { -t * FastMath.exp(t * x1), -t * FastMath.exp(t * x2) };</span>
            }
<span class="fc" id="L1147">            return jacobian;</span>
        }

        @Override
        public double[] computeValue(double[] variables) {
<span class="fc" id="L1152">            double x1 = variables[0];</span>
<span class="fc" id="L1153">            double x2 = variables[1];</span>
<span class="fc" id="L1154">            double[] f = new double[m];</span>
<span class="fc bfc" id="L1155" title="All 2 branches covered.">            for (int i = 0; i &lt; m; ++i) {</span>
<span class="fc" id="L1156">                double temp = i + 1;</span>
<span class="fc" id="L1157">                f[i] = 2 + 2 * temp - FastMath.exp(temp * x1) - FastMath.exp(temp * x2);</span>
            }
<span class="fc" id="L1159">            return f;</span>
        }
    }

    private static class BrownDennisFunction extends MinpackFunction {

        public BrownDennisFunction(int m, double[] startParams,
                                   double theoreticalStartCost,
                                   double theoreticalMinCost,
                                   double[] theoreticalMinParams) {
<span class="fc" id="L1169">            super(m, startParams, theoreticalMinCost,</span>
                theoreticalMinParams);
<span class="fc" id="L1171">            setCostAccuracy(2.5e-8);</span>
<span class="fc" id="L1172">        }</span>

        @Override
        public double[][] computeJacobian(double[] variables) {
<span class="fc" id="L1176">            double   x1 = variables[0];</span>
<span class="fc" id="L1177">            double   x2 = variables[1];</span>
<span class="fc" id="L1178">            double   x3 = variables[2];</span>
<span class="fc" id="L1179">            double   x4 = variables[3];</span>
<span class="fc" id="L1180">            double[][] jacobian = new double[m][];</span>
<span class="fc bfc" id="L1181" title="All 2 branches covered.">            for (int i = 0; i &lt; m; ++i) {</span>
<span class="fc" id="L1182">                double temp = (i + 1) / 5.0;</span>
<span class="fc" id="L1183">                double ti   = FastMath.sin(temp);</span>
<span class="fc" id="L1184">                double tmp1 = x1 + temp * x2 - FastMath.exp(temp);</span>
<span class="fc" id="L1185">                double tmp2 = x3 + ti   * x4 - FastMath.cos(temp);</span>
<span class="fc" id="L1186">                jacobian[i] = new double[] {</span>
                    2 * tmp1, 2 * temp * tmp1, 2 * tmp2, 2 * ti * tmp2
                };
            }
<span class="fc" id="L1190">            return jacobian;</span>
        }

        @Override
        public double[] computeValue(double[] variables) {
<span class="fc" id="L1195">            double x1 = variables[0];</span>
<span class="fc" id="L1196">            double x2 = variables[1];</span>
<span class="fc" id="L1197">            double x3 = variables[2];</span>
<span class="fc" id="L1198">            double x4 = variables[3];</span>
<span class="fc" id="L1199">            double[] f = new double[m];</span>
<span class="fc bfc" id="L1200" title="All 2 branches covered.">            for (int i = 0; i &lt; m; ++i) {</span>
<span class="fc" id="L1201">                double temp = (i + 1) / 5.0;</span>
<span class="fc" id="L1202">                double tmp1 = x1 + temp * x2 - FastMath.exp(temp);</span>
<span class="fc" id="L1203">                double tmp2 = x3 + FastMath.sin(temp) * x4 - FastMath.cos(temp);</span>
<span class="fc" id="L1204">                f[i] = tmp1 * tmp1 + tmp2 * tmp2;</span>
            }
<span class="fc" id="L1206">            return f;</span>
        }
    }

    private static class ChebyquadFunction extends MinpackFunction {

        private static double[] buildChebyquadArray(int n, double factor) {
<span class="fc" id="L1213">            double[] array = new double[n];</span>
<span class="fc" id="L1214">            double inv = factor / (n + 1);</span>
<span class="fc bfc" id="L1215" title="All 2 branches covered.">            for (int i = 0; i &lt; n; ++i) {</span>
<span class="fc" id="L1216">                array[i] = (i + 1) * inv;</span>
            }
<span class="fc" id="L1218">            return array;</span>
        }

        public ChebyquadFunction(int n, int m, double factor,
                                 double theoreticalStartCost,
                                 double theoreticalMinCost,
                                 double[] theoreticalMinParams) {
<span class="fc" id="L1225">            super(m, buildChebyquadArray(n, factor), theoreticalMinCost,</span>
                  theoreticalMinParams);
<span class="fc" id="L1227">        }</span>

        @Override
        public double[][] computeJacobian(double[] variables) {
<span class="fc" id="L1231">            double[][] jacobian = new double[m][];</span>
<span class="fc bfc" id="L1232" title="All 2 branches covered.">            for (int i = 0; i &lt; m; ++i) {</span>
<span class="fc" id="L1233">                jacobian[i] = new double[n];</span>
            }

<span class="fc" id="L1236">            double dx = 1.0 / n;</span>
<span class="fc bfc" id="L1237" title="All 2 branches covered.">            for (int j = 0; j &lt; n; ++j) {</span>
<span class="fc" id="L1238">                double tmp1 = 1;</span>
<span class="fc" id="L1239">                double tmp2 = 2 * variables[j] - 1;</span>
<span class="fc" id="L1240">                double temp = 2 * tmp2;</span>
<span class="fc" id="L1241">                double tmp3 = 0;</span>
<span class="fc" id="L1242">                double tmp4 = 2;</span>
<span class="fc bfc" id="L1243" title="All 2 branches covered.">                for (int i = 0; i &lt; m; ++i) {</span>
<span class="fc" id="L1244">                    jacobian[i][j] = dx * tmp4;</span>
<span class="fc" id="L1245">                    double ti = 4 * tmp2 + temp * tmp4 - tmp3;</span>
<span class="fc" id="L1246">                    tmp3 = tmp4;</span>
<span class="fc" id="L1247">                    tmp4 = ti;</span>
<span class="fc" id="L1248">                    ti   = temp * tmp2 - tmp1;</span>
<span class="fc" id="L1249">                    tmp1 = tmp2;</span>
<span class="fc" id="L1250">                    tmp2 = ti;</span>
                }
            }

<span class="fc" id="L1254">            return jacobian;</span>
        }

        @Override
        public double[] computeValue(double[] variables) {
<span class="fc" id="L1259">            double[] f = new double[m];</span>

<span class="fc bfc" id="L1261" title="All 2 branches covered.">            for (int j = 0; j &lt; n; ++j) {</span>
<span class="fc" id="L1262">                double tmp1 = 1;</span>
<span class="fc" id="L1263">                double tmp2 = 2 * variables[j] - 1;</span>
<span class="fc" id="L1264">                double temp = 2 * tmp2;</span>
<span class="fc bfc" id="L1265" title="All 2 branches covered.">                for (int i = 0; i &lt; m; ++i) {</span>
<span class="fc" id="L1266">                    f[i] += tmp2;</span>
<span class="fc" id="L1267">                    double ti = temp * tmp2 - tmp1;</span>
<span class="fc" id="L1268">                    tmp1 = tmp2;</span>
<span class="fc" id="L1269">                    tmp2 = ti;</span>
                }
            }

<span class="fc" id="L1273">            double dx = 1.0 / n;</span>
<span class="fc" id="L1274">            boolean iev = false;</span>
<span class="fc bfc" id="L1275" title="All 2 branches covered.">            for (int i = 0; i &lt; m; ++i) {</span>
<span class="fc" id="L1276">                f[i] *= dx;</span>
<span class="fc bfc" id="L1277" title="All 2 branches covered.">                if (iev) {</span>
<span class="fc" id="L1278">                    f[i] += 1.0 / (i * (i + 2));</span>
                }
<span class="fc bfc" id="L1280" title="All 2 branches covered.">                iev = ! iev;</span>
            }

<span class="fc" id="L1283">            return f;</span>
        }
    }

    private static class BrownAlmostLinearFunction extends MinpackFunction {

        public BrownAlmostLinearFunction(int m, double factor,
                                         double theoreticalStartCost,
                                         double theoreticalMinCost,
                                         double[] theoreticalMinParams) {
<span class="fc" id="L1293">            super(m, buildArray(m, factor), theoreticalMinCost,</span>
                  theoreticalMinParams);
<span class="fc" id="L1295">        }</span>

        @Override
        public double[][] computeJacobian(double[] variables) {
<span class="fc" id="L1299">            double[][] jacobian = new double[m][];</span>
<span class="fc bfc" id="L1300" title="All 2 branches covered.">            for (int i = 0; i &lt; m; ++i) {</span>
<span class="fc" id="L1301">                jacobian[i] = new double[n];</span>
            }

<span class="fc" id="L1304">            double prod = 1;</span>
<span class="fc bfc" id="L1305" title="All 2 branches covered.">            for (int j = 0; j &lt; n; ++j) {</span>
<span class="fc" id="L1306">                prod *= variables[j];</span>
<span class="fc bfc" id="L1307" title="All 2 branches covered.">                for (int i = 0; i &lt; n; ++i) {</span>
<span class="fc" id="L1308">                    jacobian[i][j] = 1;</span>
                }
<span class="fc" id="L1310">                jacobian[j][j] = 2;</span>
            }

<span class="fc bfc" id="L1313" title="All 2 branches covered.">            for (int j = 0; j &lt; n; ++j) {</span>
<span class="fc" id="L1314">                double temp = variables[j];</span>
<span class="pc bpc" id="L1315" title="1 of 2 branches missed.">                if (temp == 0) {</span>
<span class="nc" id="L1316">                    temp = 1;</span>
<span class="nc" id="L1317">                    prod = 1;</span>
<span class="nc bnc" id="L1318" title="All 2 branches missed.">                    for (int k = 0; k &lt; n; ++k) {</span>
<span class="nc bnc" id="L1319" title="All 2 branches missed.">                        if (k != j) {</span>
<span class="nc" id="L1320">                            prod *= variables[k];</span>
                        }
                    }
                }
<span class="fc" id="L1324">                jacobian[n - 1][j] = prod / temp;</span>
            }

<span class="fc" id="L1327">            return jacobian;</span>
        }

        @Override
        public double[] computeValue(double[] variables) {
<span class="fc" id="L1332">            double[] f = new double[m];</span>
<span class="fc" id="L1333">            double sum  = -(n + 1);</span>
<span class="fc" id="L1334">            double prod = 1;</span>
<span class="fc bfc" id="L1335" title="All 2 branches covered.">            for (int j = 0; j &lt; n; ++j) {</span>
<span class="fc" id="L1336">                sum  += variables[j];</span>
<span class="fc" id="L1337">                prod *= variables[j];</span>
            }
<span class="fc bfc" id="L1339" title="All 2 branches covered.">            for (int i = 0; i &lt; n; ++i) {</span>
<span class="fc" id="L1340">                f[i] = variables[i] + sum;</span>
            }
<span class="fc" id="L1342">            f[n - 1] = prod - 1;</span>
<span class="fc" id="L1343">            return f;</span>
        }
    }

    private static class Osborne1Function extends MinpackFunction {

        public Osborne1Function(double[] startParams,
                                double theoreticalStartCost,
                                double theoreticalMinCost,
                                double[] theoreticalMinParams) {
<span class="fc" id="L1353">            super(33, startParams, theoreticalMinCost,</span>
                  theoreticalMinParams);
<span class="fc" id="L1355">        }</span>

        @Override
        public double[][] computeJacobian(double[] variables) {
<span class="fc" id="L1359">            double   x2 = variables[1];</span>
<span class="fc" id="L1360">            double   x3 = variables[2];</span>
<span class="fc" id="L1361">            double   x4 = variables[3];</span>
<span class="fc" id="L1362">            double   x5 = variables[4];</span>
<span class="fc" id="L1363">            double[][] jacobian = new double[m][];</span>
<span class="fc bfc" id="L1364" title="All 2 branches covered.">            for (int i = 0; i &lt; m; ++i) {</span>
<span class="fc" id="L1365">                double temp = 10.0 * i;</span>
<span class="fc" id="L1366">                double tmp1 = FastMath.exp(-temp * x4);</span>
<span class="fc" id="L1367">                double tmp2 = FastMath.exp(-temp * x5);</span>
<span class="fc" id="L1368">                jacobian[i] = new double[] {</span>
                    -1, -tmp1, -tmp2, temp * x2 * tmp1, temp * x3 * tmp2
                };
            }
<span class="fc" id="L1372">            return jacobian;</span>
        }

        @Override
        public double[] computeValue(double[] variables) {
<span class="fc" id="L1377">            double x1 = variables[0];</span>
<span class="fc" id="L1378">            double x2 = variables[1];</span>
<span class="fc" id="L1379">            double x3 = variables[2];</span>
<span class="fc" id="L1380">            double x4 = variables[3];</span>
<span class="fc" id="L1381">            double x5 = variables[4];</span>
<span class="fc" id="L1382">            double[] f = new double[m];</span>
<span class="fc bfc" id="L1383" title="All 2 branches covered.">            for (int i = 0; i &lt; m; ++i) {</span>
<span class="fc" id="L1384">                double temp = 10.0 * i;</span>
<span class="fc" id="L1385">                double tmp1 = FastMath.exp(-temp * x4);</span>
<span class="fc" id="L1386">                double tmp2 = FastMath.exp(-temp * x5);</span>
<span class="fc" id="L1387">                f[i] = y[i] - (x1 + x2 * tmp1 + x3 * tmp2);</span>
            }
<span class="fc" id="L1389">            return f;</span>
        }

<span class="fc" id="L1392">        private static final double[] y = {</span>
            0.844, 0.908, 0.932, 0.936, 0.925, 0.908, 0.881, 0.850, 0.818, 0.784, 0.751,
            0.718, 0.685, 0.658, 0.628, 0.603, 0.580, 0.558, 0.538, 0.522, 0.506, 0.490,
            0.478, 0.467, 0.457, 0.448, 0.438, 0.431, 0.424, 0.420, 0.414, 0.411, 0.406
        };
    }

    private static class Osborne2Function extends MinpackFunction {

        public Osborne2Function(double[] startParams,
                                double theoreticalStartCost,
                                double theoreticalMinCost,
                                double[] theoreticalMinParams) {
<span class="fc" id="L1405">            super(65, startParams, theoreticalMinCost,</span>
                  theoreticalMinParams);
<span class="fc" id="L1407">        }</span>

        @Override
        public double[][] computeJacobian(double[] variables) {
<span class="fc" id="L1411">            double   x01 = variables[0];</span>
<span class="fc" id="L1412">            double   x02 = variables[1];</span>
<span class="fc" id="L1413">            double   x03 = variables[2];</span>
<span class="fc" id="L1414">            double   x04 = variables[3];</span>
<span class="fc" id="L1415">            double   x05 = variables[4];</span>
<span class="fc" id="L1416">            double   x06 = variables[5];</span>
<span class="fc" id="L1417">            double   x07 = variables[6];</span>
<span class="fc" id="L1418">            double   x08 = variables[7];</span>
<span class="fc" id="L1419">            double   x09 = variables[8];</span>
<span class="fc" id="L1420">            double   x10 = variables[9];</span>
<span class="fc" id="L1421">            double   x11 = variables[10];</span>
<span class="fc" id="L1422">            double[][] jacobian = new double[m][];</span>
<span class="fc bfc" id="L1423" title="All 2 branches covered.">            for (int i = 0; i &lt; m; ++i) {</span>
<span class="fc" id="L1424">                double temp = i / 10.0;</span>
<span class="fc" id="L1425">                double tmp1 = FastMath.exp(-x05 * temp);</span>
<span class="fc" id="L1426">                double tmp2 = FastMath.exp(-x06 * (temp - x09) * (temp - x09));</span>
<span class="fc" id="L1427">                double tmp3 = FastMath.exp(-x07 * (temp - x10) * (temp - x10));</span>
<span class="fc" id="L1428">                double tmp4 = FastMath.exp(-x08 * (temp - x11) * (temp - x11));</span>
<span class="fc" id="L1429">                jacobian[i] = new double[] {</span>
                    -tmp1,
                    -tmp2,
                    -tmp3,
                    -tmp4,
                    temp * x01 * tmp1,
                    x02 * (temp - x09) * (temp - x09) * tmp2,
                    x03 * (temp - x10) * (temp - x10) * tmp3,
                    x04 * (temp - x11) * (temp - x11) * tmp4,
                    -2 * x02 * x06 * (temp - x09) * tmp2,
                    -2 * x03 * x07 * (temp - x10) * tmp3,
                    -2 * x04 * x08 * (temp - x11) * tmp4
                };
            }
<span class="fc" id="L1443">            return jacobian;</span>
        }

        @Override
        public double[] computeValue(double[] variables) {
<span class="fc" id="L1448">            double x01 = variables[0];</span>
<span class="fc" id="L1449">            double x02 = variables[1];</span>
<span class="fc" id="L1450">            double x03 = variables[2];</span>
<span class="fc" id="L1451">            double x04 = variables[3];</span>
<span class="fc" id="L1452">            double x05 = variables[4];</span>
<span class="fc" id="L1453">            double x06 = variables[5];</span>
<span class="fc" id="L1454">            double x07 = variables[6];</span>
<span class="fc" id="L1455">            double x08 = variables[7];</span>
<span class="fc" id="L1456">            double x09 = variables[8];</span>
<span class="fc" id="L1457">            double x10 = variables[9];</span>
<span class="fc" id="L1458">            double x11 = variables[10];</span>
<span class="fc" id="L1459">            double[] f = new double[m];</span>
<span class="fc bfc" id="L1460" title="All 2 branches covered.">            for (int i = 0; i &lt; m; ++i) {</span>
<span class="fc" id="L1461">                double temp = i / 10.0;</span>
<span class="fc" id="L1462">                double tmp1 = FastMath.exp(-x05 * temp);</span>
<span class="fc" id="L1463">                double tmp2 = FastMath.exp(-x06 * (temp - x09) * (temp - x09));</span>
<span class="fc" id="L1464">                double tmp3 = FastMath.exp(-x07 * (temp - x10) * (temp - x10));</span>
<span class="fc" id="L1465">                double tmp4 = FastMath.exp(-x08 * (temp - x11) * (temp - x11));</span>
<span class="fc" id="L1466">                f[i] = y[i] - (x01 * tmp1 + x02 * tmp2 + x03 * tmp3 + x04 * tmp4);</span>
            }
<span class="fc" id="L1468">            return f;</span>
        }

<span class="fc" id="L1471">        private static final double[] y = {</span>
            1.366, 1.191, 1.112, 1.013, 0.991,
            0.885, 0.831, 0.847, 0.786, 0.725,
            0.746, 0.679, 0.608, 0.655, 0.616,
            0.606, 0.602, 0.626, 0.651, 0.724,
            0.649, 0.649, 0.694, 0.644, 0.624,
            0.661, 0.612, 0.558, 0.533, 0.495,
            0.500, 0.423, 0.395, 0.375, 0.372,
            0.391, 0.396, 0.405, 0.428, 0.429,
            0.523, 0.562, 0.607, 0.653, 0.672,
            0.708, 0.633, 0.668, 0.645, 0.632,
            0.591, 0.559, 0.597, 0.625, 0.739,
            0.710, 0.729, 0.720, 0.636, 0.581,
            0.428, 0.292, 0.162, 0.098, 0.054
        };
    }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.1.201803210924</span></div></body></html>