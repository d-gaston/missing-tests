<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>PercentileTest.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">commons_math4$All_in_commons_math4.exec</a> &gt; <a href="index.source.html" class="el_package">org.apache.commons.math4.stat.descriptive.rank</a> &gt; <span class="el_source">PercentileTest.java</span></div><h1>PercentileTest.java</h1><pre class="source lang-java linenums">/*
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the &quot;License&quot;); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.commons.math4.stat.descriptive.rank;

import java.util.Arrays;

import org.apache.commons.statistics.distribution.ContinuousDistribution;
import org.apache.commons.math4.distribution.AbstractRealDistribution;
import org.apache.commons.statistics.distribution.NormalDistribution;
import org.apache.commons.math4.exception.MathIllegalArgumentException;
import org.apache.commons.math4.exception.NotANumberException;
import org.apache.commons.math4.exception.NullArgumentException;
import org.apache.commons.math4.exception.OutOfRangeException;
import org.apache.commons.rng.simple.RandomSource;
import org.apache.commons.math4.stat.descriptive.UnivariateStatistic;
import org.apache.commons.math4.stat.descriptive.UnivariateStatisticAbstractTest;
import org.apache.commons.math4.stat.descriptive.rank.Percentile.EstimationType;
import org.apache.commons.math4.stat.ranking.NaNStrategy;
import org.apache.commons.math4.util.CentralPivotingStrategy;
import org.apache.commons.math4.util.KthSelector;
import org.apache.commons.math4.util.MathArrays;
import org.apache.commons.math4.util.MedianOf3PivotingStrategy;
import org.apache.commons.math4.util.PivotingStrategyInterface;
import org.apache.commons.math4.util.RandomPivotingStrategy;
import org.junit.Assert;
import org.junit.Before;
import org.junit.Test;

/**
 * Test cases for the {@link UnivariateStatistic} class.
 */
<span class="fc" id="L46">public class PercentileTest extends UnivariateStatisticAbstractTest{</span>

    protected Percentile stat;

    private double quantile;

    /**
     * {@link org.apache.commons.math4.stat.descriptive.rank.Percentile.EstimationType type}
     * of estimation to be used while calling {@link #getUnivariateStatistic()}
     */
    private Percentile.EstimationType type;

    /**
     * {@link NaNStrategy}
     * of estimation to be used while calling {@link #getUnivariateStatistic()}
     */
    private NaNStrategy nanStrategy;

    /**
     * kth selector
     */
    private KthSelector kthSelector;

    /**
     * A default percentile to be used for {@link #getUnivariateStatistic()}
     */
<span class="fc" id="L72">    protected final double DEFAULT_PERCENTILE = 95d;</span>

    /**
     * Before method to ensure defaults retained
     */
    @Before
    public void before() {
<span class="fc" id="L79">        quantile         = 95.0;</span>
<span class="fc" id="L80">        type             = Percentile.EstimationType.LEGACY;</span>
<span class="fc" id="L81">        nanStrategy      = NaNStrategy.REMOVED;</span>
<span class="fc" id="L82">        kthSelector      = new KthSelector(new MedianOf3PivotingStrategy());</span>
<span class="fc" id="L83">    }</span>

    private void reset(final double p, final Percentile.EstimationType type) {
<span class="fc" id="L86">        this.quantile = p;</span>
<span class="fc" id="L87">        this.type     = type;</span>
<span class="fc bfc" id="L88" title="All 2 branches covered.">        nanStrategy   = (type == Percentile.EstimationType.LEGACY) ? NaNStrategy.FIXED : NaNStrategy.REMOVED;</span>
<span class="fc" id="L89">    }</span>

    /**
     * {@inheritDoc}
     */
    @Override
    public Percentile getUnivariateStatistic() {
<span class="fc" id="L96">        return new Percentile(quantile).</span>
<span class="fc" id="L97">                withEstimationType(type).</span>
<span class="fc" id="L98">                withNaNStrategy(nanStrategy).</span>
<span class="fc" id="L99">                withKthSelector(kthSelector);</span>
    }

    /**
     * {@inheritDoc}
     */
    @Override
    public double expectedValue() {
<span class="fc" id="L107">        return this.percentile95;</span>
    }

    @Test
    public void testHighPercentile(){
<span class="fc" id="L112">        final double[] d = new double[]{1, 2, 3};</span>
<span class="fc" id="L113">        final Percentile p = new Percentile(75);</span>
<span class="fc" id="L114">        Assert.assertEquals(3.0, p.evaluate(d), 1.0e-5);</span>
<span class="fc" id="L115">    }</span>

    @Test
    public void testLowPercentile() {
<span class="fc" id="L119">        final double[] d = new double[] {0, 1};</span>
<span class="fc" id="L120">        final Percentile p = new Percentile(25);</span>
<span class="fc" id="L121">        Assert.assertEquals(0d, p.evaluate(d), Double.MIN_VALUE);</span>
<span class="fc" id="L122">    }</span>

    @Test
    public void testPercentile() {
<span class="fc" id="L126">        final double[] d = new double[] {1, 3, 2, 4};</span>
<span class="fc" id="L127">        final Percentile p = new Percentile(30);</span>
<span class="fc" id="L128">        Assert.assertEquals(1.5, p.evaluate(d), 1.0e-5);</span>
<span class="fc" id="L129">        p.setQuantile(25);</span>
<span class="fc" id="L130">        Assert.assertEquals(1.25, p.evaluate(d), 1.0e-5);</span>
<span class="fc" id="L131">        p.setQuantile(75);</span>
<span class="fc" id="L132">        Assert.assertEquals(3.75, p.evaluate(d), 1.0e-5);</span>
<span class="fc" id="L133">        p.setQuantile(50);</span>
<span class="fc" id="L134">        Assert.assertEquals(2.5, p.evaluate(d), 1.0e-5);</span>

        // invalid percentiles
        try {
<span class="nc" id="L138">            p.evaluate(d, 0, d.length, -1.0);</span>
<span class="nc" id="L139">            Assert.fail();</span>
<span class="fc" id="L140">        } catch (final MathIllegalArgumentException ex) {</span>
            // success
<span class="nc" id="L142">        }</span>
        try {
<span class="nc" id="L144">            p.evaluate(d, 0, d.length, 101.0);</span>
<span class="nc" id="L145">            Assert.fail();</span>
<span class="fc" id="L146">        } catch (final MathIllegalArgumentException ex) {</span>
            // success
<span class="nc" id="L148">        }</span>
<span class="fc" id="L149">    }</span>

    @Test
    public void testNISTExample() {
<span class="fc" id="L153">        final double[] d = new double[] {95.1772, 95.1567, 95.1937, 95.1959,</span>
                95.1442, 95.0610,  95.1591, 95.1195, 95.1772, 95.0925, 95.1990, 95.1682
        };
<span class="fc" id="L156">        final Percentile p = new Percentile(90);</span>
<span class="fc" id="L157">        Assert.assertEquals(95.1981, p.evaluate(d), 1.0e-4);</span>
<span class="fc" id="L158">        Assert.assertEquals(95.1990, p.evaluate(d,0,d.length, 100d), 0);</span>
<span class="fc" id="L159">    }</span>

    @Test
    public void test5() {
<span class="fc" id="L163">        final Percentile percentile = new Percentile(5);</span>
<span class="fc" id="L164">        Assert.assertEquals(this.percentile5, percentile.evaluate(testArray), getTolerance());</span>
<span class="fc" id="L165">    }</span>

    @Test
    public void testNullEmpty() {
<span class="fc" id="L169">        final Percentile percentile = new Percentile(50);</span>
<span class="fc" id="L170">        final double[] nullArray = null;</span>
<span class="fc" id="L171">        final double[] emptyArray = new double[] {};</span>
        try {
<span class="nc" id="L173">            percentile.evaluate(nullArray);</span>
<span class="nc" id="L174">            Assert.fail(&quot;Expecting NullArgumentException for null array&quot;);</span>
<span class="fc" id="L175">        } catch (final NullArgumentException ex) {</span>
            // expected
<span class="nc" id="L177">        }</span>
<span class="fc" id="L178">        Assert.assertTrue(Double.isNaN(percentile.evaluate(emptyArray)));</span>
<span class="fc" id="L179">    }</span>

    @Test
    public void testSingleton() {
<span class="fc" id="L183">        final Percentile percentile = new Percentile(50);</span>
<span class="fc" id="L184">        final double[] singletonArray = new double[] {1d};</span>
<span class="fc" id="L185">        Assert.assertEquals(1d, percentile.evaluate(singletonArray), 0);</span>
<span class="fc" id="L186">        Assert.assertEquals(1d, percentile.evaluate(singletonArray, 0, 1), 0);</span>
<span class="fc" id="L187">        Assert.assertEquals(1d, percentile.evaluate(singletonArray, 0, 1, 5), 0);</span>
<span class="fc" id="L188">        Assert.assertEquals(1d, percentile.evaluate(singletonArray, 0, 1, 100), 0);</span>
<span class="fc" id="L189">        Assert.assertTrue(Double.isNaN(percentile.evaluate(singletonArray, 0, 0)));</span>
<span class="fc" id="L190">    }</span>

    @Test
    public void testSpecialValues() {
<span class="fc" id="L194">        final Percentile percentile = new Percentile(50);</span>
<span class="fc" id="L195">        double[] specialValues = new double[] {0d, 1d, 2d, 3d, 4d,  Double.NaN};</span>
<span class="fc" id="L196">        Assert.assertEquals(/*2.5d*/2d, percentile.evaluate(specialValues), 0);</span>
<span class="fc" id="L197">        specialValues =  new double[] {Double.NEGATIVE_INFINITY, 1d, 2d, 3d,</span>
                Double.NaN, Double.POSITIVE_INFINITY};
<span class="fc" id="L199">        Assert.assertEquals(/*2.5d*/2d, percentile.evaluate(specialValues), 0);</span>
<span class="fc" id="L200">        specialValues = new double[] {1d, 1d, Double.POSITIVE_INFINITY,</span>
                Double.POSITIVE_INFINITY};
<span class="fc" id="L202">        Assert.assertTrue(Double.isInfinite(percentile.evaluate(specialValues)));</span>
<span class="fc" id="L203">        specialValues = new double[] {1d, 1d, Double.NaN,</span>
                Double.NaN};
<span class="pc bpc" id="L205" title="1 of 2 branches missed.">        Assert.assertTrue(!Double.isNaN(percentile.evaluate(specialValues)));</span>
<span class="pc bpc" id="L206" title="1 of 2 branches missed.">        Assert.assertTrue(1d==percentile.evaluate(specialValues));</span>
<span class="fc" id="L207">        specialValues = new double[] {1d, 1d, Double.NEGATIVE_INFINITY,</span>
                Double.NEGATIVE_INFINITY};
        // Interpolation results in NEGATIVE_INFINITY + POSITIVE_INFINITY
<span class="fc" id="L210">        Assert.assertTrue(Double.isNaN(percentile.evaluate(specialValues)));</span>
<span class="fc" id="L211">    }</span>

    @Test
    public void testSetQuantile() {
<span class="fc" id="L215">        final Percentile percentile = new Percentile(10);</span>
<span class="fc" id="L216">        percentile.setQuantile(100); // OK</span>
<span class="fc" id="L217">        Assert.assertEquals(100, percentile.getQuantile(), 0);</span>
        try {
<span class="nc" id="L219">            percentile.setQuantile(0);</span>
<span class="nc" id="L220">            Assert.fail(&quot;Expecting MathIllegalArgumentException&quot;);</span>
<span class="fc" id="L221">        } catch (final MathIllegalArgumentException ex) {</span>
            // expected
<span class="nc" id="L223">        }</span>
        try {
<span class="nc" id="L225">            new Percentile(0);</span>
<span class="nc" id="L226">            Assert.fail(&quot;Expecting MathIllegalArgumentException&quot;);</span>
<span class="fc" id="L227">        } catch (final MathIllegalArgumentException ex) {</span>
            // expected
<span class="nc" id="L229">        }</span>
<span class="fc" id="L230">    }</span>

    //Below tests are basically to run for all estimation types.
    /**
     * While {@link #testHighPercentile()} checks only for the existing
     * implementation; this method verifies for all the types including Percentile.Type.CM Percentile.Type.
     */
    @Test
    public void testAllTechniquesHighPercentile() {
<span class="fc" id="L239">        final double[] d = new double[] { 1, 2, 3 };</span>
<span class="fc" id="L240">        testAssertMappedValues(d, new Object[][] { { Percentile.EstimationType.LEGACY, 3d }, { Percentile.EstimationType.R_1, 3d },</span>
<span class="fc" id="L241">                { Percentile.EstimationType.R_2, 3d }, { Percentile.EstimationType.R_3, 2d }, { Percentile.EstimationType.R_4, 2.25 }, { Percentile.EstimationType.R_5, 2.75 },</span>
<span class="fc" id="L242">                { Percentile.EstimationType.R_6, 3d }, { Percentile.EstimationType.R_7, 2.5 },{ Percentile.EstimationType.R_8, 2.83333 }, {Percentile.EstimationType.R_9,2.81250} },</span>
<span class="fc" id="L243">                75d, 1.0e-5);</span>
<span class="fc" id="L244">    }</span>

    @Test
    public void testAllTechniquesLowPercentile() {
<span class="fc" id="L248">        final double[] d = new double[] { 0, 1 };</span>
<span class="fc" id="L249">        testAssertMappedValues(d, new Object[][] { { Percentile.EstimationType.LEGACY, 0d }, { Percentile.EstimationType.R_1, 0d },</span>
<span class="fc" id="L250">                { Percentile.EstimationType.R_2, 0d }, { Percentile.EstimationType.R_3, 0d }, { Percentile.EstimationType.R_4, 0d }, {Percentile.EstimationType.R_5, 0d}, {Percentile.EstimationType.R_6, 0d},</span>
<span class="fc" id="L251">                { Percentile.EstimationType.R_7, 0.25 }, { Percentile.EstimationType.R_8, 0d }, {Percentile.EstimationType.R_9, 0d} },</span>
<span class="fc" id="L252">                25d, Double.MIN_VALUE);</span>
<span class="fc" id="L253">    }</span>

    public void checkAllTechniquesPercentile() {
<span class="fc" id="L256">        final double[] d = new double[] { 1, 3, 2, 4 };</span>

<span class="fc" id="L258">        testAssertMappedValues(d, new Object[][] { { Percentile.EstimationType.LEGACY, 1.5d },</span>
<span class="fc" id="L259">                { Percentile.EstimationType.R_1, 2d }, { Percentile.EstimationType.R_2, 2d }, { Percentile.EstimationType.R_3, 1d }, { Percentile.EstimationType.R_4, 1.2 }, {Percentile.EstimationType.R_5, 1.7},</span>
<span class="fc" id="L260">                { Percentile.EstimationType.R_6, 1.5 },{ Percentile.EstimationType.R_7, 1.9 }, { Percentile.EstimationType.R_8, 1.63333 },{ Percentile.EstimationType.R_9, 1.65 } },</span>
<span class="fc" id="L261">                30d, 1.0e-05);</span>

<span class="fc" id="L263">        testAssertMappedValues(d, new Object[][] { { Percentile.EstimationType.LEGACY, 1.25d },</span>
<span class="fc" id="L264">                { Percentile.EstimationType.R_1, 1d }, { Percentile.EstimationType.R_2, 1.5d }, { Percentile.EstimationType.R_3, 1d }, { Percentile.EstimationType.R_4, 1d }, {Percentile.EstimationType.R_5, 1.5},</span>
<span class="fc" id="L265">                { Percentile.EstimationType.R_6, 1.25 },{ Percentile.EstimationType.R_7, 1.75 },</span>
<span class="fc" id="L266">                { Percentile.EstimationType.R_8, 1.41667 }, { Percentile.EstimationType.R_9, 1.43750 } }, 25d, 1.0e-05);</span>

<span class="fc" id="L268">        testAssertMappedValues(d, new Object[][] { { Percentile.EstimationType.LEGACY, 3.75d },</span>
<span class="fc" id="L269">                { Percentile.EstimationType.R_1, 3d }, { Percentile.EstimationType.R_2, 3.5d }, { Percentile.EstimationType.R_3, 3d }, { Percentile.EstimationType.R_4, 3d },</span>
<span class="fc" id="L270">                { Percentile.EstimationType.R_5, 3.5d },{ Percentile.EstimationType.R_6, 3.75d }, { Percentile.EstimationType.R_7, 3.25 },</span>
<span class="fc" id="L271">                { Percentile.EstimationType.R_8, 3.58333 },{ Percentile.EstimationType.R_9, 3.56250} }, 75d, 1.0e-05);</span>

<span class="fc" id="L273">        testAssertMappedValues(d, new Object[][] { { Percentile.EstimationType.LEGACY, 2.5d },</span>
<span class="fc" id="L274">                { Percentile.EstimationType.R_1, 2d }, { Percentile.EstimationType.R_2, 2.5d }, { Percentile.EstimationType.R_3, 2d }, { Percentile.EstimationType.R_4, 2d },</span>
<span class="fc" id="L275">                { Percentile.EstimationType.R_5, 2.5 },{ Percentile.EstimationType.R_6, 2.5 },{ Percentile.EstimationType.R_7, 2.5 },</span>
<span class="fc" id="L276">                { Percentile.EstimationType.R_8, 2.5 },{ Percentile.EstimationType.R_9, 2.5 } }, 50d, 1.0e-05);</span>

        // invalid percentiles
<span class="fc bfc" id="L279" title="All 2 branches covered.">        for (final Percentile.EstimationType e : Percentile.EstimationType.values()) {</span>
            try {
<span class="fc" id="L281">                reset(-1.0, e);</span>
<span class="nc" id="L282">                getUnivariateStatistic().evaluate(d, 0, d.length);</span>
<span class="nc" id="L283">                Assert.fail();</span>
<span class="fc" id="L284">            } catch (final MathIllegalArgumentException ex) {</span>
                // success
<span class="nc" id="L286">            }</span>
        }

<span class="fc bfc" id="L289" title="All 2 branches covered.">        for (final Percentile.EstimationType e : Percentile.EstimationType.values()) {</span>
            try {
<span class="fc" id="L291">                reset(101.0, e);</span>
<span class="nc" id="L292">                getUnivariateStatistic().evaluate(d, 0, d.length);</span>
<span class="nc" id="L293">                Assert.fail();</span>
<span class="fc" id="L294">            } catch (final MathIllegalArgumentException ex) {</span>
                // success
<span class="nc" id="L296">            }</span>
        }
<span class="fc" id="L298">    }</span>

    @Test
    public void testAllTechniquesPercentileUsingMedianOf3Pivoting() {
<span class="fc" id="L302">        kthSelector = new KthSelector(new MedianOf3PivotingStrategy());</span>
<span class="fc" id="L303">        Assert.assertEquals(MedianOf3PivotingStrategy.class,</span>
<span class="fc" id="L304">                            getUnivariateStatistic().getPivotingStrategy().getClass());</span>
<span class="fc" id="L305">        checkAllTechniquesPercentile();</span>
<span class="fc" id="L306">    }</span>

    @Test
    public void testAllTechniquesPercentileUsingCentralPivoting() {
<span class="fc" id="L310">        kthSelector = new KthSelector(new CentralPivotingStrategy());</span>
<span class="fc" id="L311">        Assert.assertEquals(CentralPivotingStrategy.class,</span>
<span class="fc" id="L312">                            getUnivariateStatistic().getPivotingStrategy().getClass());</span>
<span class="fc" id="L313">        checkAllTechniquesPercentile();</span>
<span class="fc" id="L314">    }</span>

    @Test
    public void testAllTechniquesPercentileUsingRandomPivoting() {
<span class="fc" id="L318">        kthSelector = new KthSelector(new RandomPivotingStrategy(RandomSource.WELL_1024_A, 0x268a7fb4194240f6l));</span>
<span class="fc" id="L319">        Assert.assertEquals(RandomPivotingStrategy.class,</span>
<span class="fc" id="L320">                            getUnivariateStatistic().getPivotingStrategy().getClass());</span>
<span class="fc" id="L321">        checkAllTechniquesPercentile();</span>
<span class="fc" id="L322">    }</span>

    @Test
    public void testAllTechniquesNISTExample() {
<span class="fc" id="L326">        final double[] d =</span>
                new double[] { 95.1772, 95.1567, 95.1937, 95.1959, 95.1442,
                        95.0610, 95.1591, 95.1195, 95.1772, 95.0925, 95.1990,
                        95.1682 };

<span class="fc" id="L331">        testAssertMappedValues(d, new Object[][] { { Percentile.EstimationType.LEGACY, 95.1981 },</span>
<span class="fc" id="L332">                { Percentile.EstimationType.R_1, 95.19590 }, { Percentile.EstimationType.R_2, 95.19590 }, { Percentile.EstimationType.R_3, 95.19590 },</span>
<span class="fc" id="L333">                { Percentile.EstimationType.R_4, 95.19546 }, { Percentile.EstimationType.R_5, 95.19683 }, { Percentile.EstimationType.R_6, 95.19807 },</span>
<span class="fc" id="L334">                { Percentile.EstimationType.R_7, 95.19568 }, { Percentile.EstimationType.R_8, 95.19724 }, { Percentile.EstimationType.R_9, 95.19714 } }, 90d,</span>
<span class="fc" id="L335">                1.0e-04);</span>

<span class="fc bfc" id="L337" title="All 2 branches covered.">        for (final Percentile.EstimationType e : Percentile.EstimationType.values()) {</span>
<span class="fc" id="L338">            reset(100.0, e);</span>
<span class="fc" id="L339">            Assert.assertEquals(95.1990, getUnivariateStatistic().evaluate(d), 1.0e-4);</span>
        }
<span class="fc" id="L341">    }</span>

    @Test
    public void testAllTechniques5() {
<span class="fc" id="L345">        reset(5, Percentile.EstimationType.LEGACY);</span>
<span class="fc" id="L346">        final UnivariateStatistic percentile = getUnivariateStatistic();</span>
<span class="fc" id="L347">        Assert.assertEquals(this.percentile5, percentile.evaluate(testArray),</span>
<span class="fc" id="L348">                getTolerance());</span>
<span class="fc" id="L349">        testAssertMappedValues(testArray,</span>
<span class="fc" id="L350">                new Object[][] { { Percentile.EstimationType.LEGACY, percentile5 }, { Percentile.EstimationType.R_1, 8.8000 },</span>
<span class="fc" id="L351">                        { Percentile.EstimationType.R_2, 8.8000 }, { Percentile.EstimationType.R_3, 8.2000 }, { Percentile.EstimationType.R_4, 8.2600 },</span>
<span class="fc" id="L352">                        { Percentile.EstimationType.R_5, 8.5600 }, { Percentile.EstimationType.R_6, 8.2900 },</span>
<span class="fc" id="L353">                        { Percentile.EstimationType.R_7, 8.8100 }, { Percentile.EstimationType.R_8, 8.4700 },</span>
<span class="fc" id="L354">                        { Percentile.EstimationType.R_9, 8.4925 }}, 5d, getTolerance());</span>
<span class="fc" id="L355">    }</span>

    @Test
    public void testAllTechniquesNullEmpty() {

<span class="fc" id="L360">        final double[] nullArray = null;</span>
<span class="fc" id="L361">        final double[] emptyArray = new double[] {};</span>
<span class="fc bfc" id="L362" title="All 2 branches covered.">        for (final Percentile.EstimationType e : Percentile.EstimationType.values()) {</span>
<span class="fc" id="L363">            reset (50, e);</span>
<span class="fc" id="L364">            final UnivariateStatistic percentile = getUnivariateStatistic();</span>
            try {
<span class="nc" id="L366">                percentile.evaluate(nullArray);</span>
<span class="nc" id="L367">                Assert.fail(&quot;Expecting NullArgumentException &quot;</span>
                        + &quot;for null array&quot;);
<span class="fc" id="L369">            } catch (final NullArgumentException ex) {</span>
                // expected
<span class="nc" id="L371">            }</span>
<span class="fc" id="L372">            Assert.assertTrue(Double.isNaN(percentile.evaluate(emptyArray)));</span>
        }

<span class="fc" id="L375">    }</span>

    @Test
    public void testAllTechniquesSingleton() {
<span class="fc" id="L379">        final double[] singletonArray = new double[] { 1d };</span>
<span class="fc bfc" id="L380" title="All 2 branches covered.">        for (final Percentile.EstimationType e : Percentile.EstimationType.values()) {</span>
<span class="fc" id="L381">            reset (50, e);</span>
<span class="fc" id="L382">            final UnivariateStatistic percentile = getUnivariateStatistic();</span>
<span class="fc" id="L383">            Assert.assertEquals(1d, percentile.evaluate(singletonArray), 0);</span>
<span class="fc" id="L384">            Assert.assertEquals(1d, percentile.evaluate(singletonArray, 0, 1),</span>
                    0);
<span class="fc" id="L386">            Assert.assertEquals(1d,</span>
<span class="fc" id="L387">                    new Percentile().evaluate(singletonArray, 0, 1, 5), 0);</span>
<span class="fc" id="L388">            Assert.assertEquals(1d,</span>
<span class="fc" id="L389">                    new Percentile().evaluate(singletonArray, 0, 1, 100), 0);</span>
<span class="fc" id="L390">            Assert.assertTrue(Double.isNaN(percentile.evaluate(singletonArray,</span>
                    0, 0)));
        }
<span class="fc" id="L393">    }</span>

    @Test
    public void testAllTechniquesEmpty() {
<span class="fc" id="L397">        final double[] singletonArray = new double[] { };</span>
<span class="fc bfc" id="L398" title="All 2 branches covered.">        for (final Percentile.EstimationType e : Percentile.EstimationType.values()) {</span>
<span class="fc" id="L399">            reset (50, e);</span>
<span class="fc" id="L400">            final UnivariateStatistic percentile = getUnivariateStatistic();</span>
<span class="fc" id="L401">            Assert.assertEquals(Double.NaN, percentile.evaluate(singletonArray),</span>
                    0);
<span class="fc" id="L403">            Assert.assertEquals(Double.NaN, percentile.evaluate(singletonArray,</span>
                    0, 0),
                    0);
<span class="fc" id="L406">            Assert.assertEquals(Double.NaN,</span>
<span class="fc" id="L407">                    new Percentile().evaluate(singletonArray, 0, 0, 5), 0);</span>
<span class="fc" id="L408">            Assert.assertEquals(Double.NaN,</span>
<span class="fc" id="L409">                    new Percentile().evaluate(singletonArray, 0, 0, 100), 0);</span>
<span class="fc" id="L410">            Assert.assertTrue(Double.isNaN(percentile.evaluate(singletonArray,</span>
                    0, 0)));
        }
<span class="fc" id="L413">    }</span>

    @Test
    public void testReplaceNanInRange() {
<span class="fc" id="L417">        final double[] specialValues =</span>
                new double[] { 0d, 1d, 2d, 3d, 4d, Double.NaN, Double.NaN, 5d,
                7d, Double.NaN, 8d};
<span class="fc" id="L420">        Assert.assertEquals(/*Double.NaN*/3.5,new Percentile(50d).evaluate(specialValues),0d);</span>
<span class="fc" id="L421">        reset (50, Percentile.EstimationType.R_1);</span>
<span class="fc" id="L422">        Assert.assertEquals(3d, getUnivariateStatistic().evaluate(specialValues),0d);</span>
<span class="fc" id="L423">        reset (50, Percentile.EstimationType.R_2);</span>
<span class="fc" id="L424">        Assert.assertEquals(3.5d, getUnivariateStatistic().evaluate(specialValues),0d);</span>
<span class="fc" id="L425">        Assert.assertEquals(Double.POSITIVE_INFINITY,new Percentile(70)</span>
<span class="fc" id="L426">                                        .withNaNStrategy(NaNStrategy.MAXIMAL)</span>
<span class="fc" id="L427">                                        .evaluate(specialValues),0d);</span>
<span class="fc" id="L428">    }</span>

    @Test
    public void testRemoveNan() {
<span class="fc" id="L432">        final double[] specialValues =</span>
                new double[] { 0d, 1d, 2d, 3d, 4d, Double.NaN };
<span class="fc" id="L434">        final double[] expectedValues =</span>
                new double[] { 0d, 1d, 2d, 3d, 4d };
<span class="fc" id="L436">        reset (50, Percentile.EstimationType.R_1);</span>
<span class="fc" id="L437">        Assert.assertEquals(2.0, getUnivariateStatistic().evaluate(specialValues), 0d);</span>
<span class="fc" id="L438">        Assert.assertEquals(2.0, getUnivariateStatistic().evaluate(expectedValues),0d);</span>
<span class="fc" id="L439">        Assert.assertTrue(Double.isNaN(getUnivariateStatistic().evaluate(specialValues,5,1)));</span>
<span class="fc" id="L440">        Assert.assertEquals(4d, getUnivariateStatistic().evaluate(specialValues, 4, 2), 0d);</span>
<span class="fc" id="L441">        Assert.assertEquals(3d, getUnivariateStatistic().evaluate(specialValues,3,3),0d);</span>
<span class="fc" id="L442">        reset(50, Percentile.EstimationType.R_2);</span>
<span class="fc" id="L443">        Assert.assertEquals(3.5d, getUnivariateStatistic().evaluate(specialValues,3,3),0d);</span>

<span class="fc" id="L445">    }</span>

    @Test
    public void testPercentileCopy() {
<span class="fc" id="L449">       reset(50d, Percentile.EstimationType.LEGACY);</span>
<span class="fc" id="L450">       final Percentile original = getUnivariateStatistic();</span>
<span class="fc" id="L451">       final Percentile copy = new Percentile(original);</span>
<span class="fc" id="L452">       Assert.assertEquals(original.getNaNStrategy(),copy.getNaNStrategy());</span>
<span class="fc" id="L453">       Assert.assertEquals(original.getQuantile(), copy.getQuantile(),0d);</span>
<span class="fc" id="L454">       Assert.assertEquals(original.getEstimationType(),copy.getEstimationType());</span>
<span class="fc" id="L455">       Assert.assertEquals(NaNStrategy.FIXED, original.getNaNStrategy());</span>
<span class="fc" id="L456">    }</span>

    @Test
    public void testAllTechniquesSpecialValues() {
<span class="fc" id="L460">        reset(50d, Percentile.EstimationType.LEGACY);</span>
<span class="fc" id="L461">        final UnivariateStatistic percentile = getUnivariateStatistic();</span>
<span class="fc" id="L462">        double[] specialValues =</span>
                new double[] { 0d, 1d, 2d, 3d, 4d, Double.NaN };
<span class="fc" id="L464">        Assert.assertEquals(2.5d, percentile.evaluate(specialValues), 0);</span>

<span class="fc" id="L466">        testAssertMappedValues(specialValues, new Object[][] {</span>
<span class="fc" id="L467">                { Percentile.EstimationType.LEGACY, 2.5d }, { Percentile.EstimationType.R_1, 2.0 }, { Percentile.EstimationType.R_2, 2.0 }, { Percentile.EstimationType.R_3, 1.0 },</span>
<span class="fc" id="L468">                { Percentile.EstimationType.R_4, 1.5 }, { Percentile.EstimationType.R_5, 2.0 }, { Percentile.EstimationType.R_6, 2.0 },</span>
<span class="fc" id="L469">                { Percentile.EstimationType.R_7, 2.0 }, { Percentile.EstimationType.R_8, 2.0 }, { Percentile.EstimationType.R_9, 2.0 }}, 50d, 0d);</span>

<span class="fc" id="L471">        specialValues =</span>
                new double[] { Double.NEGATIVE_INFINITY, 1d, 2d, 3d,
                        Double.NaN, Double.POSITIVE_INFINITY };
<span class="fc" id="L474">        Assert.assertEquals(2.5d, percentile.evaluate(specialValues), 0);</span>

<span class="fc" id="L476">        testAssertMappedValues(specialValues, new Object[][] {</span>
<span class="fc" id="L477">                { Percentile.EstimationType.LEGACY, 2.5d }, { Percentile.EstimationType.R_1, 2.0 }, { Percentile.EstimationType.R_2, 2.0 }, { Percentile.EstimationType.R_3, 1.0 },</span>
<span class="fc" id="L478">                { Percentile.EstimationType.R_4, 1.5 }, { Percentile.EstimationType.R_5, 2.0 }, { Percentile.EstimationType.R_7, 2.0 }, { Percentile.EstimationType.R_7, 2.0 },</span>
<span class="fc" id="L479">                { Percentile.EstimationType.R_8, 2.0 }, { Percentile.EstimationType.R_9, 2.0 } }, 50d, 0d);</span>

<span class="fc" id="L481">        specialValues =</span>
                new double[] { 1d, 1d, Double.POSITIVE_INFINITY,
                        Double.POSITIVE_INFINITY };
<span class="fc" id="L484">        Assert.assertTrue(Double.isInfinite(percentile.evaluate(specialValues)));</span>

<span class="fc" id="L486">        testAssertMappedValues(specialValues, new Object[][] {</span>
                // This is one test not matching with R results.
<span class="fc" id="L488">                { Percentile.EstimationType.LEGACY, Double.POSITIVE_INFINITY },</span>
<span class="fc" id="L489">                { Percentile.EstimationType.R_1,/* 1.0 */Double.NaN },</span>
<span class="fc" id="L490">                { Percentile.EstimationType.R_2, /* Double.POSITIVE_INFINITY */Double.NaN },</span>
<span class="fc" id="L491">                { Percentile.EstimationType.R_3, /* 1.0 */Double.NaN }, { Percentile.EstimationType.R_4, /* 1.0 */Double.NaN },</span>
<span class="fc" id="L492">                { Percentile.EstimationType.R_5, Double.POSITIVE_INFINITY },</span>
<span class="fc" id="L493">                { Percentile.EstimationType.R_6, Double.POSITIVE_INFINITY },</span>
<span class="fc" id="L494">                { Percentile.EstimationType.R_7, Double.POSITIVE_INFINITY },</span>
<span class="fc" id="L495">                { Percentile.EstimationType.R_8, Double.POSITIVE_INFINITY },</span>
<span class="fc" id="L496">                { Percentile.EstimationType.R_9, Double.POSITIVE_INFINITY }, }, 50d, 0d);</span>

<span class="fc" id="L498">        specialValues = new double[] { 1d, 1d, Double.NaN, Double.NaN };</span>
<span class="fc" id="L499">        Assert.assertTrue(Double.isNaN(percentile.evaluate(specialValues)));</span>
<span class="fc" id="L500">        testAssertMappedValues(specialValues, new Object[][] {</span>
<span class="fc" id="L501">                { Percentile.EstimationType.LEGACY, Double.NaN }, { Percentile.EstimationType.R_1, 1.0 }, { Percentile.EstimationType.R_2, 1.0 }, { Percentile.EstimationType.R_3, 1.0 },</span>
<span class="fc" id="L502">                { Percentile.EstimationType.R_4, 1.0 }, { Percentile.EstimationType.R_5, 1.0 },{ Percentile.EstimationType.R_6, 1.0 },{ Percentile.EstimationType.R_7, 1.0 },</span>
<span class="fc" id="L503">                { Percentile.EstimationType.R_8, 1.0 }, { Percentile.EstimationType.R_9, 1.0 },}, 50d, 0d);</span>

<span class="fc" id="L505">        specialValues =</span>
                new double[] { 1d, 1d, Double.NEGATIVE_INFINITY,
                        Double.NEGATIVE_INFINITY };

<span class="fc" id="L509">        testAssertMappedValues(specialValues, new Object[][] {</span>
<span class="fc" id="L510">                { Percentile.EstimationType.LEGACY, Double.NaN }, { Percentile.EstimationType.R_1, Double.NaN },</span>
<span class="fc" id="L511">                { Percentile.EstimationType.R_2, Double.NaN }, { Percentile.EstimationType.R_3, Double.NaN }, { Percentile.EstimationType.R_4, Double.NaN },</span>
<span class="fc" id="L512">                { Percentile.EstimationType.R_5, Double.NaN }, { Percentile.EstimationType.R_6, Double.NaN },</span>
<span class="fc" id="L513">                { Percentile.EstimationType.R_7, Double.NaN }, { Percentile.EstimationType.R_8, Double.NaN }, { Percentile.EstimationType.R_9, Double.NaN }</span>
<span class="fc" id="L514">                }, 50d, 0d);</span>

<span class="fc" id="L516">    }</span>

    @Test
    public void testAllTechniquesSetQuantile() {
<span class="fc bfc" id="L520" title="All 2 branches covered.">        for (final Percentile.EstimationType e : Percentile.EstimationType.values()) {</span>
<span class="fc" id="L521">            reset(10, e);</span>
<span class="fc" id="L522">            final Percentile percentile = getUnivariateStatistic();</span>
<span class="fc" id="L523">            percentile.setQuantile(100); // OK</span>
<span class="fc" id="L524">            Assert.assertEquals(100, percentile.getQuantile(), 0);</span>
            try {
<span class="nc" id="L526">                percentile.setQuantile(0);</span>
<span class="nc" id="L527">                Assert.fail(&quot;Expecting MathIllegalArgumentException&quot;);</span>
<span class="fc" id="L528">            } catch (final MathIllegalArgumentException ex) {</span>
                // expected
<span class="nc" id="L530">            }</span>
            try {
<span class="nc" id="L532">                new Percentile(0);</span>
<span class="nc" id="L533">                Assert.fail(&quot;Expecting MathIllegalArgumentException&quot;);</span>
<span class="fc" id="L534">            } catch (final MathIllegalArgumentException ex) {</span>
                // expected
<span class="nc" id="L536">            }</span>
        }
<span class="fc" id="L538">    }</span>

    @Test
    public void testAllTechniquesEvaluateArraySegmentWeighted() {
<span class="fc bfc" id="L542" title="All 2 branches covered.">        for (final Percentile.EstimationType e : Percentile.EstimationType.values()) {</span>
<span class="fc" id="L543">            reset(quantile, e);</span>
<span class="fc" id="L544">            testEvaluateArraySegmentWeighted();</span>
        }
<span class="fc" id="L546">    }</span>

    @Test
    public void testAllTechniquesEvaluateArraySegment() {
<span class="fc bfc" id="L550" title="All 2 branches covered.">        for (final Percentile.EstimationType e : Percentile.EstimationType.values()) {</span>
<span class="fc" id="L551">            reset(quantile, e);</span>
<span class="fc" id="L552">            testEvaluateArraySegment();</span>
        }
<span class="fc" id="L554">    }</span>

    @Test
    public void testAllTechniquesWeightedConsistency() {
<span class="fc bfc" id="L558" title="All 2 branches covered.">        for (final Percentile.EstimationType e : Percentile.EstimationType.values()) {</span>
<span class="fc" id="L559">            reset(quantile, e);</span>
<span class="fc" id="L560">            testWeightedConsistency();</span>
        }
<span class="fc" id="L562">    }</span>

    @Test
    public void testAllTechniquesEvaluation() {

<span class="fc" id="L567">        testAssertMappedValues(testArray, new Object[][] { { Percentile.EstimationType.LEGACY, 20.820 },</span>
<span class="fc" id="L568">                { Percentile.EstimationType.R_1, 19.800 }, { Percentile.EstimationType.R_2, 19.800 }, { Percentile.EstimationType.R_3, 19.800 },</span>
<span class="fc" id="L569">                { Percentile.EstimationType.R_4, 19.310 }, { Percentile.EstimationType.R_5, 20.280 }, { Percentile.EstimationType.R_6, 20.820 },</span>
<span class="fc" id="L570">                { Percentile.EstimationType.R_7, 19.555 }, { Percentile.EstimationType.R_8, 20.460 },{ Percentile.EstimationType.R_9, 20.415} },</span>
<span class="fc" id="L571">                DEFAULT_PERCENTILE, tolerance);</span>
<span class="fc" id="L572">    }</span>

    @Test
    public void testPercentileWithTechnique() {
<span class="fc" id="L576">        reset (50, Percentile.EstimationType.LEGACY);;</span>
<span class="fc" id="L577">        final Percentile p = getUnivariateStatistic();</span>
<span class="fc" id="L578">        Assert.assertTrue(Percentile.EstimationType.LEGACY.equals(p.getEstimationType()));</span>
<span class="fc" id="L579">        Assert.assertFalse(Percentile.EstimationType.R_1.equals(p.getEstimationType()));</span>
<span class="fc" id="L580">    }</span>

    static final int TINY = 10, SMALL = 50, NOMINAL = 100, MEDIUM = 500,
            STANDARD = 1000, BIG = 10000, VERY_BIG = 50000, LARGE = 1000000,
            VERY_LARGE = 10000000;
<span class="fc" id="L585">    static final int[] sampleSizes= {TINY , SMALL , NOMINAL , MEDIUM ,</span>
            STANDARD, BIG };

    @Test
    public void testStoredVsDirect() {
<span class="fc" id="L590">        final ContinuousDistribution.Sampler sampler =</span>
<span class="fc" id="L591">            new NormalDistribution(4000, 50).createSampler(RandomSource.create(RandomSource.JDK,</span>
<span class="fc" id="L592">                                                                               Long.MAX_VALUE));</span>

<span class="fc bfc" id="L594" title="All 2 branches covered.">        for (final int sampleSize : sampleSizes) {</span>
<span class="fc" id="L595">            final double[] data = AbstractRealDistribution.sample(sampleSize, sampler);</span>
<span class="fc bfc" id="L596" title="All 2 branches covered.">            for (final double p : new double[] { 50d, 95d }) {</span>
<span class="fc bfc" id="L597" title="All 2 branches covered.">                for (final Percentile.EstimationType e : Percentile.EstimationType.values()) {</span>
<span class="fc" id="L598">                    reset(p, e);</span>
<span class="fc" id="L599">                    final Percentile pStoredData = getUnivariateStatistic();</span>
<span class="fc" id="L600">                    pStoredData.setData(data);</span>
<span class="fc" id="L601">                    final double storedDataResult = pStoredData.evaluate();</span>
<span class="fc" id="L602">                    pStoredData.setData(null);</span>
<span class="fc" id="L603">                    final Percentile pDirect = getUnivariateStatistic();</span>
<span class="fc" id="L604">                    Assert.assertEquals(&quot;Sample=&quot; + sampleSize + &quot;, P=&quot; + p + &quot; e=&quot; + e,</span>
                                        storedDataResult,
<span class="fc" id="L606">                                        pDirect.evaluate(data), 0d);</span>
                }
            }
        }
<span class="fc" id="L610">    }</span>

    @Test
    public void testPercentileWithDataRef() {
<span class="fc" id="L614">        reset(50.0, Percentile.EstimationType.R_7);</span>
<span class="fc" id="L615">        final Percentile p = getUnivariateStatistic();</span>
<span class="fc" id="L616">        p.setData(testArray);</span>
<span class="fc" id="L617">        Assert.assertTrue(Percentile.EstimationType.R_7.equals(p.getEstimationType()));</span>
<span class="fc" id="L618">        Assert.assertFalse(Percentile.EstimationType.R_1.equals(p.getEstimationType()));</span>
<span class="fc" id="L619">        Assert.assertEquals(12d, p.evaluate(), 0d);</span>
<span class="fc" id="L620">        Assert.assertEquals(12.16d, p.evaluate(60d), 0d);</span>
<span class="fc" id="L621">    }</span>

    @Test(expected=NullArgumentException.class)
    public void testNullEstimation() {
<span class="fc" id="L625">        type = null;</span>
<span class="nc" id="L626">        getUnivariateStatistic();</span>
<span class="nc" id="L627">    }</span>

    @Test
    public void testAllEstimationTechniquesOnlyLimits() {
<span class="fc" id="L631">        final int N=testArray.length;</span>

<span class="fc" id="L633">        final double[] input=MathArrays.copyOf(testArray);</span>
<span class="fc" id="L634">        Arrays.sort(input);</span>
<span class="fc" id="L635">        final double min = input[0];</span>
<span class="fc" id="L636">        final double max=input[input.length-1];</span>
        //limits may be ducked by 0.01 to induce the condition of p&lt;pMin
<span class="fc" id="L638">        final Object[][] map =</span>
<span class="fc" id="L639">                new Object[][] { { Percentile.EstimationType.LEGACY, 0d, 1d }, { Percentile.EstimationType.R_1, 0d, 1d },</span>
<span class="fc" id="L640">                        { Percentile.EstimationType.R_2, 0d,1d }, { Percentile.EstimationType.R_3, 0.5/N,1d },</span>
<span class="fc" id="L641">                        { Percentile.EstimationType.R_4, 1d/N-0.001,1d },</span>
<span class="fc" id="L642">                        { Percentile.EstimationType.R_5, 0.5/N-0.001,(N-0.5)/N}, { Percentile.EstimationType.R_6, 0.99d/(N+1),</span>
<span class="fc" id="L643">                            1.01d*N/(N+1)},</span>
<span class="fc" id="L644">                        { Percentile.EstimationType.R_7, 0d,1d}, { Percentile.EstimationType.R_8, 1.99d/3/(N+1d/3),</span>
<span class="fc" id="L645">                            (N-1d/3)/(N+1d/3)},</span>
<span class="fc" id="L646">                        { Percentile.EstimationType.R_9, 4.99d/8/(N+0.25), (N-3d/8)/(N+0.25)} };</span>

<span class="fc bfc" id="L648" title="All 2 branches covered.">        for(final Object[] arr:map) {</span>
<span class="fc" id="L649">            final Percentile.EstimationType t= (Percentile.EstimationType) arr[0];</span>
<span class="fc" id="L650">            double pMin=(Double)arr[1];</span>
<span class="fc" id="L651">            final double pMax=(Double)arr[2];</span>
<span class="fc" id="L652">            Assert.assertEquals(&quot;Type:&quot;+t,0d, t.index(pMin, N),0d);</span>
<span class="fc" id="L653">            Assert.assertEquals(&quot;Type:&quot;+t,N, t.index(pMax, N),0.5d);</span>
<span class="fc bfc" id="L654" title="All 2 branches covered.">            pMin=pMin==0d?pMin+0.01:pMin;</span>
<span class="fc" id="L655">            testAssertMappedValues(testArray, new Object[][] { { t, min }}, pMin, 0.01);</span>
<span class="fc" id="L656">            testAssertMappedValues(testArray, new Object[][] { { t, max }}, pMax * 100, tolerance);</span>
        }
<span class="fc" id="L658">    }</span>

    @Test
    public void testAllEstimationTechniquesOnly() {
<span class="fc" id="L662">        Assert.assertEquals(&quot;Legacy Apache Commons Math&quot;,Percentile.EstimationType.LEGACY.getName());</span>
<span class="fc" id="L663">        final Object[][] map =</span>
<span class="fc" id="L664">                new Object[][] { { Percentile.EstimationType.LEGACY, 20.82 }, { Percentile.EstimationType.R_1, 19.8 },</span>
<span class="fc" id="L665">                        { Percentile.EstimationType.R_2, 19.8 }, { Percentile.EstimationType.R_3, 19.8 }, { Percentile.EstimationType.R_4, 19.310 },</span>
<span class="fc" id="L666">                        { Percentile.EstimationType.R_5, 20.280}, { Percentile.EstimationType.R_6, 20.820},</span>
<span class="fc" id="L667">                        { Percentile.EstimationType.R_7, 19.555 }, { Percentile.EstimationType.R_8, 20.460 },{Percentile.EstimationType.R_9,20.415} };</span>
        try {
<span class="nc" id="L669">            Percentile.EstimationType.LEGACY.evaluate(testArray, -1d, new KthSelector(new MedianOf3PivotingStrategy()));</span>
<span class="fc" id="L670">        } catch (final OutOfRangeException oore) {</span>
<span class="nc" id="L671">        }</span>
        try {
<span class="nc" id="L673">            Percentile.EstimationType.LEGACY.evaluate(testArray, 101d, new KthSelector());</span>
<span class="fc" id="L674">        } catch (final OutOfRangeException oore) {</span>
<span class="nc" id="L675">        }</span>
        try {
<span class="fc" id="L677">            Percentile.EstimationType.LEGACY.evaluate(testArray, 50d, new KthSelector());</span>
<span class="nc" id="L678">        } catch(final OutOfRangeException oore) {</span>
<span class="fc" id="L679">        }</span>
<span class="fc bfc" id="L680" title="All 2 branches covered.">        for (final Object[] o : map) {</span>
<span class="fc" id="L681">            final Percentile.EstimationType e = (Percentile.EstimationType) o[0];</span>
<span class="fc" id="L682">            final double expected = (Double) o[1];</span>
<span class="fc" id="L683">            final double result = e.evaluate(testArray, DEFAULT_PERCENTILE, new KthSelector());</span>
<span class="fc" id="L684">            Assert.assertEquals(&quot;expected[&quot; + e + &quot;] = &quot; + expected +</span>
                    &quot; but was = &quot; + result, expected, result, tolerance);
        }
<span class="fc" id="L687">    }</span>

    @Test
    public void testAllEstimationTechniquesOnlyForAllPivotingStrategies() {

<span class="fc" id="L692">        Assert.assertEquals(&quot;Legacy Apache Commons Math&quot;,Percentile.EstimationType.LEGACY.getName());</span>

<span class="fc bfc" id="L694" title="All 2 branches covered.">        for (final PivotingStrategyInterface strategy : new PivotingStrategyInterface[] {</span>
            new MedianOf3PivotingStrategy(),
            new CentralPivotingStrategy(),
            new RandomPivotingStrategy(RandomSource.WELL_1024_A, 0xf097c734e4740053l)
        }) {
<span class="fc" id="L699">            kthSelector = new KthSelector(strategy);</span>
<span class="fc" id="L700">            testAllEstimationTechniquesOnly();</span>
        }
<span class="fc" id="L702">    }</span>

    @Test
    public void testAllEstimationTechniquesOnlyForExtremeIndexes() {
<span class="fc" id="L706">        final double MAX=100;</span>
<span class="fc" id="L707">        final Object[][] map =</span>
<span class="fc" id="L708">                new Object[][] { { Percentile.EstimationType.LEGACY, 0d, MAX}, { Percentile.EstimationType.R_1, 0d,MAX+0.5 },</span>
<span class="fc" id="L709">                { Percentile.EstimationType.R_2, 0d,MAX}, { Percentile.EstimationType.R_3, 0d,MAX }, { Percentile.EstimationType.R_4, 0d,MAX },</span>
<span class="fc" id="L710">                { Percentile.EstimationType.R_5, 0d,MAX }, { Percentile.EstimationType.R_6, 0d,MAX },</span>
<span class="fc" id="L711">                { Percentile.EstimationType.R_7, 0d,MAX }, { Percentile.EstimationType.R_8, 0d,MAX }, { Percentile.EstimationType.R_9, 0d,MAX }  };</span>
<span class="fc bfc" id="L712" title="All 2 branches covered.">        for (final Object[] o : map) {</span>
<span class="fc" id="L713">            final Percentile.EstimationType e = (Percentile.EstimationType) o[0];</span>
<span class="fc" id="L714">                Assert.assertEquals(((Double)o[1]).doubleValue(),</span>
<span class="fc" id="L715">                        e.index(0d, (int)MAX),0d);</span>
<span class="fc" id="L716">                Assert.assertEquals(&quot;Enum:&quot;+e,((Double)o[2]).doubleValue(),</span>
<span class="fc" id="L717">                        e.index(1.0, (int)MAX),0d);</span>
            }
<span class="fc" id="L719">    }</span>

    @Test
    public void testAllEstimationTechniquesOnlyForNullsAndOOR() {

<span class="fc" id="L724">        final Object[][] map =</span>
<span class="fc" id="L725">                new Object[][] { { Percentile.EstimationType.LEGACY, 20.82 }, { Percentile.EstimationType.R_1, 19.8 },</span>
<span class="fc" id="L726">                        { Percentile.EstimationType.R_2, 19.8 }, { Percentile.EstimationType.R_3, 19.8 }, { Percentile.EstimationType.R_4, 19.310 },</span>
<span class="fc" id="L727">                        { Percentile.EstimationType.R_5, 20.280}, { Percentile.EstimationType.R_6, 20.820},</span>
<span class="fc" id="L728">                        { Percentile.EstimationType.R_7, 19.555 }, { Percentile.EstimationType.R_8, 20.460 },{ Percentile.EstimationType.R_9, 20.415 } };</span>
<span class="fc bfc" id="L729" title="All 2 branches covered.">        for (final Object[] o : map) {</span>
<span class="fc" id="L730">            final Percentile.EstimationType e = (Percentile.EstimationType) o[0];</span>
            try {
<span class="nc" id="L732">                e.evaluate(null, DEFAULT_PERCENTILE, new KthSelector());</span>
<span class="nc" id="L733">                Assert.fail(&quot;Expecting NullArgumentException&quot;);</span>
<span class="fc" id="L734">            } catch (final NullArgumentException nae) {</span>
                // expected
<span class="nc" id="L736">            }</span>
            try {
<span class="nc" id="L738">                e.evaluate(testArray, 120, new KthSelector());</span>
<span class="nc" id="L739">                Assert.fail(&quot;Expecting OutOfRangeException&quot;);</span>
<span class="fc" id="L740">            } catch (final OutOfRangeException oore) {</span>
                // expected
<span class="nc" id="L742">            }</span>
        }
<span class="fc" id="L744">    }</span>

    /**
     * Simple test assertion utility method assuming {@link NaNStrategy default}
     * nan handling strategy specific to each {@link EstimationType type}
     *
     * @param data input data
     * @param map of expected result against a {@link EstimationType}
     * @param p the quantile to compute for
     * @param tolerance the tolerance of difference allowed
     */
    protected void testAssertMappedValues(final double[] data, final Object[][] map,
            final Double p, final Double tolerance) {
<span class="fc bfc" id="L757" title="All 2 branches covered.">        for (final Object[] o : map) {</span>
<span class="fc" id="L758">            final Percentile.EstimationType e = (Percentile.EstimationType) o[0];</span>
<span class="fc" id="L759">            final double expected = (Double) o[1];</span>
            try {
<span class="fc" id="L761">                reset(p, e);</span>
<span class="fc" id="L762">                final double result = getUnivariateStatistic().evaluate(data);</span>
<span class="fc" id="L763">                Assert.assertEquals(&quot;expected[&quot; + e + &quot;] = &quot; + expected +</span>
<span class="fc" id="L764">                    &quot; but was = &quot; + result, expected, result, tolerance);</span>
<span class="nc" id="L765">            } catch(final Exception ex) {</span>
<span class="nc" id="L766">                Assert.fail(&quot;Exception occured for estimation type &quot;+e+&quot;:&quot;+</span>
<span class="nc" id="L767">                        ex.getLocalizedMessage());</span>
<span class="fc" id="L768">            }</span>
        }
<span class="fc" id="L770">    }</span>

    // Some NaNStrategy specific testing
    @Test
    public void testNanStrategySpecific() {
<span class="fc" id="L775">        double[] specialValues = new double[] { 0d, 1d, 2d, 3d, 4d, Double.NaN };</span>
<span class="fc" id="L776">        Assert.assertTrue(Double.isNaN(new Percentile(50d).withEstimationType(Percentile.EstimationType.LEGACY).withNaNStrategy(NaNStrategy.MAXIMAL).evaluate(specialValues, 3, 3)));</span>
<span class="fc" id="L777">        Assert.assertEquals(2d,new Percentile(50d).withEstimationType(Percentile.EstimationType.R_1).withNaNStrategy(NaNStrategy.REMOVED).evaluate(specialValues),0d);</span>
<span class="fc" id="L778">        Assert.assertEquals(Double.NaN,new Percentile(50d).withEstimationType(Percentile.EstimationType.R_5).withNaNStrategy(NaNStrategy.REMOVED).evaluate(new double[] {Double.NaN,Double.NaN,Double.NaN}),0d);</span>
<span class="fc" id="L779">        Assert.assertEquals(50d,new Percentile(50d).withEstimationType(Percentile.EstimationType.R_7).withNaNStrategy(NaNStrategy.MINIMAL).evaluate(new double[] {50d,50d,50d},1,2),0d);</span>

<span class="fc" id="L781">        specialValues = new double[] { 0d, 1d, 2d, 3d, 4d, Double.NaN, Double.NaN };</span>
<span class="fc" id="L782">        Assert.assertEquals(3.5,new Percentile().evaluate(specialValues, 3, 4),0d);</span>
<span class="fc" id="L783">        Assert.assertEquals(4d,new Percentile().evaluate(specialValues, 4, 3),0d);</span>
<span class="fc" id="L784">        Assert.assertTrue(Double.isNaN(new Percentile().evaluate(specialValues, 5, 2)));</span>

<span class="fc" id="L786">        specialValues = new double[] { 0d, 1d, 2d, 3d, 4d, Double.NaN, Double.NaN, 5d, 6d };</span>
<span class="fc" id="L787">        Assert.assertEquals(4.5,new Percentile().evaluate(specialValues, 3, 6),0d);</span>
<span class="fc" id="L788">        Assert.assertEquals(5d,new Percentile().evaluate(specialValues, 4, 5),0d);</span>
<span class="fc" id="L789">        Assert.assertTrue(Double.isNaN(new Percentile().evaluate(specialValues, 5, 2)));</span>
<span class="fc" id="L790">        Assert.assertTrue(Double.isNaN(new Percentile().evaluate(specialValues, 5, 1)));</span>
<span class="fc" id="L791">        Assert.assertEquals(5.5,new Percentile().evaluate(specialValues, 5, 4),0d);</span>
<span class="fc" id="L792">    }</span>

    // Some NaNStrategy specific testing
    @Test(expected=NotANumberException.class)
    public void testNanStrategyFailed() {
<span class="fc" id="L797">        double[] specialValues =</span>
                new double[] { 0d, 1d, 2d, 3d, 4d, Double.NaN };
<span class="fc" id="L799">        new Percentile(50d).</span>
<span class="fc" id="L800">        withEstimationType(Percentile.EstimationType.R_9).</span>
<span class="fc" id="L801">        withNaNStrategy(NaNStrategy.FAILED).</span>
<span class="nc" id="L802">        evaluate(specialValues);</span>
<span class="nc" id="L803">    }</span>

    @Test
    public void testAllTechniquesSpecialValuesWithNaNStrategy() {
<span class="fc" id="L807">        double[] specialValues =</span>
                new double[] { 0d, 1d, 2d, 3d, 4d, Double.NaN };
        try {
<span class="nc" id="L810">            new Percentile(50d).withEstimationType(Percentile.EstimationType.LEGACY).withNaNStrategy(null);</span>
<span class="nc" id="L811">            Assert.fail(&quot;Expecting NullArgumentArgumentException &quot;</span>
                    + &quot;for null Nan Strategy&quot;);
<span class="fc" id="L813">        } catch (NullArgumentException ex) {</span>
            // expected
<span class="nc" id="L815">        }</span>
        //This is as per each type's default NaNStrategy
<span class="fc" id="L817">        testAssertMappedValues(specialValues, new Object[][] {</span>
<span class="fc" id="L818">                { Percentile.EstimationType.LEGACY, 2.5d }, { Percentile.EstimationType.R_1, 2.0 }, { Percentile.EstimationType.R_2, 2.0 }, { Percentile.EstimationType.R_3, 1.0 },</span>
<span class="fc" id="L819">                { Percentile.EstimationType.R_4, 1.5 }, { Percentile.EstimationType.R_5, 2.0 }, { Percentile.EstimationType.R_6, 2.0 },</span>
<span class="fc" id="L820">                { Percentile.EstimationType.R_7, 2.0 }, { Percentile.EstimationType.R_8, 2.0 }, { Percentile.EstimationType.R_9, 2.0 }}, 50d, 0d);</span>

        //This is as per MAXIMAL and hence the values tend a +0.5 upward
<span class="fc" id="L823">        testAssertMappedValues(specialValues, new Object[][] {</span>
<span class="fc" id="L824">                { Percentile.EstimationType.LEGACY, 2.5d }, { Percentile.EstimationType.R_1, 2.0 }, { Percentile.EstimationType.R_2, 2.5 }, { Percentile.EstimationType.R_3, 2.0 },</span>
<span class="fc" id="L825">                { Percentile.EstimationType.R_4, 2.0 }, { Percentile.EstimationType.R_5, 2.5 }, { Percentile.EstimationType.R_6, 2.5 },</span>
<span class="fc" id="L826">                { Percentile.EstimationType.R_7, 2.5 }, { Percentile.EstimationType.R_8, 2.5 }, { Percentile.EstimationType.R_9, 2.5 }}, 50d, 0d,</span>
                NaNStrategy.MAXIMAL);

        //This is as per MINIMAL and hence the values tend a -0.5 downward
<span class="fc" id="L830">        testAssertMappedValues(specialValues, new Object[][] {</span>
<span class="fc" id="L831">                { Percentile.EstimationType.LEGACY, 1.5d }, { Percentile.EstimationType.R_1, 1.0 }, { Percentile.EstimationType.R_2, 1.5 }, { Percentile.EstimationType.R_3, 1.0 },</span>
<span class="fc" id="L832">                { Percentile.EstimationType.R_4, 1.0 }, { Percentile.EstimationType.R_5, 1.5 }, { Percentile.EstimationType.R_6, 1.5 },</span>
<span class="fc" id="L833">                { Percentile.EstimationType.R_7, 1.5 }, { Percentile.EstimationType.R_8, 1.5 }, { Percentile.EstimationType.R_9, 1.5 }}, 50d, 0d,</span>
                NaNStrategy.MINIMAL);

        //This is as per REMOVED as here Percentile.Type.CM changed its value from default
        //while rest of Estimation types were anyways defaulted to REMOVED
<span class="fc" id="L838">        testAssertMappedValues(specialValues, new Object[][] {</span>
<span class="fc" id="L839">                { Percentile.EstimationType.LEGACY, 2.0 }, { Percentile.EstimationType.R_1, 2.0 }, { Percentile.EstimationType.R_2, 2.0 }, { Percentile.EstimationType.R_3, 1.0 },</span>
<span class="fc" id="L840">                { Percentile.EstimationType.R_4, 1.5 }, { Percentile.EstimationType.R_5, 2.0 }, { Percentile.EstimationType.R_6, 2.0 },</span>
<span class="fc" id="L841">                { Percentile.EstimationType.R_7, 2.0 }, { Percentile.EstimationType.R_8, 2.0 }, { Percentile.EstimationType.R_9, 2.0 }}, 50d, 0d,</span>
                NaNStrategy.REMOVED);
<span class="fc" id="L843">    }</span>

    /**
     * Simple test assertion utility method
     *
     * @param data input data
     * @param map of expected result against a {@link EstimationType}
     * @param p the quantile to compute for
     * @param tolerance the tolerance of difference allowed
     * @param nanStrategy NaNStrategy to be passed
     */
    protected void testAssertMappedValues(double[] data, Object[][] map,
                                          Double p, Double tolerance, NaNStrategy nanStrategy) {
<span class="fc bfc" id="L856" title="All 2 branches covered.">        for (Object[] o : map) {</span>
<span class="fc" id="L857">            Percentile.EstimationType e = (Percentile.EstimationType) o[0];</span>
<span class="fc" id="L858">            double expected = (Double) o[1];</span>
            try {
<span class="fc" id="L860">                double result = new Percentile(p).withEstimationType(e).withNaNStrategy(nanStrategy).evaluate(data);</span>
<span class="fc" id="L861">                Assert.assertEquals(&quot;expected[&quot; + e + &quot;] = &quot; + expected + &quot; but was = &quot; + result,</span>
<span class="fc" id="L862">                                    expected, result, tolerance);</span>
<span class="nc" id="L863">            } catch(Exception ex) {</span>
<span class="nc" id="L864">                Assert.fail(&quot;Exception occured for estimation type &quot; + e + &quot;:&quot; + ex.getLocalizedMessage());</span>
<span class="fc" id="L865">            }</span>
        }
<span class="fc" id="L867">    }</span>

}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.1.201803210924</span></div></body></html>