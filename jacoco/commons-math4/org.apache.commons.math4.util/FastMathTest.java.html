<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>FastMathTest.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">commons_math4$All_in_commons_math4.exec</a> &gt; <a href="index.source.html" class="el_package">org.apache.commons.math4.util</a> &gt; <span class="el_source">FastMathTest.java</span></div><h1>FastMathTest.java</h1><pre class="source lang-java linenums">/*
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the &quot;License&quot;); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.commons.math4.util;

import static org.junit.Assert.assertEquals;
import static org.junit.Assert.assertTrue;
import static org.junit.Assert.fail;

import java.lang.reflect.Method;
import java.lang.reflect.Modifier;
import java.lang.reflect.Type;
import java.math.BigDecimal;
import java.math.BigInteger;
import java.math.RoundingMode;

import org.apache.commons.numbers.core.ArithmeticUtils;
import org.apache.commons.numbers.core.Precision;
import org.apache.commons.math4.TestUtils;
import org.apache.commons.math4.dfp.Dfp;
import org.apache.commons.math4.dfp.DfpField;
import org.apache.commons.math4.dfp.DfpMath;
import org.apache.commons.math4.exception.MathArithmeticException;
import org.apache.commons.rng.UniformRandomProvider;
import org.apache.commons.rng.simple.RandomSource;
import org.junit.Assert;
import org.junit.Before;
import org.junit.Ignore;
import org.junit.Test;

<span class="fc" id="L44">public class FastMathTest {</span>

    private static final double MAX_ERROR_ULP = 0.51;
    private static final int NUMBER_OF_TRIALS = 1000;

    private DfpField field;
    private UniformRandomProvider generator;

    @Before
    public void setUp() {
<span class="fc" id="L54">        field = new DfpField(40);</span>
<span class="fc" id="L55">        generator = RandomSource.create(RandomSource.MT, 6176597458463500194l);</span>
<span class="fc" id="L56">    }</span>

    @Test
    public void testMinMaxDouble() {
<span class="fc" id="L60">        double[][] pairs = {</span>
            { -50.0, 50.0 },
            {  Double.POSITIVE_INFINITY, 1.0 },
            {  Double.NEGATIVE_INFINITY, 1.0 },
            {  Double.NaN, 1.0 },
            {  Double.POSITIVE_INFINITY, 0.0 },
            {  Double.NEGATIVE_INFINITY, 0.0 },
            {  Double.NaN, 0.0 },
            {  Double.NaN, Double.NEGATIVE_INFINITY },
            {  Double.NaN, Double.POSITIVE_INFINITY },
            { Precision.SAFE_MIN, Precision.EPSILON }
        };
<span class="fc bfc" id="L72" title="All 2 branches covered.">        for (double[] pair : pairs) {</span>
<span class="fc" id="L73">            assertEquals(&quot;min(&quot; + pair[0] + &quot;, &quot; + pair[1] + &quot;)&quot;,</span>
<span class="fc" id="L74">                         Math.min(pair[0], pair[1]),</span>
<span class="fc" id="L75">                         FastMath.min(pair[0], pair[1]),</span>
                         Precision.EPSILON);
<span class="fc" id="L77">            assertEquals(&quot;min(&quot; + pair[1] + &quot;, &quot; + pair[0] + &quot;)&quot;,</span>
<span class="fc" id="L78">                         Math.min(pair[1], pair[0]),</span>
<span class="fc" id="L79">                         FastMath.min(pair[1], pair[0]),</span>
                         Precision.EPSILON);
<span class="fc" id="L81">            assertEquals(&quot;max(&quot; + pair[0] + &quot;, &quot; + pair[1] + &quot;)&quot;,</span>
<span class="fc" id="L82">                         Math.max(pair[0], pair[1]),</span>
<span class="fc" id="L83">                         FastMath.max(pair[0], pair[1]),</span>
                         Precision.EPSILON);
<span class="fc" id="L85">            assertEquals(&quot;max(&quot; + pair[1] + &quot;, &quot; + pair[0] + &quot;)&quot;,</span>
<span class="fc" id="L86">                         Math.max(pair[1], pair[0]),</span>
<span class="fc" id="L87">                         FastMath.max(pair[1], pair[0]),</span>
                         Precision.EPSILON);
        }
<span class="fc" id="L90">    }</span>

    @Test
    public void testMinMaxFloat() {
<span class="fc" id="L94">        float[][] pairs = {</span>
            { -50.0f, 50.0f },
            {  Float.POSITIVE_INFINITY, 1.0f },
            {  Float.NEGATIVE_INFINITY, 1.0f },
            {  Float.NaN, 1.0f },
            {  Float.POSITIVE_INFINITY, 0.0f },
            {  Float.NEGATIVE_INFINITY, 0.0f },
            {  Float.NaN, 0.0f },
            {  Float.NaN, Float.NEGATIVE_INFINITY },
            {  Float.NaN, Float.POSITIVE_INFINITY }
        };
<span class="fc bfc" id="L105" title="All 2 branches covered.">        for (float[] pair : pairs) {</span>
<span class="fc" id="L106">            assertEquals(&quot;min(&quot; + pair[0] + &quot;, &quot; + pair[1] + &quot;)&quot;,</span>
<span class="fc" id="L107">                    Math.min(pair[0], pair[1]),</span>
<span class="fc" id="L108">                    FastMath.min(pair[0], pair[1]),</span>
                    Precision.EPSILON);
<span class="fc" id="L110">            assertEquals(&quot;min(&quot; + pair[1] + &quot;, &quot; + pair[0] + &quot;)&quot;,</span>
<span class="fc" id="L111">                    Math.min(pair[1], pair[0]),</span>
<span class="fc" id="L112">                    FastMath.min(pair[1], pair[0]),</span>
                    Precision.EPSILON);
<span class="fc" id="L114">            assertEquals(&quot;max(&quot; + pair[0] + &quot;, &quot; + pair[1] + &quot;)&quot;,</span>
<span class="fc" id="L115">                    Math.max(pair[0], pair[1]),</span>
<span class="fc" id="L116">                    FastMath.max(pair[0], pair[1]),</span>
                    Precision.EPSILON);
<span class="fc" id="L118">            assertEquals(&quot;max(&quot; + pair[1] + &quot;, &quot; + pair[0] + &quot;)&quot;,</span>
<span class="fc" id="L119">                    Math.max(pair[1], pair[0]),</span>
<span class="fc" id="L120">                    FastMath.max(pair[1], pair[0]),</span>
                    Precision.EPSILON);
        }
<span class="fc" id="L123">    }</span>

    @Test
    public void testConstants() {
<span class="fc" id="L127">        assertEquals(Math.PI, FastMath.PI, 1.0e-20);</span>
<span class="fc" id="L128">        assertEquals(Math.E, FastMath.E, 1.0e-20);</span>
<span class="fc" id="L129">    }</span>

    @Test
    public void testAtan2() {
<span class="fc" id="L133">        double y1 = 1.2713504628280707e10;</span>
<span class="fc" id="L134">        double x1 = -5.674940885228782e-10;</span>
<span class="fc" id="L135">        assertEquals(Math.atan2(y1, x1), FastMath.atan2(y1, x1), 2 * Precision.EPSILON);</span>
<span class="fc" id="L136">        double y2 = 0.0;</span>
<span class="fc" id="L137">        double x2 = Double.POSITIVE_INFINITY;</span>
<span class="fc" id="L138">        assertEquals(Math.atan2(y2, x2), FastMath.atan2(y2, x2), Precision.SAFE_MIN);</span>
<span class="fc" id="L139">    }</span>

    @Test
    public void testHyperbolic() {
<span class="fc" id="L143">        double maxErr = 0;</span>
<span class="fc bfc" id="L144" title="All 2 branches covered.">        for (double x = -30; x &lt; 30; x += 0.001) {</span>
<span class="fc" id="L145">            double tst = FastMath.sinh(x);</span>
<span class="fc" id="L146">            double ref = Math.sinh(x);</span>
<span class="fc" id="L147">            maxErr = FastMath.max(maxErr, FastMath.abs(ref - tst) / FastMath.ulp(ref));</span>
        }
<span class="fc" id="L149">        assertEquals(0, maxErr, 2);</span>

<span class="fc" id="L151">        maxErr = 0;</span>
<span class="fc bfc" id="L152" title="All 2 branches covered.">        for (double x = -30; x &lt; 30; x += 0.001) {</span>
<span class="fc" id="L153">            double tst = FastMath.cosh(x);</span>
<span class="fc" id="L154">            double ref = Math.cosh(x);</span>
<span class="fc" id="L155">            maxErr = FastMath.max(maxErr, FastMath.abs(ref - tst) / FastMath.ulp(ref));</span>
        }
<span class="fc" id="L157">        assertEquals(0, maxErr, 2);</span>

<span class="fc" id="L159">        maxErr = 0;</span>
<span class="fc bfc" id="L160" title="All 2 branches covered.">        for (double x = -0.5; x &lt; 0.5; x += 0.001) {</span>
<span class="fc" id="L161">            double tst = FastMath.tanh(x);</span>
<span class="fc" id="L162">            double ref = Math.tanh(x);</span>
<span class="fc" id="L163">            maxErr = FastMath.max(maxErr, FastMath.abs(ref - tst) / FastMath.ulp(ref));</span>
        }
<span class="fc" id="L165">        assertEquals(0, maxErr, 4);</span>

<span class="fc" id="L167">    }</span>

    @Test
    public void testMath904() {
<span class="fc" id="L171">        final double x = -1;</span>
<span class="fc" id="L172">        final double y = (5 + 1e-15) * 1e15;</span>
<span class="fc" id="L173">        assertEquals(Math.pow(x, y),</span>
<span class="fc" id="L174">                     FastMath.pow(x, y), 0);</span>
<span class="fc" id="L175">        assertEquals(Math.pow(x, -y),</span>
<span class="fc" id="L176">                FastMath.pow(x, -y), 0);</span>
<span class="fc" id="L177">    }</span>

    @Test
    public void testMath905LargePositive() {
<span class="fc" id="L181">        final double start = StrictMath.log(Double.MAX_VALUE);</span>
<span class="fc" id="L182">        final double endT = StrictMath.sqrt(2) * StrictMath.sqrt(Double.MAX_VALUE);</span>
<span class="fc" id="L183">        final double end = 2 * StrictMath.log(endT);</span>

<span class="fc" id="L185">        double maxErr = 0;</span>
<span class="fc bfc" id="L186" title="All 2 branches covered.">        for (double x = start; x &lt; end; x += 1e-3) {</span>
<span class="fc" id="L187">            final double tst = FastMath.cosh(x);</span>
<span class="fc" id="L188">            final double ref = Math.cosh(x);</span>
<span class="fc" id="L189">            maxErr = FastMath.max(maxErr, FastMath.abs(ref - tst) / FastMath.ulp(ref));</span>
        }
<span class="fc" id="L191">        assertEquals(0, maxErr, 3);</span>

<span class="fc bfc" id="L193" title="All 2 branches covered.">        for (double x = start; x &lt; end; x += 1e-3) {</span>
<span class="fc" id="L194">            final double tst = FastMath.sinh(x);</span>
<span class="fc" id="L195">            final double ref = Math.sinh(x);</span>
<span class="fc" id="L196">            maxErr = FastMath.max(maxErr, FastMath.abs(ref - tst) / FastMath.ulp(ref));</span>
        }
<span class="fc" id="L198">        assertEquals(0, maxErr, 3);</span>
<span class="fc" id="L199">    }</span>

    @Test
    public void testMath905LargeNegative() {
<span class="fc" id="L203">        final double start = -StrictMath.log(Double.MAX_VALUE);</span>
<span class="fc" id="L204">        final double endT = StrictMath.sqrt(2) * StrictMath.sqrt(Double.MAX_VALUE);</span>
<span class="fc" id="L205">        final double end = -2 * StrictMath.log(endT);</span>

<span class="fc" id="L207">        double maxErr = 0;</span>
<span class="fc bfc" id="L208" title="All 2 branches covered.">        for (double x = start; x &gt; end; x -= 1e-3) {</span>
<span class="fc" id="L209">            final double tst = FastMath.cosh(x);</span>
<span class="fc" id="L210">            final double ref = Math.cosh(x);</span>
<span class="fc" id="L211">            maxErr = FastMath.max(maxErr, FastMath.abs(ref - tst) / FastMath.ulp(ref));</span>
        }
<span class="fc" id="L213">        assertEquals(0, maxErr, 3);</span>

<span class="fc bfc" id="L215" title="All 2 branches covered.">        for (double x = start; x &gt; end; x -= 1e-3) {</span>
<span class="fc" id="L216">            final double tst = FastMath.sinh(x);</span>
<span class="fc" id="L217">            final double ref = Math.sinh(x);</span>
<span class="fc" id="L218">            maxErr = FastMath.max(maxErr, FastMath.abs(ref - tst) / FastMath.ulp(ref));</span>
        }
<span class="fc" id="L220">        assertEquals(0, maxErr, 3);</span>
<span class="fc" id="L221">    }</span>

    @Test
    public void testMath1269() {
<span class="fc" id="L225">        final double arg = 709.8125;</span>
<span class="fc" id="L226">        final double vM = Math.exp(arg);</span>
<span class="fc" id="L227">        final double vFM = FastMath.exp(arg);</span>
<span class="fc" id="L228">        assertTrue(&quot;exp(&quot; + arg + &quot;) is &quot; + vFM + &quot; instead of &quot; + vM,</span>
<span class="fc" id="L229">                Precision.equalsIncludingNaN(vM, vFM));</span>
<span class="fc" id="L230">    }</span>

    @Test
    public void testHyperbolicInverses() {
<span class="fc" id="L234">        double maxErr = 0;</span>
<span class="fc bfc" id="L235" title="All 2 branches covered.">        for (double x = -30; x &lt; 30; x += 0.01) {</span>
<span class="fc" id="L236">            maxErr = FastMath.max(maxErr, FastMath.abs(x - FastMath.sinh(FastMath.asinh(x))) / (2 * FastMath.ulp(x)));</span>
        }
<span class="fc" id="L238">        assertEquals(0, maxErr, 3);</span>

<span class="fc" id="L240">        maxErr = 0;</span>
<span class="fc bfc" id="L241" title="All 2 branches covered.">        for (double x = 1; x &lt; 30; x += 0.01) {</span>
<span class="fc" id="L242">            maxErr = FastMath.max(maxErr, FastMath.abs(x - FastMath.cosh(FastMath.acosh(x))) / (2 * FastMath.ulp(x)));</span>
        }
<span class="fc" id="L244">        assertEquals(0, maxErr, 2);</span>

<span class="fc" id="L246">        maxErr = 0;</span>
<span class="fc bfc" id="L247" title="All 2 branches covered.">        for (double x = -1 + Precision.EPSILON; x &lt; 1 - Precision.EPSILON; x += 0.0001) {</span>
<span class="fc" id="L248">            maxErr = FastMath.max(maxErr, FastMath.abs(x - FastMath.tanh(FastMath.atanh(x))) / (2 * FastMath.ulp(x)));</span>
        }
<span class="fc" id="L250">        assertEquals(0, maxErr, 2);</span>
<span class="fc" id="L251">    }</span>

    @Test
    public void testLogAccuracy() {
<span class="fc" id="L255">        double maxerrulp = 0.0;</span>

<span class="fc bfc" id="L257" title="All 2 branches covered.">        for (int i = 0; i &lt; NUMBER_OF_TRIALS; i++) {</span>
<span class="fc" id="L258">            double x = Math.exp(generator.nextDouble() * 1416.0 - 708.0) * generator.nextDouble();</span>
            // double x = generator.nextDouble()*2.0;
<span class="fc" id="L260">            double tst = FastMath.log(x);</span>
<span class="fc" id="L261">            double ref = DfpMath.log(field.newDfp(x)).toDouble();</span>
<span class="fc" id="L262">            double err = (tst - ref) / ref;</span>

<span class="pc bpc" id="L264" title="1 of 2 branches missed.">            if (err != 0.0) {</span>
<span class="nc" id="L265">                double ulp = Math.abs(ref -</span>
<span class="nc" id="L266">                                      Double.longBitsToDouble((Double.doubleToLongBits(ref) ^ 1)));</span>
<span class="nc" id="L267">                double errulp = field.newDfp(tst).subtract(DfpMath.log(field.newDfp(x))).divide(field.newDfp(ulp)).toDouble();</span>
//                System.out.println(x + &quot;\t&quot; + tst + &quot;\t&quot; + ref + &quot;\t&quot; + err + &quot;\t&quot; + errulp);

<span class="nc" id="L270">                maxerrulp = Math.max(maxerrulp, Math.abs(errulp));</span>
            }
        }

<span class="pc bpc" id="L274" title="1 of 2 branches missed.">        assertTrue(&quot;log() had errors in excess of &quot; + MAX_ERROR_ULP + &quot; ULP&quot;, maxerrulp &lt; MAX_ERROR_ULP);</span>
<span class="fc" id="L275">    }</span>

    @Test
    public void testLog10Accuracy() {
<span class="fc" id="L279">        double maxerrulp = 0.0;</span>

<span class="fc bfc" id="L281" title="All 2 branches covered.">        for (int i = 0; i &lt; NUMBER_OF_TRIALS; i++) {</span>
<span class="fc" id="L282">            double x = Math.exp(generator.nextDouble() * 1416.0 - 708.0) * generator.nextDouble();</span>
            // double x = generator.nextDouble()*2.0;
<span class="fc" id="L284">            double tst = FastMath.log10(x);</span>
<span class="fc" id="L285">            double ref = DfpMath.log(field.newDfp(x)).divide(DfpMath.log(field.newDfp(&quot;10&quot;))).toDouble();</span>
<span class="fc" id="L286">            double err = (tst - ref) / ref;</span>

<span class="pc bpc" id="L288" title="1 of 2 branches missed.">            if (err != 0.0) {</span>
<span class="nc" id="L289">                double ulp = Math.abs(ref -</span>
<span class="nc" id="L290">                                      Double.longBitsToDouble((Double.doubleToLongBits(ref) ^ 1)));</span>
<span class="nc" id="L291">                double errulp = field.newDfp(tst).subtract(DfpMath.log(field.newDfp(x)).divide(DfpMath.log(field.newDfp(&quot;10&quot;)))).divide(field.newDfp(ulp)).toDouble();</span>
//                System.out.println(x + &quot;\t&quot; + tst + &quot;\t&quot; + ref + &quot;\t&quot; + err + &quot;\t&quot; + errulp);

<span class="nc" id="L294">                maxerrulp = Math.max(maxerrulp, Math.abs(errulp));</span>
            }
        }

<span class="pc bpc" id="L298" title="1 of 2 branches missed.">        assertTrue(&quot;log10() had errors in excess of &quot; + MAX_ERROR_ULP + &quot; ULP&quot;, maxerrulp &lt; MAX_ERROR_ULP);</span>
<span class="fc" id="L299">    }</span>

    @Test
    public void testLog1pAccuracy() {
<span class="fc" id="L303">        double maxerrulp = 0.0;</span>

<span class="fc bfc" id="L305" title="All 2 branches covered.">        for (int i = 0; i &lt; NUMBER_OF_TRIALS; i++) {</span>
<span class="fc" id="L306">            double x = Math.exp(generator.nextDouble() * 10.0 - 5.0) * generator.nextDouble();</span>
            // double x = generator.nextDouble()*2.0;
<span class="fc" id="L308">            double tst = FastMath.log1p(x);</span>
<span class="fc" id="L309">            double ref = DfpMath.log(field.newDfp(x).add(field.getOne())).toDouble();</span>
<span class="fc" id="L310">            double err = (tst - ref) / ref;</span>

<span class="pc bpc" id="L312" title="1 of 2 branches missed.">            if (err != 0.0) {</span>
<span class="nc" id="L313">                double ulp = Math.abs(ref -</span>
<span class="nc" id="L314">                                      Double.longBitsToDouble((Double.doubleToLongBits(ref) ^ 1)));</span>
<span class="nc" id="L315">                double errulp = field.newDfp(tst).subtract(DfpMath.log(field.newDfp(x).add(field.getOne()))).divide(field.newDfp(ulp)).toDouble();</span>
//                System.out.println(x + &quot;\t&quot; + tst + &quot;\t&quot; + ref + &quot;\t&quot; + err + &quot;\t&quot; + errulp);

<span class="nc" id="L318">                maxerrulp = Math.max(maxerrulp, Math.abs(errulp));</span>
            }
        }

<span class="pc bpc" id="L322" title="1 of 2 branches missed.">        assertTrue(&quot;log1p() had errors in excess of &quot; + MAX_ERROR_ULP + &quot; ULP&quot;, maxerrulp &lt; MAX_ERROR_ULP);</span>
<span class="fc" id="L323">    }</span>

    @Test
    public void testLog1pSpecialCases() {
<span class="fc" id="L327">        assertTrue(&quot;Logp of -1.0 should be -Inf&quot;, Double.isInfinite(FastMath.log1p(-1.0)));</span>
<span class="fc" id="L328">    }</span>

    @Test
    public void testLogSpecialCases() {
<span class="fc" id="L332">        assertEquals(&quot;Log of zero should be -Inf&quot;, Double.NEGATIVE_INFINITY, FastMath.log(0.0), 1.0);</span>
<span class="fc" id="L333">        assertEquals(&quot;Log of -zero should be -Inf&quot;, Double.NEGATIVE_INFINITY, FastMath.log(-0.0), 1.0);</span>
<span class="fc" id="L334">        assertTrue(&quot;Log of NaN should be NaN&quot;, Double.isNaN(FastMath.log(Double.NaN)));</span>
<span class="fc" id="L335">        assertTrue(&quot;Log of negative number should be NaN&quot;, Double.isNaN(FastMath.log(-1.0)));</span>
<span class="fc" id="L336">        assertEquals(&quot;Log of Double.MIN_VALUE should be -744.4400719213812&quot;, -744.4400719213812, FastMath.log(Double.MIN_VALUE), Precision.EPSILON);</span>
<span class="fc" id="L337">        assertEquals(&quot;Log of infinity should be infinity&quot;, Double.POSITIVE_INFINITY, FastMath.log(Double.POSITIVE_INFINITY), 1.0);</span>
<span class="fc" id="L338">    }</span>

    @Test
    public void testExpSpecialCases() {
        // Smallest value that will round up to Double.MIN_VALUE
<span class="fc" id="L343">        assertEquals(Double.MIN_VALUE, FastMath.exp(-745.1332191019411), Precision.EPSILON);</span>
<span class="fc" id="L344">        assertEquals(&quot;exp(-745.1332191019412) should be 0.0&quot;, 0.0, FastMath.exp(-745.1332191019412), Precision.EPSILON);</span>
<span class="fc" id="L345">        assertTrue(&quot;exp of NaN should be NaN&quot;, Double.isNaN(FastMath.exp(Double.NaN)));</span>
<span class="fc" id="L346">        assertEquals(&quot;exp of infinity should be infinity&quot;, Double.POSITIVE_INFINITY, FastMath.exp(Double.POSITIVE_INFINITY), 1.0);</span>
<span class="fc" id="L347">        assertEquals(&quot;exp of -infinity should be 0.0&quot;, 0.0, FastMath.exp(Double.NEGATIVE_INFINITY), Precision.EPSILON);</span>
<span class="fc" id="L348">        assertEquals(&quot;exp(1) should be Math.E&quot;, Math.E, FastMath.exp(1.0), Precision.EPSILON);</span>
<span class="fc" id="L349">    }</span>

    @Test
    public void testPowSpecialCases() {
<span class="fc" id="L353">        final double EXACT = -1.0;</span>

<span class="fc" id="L355">        assertEquals(&quot;pow(-1, 0) should be 1.0&quot;, 1.0, FastMath.pow(-1.0, 0.0), Precision.EPSILON);</span>
<span class="fc" id="L356">        assertEquals(&quot;pow(-1, -0) should be 1.0&quot;, 1.0, FastMath.pow(-1.0, -0.0), Precision.EPSILON);</span>
<span class="fc" id="L357">        assertEquals(&quot;pow(PI, 1.0) should be PI&quot;, FastMath.PI, FastMath.pow(FastMath.PI, 1.0), Precision.EPSILON);</span>
<span class="fc" id="L358">        assertEquals(&quot;pow(-PI, 1.0) should be -PI&quot;, -FastMath.PI, FastMath.pow(-FastMath.PI, 1.0), Precision.EPSILON);</span>
<span class="fc" id="L359">        assertTrue(&quot;pow(PI, NaN) should be NaN&quot;, Double.isNaN(FastMath.pow(Math.PI, Double.NaN)));</span>
<span class="fc" id="L360">        assertTrue(&quot;pow(NaN, PI) should be NaN&quot;, Double.isNaN(FastMath.pow(Double.NaN, Math.PI)));</span>
<span class="fc" id="L361">        assertEquals(&quot;pow(2.0, Infinity) should be Infinity&quot;, Double.POSITIVE_INFINITY, FastMath.pow(2.0, Double.POSITIVE_INFINITY), 1.0);</span>
<span class="fc" id="L362">        assertEquals(&quot;pow(0.5, -Infinity) should be Infinity&quot;, Double.POSITIVE_INFINITY, FastMath.pow(0.5, Double.NEGATIVE_INFINITY), 1.0);</span>
<span class="fc" id="L363">        assertEquals(&quot;pow(0.5, Infinity) should be 0.0&quot;, 0.0, FastMath.pow(0.5, Double.POSITIVE_INFINITY), Precision.EPSILON);</span>
<span class="fc" id="L364">        assertEquals(&quot;pow(2.0, -Infinity) should be 0.0&quot;, 0.0, FastMath.pow(2.0, Double.NEGATIVE_INFINITY), Precision.EPSILON);</span>
<span class="fc" id="L365">        assertEquals(&quot;pow(0.0, 0.5) should be 0.0&quot;, 0.0, FastMath.pow(0.0, 0.5), Precision.EPSILON);</span>
<span class="fc" id="L366">        assertEquals(&quot;pow(Infinity, -0.5) should be 0.0&quot;, 0.0, FastMath.pow(Double.POSITIVE_INFINITY, -0.5), Precision.EPSILON);</span>
<span class="fc" id="L367">        assertEquals(&quot;pow(0.0, -0.5) should be Inf&quot;, Double.POSITIVE_INFINITY, FastMath.pow(0.0, -0.5), 1.0);</span>
<span class="fc" id="L368">        assertEquals(&quot;pow(Inf, 0.5) should be Inf&quot;, Double.POSITIVE_INFINITY, FastMath.pow(Double.POSITIVE_INFINITY, 0.5), 1.0);</span>
<span class="fc" id="L369">        assertEquals(&quot;pow(-0.0, -3.0) should be -Inf&quot;, Double.NEGATIVE_INFINITY, FastMath.pow(-0.0, -3.0), 1.0);</span>
<span class="fc" id="L370">        assertEquals(&quot;pow(-0.0, Infinity) should be 0.0&quot;, 0.0, FastMath.pow(-0.0, Double.POSITIVE_INFINITY), Precision.EPSILON);</span>
<span class="fc" id="L371">        assertTrue(&quot;pow(-0.0, NaN) should be NaN&quot;, Double.isNaN(FastMath.pow(-0.0, Double.NaN)));</span>
<span class="fc" id="L372">        assertEquals(&quot;pow(-0.0, -tiny) should be Infinity&quot;, Double.POSITIVE_INFINITY, FastMath.pow(-0.0, -Double.MIN_VALUE), 1.0);</span>
<span class="fc" id="L373">        assertEquals(&quot;pow(-0.0, -huge) should be Infinity&quot;, Double.POSITIVE_INFINITY, FastMath.pow(-0.0, -Double.MAX_VALUE), 1.0);</span>
<span class="fc" id="L374">        assertEquals(&quot;pow(-Inf, 3.0) should be -Inf&quot;, Double.NEGATIVE_INFINITY, FastMath.pow(Double.NEGATIVE_INFINITY, 3.0), 1.0);</span>
<span class="fc" id="L375">        assertEquals(&quot;pow(-Inf, -3.0) should be -0.0&quot;, -0.0, FastMath.pow(Double.NEGATIVE_INFINITY, -3.0), EXACT);</span>
<span class="fc" id="L376">        assertEquals(&quot;pow(-0.0, -3.5) should be Inf&quot;, Double.POSITIVE_INFINITY, FastMath.pow(-0.0, -3.5), 1.0);</span>
<span class="fc" id="L377">        assertEquals(&quot;pow(Inf, 3.5) should be Inf&quot;, Double.POSITIVE_INFINITY, FastMath.pow(Double.POSITIVE_INFINITY, 3.5), 1.0);</span>
<span class="fc" id="L378">        assertEquals(&quot;pow(-2.0, 3.0) should be -8.0&quot;, -8.0, FastMath.pow(-2.0, 3.0), Precision.EPSILON);</span>
<span class="fc" id="L379">        assertTrue(&quot;pow(-2.0, 3.5) should be NaN&quot;, Double.isNaN(FastMath.pow(-2.0, 3.5)));</span>
<span class="fc" id="L380">        assertTrue(&quot;pow(NaN, -Infinity) should be NaN&quot;, Double.isNaN(FastMath.pow(Double.NaN, Double.NEGATIVE_INFINITY)));</span>
<span class="fc" id="L381">        assertEquals(&quot;pow(NaN, 0.0) should be 1.0&quot;, 1.0, FastMath.pow(Double.NaN, 0.0), Precision.EPSILON);</span>
<span class="fc" id="L382">        assertEquals(&quot;pow(-Infinity, -Infinity) should be 0.0&quot;, 0.0, FastMath.pow(Double.NEGATIVE_INFINITY, Double.NEGATIVE_INFINITY), Precision.EPSILON);</span>
<span class="fc" id="L383">        assertEquals(&quot;pow(-huge, -huge) should be 0.0&quot;, 0.0, FastMath.pow(-Double.MAX_VALUE, -Double.MAX_VALUE), Precision.EPSILON);</span>
<span class="fc" id="L384">        assertTrue(&quot;pow(-huge,  huge) should be +Inf&quot;, Double.isInfinite(FastMath.pow(-Double.MAX_VALUE, Double.MAX_VALUE)));</span>
<span class="fc" id="L385">        assertTrue(&quot;pow(NaN, -Infinity) should be NaN&quot;, Double.isNaN(FastMath.pow(Double.NaN, Double.NEGATIVE_INFINITY)));</span>
<span class="fc" id="L386">        assertEquals(&quot;pow(NaN, -0.0) should be 1.0&quot;, 1.0, FastMath.pow(Double.NaN, -0.0), Precision.EPSILON);</span>
<span class="fc" id="L387">        assertEquals(&quot;pow(-Infinity, -Infinity) should be 0.0&quot;, 0.0, FastMath.pow(Double.NEGATIVE_INFINITY, Double.NEGATIVE_INFINITY), Precision.EPSILON);</span>
<span class="fc" id="L388">        assertEquals(&quot;pow(-huge, -huge) should be 0.0&quot;, 0.0, FastMath.pow(-Double.MAX_VALUE, -Double.MAX_VALUE), Precision.EPSILON);</span>
<span class="fc" id="L389">        assertEquals(&quot;pow(-huge,  huge) should be +Inf&quot;, Double.POSITIVE_INFINITY, FastMath.pow(-Double.MAX_VALUE, Double.MAX_VALUE), 1.0);</span>

        // Added tests for a 100% coverage

<span class="fc" id="L393">        assertTrue(&quot;pow(+Inf, NaN) should be NaN&quot;, Double.isNaN(FastMath.pow(Double.POSITIVE_INFINITY, Double.NaN)));</span>
<span class="fc" id="L394">        assertTrue(&quot;pow(1.0, +Inf) should be NaN&quot;, Double.isNaN(FastMath.pow(1.0, Double.POSITIVE_INFINITY)));</span>
<span class="fc" id="L395">        assertTrue(&quot;pow(-Inf, NaN) should be NaN&quot;, Double.isNaN(FastMath.pow(Double.NEGATIVE_INFINITY, Double.NaN)));</span>
<span class="fc" id="L396">        assertEquals(&quot;pow(-Inf, -1.0) should be -0.0&quot;, -0.0, FastMath.pow(Double.NEGATIVE_INFINITY, -1.0), EXACT);</span>
<span class="fc" id="L397">        assertEquals(&quot;pow(-Inf, -2.0) should be 0.0&quot;, 0.0, FastMath.pow(Double.NEGATIVE_INFINITY, -2.0), EXACT);</span>
<span class="fc" id="L398">        assertEquals(&quot;pow(-Inf, 1.0) should be -Inf&quot;, Double.NEGATIVE_INFINITY, FastMath.pow(Double.NEGATIVE_INFINITY, 1.0), 1.0);</span>
<span class="fc" id="L399">        assertEquals(&quot;pow(-Inf, 2.0) should be +Inf&quot;, Double.POSITIVE_INFINITY, FastMath.pow(Double.NEGATIVE_INFINITY, 2.0), 1.0);</span>
<span class="fc" id="L400">        assertTrue(&quot;pow(1.0, -Inf) should be NaN&quot;, Double.isNaN(FastMath.pow(1.0, Double.NEGATIVE_INFINITY)));</span>
<span class="fc" id="L401">        assertEquals(&quot;pow(-0.0, 1.0) should be -0.0&quot;, -0.0, FastMath.pow(-0.0, 1.0), EXACT);</span>
<span class="fc" id="L402">        assertEquals(&quot;pow(0.0, 1.0) should be 0.0&quot;, 0.0, FastMath.pow(0.0, 1.0), EXACT);</span>
<span class="fc" id="L403">        assertEquals(&quot;pow(0.0, +Inf) should be 0.0&quot;, 0.0, FastMath.pow(0.0, Double.POSITIVE_INFINITY), EXACT);</span>
<span class="fc" id="L404">        assertEquals(&quot;pow(-0.0, even) should be 0.0&quot;, 0.0, FastMath.pow(-0.0, 6.0), EXACT);</span>
<span class="fc" id="L405">        assertEquals(&quot;pow(-0.0, odd) should be -0.0&quot;, -0.0, FastMath.pow(-0.0, 13.0), EXACT);</span>
<span class="fc" id="L406">        assertEquals(&quot;pow(-0.0, -even) should be +Inf&quot;, Double.POSITIVE_INFINITY, FastMath.pow(-0.0, -6.0), EXACT);</span>
<span class="fc" id="L407">        assertEquals(&quot;pow(-0.0, -odd) should be -Inf&quot;, Double.NEGATIVE_INFINITY, FastMath.pow(-0.0, -13.0), EXACT);</span>
<span class="fc" id="L408">        assertEquals(&quot;pow(-2.0, 4.0) should be 16.0&quot;, 16.0, FastMath.pow(-2.0, 4.0), EXACT);</span>
<span class="fc" id="L409">        assertEquals(&quot;pow(-2.0, 4.5) should be NaN&quot;, Double.NaN, FastMath.pow(-2.0, 4.5), EXACT);</span>
<span class="fc" id="L410">        assertEquals(&quot;pow(-0.0, -0.0) should be 1.0&quot;, 1.0, FastMath.pow(-0.0, -0.0), EXACT);</span>
<span class="fc" id="L411">        assertEquals(&quot;pow(-0.0, 0.0) should be 1.0&quot;, 1.0, FastMath.pow(-0.0, 0.0), EXACT);</span>
<span class="fc" id="L412">        assertEquals(&quot;pow(0.0, -0.0) should be 1.0&quot;, 1.0, FastMath.pow(0.0, -0.0), EXACT);</span>
<span class="fc" id="L413">        assertEquals(&quot;pow(0.0, 0.0) should be 1.0&quot;, 1.0, FastMath.pow(0.0, 0.0), EXACT);</span>
<span class="fc" id="L414">    }</span>

    @Test(timeout=20000L)
    public void testPowAllSpecialCases() {
<span class="fc" id="L418">        final double EXACT = -1.0;</span>
<span class="fc" id="L419">        final double DOUBLES[] = new double[]</span>
            {
                Double.NEGATIVE_INFINITY, -0.0, Double.NaN, 0.0, Double.POSITIVE_INFINITY,
                Long.MIN_VALUE, Integer.MIN_VALUE, Short.MIN_VALUE, Byte.MIN_VALUE,
                -(double)Long.MIN_VALUE, -(double)Integer.MIN_VALUE, -(double)Short.MIN_VALUE, -(double)Byte.MIN_VALUE,
                Byte.MAX_VALUE, Short.MAX_VALUE, Integer.MAX_VALUE, Long.MAX_VALUE,
                -Byte.MAX_VALUE, -Short.MAX_VALUE, -Integer.MAX_VALUE, -Long.MAX_VALUE,
                Float.MAX_VALUE, Double.MAX_VALUE, Double.MIN_VALUE, Float.MIN_VALUE,
                -Float.MAX_VALUE, -Double.MAX_VALUE, -Double.MIN_VALUE, -Float.MIN_VALUE,
                0.5, 0.1, 0.2, 0.8, 1.1, 1.2, 1.5, 1.8, 1.0, 2.0, 3.0, 4.0, 5.0, 6.0, 7.0, 8.0, 9.0, 1.3, 2.2, 2.5, 2.8, 33.0, 33.1, 33.5, 33.8, 10.0, 300.0, 400.0, 500.0,
                -0.5, -0.1, -0.2, -0.8, -1.1, -1.2, -1.5, -1.8, -1.0, -2.0, -3.0, -4.0, -5.0, -6.0, -7.0, -8.0, -9.0, -1.3, -2.2, -2.5, -2.8, -33.0, -33.1, -33.5, -33.8, -10.0, -300.0, -400.0, -500.0
            };

        // Special cases from Math.pow javadoc:
        // If the second argument is positive or negative zero, then the result is 1.0.
<span class="fc bfc" id="L434" title="All 2 branches covered.">        for (double d : DOUBLES) {</span>
<span class="fc" id="L435">            assertEquals(1.0, FastMath.pow(d, 0.0), EXACT);</span>
        }
<span class="fc bfc" id="L437" title="All 2 branches covered.">        for (double d : DOUBLES) {</span>
<span class="fc" id="L438">            assertEquals(1.0, FastMath.pow(d, -0.0), EXACT);</span>
        }
        // If the second argument is 1.0, then the result is the same as the first argument.
<span class="fc bfc" id="L441" title="All 2 branches covered.">        for (double d : DOUBLES) {</span>
<span class="fc" id="L442">            assertEquals(d, FastMath.pow(d, 1.0), EXACT);</span>
        }
        // If the second argument is NaN, then the result is NaN.
<span class="fc bfc" id="L445" title="All 2 branches covered.">        for (double d : DOUBLES) {</span>
<span class="fc" id="L446">            assertEquals(Double.NaN, FastMath.pow(d, Double.NaN), EXACT);</span>
        }
        // If the first argument is NaN and the second argument is nonzero, then the result is NaN.
<span class="fc bfc" id="L449" title="All 2 branches covered.">        for (double i : DOUBLES) {</span>
<span class="fc bfc" id="L450" title="All 2 branches covered.">            if (i != 0.0) {</span>
<span class="fc" id="L451">                assertEquals(Double.NaN, FastMath.pow(Double.NaN, i), EXACT);</span>
            }
        }
        // If the absolute value of the first argument is greater than 1 and the second argument is positive infinity, or
        // the absolute value of the first argument is less than 1 and the second argument is negative infinity, then the result is positive infinity.
<span class="fc bfc" id="L456" title="All 2 branches covered.">        for (double d : DOUBLES) {</span>
<span class="fc bfc" id="L457" title="All 2 branches covered.">            if (Math.abs(d) &gt; 1.0) {</span>
<span class="fc" id="L458">                assertEquals(Double.POSITIVE_INFINITY, FastMath.pow(d, Double.POSITIVE_INFINITY), EXACT);</span>
            }
        }
<span class="fc bfc" id="L461" title="All 2 branches covered.">        for (double d : DOUBLES) {</span>
<span class="fc bfc" id="L462" title="All 2 branches covered.">            if (Math.abs(d) &lt; 1.0) {</span>
<span class="fc" id="L463">                assertEquals(Double.POSITIVE_INFINITY, FastMath.pow(d, Double.NEGATIVE_INFINITY), EXACT);</span>
            }
        }
        // If the absolute value of the first argument is greater than 1 and the second argument is negative infinity, or
        // the absolute value of the first argument is less than 1 and the second argument is positive infinity, then the result is positive zero.
<span class="fc bfc" id="L468" title="All 2 branches covered.">        for (double d : DOUBLES) {</span>
<span class="fc bfc" id="L469" title="All 2 branches covered.">            if (Math.abs(d) &gt; 1.0) {</span>
<span class="fc" id="L470">                assertEquals(0.0, FastMath.pow(d, Double.NEGATIVE_INFINITY), EXACT);</span>
            }
        }
<span class="fc bfc" id="L473" title="All 2 branches covered.">        for (double d : DOUBLES) {</span>
<span class="fc bfc" id="L474" title="All 2 branches covered.">            if (Math.abs(d) &lt; 1.0) {</span>
<span class="fc" id="L475">                assertEquals(0.0, FastMath.pow(d, Double.POSITIVE_INFINITY), EXACT);</span>
            }
        }
        // If the absolute value of the first argument equals 1 and the second argument is infinite, then the result is NaN.
<span class="fc" id="L479">        assertEquals(Double.NaN, FastMath.pow(1.0, Double.POSITIVE_INFINITY), EXACT);</span>
<span class="fc" id="L480">        assertEquals(Double.NaN, FastMath.pow(1.0, Double.NEGATIVE_INFINITY), EXACT);</span>
<span class="fc" id="L481">        assertEquals(Double.NaN, FastMath.pow(-1.0, Double.POSITIVE_INFINITY), EXACT);</span>
<span class="fc" id="L482">        assertEquals(Double.NaN, FastMath.pow(-1.0, Double.NEGATIVE_INFINITY), EXACT);</span>
        // If the first argument is positive zero and the second argument is greater than zero, or
        // the first argument is positive infinity and the second argument is less than zero, then the result is positive zero.
<span class="fc bfc" id="L485" title="All 2 branches covered.">        for (double i : DOUBLES) {</span>
<span class="fc bfc" id="L486" title="All 2 branches covered.">            if (i &gt; 0.0) {</span>
<span class="fc" id="L487">                assertEquals(0.0, FastMath.pow(0.0, i), EXACT);</span>
            }
        }
<span class="fc bfc" id="L490" title="All 2 branches covered.">        for (double i : DOUBLES) {</span>
<span class="fc bfc" id="L491" title="All 2 branches covered.">            if (i &lt; 0.0) {</span>
<span class="fc" id="L492">                assertEquals(0.0, FastMath.pow(Double.POSITIVE_INFINITY, i), EXACT);</span>
            }
        }
        // If the first argument is positive zero and the second argument is less than zero, or
        // the first argument is positive infinity and the second argument is greater than zero, then the result is positive infinity.
<span class="fc bfc" id="L497" title="All 2 branches covered.">        for (double i : DOUBLES) {</span>
<span class="fc bfc" id="L498" title="All 2 branches covered.">            if (i &lt; 0.0) {</span>
<span class="fc" id="L499">                assertEquals(Double.POSITIVE_INFINITY, FastMath.pow(0.0, i), EXACT);</span>
            }
        }
<span class="fc bfc" id="L502" title="All 2 branches covered.">        for (double i : DOUBLES) {</span>
<span class="fc bfc" id="L503" title="All 2 branches covered.">            if (i &gt; 0.0) {</span>
<span class="fc" id="L504">                assertEquals(Double.POSITIVE_INFINITY, FastMath.pow(Double.POSITIVE_INFINITY, i), EXACT);</span>
            }
        }
        // If the first argument is negative zero and the second argument is greater than zero but not a finite odd integer, or
        // the first argument is negative infinity and the second argument is less than zero but not a finite odd integer, then the result is positive zero.
<span class="fc bfc" id="L509" title="All 2 branches covered.">        for (double i : DOUBLES) {</span>
<span class="fc bfc" id="L510" title="All 6 branches covered.">            if (i &gt; 0.0 &amp;&amp; (Double.isInfinite(i) || i % 2.0 == 0.0)) {</span>
<span class="fc" id="L511">                assertEquals(0.0, FastMath.pow(-0.0, i), EXACT);</span>
            }
        }
<span class="fc bfc" id="L514" title="All 2 branches covered.">        for (double i : DOUBLES) {</span>
<span class="fc bfc" id="L515" title="All 6 branches covered.">            if (i &lt; 0.0 &amp;&amp; (Double.isInfinite(i) || i % 2.0 == 0.0)) {</span>
<span class="fc" id="L516">                assertEquals(0.0, FastMath.pow(Double.NEGATIVE_INFINITY, i), EXACT);</span>
            }
        }
        // If the first argument is negative zero and the second argument is a positive finite odd integer, or
        // the first argument is negative infinity and the second argument is a negative finite odd integer, then the result is negative zero.
<span class="fc bfc" id="L521" title="All 2 branches covered.">        for (double i : DOUBLES) {</span>
<span class="fc bfc" id="L522" title="All 4 branches covered.">            if (i &gt; 0.0 &amp;&amp; i % 2.0 == 1.0) {</span>
<span class="fc" id="L523">                assertEquals(-0.0, FastMath.pow(-0.0, i), EXACT);</span>
            }
        }
<span class="fc bfc" id="L526" title="All 2 branches covered.">        for (double i : DOUBLES) {</span>
<span class="fc bfc" id="L527" title="All 4 branches covered.">            if (i &lt; 0.0 &amp;&amp; i % 2.0 == -1.0) {</span>
<span class="fc" id="L528">                assertEquals(-0.0, FastMath.pow(Double.NEGATIVE_INFINITY, i), EXACT);</span>
            }
        }
        // If the first argument is negative zero and the second argument is less than zero but not a finite odd integer, or
        // the first argument is negative infinity and the second argument is greater than zero but not a finite odd integer, then the result is positive infinity.
<span class="fc bfc" id="L533" title="All 2 branches covered.">        for (double i : DOUBLES) {</span>
<span class="fc bfc" id="L534" title="All 6 branches covered.">            if (i &gt; 0.0 &amp;&amp; (Double.isInfinite(i) || i % 2.0 == 0.0)) {</span>
<span class="fc" id="L535">                assertEquals(Double.POSITIVE_INFINITY, FastMath.pow(Double.NEGATIVE_INFINITY, i), EXACT);</span>
            }
        }
<span class="fc bfc" id="L538" title="All 2 branches covered.">        for (double i : DOUBLES) {</span>
<span class="fc bfc" id="L539" title="All 6 branches covered.">            if (i &lt; 0.0 &amp;&amp; (Double.isInfinite(i) || i % 2.0 == 0.0)) {</span>
<span class="fc" id="L540">                assertEquals(Double.POSITIVE_INFINITY, FastMath.pow(-0.0, i), EXACT);</span>
            }
        }
        // If the first argument is negative zero and the second argument is a negative finite odd integer, or
        // the first argument is negative infinity and the second argument is a positive finite odd integer, then the result is negative infinity.
<span class="fc bfc" id="L545" title="All 2 branches covered.">        for (double i : DOUBLES) {</span>
<span class="fc bfc" id="L546" title="All 4 branches covered.">            if (i &gt; 0.0 &amp;&amp; i % 2.0 == 1.0) {</span>
<span class="fc" id="L547">                assertEquals(Double.NEGATIVE_INFINITY, FastMath.pow(Double.NEGATIVE_INFINITY, i), EXACT);</span>
            }
        }
<span class="fc bfc" id="L550" title="All 2 branches covered.">        for (double i : DOUBLES) {</span>
<span class="fc bfc" id="L551" title="All 4 branches covered.">            if (i &lt; 0.0 &amp;&amp; i % 2.0 == -1.0) {</span>
<span class="fc" id="L552">                assertEquals(Double.NEGATIVE_INFINITY, FastMath.pow(-0.0, i), EXACT);</span>
            }
        }
<span class="fc bfc" id="L555" title="All 2 branches covered.">        for (double d : DOUBLES) {</span>
            // If the first argument is finite and less than zero
<span class="fc bfc" id="L557" title="All 4 branches covered.">            if (d &lt; 0.0 &amp;&amp; Math.abs(d) &lt;= Double.MAX_VALUE) {</span>
<span class="fc bfc" id="L558" title="All 2 branches covered.">                for (double i : DOUBLES) {</span>
<span class="fc bfc" id="L559" title="All 2 branches covered.">                    if (Math.abs(i) &lt;= Double.MAX_VALUE) {</span>
                        // if the second argument is a finite even integer, the result is equal to the result of raising the absolute value of the first argument to the power of the second argument
<span class="fc bfc" id="L561" title="All 2 branches covered.">                        if (i % 2.0 == 0.0) assertEquals(FastMath.pow(-d, i), FastMath.pow(d, i), EXACT);</span>
                        // if the second argument is a finite odd integer, the result is equal to the negative of the result of raising the absolute value of the first argument to the power of the second argument
<span class="fc bfc" id="L563" title="All 2 branches covered.">                        else if (Math.abs(i) % 2.0 == 1.0) assertEquals(-FastMath.pow(-d, i), FastMath.pow(d, i), EXACT);</span>
                        // if the second argument is finite and not an integer, then the result is NaN.
<span class="fc" id="L565">                        else assertEquals(Double.NaN, FastMath.pow(d, i), EXACT);</span>
                    }
                }
            }
        }
        // If both arguments are integers, then the result is exactly equal to the mathematical result of raising the first argument to the power
        // of the second argument if that result can in fact be represented exactly as a double value.
<span class="fc" id="L572">        final int TOO_BIG_TO_CALCULATE = 18; // This value is empirical: 2^18 &gt; 200.000 resulting bits after raising d to power i.</span>
<span class="fc bfc" id="L573" title="All 2 branches covered.">        for (double d : DOUBLES) {</span>
<span class="fc bfc" id="L574" title="All 2 branches covered.">            if (d % 1.0 == 0.0) {</span>
<span class="fc bfc" id="L575" title="All 2 branches covered.">                boolean dNegative = Double.doubleToRawLongBits( d ) &lt; 0L;</span>
<span class="fc bfc" id="L576" title="All 2 branches covered.">                for (double i : DOUBLES) {</span>
<span class="fc bfc" id="L577" title="All 2 branches covered.">                    if (i % 1.0 == 0.0) {</span>
<span class="fc" id="L578">                        BigInteger bd = BigDecimal.valueOf(d).toBigInteger().abs();</span>
<span class="fc" id="L579">                        BigInteger bi = BigDecimal.valueOf(i).toBigInteger().abs();</span>
                        double expected;
<span class="fc bfc" id="L581" title="All 6 branches covered.">                        if (bd.bitLength() &gt; 1 &amp;&amp; bi.bitLength() &gt; 1 &amp;&amp; 32 - Integer.numberOfLeadingZeros(bd.bitLength()) + bi.bitLength() &gt; TOO_BIG_TO_CALCULATE) {</span>
                            // Result would be too big.
<span class="fc bfc" id="L583" title="All 2 branches covered.">                            expected = i &lt; 0.0 ? 0.0 : Double.POSITIVE_INFINITY;</span>
                        } else {
<span class="fc" id="L585">                            BigInteger res = ArithmeticUtils.pow(bd, bi);</span>
<span class="fc bfc" id="L586" title="All 2 branches covered.">                            if (i &gt;= 0.0) {</span>
<span class="fc" id="L587">                                expected = res.doubleValue();</span>
<span class="fc bfc" id="L588" title="All 2 branches covered.">                            } else if (res.signum() == 0) {</span>
<span class="fc" id="L589">                                expected = Double.POSITIVE_INFINITY;</span>
                            } else {
<span class="fc" id="L591">                                expected = BigDecimal.ONE.divide( new BigDecimal( res ), 1024, RoundingMode.HALF_UP ).doubleValue();</span>
                            }
                        }
<span class="fc bfc" id="L594" title="All 4 branches covered.">                        if (dNegative &amp;&amp; bi.testBit( 0 )) {</span>
<span class="fc" id="L595">                            expected = -expected;</span>
                        }
<span class="pc bpc" id="L597" title="1 of 6 branches missed.">                        assertEquals(d + &quot;^&quot; + i + &quot;=&quot; + expected + &quot;, Math.pow=&quot; + Math.pow(d, i), expected, FastMath.pow(d, i), expected == 0.0 || Double.isInfinite(expected) || Double.isNaN(expected) ? EXACT : 2.0 * Math.ulp(expected));</span>
                    }
                }
            }
        }
<span class="fc" id="L602">    }</span>

    @Test
    public void testPowLargeIntegralDouble() {
<span class="fc" id="L606">        double y = FastMath.scalb(1.0, 65);</span>
<span class="fc" id="L607">        assertEquals(Double.POSITIVE_INFINITY, FastMath.pow(FastMath.nextUp(1.0), y),    1.0);</span>
<span class="fc" id="L608">        assertEquals(1.0,                      FastMath.pow(1.0, y),                     1.0);</span>
<span class="fc" id="L609">        assertEquals(0.0,                      FastMath.pow(FastMath.nextDown(1.0), y),  1.0);</span>
<span class="fc" id="L610">        assertEquals(0.0,                      FastMath.pow(FastMath.nextUp(-1.0), y),   1.0);</span>
<span class="fc" id="L611">        assertEquals(1.0,                      FastMath.pow(-1.0, y),                    1.0);</span>
<span class="fc" id="L612">        assertEquals(Double.POSITIVE_INFINITY, FastMath.pow(FastMath.nextDown(-1.0), y), 1.0);</span>
<span class="fc" id="L613">    }</span>

    @Test
    public void testAtan2SpecialCases() {

<span class="fc" id="L618">        assertTrue(&quot;atan2(NaN, 0.0) should be NaN&quot;, Double.isNaN(FastMath.atan2(Double.NaN, 0.0)));</span>
<span class="fc" id="L619">        assertTrue(&quot;atan2(0.0, NaN) should be NaN&quot;, Double.isNaN(FastMath.atan2(0.0, Double.NaN)));</span>
<span class="fc" id="L620">        assertEquals(&quot;atan2(0.0, 0.0) should be 0.0&quot;, 0.0, FastMath.atan2(0.0, 0.0), Precision.EPSILON);</span>
<span class="fc" id="L621">        assertEquals(&quot;atan2(0.0, 0.001) should be 0.0&quot;, 0.0, FastMath.atan2(0.0, 0.001), Precision.EPSILON);</span>
<span class="fc" id="L622">        assertEquals(&quot;atan2(0.1, +Inf) should be 0.0&quot;, 0.0, FastMath.atan2(0.1, Double.POSITIVE_INFINITY), Precision.EPSILON);</span>
<span class="fc" id="L623">        assertEquals(&quot;atan2(-0.0, 0.0) should be -0.0&quot;, -0.0, FastMath.atan2(-0.0, 0.0), Precision.EPSILON);</span>
<span class="fc" id="L624">        assertEquals(&quot;atan2(-0.0, 0.001) should be -0.0&quot;, -0.0, FastMath.atan2(-0.0, 0.001), Precision.EPSILON);</span>
<span class="fc" id="L625">        assertEquals(&quot;atan2(-0.0, +Inf) should be -0.0&quot;, -0.0, FastMath.atan2(-0.1, Double.POSITIVE_INFINITY), Precision.EPSILON);</span>
<span class="fc" id="L626">        assertEquals(&quot;atan2(0.0, -0.0) should be PI&quot;, FastMath.PI, FastMath.atan2(0.0, -0.0), Precision.EPSILON);</span>
<span class="fc" id="L627">        assertEquals(&quot;atan2(0.1, -Inf) should be PI&quot;, FastMath.PI, FastMath.atan2(0.1, Double.NEGATIVE_INFINITY), Precision.EPSILON);</span>
<span class="fc" id="L628">        assertEquals(&quot;atan2(-0.0, -0.0) should be -PI&quot;, -FastMath.PI, FastMath.atan2(-0.0, -0.0), Precision.EPSILON);</span>
<span class="fc" id="L629">        assertEquals(&quot;atan2(0.1, -Inf) should be -PI&quot;, -FastMath.PI, FastMath.atan2(-0.1, Double.NEGATIVE_INFINITY), Precision.EPSILON);</span>
<span class="fc" id="L630">        assertEquals(&quot;atan2(0.1, 0.0) should be PI/2&quot;, FastMath.PI / 2.0, FastMath.atan2(0.1, 0.0), Precision.EPSILON);</span>
<span class="fc" id="L631">        assertEquals(&quot;atan2(0.1, -0.0) should be PI/2&quot;, FastMath.PI / 2.0, FastMath.atan2(0.1, -0.0), Precision.EPSILON);</span>
<span class="fc" id="L632">        assertEquals(&quot;atan2(Inf, 0.1) should be PI/2&quot;, FastMath.PI / 2.0, FastMath.atan2(Double.POSITIVE_INFINITY, 0.1), Precision.EPSILON);</span>
<span class="fc" id="L633">        assertEquals(&quot;atan2(Inf, -0.1) should be PI/2&quot;, FastMath.PI / 2.0, FastMath.atan2(Double.POSITIVE_INFINITY, -0.1), Precision.EPSILON);</span>
<span class="fc" id="L634">        assertEquals(&quot;atan2(-0.1, 0.0) should be -PI/2&quot;, -FastMath.PI / 2.0, FastMath.atan2(-0.1, 0.0), Precision.EPSILON);</span>
<span class="fc" id="L635">        assertEquals(&quot;atan2(-0.1, -0.0) should be -PI/2&quot;, -FastMath.PI / 2.0, FastMath.atan2(-0.1, -0.0), Precision.EPSILON);</span>
<span class="fc" id="L636">        assertEquals(&quot;atan2(-Inf, 0.1) should be -PI/2&quot;, -FastMath.PI / 2.0, FastMath.atan2(Double.NEGATIVE_INFINITY, 0.1), Precision.EPSILON);</span>
<span class="fc" id="L637">        assertEquals(&quot;atan2(-Inf, -0.1) should be -PI/2&quot;, -FastMath.PI / 2.0, FastMath.atan2(Double.NEGATIVE_INFINITY, -0.1), Precision.EPSILON);</span>
<span class="fc" id="L638">        assertEquals(&quot;atan2(Inf, Inf) should be PI/4&quot;, FastMath.PI / 4.0, FastMath.atan2(Double.POSITIVE_INFINITY, Double.POSITIVE_INFINITY),</span>
                     Precision.EPSILON);
<span class="fc" id="L640">        assertEquals(&quot;atan2(Inf, -Inf) should be PI * 3/4&quot;, FastMath.PI * 3.0 / 4.0,</span>
<span class="fc" id="L641">                     FastMath.atan2(Double.POSITIVE_INFINITY, Double.NEGATIVE_INFINITY), Precision.EPSILON);</span>
<span class="fc" id="L642">        assertEquals(&quot;atan2(-Inf, Inf) should be -PI/4&quot;, -FastMath.PI / 4.0, FastMath.atan2(Double.NEGATIVE_INFINITY, Double.POSITIVE_INFINITY),</span>
                     Precision.EPSILON);
<span class="fc" id="L644">        assertEquals(&quot;atan2(-Inf, -Inf) should be -PI * 3/4&quot;, - FastMath.PI * 3.0 / 4.0,</span>
<span class="fc" id="L645">                     FastMath.atan2(Double.NEGATIVE_INFINITY, Double.NEGATIVE_INFINITY), Precision.EPSILON);</span>
<span class="fc" id="L646">    }</span>

    @Test
    public void testPowAccuracy() {
<span class="fc" id="L650">        double maxerrulp = 0.0;</span>

<span class="fc bfc" id="L652" title="All 2 branches covered.">        for (int i = 0; i &lt; NUMBER_OF_TRIALS; i++) {</span>
<span class="fc" id="L653">            double x = (generator.nextDouble() * 2.0 + 0.25);</span>
<span class="fc" id="L654">            double y = (generator.nextDouble() * 1200.0 - 600.0) * generator.nextDouble();</span>
            /*
             * double x = FastMath.floor(generator.nextDouble()*1024.0 - 512.0); double
             * y; if (x != 0) y = FastMath.floor(512.0 / FastMath.abs(x)); else
             * y = generator.nextDouble()*1200.0; y = y - y/2; x = FastMath.pow(2.0, x) *
             * generator.nextDouble(); y = y * generator.nextDouble();
             */

            // double x = generator.nextDouble()*2.0;
<span class="fc" id="L663">            double tst = FastMath.pow(x, y);</span>
<span class="fc" id="L664">            double ref = DfpMath.pow(field.newDfp(x), field.newDfp(y)).toDouble();</span>
<span class="fc" id="L665">            double err = (tst - ref) / ref;</span>

<span class="pc bpc" id="L667" title="1 of 2 branches missed.">            if (err != 0) {</span>
<span class="nc" id="L668">                double ulp = Math.abs(ref -</span>
<span class="nc" id="L669">                                      Double.longBitsToDouble((Double.doubleToLongBits(ref) ^ 1)));</span>
<span class="nc" id="L670">                double errulp = field.newDfp(tst).subtract(DfpMath.pow(field.newDfp(x), field.newDfp(y))).divide(field.newDfp(ulp)).toDouble();</span>
//                System.out.println(x + &quot;\t&quot; + y + &quot;\t&quot; + tst + &quot;\t&quot; + ref + &quot;\t&quot; + err + &quot;\t&quot; + errulp);

<span class="nc" id="L673">                maxerrulp = Math.max(maxerrulp, Math.abs(errulp));</span>
            }
        }

<span class="pc bpc" id="L677" title="1 of 2 branches missed.">        assertTrue(&quot;pow() had errors in excess of &quot; + MAX_ERROR_ULP + &quot; ULP&quot;, maxerrulp &lt; MAX_ERROR_ULP);</span>
<span class="fc" id="L678">    }</span>

    @Test
    public void testExpAccuracy() {
<span class="fc" id="L682">        double maxerrulp = 0.0;</span>

<span class="fc bfc" id="L684" title="All 2 branches covered.">        for (int i = 0; i &lt; NUMBER_OF_TRIALS; i++) {</span>
            /* double x = 1.0 + i/1024.0/2.0; */
<span class="fc" id="L686">            double x = ((generator.nextDouble() * 1416.0) - 708.0) * generator.nextDouble();</span>
            // double x = (generator.nextDouble() * 20.0) - 10.0;
            // double x = ((generator.nextDouble() * 2.0) - 1.0) * generator.nextDouble();
            /* double x = 3.0 / 512.0 * i - 3.0; */
<span class="fc" id="L690">            double tst = FastMath.exp(x);</span>
<span class="fc" id="L691">            double ref = DfpMath.exp(field.newDfp(x)).toDouble();</span>
<span class="fc" id="L692">            double err = (tst - ref) / ref;</span>

<span class="fc bfc" id="L694" title="All 2 branches covered.">            if (err != 0) {</span>
<span class="fc" id="L695">                double ulp = Math.abs(ref -</span>
<span class="fc" id="L696">                                      Double.longBitsToDouble((Double.doubleToLongBits(ref) ^ 1)));</span>
<span class="fc" id="L697">                double errulp = field.newDfp(tst).subtract(DfpMath.exp(field.newDfp(x))).divide(field.newDfp(ulp)).toDouble();</span>
//                System.out.println(x + &quot;\t&quot; + tst + &quot;\t&quot; + ref + &quot;\t&quot; + err + &quot;\t&quot; + errulp);

<span class="fc" id="L700">                maxerrulp = Math.max(maxerrulp, Math.abs(errulp));</span>
            }
        }

<span class="pc bpc" id="L704" title="1 of 2 branches missed.">        assertTrue(&quot;exp() had errors in excess of &quot; + MAX_ERROR_ULP + &quot; ULP&quot;, maxerrulp &lt; MAX_ERROR_ULP);</span>
<span class="fc" id="L705">    }</span>

    @Test
    public void testSinAccuracy() {
<span class="fc" id="L709">        double maxerrulp = 0.0;</span>

<span class="fc bfc" id="L711" title="All 2 branches covered.">        for (int i = 0; i &lt; NUMBER_OF_TRIALS; i++) {</span>
            /* double x = 1.0 + i/1024.0/2.0; */
            // double x = ((generator.nextDouble() * 1416.0) - 708.0) * generator.nextDouble();
<span class="fc" id="L714">            double x = ((generator.nextDouble() * Math.PI) - Math.PI / 2.0) *</span>
<span class="fc" id="L715">                       Math.pow(2, 21) * generator.nextDouble();</span>
            // double x = (generator.nextDouble() * 20.0) - 10.0;
            // double x = ((generator.nextDouble() * 2.0) - 1.0) * generator.nextDouble();
            /* double x = 3.0 / 512.0 * i - 3.0; */
<span class="fc" id="L719">            double tst = FastMath.sin(x);</span>
<span class="fc" id="L720">            double ref = DfpMath.sin(field.newDfp(x)).toDouble();</span>
<span class="fc" id="L721">            double err = (tst - ref) / ref;</span>

<span class="fc bfc" id="L723" title="All 2 branches covered.">            if (err != 0) {</span>
<span class="fc" id="L724">                double ulp = Math.abs(ref -</span>
<span class="fc" id="L725">                                      Double.longBitsToDouble((Double.doubleToLongBits(ref) ^ 1)));</span>
<span class="fc" id="L726">                double errulp = field.newDfp(tst).subtract(DfpMath.sin(field.newDfp(x))).divide(field.newDfp(ulp)).toDouble();</span>
//                System.out.println(x + &quot;\t&quot; + tst + &quot;\t&quot; + ref + &quot;\t&quot; + err + &quot;\t&quot; + errulp);

<span class="fc" id="L729">                maxerrulp = Math.max(maxerrulp, Math.abs(errulp));</span>
            }
        }

<span class="pc bpc" id="L733" title="1 of 2 branches missed.">        assertTrue(&quot;sin() had errors in excess of &quot; + MAX_ERROR_ULP + &quot; ULP&quot;, maxerrulp &lt; MAX_ERROR_ULP);</span>
<span class="fc" id="L734">    }</span>

    @Test
    public void testCosAccuracy() {
<span class="fc" id="L738">        double maxerrulp = 0.0;</span>

<span class="fc bfc" id="L740" title="All 2 branches covered.">        for (int i = 0; i &lt; NUMBER_OF_TRIALS; i++) {</span>
            /* double x = 1.0 + i/1024.0/2.0; */
            // double x = ((generator.nextDouble() * 1416.0) - 708.0) * generator.nextDouble();
<span class="fc" id="L743">            double x = ((generator.nextDouble() * Math.PI) - Math.PI / 2.0) *</span>
<span class="fc" id="L744">                       Math.pow(2, 21) * generator.nextDouble();</span>
            // double x = (generator.nextDouble() * 20.0) - 10.0;
            // double x = ((generator.nextDouble() * 2.0) - 1.0) * generator.nextDouble();
            /* double x = 3.0 / 512.0 * i - 3.0; */
<span class="fc" id="L748">            double tst = FastMath.cos(x);</span>
<span class="fc" id="L749">            double ref = DfpMath.cos(field.newDfp(x)).toDouble();</span>
<span class="fc" id="L750">            double err = (tst - ref) / ref;</span>

<span class="pc bpc" id="L752" title="1 of 2 branches missed.">            if (err != 0) {</span>
<span class="nc" id="L753">                double ulp = Math.abs(ref -</span>
<span class="nc" id="L754">                                      Double.longBitsToDouble((Double.doubleToLongBits(ref) ^ 1)));</span>
<span class="nc" id="L755">                double errulp = field.newDfp(tst).subtract(DfpMath.cos(field.newDfp(x))).divide(field.newDfp(ulp)).toDouble();</span>
//                System.out.println(x + &quot;\t&quot; + tst + &quot;\t&quot; + ref + &quot;\t&quot; + err + &quot;\t&quot; + errulp);

<span class="nc" id="L758">                maxerrulp = Math.max(maxerrulp, Math.abs(errulp));</span>
            }
        }

<span class="pc bpc" id="L762" title="1 of 2 branches missed.">        assertTrue(&quot;cos() had errors in excess of &quot; + MAX_ERROR_ULP + &quot; ULP&quot;, maxerrulp &lt; MAX_ERROR_ULP);</span>
<span class="fc" id="L763">    }</span>

    @Test
    public void testTanAccuracy() {
<span class="fc" id="L767">        double maxerrulp = 0.0;</span>

<span class="fc bfc" id="L769" title="All 2 branches covered.">        for (int i = 0; i &lt; NUMBER_OF_TRIALS; i++) {</span>
            /* double x = 1.0 + i/1024.0/2.0; */
            // double x = ((generator.nextDouble() * 1416.0) - 708.0) * generator.nextDouble();
<span class="fc" id="L772">            double x = ((generator.nextDouble() * Math.PI) - Math.PI / 2.0) *</span>
<span class="fc" id="L773">                       Math.pow(2, 12) * generator.nextDouble();</span>
            // double x = (generator.nextDouble() * 20.0) - 10.0;
            // double x = ((generator.nextDouble() * 2.0) - 1.0) * generator.nextDouble();
            /* double x = 3.0 / 512.0 * i - 3.0; */
<span class="fc" id="L777">            double tst = FastMath.tan(x);</span>
<span class="fc" id="L778">            double ref = DfpMath.tan(field.newDfp(x)).toDouble();</span>
<span class="fc" id="L779">            double err = (tst - ref) / ref;</span>

<span class="pc bpc" id="L781" title="1 of 2 branches missed.">            if (err != 0) {</span>
<span class="nc" id="L782">                double ulp = Math.abs(ref -</span>
<span class="nc" id="L783">                                      Double.longBitsToDouble((Double.doubleToLongBits(ref) ^ 1)));</span>
<span class="nc" id="L784">                double errulp = field.newDfp(tst).subtract(DfpMath.tan(field.newDfp(x))).divide(field.newDfp(ulp)).toDouble();</span>
//                System.out.println(x + &quot;\t&quot; + tst + &quot;\t&quot; + ref + &quot;\t&quot; + err + &quot;\t&quot; + errulp);

<span class="nc" id="L787">                maxerrulp = Math.max(maxerrulp, Math.abs(errulp));</span>
            }
        }

<span class="pc bpc" id="L791" title="1 of 2 branches missed.">        assertTrue(&quot;tan() had errors in excess of &quot; + MAX_ERROR_ULP + &quot; ULP&quot;, maxerrulp &lt; MAX_ERROR_ULP);</span>
<span class="fc" id="L792">    }</span>

    @Test
    public void testAtanAccuracy() {
<span class="fc" id="L796">        double maxerrulp = 0.0;</span>

<span class="fc bfc" id="L798" title="All 2 branches covered.">        for (int i = 0; i &lt; NUMBER_OF_TRIALS; i++) {</span>
            /* double x = 1.0 + i/1024.0/2.0; */
            // double x = ((generator.nextDouble() * 1416.0) - 708.0) * generator.nextDouble();
            // double x = ((generator.nextDouble() * Math.PI) - Math.PI/2.0) *
            // generator.nextDouble();
<span class="fc" id="L803">            double x = ((generator.nextDouble() * 16.0) - 8.0) * generator.nextDouble();</span>

            // double x = (generator.nextDouble() * 20.0) - 10.0;
            // double x = ((generator.nextDouble() * 2.0) - 1.0) * generator.nextDouble();
            /* double x = 3.0 / 512.0 * i - 3.0; */
<span class="fc" id="L808">            double tst = FastMath.atan(x);</span>
<span class="fc" id="L809">            double ref = DfpMath.atan(field.newDfp(x)).toDouble();</span>
<span class="fc" id="L810">            double err = (tst - ref) / ref;</span>

<span class="pc bpc" id="L812" title="1 of 2 branches missed.">            if (err != 0) {</span>
<span class="nc" id="L813">                double ulp = Math.abs(ref -</span>
<span class="nc" id="L814">                                      Double.longBitsToDouble((Double.doubleToLongBits(ref) ^ 1)));</span>
<span class="nc" id="L815">                double errulp = field.newDfp(tst).subtract(DfpMath.atan(field.newDfp(x))).divide(field.newDfp(ulp)).toDouble();</span>
//                System.out.println(x + &quot;\t&quot; + tst + &quot;\t&quot; + ref + &quot;\t&quot; + err + &quot;\t&quot; + errulp);

<span class="nc" id="L818">                maxerrulp = Math.max(maxerrulp, Math.abs(errulp));</span>
            }
        }

<span class="pc bpc" id="L822" title="1 of 2 branches missed.">        assertTrue(&quot;atan() had errors in excess of &quot; + MAX_ERROR_ULP + &quot; ULP&quot;, maxerrulp &lt; MAX_ERROR_ULP);</span>
<span class="fc" id="L823">    }</span>

    @Test
    public void testAtan2Accuracy() {
<span class="fc" id="L827">        double maxerrulp = 0.0;</span>

<span class="fc bfc" id="L829" title="All 2 branches covered.">        for (int i = 0; i &lt; NUMBER_OF_TRIALS; i++) {</span>
            /* double x = 1.0 + i/1024.0/2.0; */
            // double x = ((generator.nextDouble() * 1416.0) - 708.0) * generator.nextDouble();
<span class="fc" id="L832">            double x = generator.nextDouble() - 0.5;</span>
<span class="fc" id="L833">            double y = generator.nextDouble() - 0.5;</span>
            // double x = (generator.nextDouble() * 20.0) - 10.0;
            // double x = ((generator.nextDouble() * 2.0) - 1.0) * generator.nextDouble();
            /* double x = 3.0 / 512.0 * i - 3.0; */
<span class="fc" id="L837">            double tst = FastMath.atan2(y, x);</span>
<span class="fc" id="L838">            Dfp refdfp = DfpMath.atan(field.newDfp(y).divide(field.newDfp(x)));</span>
            /* Make adjustments for sign */
<span class="fc bfc" id="L840" title="All 2 branches covered.">            if (x &lt; 0.0) {</span>
<span class="fc bfc" id="L841" title="All 2 branches covered.">                if (y &gt; 0.0) {</span>
<span class="fc" id="L842">                    refdfp = field.getPi().add(refdfp);</span>
                } else {
<span class="fc" id="L844">                    refdfp = refdfp.subtract(field.getPi());</span>
                }
            }

<span class="fc" id="L848">            double ref = refdfp.toDouble();</span>
<span class="fc" id="L849">            double err = (tst - ref) / ref;</span>

<span class="pc bpc" id="L851" title="1 of 2 branches missed.">            if (err != 0) {</span>
<span class="nc" id="L852">                double ulp = Math.abs(ref -</span>
<span class="nc" id="L853">                                      Double.longBitsToDouble((Double.doubleToLongBits(ref) ^ 1)));</span>
<span class="nc" id="L854">                double errulp = field.newDfp(tst).subtract(refdfp).divide(field.newDfp(ulp)).toDouble();</span>
//                System.out.println(x + &quot;\t&quot; + y + &quot;\t&quot; + tst + &quot;\t&quot; + ref + &quot;\t&quot; + errulp);

<span class="nc" id="L857">                maxerrulp = Math.max(maxerrulp, Math.abs(errulp));</span>
            }
        }

<span class="pc bpc" id="L861" title="1 of 2 branches missed.">        assertTrue(&quot;atan2() had errors in excess of &quot; + MAX_ERROR_ULP + &quot; ULP&quot;, maxerrulp &lt; MAX_ERROR_ULP);</span>
<span class="fc" id="L862">    }</span>

    @Test
    public void testExpm1Accuracy() {
<span class="fc" id="L866">        double maxerrulp = 0.0;</span>

<span class="fc bfc" id="L868" title="All 2 branches covered.">        for (int i = 0; i &lt; NUMBER_OF_TRIALS; i++) {</span>
            /* double x = 1.0 + i/1024.0/2.0; */
            // double x = (generator.nextDouble() * 20.0) - 10.0;
<span class="fc" id="L871">            double x = ((generator.nextDouble() * 16.0) - 8.0) * generator.nextDouble();</span>
            /* double x = 3.0 / 512.0 * i - 3.0; */
<span class="fc" id="L873">            double tst = FastMath.expm1(x);</span>
<span class="fc" id="L874">            double ref = DfpMath.exp(field.newDfp(x)).subtract(field.getOne()).toDouble();</span>
<span class="fc" id="L875">            double err = (tst - ref) / ref;</span>

<span class="pc bpc" id="L877" title="1 of 2 branches missed.">            if (err != 0) {</span>
<span class="nc" id="L878">                double ulp = Math.abs(ref -</span>
<span class="nc" id="L879">                                      Double.longBitsToDouble((Double.doubleToLongBits(ref) ^ 1)));</span>
<span class="nc" id="L880">                double errulp = field.newDfp(tst).subtract(DfpMath.exp(field.newDfp(x)).subtract(field.getOne())).divide(field.newDfp(ulp)).toDouble();</span>
//                System.out.println(x + &quot;\t&quot; + tst + &quot;\t&quot; + ref + &quot;\t&quot; + err + &quot;\t&quot; + errulp);

<span class="nc" id="L883">                maxerrulp = Math.max(maxerrulp, Math.abs(errulp));</span>
            }
        }

<span class="pc bpc" id="L887" title="1 of 2 branches missed.">        assertTrue(&quot;expm1() had errors in excess of &quot; + MAX_ERROR_ULP + &quot; ULP&quot;, maxerrulp &lt; MAX_ERROR_ULP);</span>
<span class="fc" id="L888">    }</span>

    @Test
    public void testAsinAccuracy() {
<span class="fc" id="L892">        double maxerrulp = 0.0;</span>

<span class="fc bfc" id="L894" title="All 2 branches covered.">        for (int i=0; i&lt;10000; i++) {</span>
<span class="fc" id="L895">            double x = ((generator.nextDouble() * 2.0) - 1.0) * generator.nextDouble();</span>

<span class="fc" id="L897">            double tst = FastMath.asin(x);</span>
<span class="fc" id="L898">            double ref = DfpMath.asin(field.newDfp(x)).toDouble();</span>
<span class="fc" id="L899">            double err = (tst - ref) / ref;</span>

<span class="fc bfc" id="L901" title="All 2 branches covered.">            if (err != 0) {</span>
<span class="fc" id="L902">                double ulp = Math.abs(ref - Double.longBitsToDouble((Double.doubleToLongBits(ref) ^ 1)));</span>
<span class="fc" id="L903">                double errulp = field.newDfp(tst).subtract(DfpMath.asin(field.newDfp(x))).divide(field.newDfp(ulp)).toDouble();</span>
                //System.out.println(x+&quot;\t&quot;+tst+&quot;\t&quot;+ref+&quot;\t&quot;+err+&quot;\t&quot;+errulp);

<span class="fc" id="L906">                maxerrulp = Math.max(maxerrulp, Math.abs(errulp));</span>
            }
        }

<span class="pc bpc" id="L910" title="1 of 2 branches missed.">        assertTrue(&quot;asin() had errors in excess of &quot; + MAX_ERROR_ULP + &quot; ULP&quot;, maxerrulp &lt; MAX_ERROR_ULP);</span>
<span class="fc" id="L911">    }</span>

    @Test
    public void testAcosAccuracy() {
<span class="fc" id="L915">        double maxerrulp = 0.0;</span>

<span class="fc bfc" id="L917" title="All 2 branches covered.">        for (int i=0; i&lt;10000; i++) {</span>
<span class="fc" id="L918">            double x = ((generator.nextDouble() * 2.0) - 1.0) * generator.nextDouble();</span>

<span class="fc" id="L920">            double tst = FastMath.acos(x);</span>
<span class="fc" id="L921">            double ref = DfpMath.acos(field.newDfp(x)).toDouble();</span>
<span class="fc" id="L922">            double err = (tst - ref) / ref;</span>

<span class="pc bpc" id="L924" title="1 of 2 branches missed.">            if (err != 0) {</span>
<span class="nc" id="L925">                double ulp = Math.abs(ref - Double.longBitsToDouble((Double.doubleToLongBits(ref) ^ 1)));</span>
<span class="nc" id="L926">                double errulp = field.newDfp(tst).subtract(DfpMath.acos(field.newDfp(x))).divide(field.newDfp(ulp)).toDouble();</span>
                //System.out.println(x+&quot;\t&quot;+tst+&quot;\t&quot;+ref+&quot;\t&quot;+err+&quot;\t&quot;+errulp);

<span class="nc" id="L929">                maxerrulp = Math.max(maxerrulp, Math.abs(errulp));</span>
            }
        }

<span class="pc bpc" id="L933" title="1 of 2 branches missed.">        assertTrue(&quot;acos() had errors in excess of &quot; + MAX_ERROR_ULP + &quot; ULP&quot;, maxerrulp &lt; MAX_ERROR_ULP);</span>
<span class="fc" id="L934">    }</span>

    /**
     * Added tests for a 100% coverage of acos().
     */
    @Test
    public void testAcosSpecialCases() {

<span class="fc" id="L942">        assertTrue(&quot;acos(NaN) should be NaN&quot;, Double.isNaN(FastMath.acos(Double.NaN)));</span>
<span class="fc" id="L943">        assertTrue(&quot;acos(-1.1) should be NaN&quot;, Double.isNaN(FastMath.acos(-1.1)));</span>
<span class="fc" id="L944">        assertTrue(&quot;acos(-1.1) should be NaN&quot;, Double.isNaN(FastMath.acos(1.1)));</span>
<span class="fc" id="L945">        assertEquals(&quot;acos(-1.0) should be PI&quot;, FastMath.acos(-1.0), FastMath.PI, Precision.EPSILON);</span>
<span class="fc" id="L946">        assertEquals(&quot;acos(1.0) should be 0.0&quot;, FastMath.acos(1.0), 0.0, Precision.EPSILON);</span>
<span class="fc" id="L947">        assertEquals(&quot;acos(0.0) should be PI/2&quot;, FastMath.acos(0.0), FastMath.PI / 2.0, Precision.EPSILON);</span>
<span class="fc" id="L948">    }</span>

    /**
     * Added tests for a 100% coverage of asin().
     */
    @Test
    public void testAsinSpecialCases() {

<span class="fc" id="L956">        assertTrue(&quot;asin(NaN) should be NaN&quot;, Double.isNaN(FastMath.asin(Double.NaN)));</span>
<span class="fc" id="L957">        assertTrue(&quot;asin(1.1) should be NaN&quot;, Double.isNaN(FastMath.asin(1.1)));</span>
<span class="fc" id="L958">        assertTrue(&quot;asin(-1.1) should be NaN&quot;, Double.isNaN(FastMath.asin(-1.1)));</span>
<span class="fc" id="L959">        assertEquals(&quot;asin(1.0) should be PI/2&quot;, FastMath.asin(1.0), FastMath.PI / 2.0, Precision.EPSILON);</span>
<span class="fc" id="L960">        assertEquals(&quot;asin(-1.0) should be -PI/2&quot;, FastMath.asin(-1.0), -FastMath.PI / 2.0, Precision.EPSILON);</span>
<span class="fc" id="L961">        assertEquals(&quot;asin(0.0) should be 0.0&quot;, FastMath.asin(0.0), 0.0, Precision.EPSILON);</span>
<span class="fc" id="L962">    }</span>

    private Dfp cosh(Dfp x) {
<span class="fc" id="L965">      return DfpMath.exp(x).add(DfpMath.exp(x.negate())).divide(2);</span>
    }

    private Dfp sinh(Dfp x) {
<span class="fc" id="L969">      return DfpMath.exp(x).subtract(DfpMath.exp(x.negate())).divide(2);</span>
    }

    private Dfp tanh(Dfp x) {
<span class="fc" id="L973">      return sinh(x).divide(cosh(x));</span>
    }

    @Test
    public void testSinhAccuracy() {
<span class="fc" id="L978">        double maxerrulp = 0.0;</span>

<span class="fc bfc" id="L980" title="All 2 branches covered.">        for (int i=0; i&lt;10000; i++) {</span>
<span class="fc" id="L981">            double x = ((generator.nextDouble() * 16.0) - 8.0) * generator.nextDouble();</span>

<span class="fc" id="L983">            double tst = FastMath.sinh(x);</span>
<span class="fc" id="L984">            double ref = sinh(field.newDfp(x)).toDouble();</span>
<span class="fc" id="L985">            double err = (tst - ref) / ref;</span>

<span class="fc bfc" id="L987" title="All 2 branches covered.">            if (err != 0) {</span>
<span class="fc" id="L988">                double ulp = Math.abs(ref - Double.longBitsToDouble((Double.doubleToLongBits(ref) ^ 1)));</span>
<span class="fc" id="L989">                double errulp = field.newDfp(tst).subtract(sinh(field.newDfp(x))).divide(field.newDfp(ulp)).toDouble();</span>
                //System.out.println(x+&quot;\t&quot;+tst+&quot;\t&quot;+ref+&quot;\t&quot;+err+&quot;\t&quot;+errulp);
<span class="fc" id="L991">                maxerrulp = Math.max(maxerrulp, Math.abs(errulp));</span>
            }
        }

<span class="pc bpc" id="L995" title="1 of 2 branches missed.">        assertTrue(&quot;sinh() had errors in excess of &quot; + MAX_ERROR_ULP + &quot; ULP&quot;, maxerrulp &lt; MAX_ERROR_ULP);</span>
<span class="fc" id="L996">    }</span>

    @Test
    public void testCoshAccuracy() {
<span class="fc" id="L1000">        double maxerrulp = 0.0;</span>

<span class="fc bfc" id="L1002" title="All 2 branches covered.">        for (int i=0; i&lt;10000; i++) {</span>
<span class="fc" id="L1003">            double x = ((generator.nextDouble() * 16.0) - 8.0) * generator.nextDouble();</span>

<span class="fc" id="L1005">            double tst = FastMath.cosh(x);</span>
<span class="fc" id="L1006">            double ref = cosh(field.newDfp(x)).toDouble();</span>
<span class="fc" id="L1007">            double err = (tst - ref) / ref;</span>

<span class="fc bfc" id="L1009" title="All 2 branches covered.">            if (err != 0) {</span>
<span class="fc" id="L1010">                double ulp = Math.abs(ref - Double.longBitsToDouble((Double.doubleToLongBits(ref) ^ 1)));</span>
<span class="fc" id="L1011">                double errulp = field.newDfp(tst).subtract(cosh(field.newDfp(x))).divide(field.newDfp(ulp)).toDouble();</span>
                //System.out.println(x+&quot;\t&quot;+tst+&quot;\t&quot;+ref+&quot;\t&quot;+err+&quot;\t&quot;+errulp);
<span class="fc" id="L1013">                maxerrulp = Math.max(maxerrulp, Math.abs(errulp));</span>
            }
        }

<span class="pc bpc" id="L1017" title="1 of 2 branches missed.">        assertTrue(&quot;cosh() had errors in excess of &quot; + MAX_ERROR_ULP + &quot; ULP&quot;, maxerrulp &lt; MAX_ERROR_ULP);</span>
<span class="fc" id="L1018">    }</span>

    @Test
    public void testTanhAccuracy() {
<span class="fc" id="L1022">        double maxerrulp = 0.0;</span>

<span class="fc bfc" id="L1024" title="All 2 branches covered.">        for (int i=0; i&lt;10000; i++) {</span>
<span class="fc" id="L1025">            double x = ((generator.nextDouble() * 16.0) - 8.0) * generator.nextDouble();</span>

<span class="fc" id="L1027">            double tst = FastMath.tanh(x);</span>
<span class="fc" id="L1028">            double ref = tanh(field.newDfp(x)).toDouble();</span>
<span class="fc" id="L1029">            double err = (tst - ref) / ref;</span>

<span class="pc bpc" id="L1031" title="1 of 2 branches missed.">            if (err != 0) {</span>
<span class="nc" id="L1032">                double ulp = Math.abs(ref - Double.longBitsToDouble((Double.doubleToLongBits(ref) ^ 1)));</span>
<span class="nc" id="L1033">                double errulp = field.newDfp(tst).subtract(tanh(field.newDfp(x))).divide(field.newDfp(ulp)).toDouble();</span>
                //System.out.println(x+&quot;\t&quot;+tst+&quot;\t&quot;+ref+&quot;\t&quot;+err+&quot;\t&quot;+errulp);
<span class="nc" id="L1035">                maxerrulp = Math.max(maxerrulp, Math.abs(errulp));</span>
            }
        }

<span class="pc bpc" id="L1039" title="1 of 2 branches missed.">        assertTrue(&quot;tanh() had errors in excess of &quot; + MAX_ERROR_ULP + &quot; ULP&quot;, maxerrulp &lt; MAX_ERROR_ULP);</span>
<span class="fc" id="L1040">    }</span>

    @Test
    public void testCbrtAccuracy() {
<span class="fc" id="L1044">        double maxerrulp = 0.0;</span>

<span class="fc bfc" id="L1046" title="All 2 branches covered.">        for (int i=0; i&lt;10000; i++) {</span>
<span class="fc" id="L1047">            double x = ((generator.nextDouble() * 200.0) - 100.0) * generator.nextDouble();</span>

<span class="fc" id="L1049">            double tst = FastMath.cbrt(x);</span>
<span class="fc" id="L1050">            double ref = cbrt(field.newDfp(x)).toDouble();</span>
<span class="fc" id="L1051">            double err = (tst - ref) / ref;</span>

<span class="pc bpc" id="L1053" title="1 of 2 branches missed.">            if (err != 0) {</span>
<span class="nc" id="L1054">                double ulp = Math.abs(ref - Double.longBitsToDouble((Double.doubleToLongBits(ref) ^ 1)));</span>
<span class="nc" id="L1055">                double errulp = field.newDfp(tst).subtract(cbrt(field.newDfp(x))).divide(field.newDfp(ulp)).toDouble();</span>
                //System.out.println(x+&quot;\t&quot;+tst+&quot;\t&quot;+ref+&quot;\t&quot;+err+&quot;\t&quot;+errulp);
<span class="nc" id="L1057">                maxerrulp = Math.max(maxerrulp, Math.abs(errulp));</span>
            }
        }

<span class="pc bpc" id="L1061" title="1 of 2 branches missed.">        assertTrue(&quot;cbrt() had errors in excess of &quot; + MAX_ERROR_ULP + &quot; ULP&quot;, maxerrulp &lt; MAX_ERROR_ULP);</span>
<span class="fc" id="L1062">    }</span>

    private Dfp cbrt(Dfp x) {
<span class="fc" id="L1065">        boolean negative=false;</span>

<span class="fc bfc" id="L1067" title="All 2 branches covered.">        if (x.lessThan(field.getZero())) {</span>
<span class="fc" id="L1068">            negative = true;</span>
<span class="fc" id="L1069">            x = x.negate();</span>
        }

<span class="fc" id="L1072">        Dfp y = DfpMath.pow(x, field.getOne().divide(3));</span>

<span class="fc bfc" id="L1074" title="All 2 branches covered.">        if (negative) {</span>
<span class="fc" id="L1075">            y = y.negate();</span>
        }

<span class="fc" id="L1078">        return y;</span>
    }

    @Test
    public void testToDegrees() {
<span class="fc" id="L1083">        double maxerrulp = 0.0;</span>
<span class="fc bfc" id="L1084" title="All 2 branches covered.">        for (int i = 0; i &lt; NUMBER_OF_TRIALS; i++) {</span>
<span class="fc" id="L1085">            double x = generator.nextDouble();</span>
<span class="fc" id="L1086">            double tst = field.newDfp(x).multiply(180).divide(field.getPi()).toDouble();</span>
<span class="fc" id="L1087">            double ref = FastMath.toDegrees(x);</span>
<span class="fc" id="L1088">            double err = (tst - ref) / ref;</span>

<span class="pc bpc" id="L1090" title="1 of 2 branches missed.">            if (err != 0) {</span>
<span class="nc" id="L1091">                double ulp = Math.abs(ref -</span>
<span class="nc" id="L1092">                                      Double.longBitsToDouble((Double.doubleToLongBits(ref) ^ 1)));</span>
<span class="nc" id="L1093">                double errulp = field.newDfp(tst).subtract(DfpMath.exp(field.newDfp(x)).subtract(field.getOne())).divide(field.newDfp(ulp)).toDouble();</span>
//                System.out.println(x + &quot;\t&quot; + tst + &quot;\t&quot; + ref + &quot;\t&quot; + err + &quot;\t&quot; + errulp);

<span class="nc" id="L1096">                maxerrulp = Math.max(maxerrulp, Math.abs(errulp));</span>
            }
        }
<span class="pc bpc" id="L1099" title="1 of 2 branches missed.">        assertTrue(&quot;toDegrees() had errors in excess of &quot; + MAX_ERROR_ULP + &quot; ULP&quot;, maxerrulp &lt; MAX_ERROR_ULP);</span>
<span class="fc" id="L1100">    }</span>

    @Test
    public void testToRadians() {
<span class="fc" id="L1104">        double maxerrulp = 0.0;</span>
<span class="fc bfc" id="L1105" title="All 2 branches covered.">        for (int i = 0; i &lt; NUMBER_OF_TRIALS; i++) {</span>
<span class="fc" id="L1106">            double x = generator.nextDouble();</span>
<span class="fc" id="L1107">            double tst = field.newDfp(x).multiply(field.getPi()).divide(180).toDouble();</span>
<span class="fc" id="L1108">            double ref = FastMath.toRadians(x);</span>
<span class="fc" id="L1109">            double err = (tst - ref) / ref;</span>

<span class="pc bpc" id="L1111" title="1 of 2 branches missed.">            if (err != 0) {</span>
<span class="nc" id="L1112">                double ulp = Math.abs(ref -</span>
<span class="nc" id="L1113">                                      Double.longBitsToDouble((Double.doubleToLongBits(ref) ^ 1)));</span>
<span class="nc" id="L1114">                double errulp = field.newDfp(tst).subtract(DfpMath.exp(field.newDfp(x)).subtract(field.getOne())).divide(field.newDfp(ulp)).toDouble();</span>
//                System.out.println(x + &quot;\t&quot; + tst + &quot;\t&quot; + ref + &quot;\t&quot; + err + &quot;\t&quot; + errulp);

<span class="nc" id="L1117">                maxerrulp = Math.max(maxerrulp, Math.abs(errulp));</span>
            }
        }

<span class="pc bpc" id="L1121" title="1 of 2 branches missed.">        assertTrue(&quot;toRadians() had errors in excess of &quot; + MAX_ERROR_ULP + &quot; ULP&quot;, maxerrulp &lt; MAX_ERROR_ULP);</span>
<span class="fc" id="L1122">    }</span>

    @Test
    public void testNextAfter() {
        // 0x402fffffffffffff 0x404123456789abcd -&gt; 4030000000000000
<span class="fc" id="L1127">        assertEquals(16.0, FastMath.nextUp(15.999999999999998), 0.0);</span>

        // 0xc02fffffffffffff 0x404123456789abcd -&gt; c02ffffffffffffe
<span class="fc" id="L1130">        assertEquals(-15.999999999999996, FastMath.nextAfter(-15.999999999999998, 34.27555555555555), 0.0);</span>

        // 0x402fffffffffffff 0x400123456789abcd -&gt; 402ffffffffffffe
<span class="fc" id="L1133">        assertEquals(15.999999999999996, FastMath.nextDown(15.999999999999998), 0.0);</span>

        // 0xc02fffffffffffff 0x400123456789abcd -&gt; c02ffffffffffffe
<span class="fc" id="L1136">        assertEquals(-15.999999999999996, FastMath.nextAfter(-15.999999999999998, 2.142222222222222), 0.0);</span>

        // 0x4020000000000000 0x404123456789abcd -&gt; 4020000000000001
<span class="fc" id="L1139">        assertEquals(8.000000000000002, FastMath.nextAfter(8.0, 34.27555555555555), 0.0);</span>

        // 0xc020000000000000 0x404123456789abcd -&gt; c01fffffffffffff
<span class="fc" id="L1142">        assertEquals(-7.999999999999999, FastMath.nextAfter(-8.0, 34.27555555555555), 0.0);</span>

        // 0x4020000000000000 0x400123456789abcd -&gt; 401fffffffffffff
<span class="fc" id="L1145">        assertEquals(7.999999999999999, FastMath.nextAfter(8.0, 2.142222222222222), 0.0);</span>

        // 0xc020000000000000 0x400123456789abcd -&gt; c01fffffffffffff
<span class="fc" id="L1148">        assertEquals(-7.999999999999999, FastMath.nextAfter(-8.0, 2.142222222222222), 0.0);</span>

        // 0x3f2e43753d36a223 0x3f2e43753d36a224 -&gt; 3f2e43753d36a224
<span class="fc" id="L1151">        assertEquals(2.308922399667661E-4, FastMath.nextAfter(2.3089223996676606E-4, 2.308922399667661E-4), 0.0);</span>

        // 0x3f2e43753d36a223 0x3f2e43753d36a223 -&gt; 3f2e43753d36a223
<span class="fc" id="L1154">        assertEquals(2.3089223996676606E-4, FastMath.nextAfter(2.3089223996676606E-4, 2.3089223996676606E-4), 0.0);</span>

        // 0x3f2e43753d36a223 0x3f2e43753d36a222 -&gt; 3f2e43753d36a222
<span class="fc" id="L1157">        assertEquals(2.3089223996676603E-4, FastMath.nextAfter(2.3089223996676606E-4, 2.3089223996676603E-4), 0.0);</span>

        // 0x3f2e43753d36a223 0xbf2e43753d36a224 -&gt; 3f2e43753d36a222
<span class="fc" id="L1160">        assertEquals(2.3089223996676603E-4, FastMath.nextAfter(2.3089223996676606E-4, -2.308922399667661E-4), 0.0);</span>

        // 0x3f2e43753d36a223 0xbf2e43753d36a223 -&gt; 3f2e43753d36a222
<span class="fc" id="L1163">        assertEquals(2.3089223996676603E-4, FastMath.nextAfter(2.3089223996676606E-4, -2.3089223996676606E-4), 0.0);</span>

        // 0x3f2e43753d36a223 0xbf2e43753d36a222 -&gt; 3f2e43753d36a222
<span class="fc" id="L1166">        assertEquals(2.3089223996676603E-4, FastMath.nextAfter(2.3089223996676606E-4, -2.3089223996676603E-4), 0.0);</span>

        // 0xbf2e43753d36a223 0x3f2e43753d36a224 -&gt; bf2e43753d36a222
<span class="fc" id="L1169">        assertEquals(-2.3089223996676603E-4, FastMath.nextAfter(-2.3089223996676606E-4, 2.308922399667661E-4), 0.0);</span>

        // 0xbf2e43753d36a223 0x3f2e43753d36a223 -&gt; bf2e43753d36a222
<span class="fc" id="L1172">        assertEquals(-2.3089223996676603E-4, FastMath.nextAfter(-2.3089223996676606E-4, 2.3089223996676606E-4), 0.0);</span>

        // 0xbf2e43753d36a223 0x3f2e43753d36a222 -&gt; bf2e43753d36a222
<span class="fc" id="L1175">        assertEquals(-2.3089223996676603E-4, FastMath.nextAfter(-2.3089223996676606E-4, 2.3089223996676603E-4), 0.0);</span>

        // 0xbf2e43753d36a223 0xbf2e43753d36a224 -&gt; bf2e43753d36a224
<span class="fc" id="L1178">        assertEquals(-2.308922399667661E-4, FastMath.nextAfter(-2.3089223996676606E-4, -2.308922399667661E-4), 0.0);</span>

        // 0xbf2e43753d36a223 0xbf2e43753d36a223 -&gt; bf2e43753d36a223
<span class="fc" id="L1181">        assertEquals(-2.3089223996676606E-4, FastMath.nextAfter(-2.3089223996676606E-4, -2.3089223996676606E-4), 0.0);</span>

        // 0xbf2e43753d36a223 0xbf2e43753d36a222 -&gt; bf2e43753d36a222
<span class="fc" id="L1184">        assertEquals(-2.3089223996676603E-4, FastMath.nextAfter(-2.3089223996676606E-4, -2.3089223996676603E-4), 0.0);</span>

<span class="fc" id="L1186">    }</span>

    @Test
    public void testDoubleNextAfterSpecialCases() {
<span class="fc" id="L1190">        assertEquals(-Double.MAX_VALUE,FastMath.nextAfter(Double.NEGATIVE_INFINITY, 0D), 0D);</span>
<span class="fc" id="L1191">        assertEquals(Double.MAX_VALUE,FastMath.nextAfter(Double.POSITIVE_INFINITY, 0D), 0D);</span>
<span class="fc" id="L1192">        assertEquals(Double.NaN,FastMath.nextAfter(Double.NaN, 0D), 0D);</span>
<span class="fc" id="L1193">        assertEquals(Double.POSITIVE_INFINITY,FastMath.nextAfter(Double.MAX_VALUE, Double.POSITIVE_INFINITY), 0D);</span>
<span class="fc" id="L1194">        assertEquals(Double.NEGATIVE_INFINITY,FastMath.nextAfter(-Double.MAX_VALUE, Double.NEGATIVE_INFINITY), 0D);</span>
<span class="fc" id="L1195">        assertEquals(Double.MIN_VALUE, FastMath.nextAfter(0D, 1D), 0D);</span>
<span class="fc" id="L1196">        assertEquals(-Double.MIN_VALUE, FastMath.nextAfter(0D, -1D), 0D);</span>
<span class="fc" id="L1197">        assertEquals(0D, FastMath.nextAfter(Double.MIN_VALUE, -1), 0D);</span>
<span class="fc" id="L1198">        assertEquals(0D, FastMath.nextAfter(-Double.MIN_VALUE, 1), 0D);</span>
<span class="fc" id="L1199">    }</span>

    @Test
    public void testFloatNextAfterSpecialCases() {
<span class="fc" id="L1203">        assertEquals(-Float.MAX_VALUE, FastMath.nextAfter(Float.NEGATIVE_INFINITY, 0F), 0F);</span>
<span class="fc" id="L1204">        assertEquals(Float.MAX_VALUE, FastMath.nextAfter(Float.POSITIVE_INFINITY, 0F), 0F);</span>
<span class="fc" id="L1205">        assertEquals(Float.NaN, FastMath.nextAfter(Float.NaN, 0F), 0F);</span>
<span class="fc" id="L1206">        assertEquals(Float.POSITIVE_INFINITY, FastMath.nextUp(Float.MAX_VALUE), 0F);</span>
<span class="fc" id="L1207">        assertEquals(Float.NEGATIVE_INFINITY, FastMath.nextDown(-Float.MAX_VALUE), 0F);</span>
<span class="fc" id="L1208">        assertEquals(Float.MIN_VALUE, FastMath.nextAfter(0F, 1F), 0F);</span>
<span class="fc" id="L1209">        assertEquals(-Float.MIN_VALUE, FastMath.nextAfter(0F, -1F), 0F);</span>
<span class="fc" id="L1210">        assertEquals(0F, FastMath.nextAfter(Float.MIN_VALUE, -1F), 0F);</span>
<span class="fc" id="L1211">        assertEquals(0F, FastMath.nextAfter(-Float.MIN_VALUE, 1F), 0F);</span>
<span class="fc" id="L1212">    }</span>

    @Test
    public void testDoubleScalbSpecialCases() {
<span class="fc" id="L1216">        assertEquals(2.5269841324701218E-175,  FastMath.scalb(2.2250738585072014E-308, 442), 0D);</span>
<span class="fc" id="L1217">        assertEquals(1.307993905256674E297,    FastMath.scalb(1.1102230246251565E-16, 1040), 0D);</span>
<span class="fc" id="L1218">        assertEquals(7.2520887996488946E-217,  FastMath.scalb(Double.MIN_VALUE,        356), 0D);</span>
<span class="fc" id="L1219">        assertEquals(8.98846567431158E307,     FastMath.scalb(Double.MIN_VALUE,       2097), 0D);</span>
<span class="fc" id="L1220">        assertEquals(Double.POSITIVE_INFINITY, FastMath.scalb(Double.MIN_VALUE,       2098), 0D);</span>
<span class="fc" id="L1221">        assertEquals(1.1125369292536007E-308,  FastMath.scalb(2.225073858507201E-308,   -1), 0D);</span>
<span class="fc" id="L1222">        assertEquals(1.0E-323,                 FastMath.scalb(Double.MAX_VALUE,      -2097), 0D);</span>
<span class="fc" id="L1223">        assertEquals(Double.MIN_VALUE,         FastMath.scalb(Double.MAX_VALUE,      -2098), 0D);</span>
<span class="fc" id="L1224">        assertEquals(0,                        FastMath.scalb(Double.MAX_VALUE,      -2099), 0D);</span>
<span class="fc" id="L1225">        assertEquals(Double.POSITIVE_INFINITY, FastMath.scalb(Double.POSITIVE_INFINITY, -1000000), 0D);</span>
<span class="fc" id="L1226">        assertEquals(Double.NEGATIVE_INFINITY, FastMath.scalb(-1.1102230246251565E-16, 1078), 0D);</span>
<span class="fc" id="L1227">        assertEquals(Double.NEGATIVE_INFINITY, FastMath.scalb(-1.1102230246251565E-16,  1079), 0D);</span>
<span class="fc" id="L1228">        assertEquals(Double.NEGATIVE_INFINITY, FastMath.scalb(-2.2250738585072014E-308, 2047), 0D);</span>
<span class="fc" id="L1229">        assertEquals(Double.NEGATIVE_INFINITY, FastMath.scalb(-2.2250738585072014E-308, 2048), 0D);</span>
<span class="fc" id="L1230">        assertEquals(Double.NEGATIVE_INFINITY, FastMath.scalb(-1.7976931348623157E308,  2147483647), 0D);</span>
<span class="fc" id="L1231">        assertEquals(Double.POSITIVE_INFINITY, FastMath.scalb( 1.7976931348623157E308,  2147483647), 0D);</span>
<span class="fc" id="L1232">        assertEquals(Double.NEGATIVE_INFINITY, FastMath.scalb(-1.1102230246251565E-16,  2147483647), 0D);</span>
<span class="fc" id="L1233">        assertEquals(Double.POSITIVE_INFINITY, FastMath.scalb( 1.1102230246251565E-16,  2147483647), 0D);</span>
<span class="fc" id="L1234">        assertEquals(Double.NEGATIVE_INFINITY, FastMath.scalb(-2.2250738585072014E-308, 2147483647), 0D);</span>
<span class="fc" id="L1235">        assertEquals(Double.POSITIVE_INFINITY, FastMath.scalb( 2.2250738585072014E-308, 2147483647), 0D);</span>
<span class="fc" id="L1236">    }</span>

    @Test
    public void testFloatScalbSpecialCases() {
<span class="fc" id="L1240">        assertEquals(0f, FastMath.scalb(Float.MIN_VALUE, -30), 0F);</span>
<span class="fc" id="L1241">        assertEquals(2 * Float.MIN_VALUE, FastMath.scalb(Float.MIN_VALUE, 1), 0F);</span>
<span class="fc" id="L1242">        assertEquals(7.555786e22f, FastMath.scalb(Float.MAX_VALUE, -52), 0F);</span>
<span class="fc" id="L1243">        assertEquals(1.7014118e38f, FastMath.scalb(Float.MIN_VALUE, 276), 0F);</span>
<span class="fc" id="L1244">        assertEquals(Float.POSITIVE_INFINITY, FastMath.scalb(Float.MIN_VALUE, 277), 0F);</span>
<span class="fc" id="L1245">        assertEquals(5.8774718e-39f, FastMath.scalb(1.1754944e-38f, -1), 0F);</span>
<span class="fc" id="L1246">        assertEquals(2 * Float.MIN_VALUE, FastMath.scalb(Float.MAX_VALUE, -276), 0F);</span>
<span class="fc" id="L1247">        assertEquals(Float.MIN_VALUE, FastMath.scalb(Float.MAX_VALUE, -277), 0F);</span>
<span class="fc" id="L1248">        assertEquals(0, FastMath.scalb(Float.MAX_VALUE, -278), 0F);</span>
<span class="fc" id="L1249">        assertEquals(Float.POSITIVE_INFINITY, FastMath.scalb(Float.POSITIVE_INFINITY, -1000000), 0F);</span>
<span class="fc" id="L1250">        assertEquals(-3.13994498e38f, FastMath.scalb(-1.1e-7f, 151), 0F);</span>
<span class="fc" id="L1251">        assertEquals(Float.NEGATIVE_INFINITY, FastMath.scalb(-1.1e-7f, 152), 0F);</span>
<span class="fc" id="L1252">        assertEquals(Float.POSITIVE_INFINITY, FastMath.scalb(3.4028235E38f, 2147483647), 0F);</span>
<span class="fc" id="L1253">        assertEquals(Float.NEGATIVE_INFINITY, FastMath.scalb(-3.4028235E38f, 2147483647), 0F);</span>
<span class="fc" id="L1254">    }</span>

    private boolean compareClassMethods(Class&lt;?&gt; class1, Class&lt;?&gt; class2){
<span class="fc" id="L1257">        boolean allfound = true;</span>
<span class="fc bfc" id="L1258" title="All 2 branches covered.">        for(Method method1 : class1.getDeclaredMethods()){</span>
<span class="fc bfc" id="L1259" title="All 2 branches covered.">            if (Modifier.isPublic(method1.getModifiers())){</span>
<span class="fc" id="L1260">                Type []params = method1.getGenericParameterTypes();</span>
                try {
<span class="fc" id="L1262">                    class2.getDeclaredMethod(method1.getName(), (Class[]) params);</span>
<span class="nc" id="L1263">                } catch (NoSuchMethodException e) {</span>
<span class="nc" id="L1264">                    allfound = false;</span>
<span class="nc" id="L1265">                    System.out.println(class2.getSimpleName()+&quot; does not implement: &quot;+method1);</span>
<span class="fc" id="L1266">                }</span>
            }
        }
<span class="fc" id="L1269">        return allfound;</span>
    }

    @Test
    public void checkMissingFastMathClasses() {
<span class="fc" id="L1274">        boolean ok = compareClassMethods(StrictMath.class, FastMath.class);</span>
<span class="fc" id="L1275">        assertTrue(&quot;FastMath should implement all StrictMath methods&quot;, ok);</span>
<span class="fc" id="L1276">    }</span>

    @Ignore
    @Test
    public void checkExtraFastMathClasses() {
<span class="nc" id="L1281">        compareClassMethods(FastMath.class, StrictMath.class);</span>
<span class="nc" id="L1282">    }</span>

    @Test
    public void testSignumDouble() {
<span class="fc" id="L1286">        final double delta = 0.0;</span>
<span class="fc" id="L1287">        assertEquals(1.0, FastMath.signum(2.0), delta);</span>
<span class="fc" id="L1288">        assertEquals(0.0, FastMath.signum(0.0), delta);</span>
<span class="fc" id="L1289">        assertEquals(-1.0, FastMath.signum(-2.0), delta);</span>
<span class="fc" id="L1290">        TestUtils.assertSame(-0. / 0., FastMath.signum(Double.NaN));</span>
<span class="fc" id="L1291">    }</span>

    @Test
    public void testSignumFloat() {
<span class="fc" id="L1295">        final float delta = 0.0F;</span>
<span class="fc" id="L1296">        assertEquals(1.0F, FastMath.signum(2.0F), delta);</span>
<span class="fc" id="L1297">        assertEquals(0.0F, FastMath.signum(0.0F), delta);</span>
<span class="fc" id="L1298">        assertEquals(-1.0F, FastMath.signum(-2.0F), delta);</span>
<span class="fc" id="L1299">        TestUtils.assertSame(Float.NaN, FastMath.signum(Float.NaN));</span>
<span class="fc" id="L1300">    }</span>

    @Test
    public void testLogWithBase() {
<span class="fc" id="L1304">        assertEquals(2.0, FastMath.log(2, 4), 0);</span>
<span class="fc" id="L1305">        assertEquals(3.0, FastMath.log(2, 8), 0);</span>
<span class="fc" id="L1306">        assertTrue(Double.isNaN(FastMath.log(-1, 1)));</span>
<span class="fc" id="L1307">        assertTrue(Double.isNaN(FastMath.log(1, -1)));</span>
<span class="fc" id="L1308">        assertTrue(Double.isNaN(FastMath.log(0, 0)));</span>
<span class="fc" id="L1309">        assertEquals(0, FastMath.log(0, 10), 0);</span>
<span class="fc" id="L1310">        assertEquals(Double.NEGATIVE_INFINITY, FastMath.log(10, 0), 0);</span>
<span class="fc" id="L1311">    }</span>

    @Test
    public void testIndicatorDouble() {
<span class="fc" id="L1315">        double delta = 0.0;</span>
<span class="fc" id="L1316">        assertEquals(1.0, FastMath.copySign(1d, 2.0), delta);</span>
<span class="fc" id="L1317">        assertEquals(1.0, FastMath.copySign(1d, 0.0), delta);</span>
<span class="fc" id="L1318">        assertEquals(-1.0, FastMath.copySign(1d, -0.0), delta);</span>
<span class="fc" id="L1319">        assertEquals(1.0, FastMath.copySign(1d, Double.POSITIVE_INFINITY), delta);</span>
<span class="fc" id="L1320">        assertEquals(-1.0, FastMath.copySign(1d, Double.NEGATIVE_INFINITY), delta);</span>
<span class="fc" id="L1321">        assertEquals(1.0, FastMath.copySign(1d, Double.NaN), delta);</span>
<span class="fc" id="L1322">        assertEquals(-1.0, FastMath.copySign(1d, -2.0), delta);</span>
<span class="fc" id="L1323">    }</span>

    @Test
    public void testIndicatorFloat() {
<span class="fc" id="L1327">        float delta = 0.0F;</span>
<span class="fc" id="L1328">        assertEquals(1.0F, FastMath.copySign(1d, 2.0F), delta);</span>
<span class="fc" id="L1329">        assertEquals(1.0F, FastMath.copySign(1d, 0.0F), delta);</span>
<span class="fc" id="L1330">        assertEquals(-1.0F, FastMath.copySign(1d, -0.0F), delta);</span>
<span class="fc" id="L1331">        assertEquals(1.0F, FastMath.copySign(1d, Float.POSITIVE_INFINITY), delta);</span>
<span class="fc" id="L1332">        assertEquals(-1.0F, FastMath.copySign(1d, Float.NEGATIVE_INFINITY), delta);</span>
<span class="fc" id="L1333">        assertEquals(1.0F, FastMath.copySign(1d, Float.NaN), delta);</span>
<span class="fc" id="L1334">        assertEquals(-1.0F, FastMath.copySign(1d, -2.0F), delta);</span>
<span class="fc" id="L1335">    }</span>

    @Test
    public void testIntPow() {
<span class="fc" id="L1339">        final int maxExp = 300;</span>
<span class="fc" id="L1340">        DfpField field = new DfpField(40);</span>
<span class="fc" id="L1341">        final double base = 1.23456789;</span>
<span class="fc" id="L1342">        Dfp baseDfp = field.newDfp(base);</span>
<span class="fc" id="L1343">        Dfp dfpPower = field.getOne();</span>
<span class="fc bfc" id="L1344" title="All 2 branches covered.">        for (int i = 0; i &lt; maxExp; i++) {</span>
<span class="fc" id="L1345">            assertEquals(&quot;exp=&quot; + i, dfpPower.toDouble(), FastMath.pow(base, i),</span>
<span class="fc" id="L1346">                         0.6 * FastMath.ulp(dfpPower.toDouble()));</span>
<span class="fc" id="L1347">            dfpPower = dfpPower.multiply(baseDfp);</span>
        }
<span class="fc" id="L1349">    }</span>

    @Test
    public void testIntPowHuge() {
<span class="fc" id="L1353">        assertTrue(Double.isInfinite(FastMath.pow(FastMath.scalb(1.0, 500), 4)));</span>
<span class="fc" id="L1354">    }</span>

    @Test(timeout=5000L) // This test must finish in finite time.
    public void testIntPowLongMinValue() {
<span class="fc" id="L1358">        assertEquals(1.0, FastMath.pow(1.0, Long.MIN_VALUE), -1.0);</span>
<span class="fc" id="L1359">    }</span>

    @Test(timeout=5000L)
    public void testIntPowSpecialCases() {
<span class="fc" id="L1363">        final double EXACT = -1.0;</span>
<span class="fc" id="L1364">        final double DOUBLES[] = new double[]</span>
            {
                Double.NEGATIVE_INFINITY, -0.0, Double.NaN, 0.0, Double.POSITIVE_INFINITY,
                Long.MIN_VALUE, Integer.MIN_VALUE, Short.MIN_VALUE, Byte.MIN_VALUE,
                -(double)Long.MIN_VALUE, -(double)Integer.MIN_VALUE, -(double)Short.MIN_VALUE, -(double)Byte.MIN_VALUE,
                Byte.MAX_VALUE, Short.MAX_VALUE, Integer.MAX_VALUE, Long.MAX_VALUE,
                -Byte.MAX_VALUE, -Short.MAX_VALUE, -Integer.MAX_VALUE, -Long.MAX_VALUE,
                Float.MAX_VALUE, Double.MAX_VALUE, Double.MIN_VALUE, Float.MIN_VALUE,
                -Float.MAX_VALUE, -Double.MAX_VALUE, -Double.MIN_VALUE, -Float.MIN_VALUE,
                0.5, 0.1, 0.2, 0.8, 1.1, 1.2, 1.5, 1.8, 1.0, 2.0, 3.0, 4.0, 5.0, 6.0, 7.0, 8.0, 9.0, 1.3, 2.2, 2.5, 2.8, 33.0, 33.1, 33.5, 33.8, 10.0, 300.0, 400.0, 500.0,
                -0.5, -0.1, -0.2, -0.8, -1.1, -1.2, -1.5, -1.8, -1.0, -2.0, -3.0, -4.0, -5.0, -6.0, -7.0, -8.0, -9.0, -1.3, -2.2, -2.5, -2.8, -33.0, -33.1, -33.5, -33.8, -10.0, -300.0, -400.0, -500.0
            };

<span class="fc" id="L1377">        final long INTS[] = new long[]{Long.MAX_VALUE, Long.MAX_VALUE - 1, Long.MIN_VALUE, Long.MIN_VALUE + 1, Long.MIN_VALUE + 2, Integer.MAX_VALUE, Integer.MAX_VALUE - 1, Integer.MIN_VALUE, Integer.MIN_VALUE + 1, Integer.MIN_VALUE + 2, 0, 1, 2, 3, 5, 8, 10, 20, 100, 300, 500, -1, -2, -3, -5, -8, -10, -20, -100, -300, -500};</span>
        // Special cases from Math.pow javadoc:
        // If the second argument is positive or negative zero, then the result is 1.0.
<span class="fc bfc" id="L1380" title="All 2 branches covered.">        for (double d : DOUBLES) {</span>
<span class="fc" id="L1381">            assertEquals(1.0, FastMath.pow(d, 0L), EXACT);</span>
        }
        // If the second argument is 1.0, then the result is the same as the first argument.
<span class="fc bfc" id="L1384" title="All 2 branches covered.">        for (double d : DOUBLES) {</span>
<span class="fc" id="L1385">            assertEquals(d, FastMath.pow(d, 1L), EXACT);</span>
        }
        // If the second argument is NaN, then the result is NaN. &lt;- Impossible with int.
        // If the first argument is NaN and the second argument is nonzero, then the result is NaN.
<span class="fc bfc" id="L1389" title="All 2 branches covered.">        for (long i : INTS) {</span>
<span class="fc bfc" id="L1390" title="All 2 branches covered.">            if (i != 0L) {</span>
<span class="fc" id="L1391">                assertEquals(Double.NaN, FastMath.pow(Double.NaN, i), EXACT);</span>
            }
        }
        // If the absolute value of the first argument is greater than 1 and the second argument is positive infinity, or
        // the absolute value of the first argument is less than 1 and the second argument is negative infinity, then the result is positive infinity.
<span class="fc bfc" id="L1396" title="All 2 branches covered.">        for (double d : DOUBLES) {</span>
<span class="fc bfc" id="L1397" title="All 2 branches covered.">            if (Math.abs(d) &gt; 1.0) {</span>
<span class="fc" id="L1398">                assertEquals(Double.POSITIVE_INFINITY, FastMath.pow(d, Long.MAX_VALUE - 1L), EXACT);</span>
            }
        }
<span class="fc bfc" id="L1401" title="All 2 branches covered.">        for (double d : DOUBLES) {</span>
<span class="fc bfc" id="L1402" title="All 2 branches covered.">            if (Math.abs(d) &lt; 1.0) {</span>
<span class="fc" id="L1403">                assertEquals(Double.POSITIVE_INFINITY, FastMath.pow(d, Long.MIN_VALUE), EXACT);</span>
            }
        }
        // Note: Long.MAX_VALUE isn't actually an infinity, so its parity affects the sign of resulting infinity.
<span class="fc bfc" id="L1407" title="All 2 branches covered.">        for (double d : DOUBLES) {</span>
<span class="fc bfc" id="L1408" title="All 2 branches covered.">            if (Math.abs(d) &gt; 1.0) {</span>
<span class="fc" id="L1409">                assertTrue(Double.isInfinite(FastMath.pow(d, Long.MAX_VALUE)));</span>
            }
        }
<span class="fc bfc" id="L1412" title="All 2 branches covered.">        for (double d : DOUBLES) {</span>
<span class="fc bfc" id="L1413" title="All 2 branches covered.">            if (Math.abs(d) &lt; 1.0) {</span>
<span class="fc" id="L1414">                assertTrue(Double.isInfinite(FastMath.pow(d, Long.MIN_VALUE + 1L)));</span>
            }
        }
        // If the absolute value of the first argument is greater than 1 and the second argument is negative infinity, or
        // the absolute value of the first argument is less than 1 and the second argument is positive infinity, then the result is positive zero.
<span class="fc bfc" id="L1419" title="All 2 branches covered.">        for (double d : DOUBLES) {</span>
<span class="fc bfc" id="L1420" title="All 2 branches covered.">            if (Math.abs(d) &gt; 1.0) {</span>
<span class="fc" id="L1421">                assertEquals(0.0, FastMath.pow(d, Long.MIN_VALUE), EXACT);</span>
            }
        }
<span class="fc bfc" id="L1424" title="All 2 branches covered.">        for (double d : DOUBLES) {</span>
<span class="fc bfc" id="L1425" title="All 2 branches covered.">            if (Math.abs(d) &lt; 1.0) {</span>
<span class="fc" id="L1426">                assertEquals(0.0, FastMath.pow(d, Long.MAX_VALUE - 1L), EXACT);</span>
            }
        }
        // Note: Long.MAX_VALUE isn't actually an infinity, so its parity affects the sign of resulting zero.
<span class="fc bfc" id="L1430" title="All 2 branches covered.">        for (double d : DOUBLES) {</span>
<span class="fc bfc" id="L1431" title="All 2 branches covered.">            if (Math.abs(d) &gt; 1.0) {</span>
<span class="pc bpc" id="L1432" title="1 of 2 branches missed.">                assertTrue(FastMath.pow(d, Long.MIN_VALUE + 1L) == 0.0);</span>
            }
        }
<span class="fc bfc" id="L1435" title="All 2 branches covered.">        for (double d : DOUBLES) {</span>
<span class="fc bfc" id="L1436" title="All 2 branches covered.">            if (Math.abs(d) &lt; 1.0) {</span>
<span class="pc bpc" id="L1437" title="1 of 2 branches missed.">                assertTrue(FastMath.pow(d, Long.MAX_VALUE) == 0.0);</span>
            }
        }
        // If the absolute value of the first argument equals 1 and the second argument is infinite, then the result is NaN. &lt;- Impossible with int.
        // If the first argument is positive zero and the second argument is greater than zero, or
        // the first argument is positive infinity and the second argument is less than zero, then the result is positive zero.
<span class="fc bfc" id="L1443" title="All 2 branches covered.">        for (long i : INTS) {</span>
<span class="fc bfc" id="L1444" title="All 2 branches covered.">            if (i &gt; 0L) {</span>
<span class="fc" id="L1445">                assertEquals(0.0, FastMath.pow(0.0, i), EXACT);</span>
            }
        }
<span class="fc bfc" id="L1448" title="All 2 branches covered.">        for (long i : INTS) {</span>
<span class="fc bfc" id="L1449" title="All 2 branches covered.">            if (i &lt; 0L) {</span>
<span class="fc" id="L1450">                assertEquals(0.0, FastMath.pow(Double.POSITIVE_INFINITY, i), EXACT);</span>
            }
        }
        // If the first argument is positive zero and the second argument is less than zero, or
        // the first argument is positive infinity and the second argument is greater than zero, then the result is positive infinity.
<span class="fc bfc" id="L1455" title="All 2 branches covered.">        for (long i : INTS) {</span>
<span class="fc bfc" id="L1456" title="All 2 branches covered.">            if (i &lt; 0L) {</span>
<span class="fc" id="L1457">                assertEquals(Double.POSITIVE_INFINITY, FastMath.pow(0.0, i), EXACT);</span>
            }
        }
<span class="fc bfc" id="L1460" title="All 2 branches covered.">        for (long i : INTS) {</span>
<span class="fc bfc" id="L1461" title="All 2 branches covered.">            if (i &gt; 0L) {</span>
<span class="fc" id="L1462">                assertEquals(Double.POSITIVE_INFINITY, FastMath.pow(Double.POSITIVE_INFINITY, i), EXACT);</span>
            }
        }
        // If the first argument is negative zero and the second argument is greater than zero but not a finite odd integer, or
        // the first argument is negative infinity and the second argument is less than zero but not a finite odd integer, then the result is positive zero.
<span class="fc bfc" id="L1467" title="All 2 branches covered.">        for (long i : INTS) {</span>
<span class="fc bfc" id="L1468" title="All 4 branches covered.">            if (i &gt; 0L &amp;&amp; (i &amp; 1L) == 0L) {</span>
<span class="fc" id="L1469">                assertEquals(0.0, FastMath.pow(-0.0, i), EXACT);</span>
            }
        }
<span class="fc bfc" id="L1472" title="All 2 branches covered.">        for (long i : INTS) {</span>
<span class="fc bfc" id="L1473" title="All 4 branches covered.">            if (i &lt; 0L &amp;&amp; (i &amp; 1L) == 0L) {</span>
<span class="fc" id="L1474">                assertEquals(0.0, FastMath.pow(Double.NEGATIVE_INFINITY, i), EXACT);</span>
            }
        }
        // If the first argument is negative zero and the second argument is a positive finite odd integer, or
        // the first argument is negative infinity and the second argument is a negative finite odd integer, then the result is negative zero.
<span class="fc bfc" id="L1479" title="All 2 branches covered.">        for (long i : INTS) {</span>
<span class="fc bfc" id="L1480" title="All 4 branches covered.">            if (i &gt; 0L &amp;&amp; (i &amp; 1L) == 1L) {</span>
<span class="fc" id="L1481">                assertEquals(-0.0, FastMath.pow(-0.0, i), EXACT);</span>
            }
        }
<span class="fc bfc" id="L1484" title="All 2 branches covered.">        for (long i : INTS) {</span>
<span class="fc bfc" id="L1485" title="All 4 branches covered.">            if (i &lt; 0L &amp;&amp; (i &amp; 1L) == 1L) {</span>
<span class="fc" id="L1486">                assertEquals(-0.0, FastMath.pow(Double.NEGATIVE_INFINITY, i), EXACT);</span>
            }
        }
        // If the first argument is negative zero and the second argument is less than zero but not a finite odd integer, or
        // the first argument is negative infinity and the second argument is greater than zero but not a finite odd integer, then the result is positive infinity.
<span class="fc bfc" id="L1491" title="All 2 branches covered.">        for (long i : INTS) {</span>
<span class="fc bfc" id="L1492" title="All 4 branches covered.">            if (i &gt; 0L &amp;&amp; (i &amp; 1L) == 0L) {</span>
<span class="fc" id="L1493">                assertEquals(Double.POSITIVE_INFINITY, FastMath.pow(Double.NEGATIVE_INFINITY, i), EXACT);</span>
            }
        }
<span class="fc bfc" id="L1496" title="All 2 branches covered.">        for (long i : INTS) {</span>
<span class="fc bfc" id="L1497" title="All 4 branches covered.">            if (i &lt; 0L &amp;&amp; (i &amp; 1L) == 0L) {</span>
<span class="fc" id="L1498">                assertEquals(Double.POSITIVE_INFINITY, FastMath.pow(-0.0, i), EXACT);</span>
            }
        }
        // If the first argument is negative zero and the second argument is a negative finite odd integer, or
        // the first argument is negative infinity and the second argument is a positive finite odd integer, then the result is negative infinity.
<span class="fc bfc" id="L1503" title="All 2 branches covered.">        for (long i : INTS) {</span>
<span class="fc bfc" id="L1504" title="All 4 branches covered.">            if (i &gt; 0L &amp;&amp; (i &amp; 1L) == 1L) {</span>
<span class="fc" id="L1505">                assertEquals(Double.NEGATIVE_INFINITY, FastMath.pow(Double.NEGATIVE_INFINITY, i), EXACT);</span>
            }
        }
<span class="fc bfc" id="L1508" title="All 2 branches covered.">        for (long i : INTS) {</span>
<span class="fc bfc" id="L1509" title="All 4 branches covered.">            if (i &lt; 0L &amp;&amp; (i &amp; 1L) == 1L) {</span>
<span class="fc" id="L1510">                assertEquals(Double.NEGATIVE_INFINITY, FastMath.pow(-0.0, i), EXACT);</span>
            }
        }
<span class="fc bfc" id="L1513" title="All 2 branches covered.">        for (double d : DOUBLES) {</span>
            // If the first argument is finite and less than zero
<span class="fc bfc" id="L1515" title="All 4 branches covered.">            if (d &lt; 0.0 &amp;&amp; Math.abs(d) &lt;= Double.MAX_VALUE) {</span>
<span class="fc bfc" id="L1516" title="All 2 branches covered.">                for (long i : INTS) {</span>
                    // if the second argument is a finite even integer, the result is equal to the result of raising the absolute value of the first argument to the power of the second argument
<span class="fc bfc" id="L1518" title="All 2 branches covered.">                    if ((i &amp; 1L) == 0L) assertEquals(FastMath.pow(-d, i), FastMath.pow(d, i), EXACT);</span>
                    // if the second argument is a finite odd integer, the result is equal to the negative of the result of raising the absolute value of the first argument to the power of the second argument
<span class="fc" id="L1520">                    else assertEquals(-FastMath.pow(-d, i), FastMath.pow(d, i), EXACT);</span>
                    // if the second argument is finite and not an integer, then the result is NaN. &lt;- Impossible with int.
                }
            }
        }
        // If both arguments are integers, then the result is exactly equal to the mathematical result of raising the first argument to the power
        // of the second argument if that result can in fact be represented exactly as a double value. &lt;- Other tests.
<span class="fc" id="L1527">    }</span>

    @Test
    public void testIncrementExactInt() {
<span class="fc" id="L1531">        int[] specialValues = new int[] {</span>
            Integer.MIN_VALUE, Integer.MIN_VALUE + 1, Integer.MIN_VALUE + 2,
            Integer.MAX_VALUE, Integer.MAX_VALUE - 1, Integer.MAX_VALUE - 2,
            -10, -9, -8, -7, -6, -5, -4, -3, -2, -1, 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10,
            -1 - (Integer.MIN_VALUE / 2), 0 - (Integer.MIN_VALUE / 2), 1 - (Integer.MIN_VALUE / 2),
            -1 + (Integer.MAX_VALUE / 2), 0 + (Integer.MAX_VALUE / 2), 1 + (Integer.MAX_VALUE / 2),
        };
<span class="fc bfc" id="L1538" title="All 2 branches covered.">        for (int a : specialValues) {</span>
<span class="fc" id="L1539">            BigInteger bdA   = BigInteger.valueOf(a);</span>
<span class="fc" id="L1540">            BigInteger bdSum = bdA.add(BigInteger.ONE);</span>
<span class="pc bpc" id="L1541" title="1 of 2 branches missed.">            if (bdSum.compareTo(BigInteger.valueOf(Integer.MIN_VALUE)) &lt; 0 ||</span>
<span class="fc bfc" id="L1542" title="All 2 branches covered.">                bdSum.compareTo(BigInteger.valueOf(Integer.MAX_VALUE)) &gt; 0) {</span>
                try {
<span class="nc" id="L1544">                    FastMath.incrementExact(a);</span>
<span class="nc" id="L1545">                    Assert.fail(&quot;an exception should have been thrown&quot;);</span>
<span class="fc" id="L1546">                } catch (MathArithmeticException mae) {</span>
                    // expected
<span class="pc" id="L1548">                }</span>
            } else {
<span class="fc" id="L1550">                assertEquals(bdSum, BigInteger.valueOf(FastMath.incrementExact(a)));</span>
            }
        }
<span class="fc" id="L1553">    }</span>

    @Test
    public void testDecrementExactInt() {
<span class="fc" id="L1557">        int[] specialValues = new int[] {</span>
            Integer.MIN_VALUE, Integer.MIN_VALUE + 1, Integer.MIN_VALUE + 2,
            Integer.MAX_VALUE, Integer.MAX_VALUE - 1, Integer.MAX_VALUE - 2,
            -10, -9, -8, -7, -6, -5, -4, -3, -2, -1, 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10,
            -1 - (Integer.MIN_VALUE / 2), 0 - (Integer.MIN_VALUE / 2), 1 - (Integer.MIN_VALUE / 2),
            -1 + (Integer.MAX_VALUE / 2), 0 + (Integer.MAX_VALUE / 2), 1 + (Integer.MAX_VALUE / 2),
        };
<span class="fc bfc" id="L1564" title="All 2 branches covered.">        for (int a : specialValues) {</span>
<span class="fc" id="L1565">            BigInteger bdA   = BigInteger.valueOf(a);</span>
<span class="fc" id="L1566">            BigInteger bdSub = bdA.subtract(BigInteger.ONE);</span>
<span class="fc bfc" id="L1567" title="All 2 branches covered.">            if (bdSub.compareTo(BigInteger.valueOf(Integer.MIN_VALUE)) &lt; 0 ||</span>
<span class="pc bpc" id="L1568" title="1 of 2 branches missed.">                bdSub.compareTo(BigInteger.valueOf(Integer.MAX_VALUE)) &gt; 0) {</span>
                try {
<span class="nc" id="L1570">                    FastMath.decrementExact(a);</span>
<span class="nc" id="L1571">                    fail(&quot;an exception should have been thrown&quot;);</span>
<span class="fc" id="L1572">                } catch (MathArithmeticException mae) {</span>
                    // expected
<span class="pc" id="L1574">                }</span>
            } else {
<span class="fc" id="L1576">                assertEquals(bdSub, BigInteger.valueOf(FastMath.decrementExact(a)));</span>
            }
        }
<span class="fc" id="L1579">    }</span>

    @Test
    public void testAddExactInt() {
<span class="fc" id="L1583">        int[] specialValues = new int[] {</span>
            Integer.MIN_VALUE, Integer.MIN_VALUE + 1, Integer.MIN_VALUE + 2,
            Integer.MAX_VALUE, Integer.MAX_VALUE - 1, Integer.MAX_VALUE - 2,
            -10, -9, -8, -7, -6, -5, -4, -3, -2, -1, 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10,
            -1 - (Integer.MIN_VALUE / 2), 0 - (Integer.MIN_VALUE / 2), 1 - (Integer.MIN_VALUE / 2),
            -1 + (Integer.MAX_VALUE / 2), 0 + (Integer.MAX_VALUE / 2), 1 + (Integer.MAX_VALUE / 2),
        };
<span class="fc bfc" id="L1590" title="All 2 branches covered.">        for (int a : specialValues) {</span>
<span class="fc bfc" id="L1591" title="All 2 branches covered.">            for (int b : specialValues) {</span>
<span class="fc" id="L1592">                BigInteger bdA   = BigInteger.valueOf(a);</span>
<span class="fc" id="L1593">                BigInteger bdB   = BigInteger.valueOf(b);</span>
<span class="fc" id="L1594">                BigInteger bdSum = bdA.add(bdB);</span>
<span class="fc bfc" id="L1595" title="All 2 branches covered.">                if (bdSum.compareTo(BigInteger.valueOf(Integer.MIN_VALUE)) &lt; 0 ||</span>
<span class="fc bfc" id="L1596" title="All 2 branches covered.">                        bdSum.compareTo(BigInteger.valueOf(Integer.MAX_VALUE)) &gt; 0) {</span>
                    try {
<span class="nc" id="L1598">                        FastMath.addExact(a, b);</span>
<span class="nc" id="L1599">                        fail(&quot;an exception should have been thrown&quot;);</span>
<span class="fc" id="L1600">                    } catch (MathArithmeticException mae) {</span>
                        // expected
<span class="pc" id="L1602">                    }</span>
                } else {
<span class="fc" id="L1604">                    assertEquals(bdSum, BigInteger.valueOf(FastMath.addExact(a, b)));</span>
                }
            }
        }
<span class="fc" id="L1608">    }</span>

    @Test
    public void testAddExactLong() {
<span class="fc" id="L1612">        long[] specialValues = new long[] {</span>
            Long.MIN_VALUE, Long.MIN_VALUE + 1, Long.MIN_VALUE + 2,
            Long.MAX_VALUE, Long.MAX_VALUE - 1, Long.MAX_VALUE - 2,
            -10, -9, -8, -7, -6, -5, -4, -3, -2, -1, 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10,
            -1 - (Long.MIN_VALUE / 2), 0 - (Long.MIN_VALUE / 2), 1 - (Long.MIN_VALUE / 2),
            -1 + (Long.MAX_VALUE / 2), 0 + (Long.MAX_VALUE / 2), 1 + (Long.MAX_VALUE / 2),
        };
<span class="fc bfc" id="L1619" title="All 2 branches covered.">        for (long a : specialValues) {</span>
<span class="fc bfc" id="L1620" title="All 2 branches covered.">            for (long b : specialValues) {</span>
<span class="fc" id="L1621">                BigInteger bdA   = BigInteger.valueOf(a);</span>
<span class="fc" id="L1622">                BigInteger bdB   = BigInteger.valueOf(b);</span>
<span class="fc" id="L1623">                BigInteger bdSum = bdA.add(bdB);</span>
<span class="fc bfc" id="L1624" title="All 2 branches covered.">                if (bdSum.compareTo(BigInteger.valueOf(Long.MIN_VALUE)) &lt; 0 ||</span>
<span class="fc bfc" id="L1625" title="All 2 branches covered.">                        bdSum.compareTo(BigInteger.valueOf(Long.MAX_VALUE)) &gt; 0) {</span>
                    try {
<span class="nc" id="L1627">                        FastMath.addExact(a, b);</span>
<span class="nc" id="L1628">                        fail(&quot;an exception should have been thrown&quot;);</span>
<span class="fc" id="L1629">                    } catch (MathArithmeticException mae) {</span>
                        // expected
<span class="pc" id="L1631">                    }</span>
                } else {
<span class="fc" id="L1633">                    assertEquals(bdSum, BigInteger.valueOf(FastMath.addExact(a, b)));</span>
                }
            }
        }
<span class="fc" id="L1637">    }</span>

    @Test
    public void testSubtractExactInt() {
<span class="fc" id="L1641">        int[] specialValues = new int[] {</span>
            Integer.MIN_VALUE, Integer.MIN_VALUE + 1, Integer.MIN_VALUE + 2,
            Integer.MAX_VALUE, Integer.MAX_VALUE - 1, Integer.MAX_VALUE - 2,
            -10, -9, -8, -7, -6, -5, -4, -3, -2, -1, 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10,
            -1 - (Integer.MIN_VALUE / 2), 0 - (Integer.MIN_VALUE / 2), 1 - (Integer.MIN_VALUE / 2),
            -1 + (Integer.MAX_VALUE / 2), 0 + (Integer.MAX_VALUE / 2), 1 + (Integer.MAX_VALUE / 2),
        };
<span class="fc bfc" id="L1648" title="All 2 branches covered.">        for (int a : specialValues) {</span>
<span class="fc bfc" id="L1649" title="All 2 branches covered.">            for (int b : specialValues) {</span>
<span class="fc" id="L1650">                BigInteger bdA   = BigInteger.valueOf(a);</span>
<span class="fc" id="L1651">                BigInteger bdB   = BigInteger.valueOf(b);</span>
<span class="fc" id="L1652">                BigInteger bdSub = bdA.subtract(bdB);</span>
<span class="fc bfc" id="L1653" title="All 2 branches covered.">                if (bdSub.compareTo(BigInteger.valueOf(Integer.MIN_VALUE)) &lt; 0 ||</span>
<span class="fc bfc" id="L1654" title="All 2 branches covered.">                        bdSub.compareTo(BigInteger.valueOf(Integer.MAX_VALUE)) &gt; 0) {</span>
                    try {
<span class="nc" id="L1656">                        FastMath.subtractExact(a, b);</span>
<span class="nc" id="L1657">                        fail(&quot;an exception should have been thrown&quot;);</span>
<span class="fc" id="L1658">                    } catch (MathArithmeticException mae) {</span>
                        // expected
<span class="pc" id="L1660">                    }</span>
                } else {
<span class="fc" id="L1662">                    assertEquals(bdSub, BigInteger.valueOf(FastMath.subtractExact(a, b)));</span>
                }
            }
        }
<span class="fc" id="L1666">    }</span>

    @Test
    public void testSubtractExactLong() {
<span class="fc" id="L1670">        long[] specialValues = new long[] {</span>
            Long.MIN_VALUE, Long.MIN_VALUE + 1, Long.MIN_VALUE + 2,
            Long.MAX_VALUE, Long.MAX_VALUE - 1, Long.MAX_VALUE - 2,
            -10, -9, -8, -7, -6, -5, -4, -3, -2, -1, 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10,
            -1 - (Long.MIN_VALUE / 2), 0 - (Long.MIN_VALUE / 2), 1 - (Long.MIN_VALUE / 2),
            -1 + (Long.MAX_VALUE / 2), 0 + (Long.MAX_VALUE / 2), 1 + (Long.MAX_VALUE / 2),
        };
<span class="fc bfc" id="L1677" title="All 2 branches covered.">        for (long a : specialValues) {</span>
<span class="fc bfc" id="L1678" title="All 2 branches covered.">            for (long b : specialValues) {</span>
<span class="fc" id="L1679">                BigInteger bdA   = BigInteger.valueOf(a);</span>
<span class="fc" id="L1680">                BigInteger bdB   = BigInteger.valueOf(b);</span>
<span class="fc" id="L1681">                BigInteger bdSub = bdA.subtract(bdB);</span>
<span class="fc bfc" id="L1682" title="All 2 branches covered.">                if (bdSub.compareTo(BigInteger.valueOf(Long.MIN_VALUE)) &lt; 0 ||</span>
<span class="fc bfc" id="L1683" title="All 2 branches covered.">                        bdSub.compareTo(BigInteger.valueOf(Long.MAX_VALUE)) &gt; 0) {</span>
                    try {
<span class="nc" id="L1685">                        FastMath.subtractExact(a, b);</span>
<span class="nc" id="L1686">                        fail(&quot;an exception should have been thrown&quot;);</span>
<span class="fc" id="L1687">                    } catch (MathArithmeticException mae) {</span>
                        // expected
<span class="pc" id="L1689">                    }</span>
                } else {
<span class="fc" id="L1691">                    assertEquals(bdSub, BigInteger.valueOf(FastMath.subtractExact(a, b)));</span>
                }
            }
        }
<span class="fc" id="L1695">    }</span>

    @Test
    public void testMultiplyExactInt() {
<span class="fc" id="L1699">        int[] specialValues = new int[] {</span>
            Integer.MIN_VALUE, Integer.MIN_VALUE + 1, Integer.MIN_VALUE + 2,
            Integer.MAX_VALUE, Integer.MAX_VALUE - 1, Integer.MAX_VALUE - 2,
            -10, -9, -8, -7, -6, -5, -4, -3, -2, -1, 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10,
            -1 - (Integer.MIN_VALUE / 2), 0 - (Integer.MIN_VALUE / 2), 1 - (Integer.MIN_VALUE / 2),
            -1 + (Integer.MAX_VALUE / 2), 0 + (Integer.MAX_VALUE / 2), 1 + (Integer.MAX_VALUE / 2),
        };
<span class="fc bfc" id="L1706" title="All 2 branches covered.">        for (int a : specialValues) {</span>
<span class="fc bfc" id="L1707" title="All 2 branches covered.">            for (int b : specialValues) {</span>
<span class="fc" id="L1708">                BigInteger bdA   = BigInteger.valueOf(a);</span>
<span class="fc" id="L1709">                BigInteger bdB   = BigInteger.valueOf(b);</span>
<span class="fc" id="L1710">                BigInteger bdMul = bdA.multiply(bdB);</span>
<span class="fc bfc" id="L1711" title="All 2 branches covered.">                if (bdMul.compareTo(BigInteger.valueOf(Integer.MIN_VALUE)) &lt; 0 ||</span>
<span class="fc bfc" id="L1712" title="All 2 branches covered.">                    bdMul.compareTo(BigInteger.valueOf(Integer.MAX_VALUE)) &gt; 0) {</span>
                    try {
<span class="nc" id="L1714">                        FastMath.multiplyExact(a, b);</span>
<span class="nc" id="L1715">                        fail(&quot;an exception should have been thrown &quot; + a + b);</span>
<span class="fc" id="L1716">                    } catch (MathArithmeticException mae) {</span>
                        // expected
<span class="pc" id="L1718">                    }</span>
                } else {
<span class="fc" id="L1720">                    assertEquals(bdMul, BigInteger.valueOf(FastMath.multiplyExact(a, b)));</span>
                }
            }
        }
<span class="fc" id="L1724">    }</span>

    @Test
    public void testMultiplyExactLong() {
<span class="fc" id="L1728">        long[] specialValues = new long[] {</span>
            Long.MIN_VALUE, Long.MIN_VALUE + 1, Long.MIN_VALUE + 2,
            Long.MAX_VALUE, Long.MAX_VALUE - 1, Long.MAX_VALUE - 2,
            -10, -9, -8, -7, -6, -5, -4, -3, -2, -1, 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10,
            -1 - (Long.MIN_VALUE / 2), 0 - (Long.MIN_VALUE / 2), 1 - (Long.MIN_VALUE / 2),
            -1 + (Long.MAX_VALUE / 2), 0 + (Long.MAX_VALUE / 2), 1 + (Long.MAX_VALUE / 2),
        };
<span class="fc bfc" id="L1735" title="All 2 branches covered.">        for (long a : specialValues) {</span>
<span class="fc bfc" id="L1736" title="All 2 branches covered.">            for (long b : specialValues) {</span>
<span class="fc" id="L1737">                BigInteger bdA   = BigInteger.valueOf(a);</span>
<span class="fc" id="L1738">                BigInteger bdB   = BigInteger.valueOf(b);</span>
<span class="fc" id="L1739">                BigInteger bdMul = bdA.multiply(bdB);</span>
<span class="fc bfc" id="L1740" title="All 2 branches covered.">                if (bdMul.compareTo(BigInteger.valueOf(Long.MIN_VALUE)) &lt; 0 ||</span>
<span class="fc bfc" id="L1741" title="All 2 branches covered.">                    bdMul.compareTo(BigInteger.valueOf(Long.MAX_VALUE)) &gt; 0) {</span>
                    try {
<span class="nc" id="L1743">                        FastMath.multiplyExact(a, b);</span>
<span class="nc" id="L1744">                        fail(&quot;an exception should have been thrown &quot; + a + b);</span>
<span class="fc" id="L1745">                    } catch (MathArithmeticException mae) {</span>
                        // expected
<span class="pc" id="L1747">                    }</span>
                } else {
<span class="fc" id="L1749">                    assertEquals(bdMul, BigInteger.valueOf(FastMath.multiplyExact(a, b)));</span>
                }
            }
        }
<span class="fc" id="L1753">    }</span>

    @Test(expected=MathArithmeticException.class)
    public void testToIntExactTooLow() {
<span class="nc" id="L1757">        FastMath.toIntExact(-1l + Integer.MIN_VALUE);</span>
<span class="nc" id="L1758">    }</span>

    @Test(expected=MathArithmeticException.class)
    public void testToIntExactTooHigh() {
<span class="nc" id="L1762">        FastMath.toIntExact(+1l + Integer.MAX_VALUE);</span>
<span class="nc" id="L1763">    }</span>

    @Test
    public void testToIntExact() {
<span class="fc bfc" id="L1767" title="All 2 branches covered.">        for (int n = -1000; n &lt; 1000; ++n) {</span>
<span class="fc" id="L1768">            assertEquals(n, FastMath.toIntExact(0l + n));</span>
        }
<span class="fc" id="L1770">        assertEquals(Integer.MIN_VALUE, FastMath.toIntExact(0l + Integer.MIN_VALUE));</span>
<span class="fc" id="L1771">        assertEquals(Integer.MAX_VALUE, FastMath.toIntExact(0l + Integer.MAX_VALUE));</span>
<span class="fc" id="L1772">    }</span>

    @Test
    public void testFloorDivInt() {
<span class="fc" id="L1776">        assertEquals(+1, FastMath.floorDiv(+4, +3));</span>
<span class="fc" id="L1777">        assertEquals(-2, FastMath.floorDiv(-4, +3));</span>
<span class="fc" id="L1778">        assertEquals(-2, FastMath.floorDiv(+4, -3));</span>
<span class="fc" id="L1779">        assertEquals(+1, FastMath.floorDiv(-4, -3));</span>
        try {
<span class="nc" id="L1781">            FastMath.floorDiv(1, 0);</span>
<span class="nc" id="L1782">            fail(&quot;an exception should have been thrown&quot;);</span>
<span class="fc" id="L1783">        } catch (MathArithmeticException mae) {</span>
            // expected
<span class="nc" id="L1785">        }</span>
<span class="fc bfc" id="L1786" title="All 2 branches covered.">        for (int a = -100; a &lt;= 100; ++a) {</span>
<span class="fc bfc" id="L1787" title="All 2 branches covered.">            for (int b = -100; b &lt;= 100; ++b) {</span>
<span class="fc bfc" id="L1788" title="All 2 branches covered.">                if (b != 0) {</span>
<span class="fc" id="L1789">                    assertEquals(poorManFloorDiv(a, b), FastMath.floorDiv(a, b));</span>
                }
            }
        }
<span class="fc" id="L1793">    }</span>

    @Test
    public void testFloorModInt() {
<span class="fc" id="L1797">        assertEquals(+1, FastMath.floorMod(+4, +3));</span>
<span class="fc" id="L1798">        assertEquals(+2, FastMath.floorMod(-4, +3));</span>
<span class="fc" id="L1799">        assertEquals(-2, FastMath.floorMod(+4, -3));</span>
<span class="fc" id="L1800">        assertEquals(-1, FastMath.floorMod(-4, -3));</span>
        try {
<span class="nc" id="L1802">            FastMath.floorMod(1, 0);</span>
<span class="nc" id="L1803">            fail(&quot;an exception should have been thrown&quot;);</span>
<span class="fc" id="L1804">        } catch (MathArithmeticException mae) {</span>
            // expected
<span class="nc" id="L1806">        }</span>
<span class="fc bfc" id="L1807" title="All 2 branches covered.">        for (int a = -100; a &lt;= 100; ++a) {</span>
<span class="fc bfc" id="L1808" title="All 2 branches covered.">            for (int b = -100; b &lt;= 100; ++b) {</span>
<span class="fc bfc" id="L1809" title="All 2 branches covered.">                if (b != 0) {</span>
<span class="fc" id="L1810">                    assertEquals(poorManFloorMod(a, b), FastMath.floorMod(a, b));</span>
                }
            }
        }
<span class="fc" id="L1814">    }</span>

    @Test
    public void testFloorDivModInt() {
<span class="fc" id="L1818">        UniformRandomProvider generator = RandomSource.create(RandomSource.WELL_1024_A,</span>
<span class="fc" id="L1819">                                                              0x7ccab45edeaab90al);</span>
<span class="fc bfc" id="L1820" title="All 2 branches covered.">        for (int i = 0; i &lt; 10000; ++i) {</span>
<span class="fc" id="L1821">            int a = generator.nextInt();</span>
<span class="fc" id="L1822">            int b = generator.nextInt();</span>
<span class="pc bpc" id="L1823" title="1 of 2 branches missed.">            if (b == 0) {</span>
                try {
<span class="nc" id="L1825">                    FastMath.floorDiv(a, b);</span>
<span class="nc" id="L1826">                    fail(&quot;an exception should have been thrown&quot;);</span>
<span class="nc" id="L1827">                } catch (MathArithmeticException mae) {</span>
                    // expected
<span class="nc" id="L1829">                }</span>
            } else {
<span class="fc" id="L1831">                int d = FastMath.floorDiv(a, b);</span>
<span class="fc" id="L1832">                int m = FastMath.floorMod(a, b);</span>
<span class="fc" id="L1833">                assertEquals(FastMath.toIntExact(poorManFloorDiv(a, b)), d);</span>
<span class="fc" id="L1834">                assertEquals(FastMath.toIntExact(poorManFloorMod(a, b)), m);</span>
<span class="fc" id="L1835">                assertEquals(a, d * b + m);</span>
<span class="fc bfc" id="L1836" title="All 2 branches covered.">                if (b &lt; 0) {</span>
<span class="pc bpc" id="L1837" title="1 of 2 branches missed.">                    assertTrue(m &lt;= 0);</span>
<span class="pc bpc" id="L1838" title="1 of 2 branches missed.">                    assertTrue(-m &lt; -b);</span>
                } else {
<span class="pc bpc" id="L1840" title="1 of 2 branches missed.">                    assertTrue(m &gt;= 0);</span>
<span class="pc bpc" id="L1841" title="1 of 2 branches missed.">                    assertTrue(m &lt; b);</span>
                }
            }
        }
<span class="fc" id="L1845">    }</span>

    @Test
    public void testFloorDivLong() {
<span class="fc" id="L1849">        assertEquals(+1l, FastMath.floorDiv(+4l, +3l));</span>
<span class="fc" id="L1850">        assertEquals(-2l, FastMath.floorDiv(-4l, +3l));</span>
<span class="fc" id="L1851">        assertEquals(-2l, FastMath.floorDiv(+4l, -3l));</span>
<span class="fc" id="L1852">        assertEquals(+1l, FastMath.floorDiv(-4l, -3l));</span>
        try {
<span class="nc" id="L1854">            FastMath.floorDiv(1l, 0l);</span>
<span class="nc" id="L1855">            fail(&quot;an exception should have been thrown&quot;);</span>
<span class="fc" id="L1856">        } catch (MathArithmeticException mae) {</span>
            // expected
<span class="nc" id="L1858">        }</span>
<span class="fc bfc" id="L1859" title="All 2 branches covered.">        for (long a = -100l; a &lt;= 100l; ++a) {</span>
<span class="fc bfc" id="L1860" title="All 2 branches covered.">            for (long b = -100l; b &lt;= 100l; ++b) {</span>
<span class="fc bfc" id="L1861" title="All 2 branches covered.">                if (b != 0) {</span>
<span class="fc" id="L1862">                    assertEquals(poorManFloorDiv(a, b), FastMath.floorDiv(a, b));</span>
                }
            }
        }
<span class="fc" id="L1866">    }</span>

    @Test
    public void testFloorModLong() {
<span class="fc" id="L1870">        assertEquals(+1l, FastMath.floorMod(+4l, +3l));</span>
<span class="fc" id="L1871">        assertEquals(+2l, FastMath.floorMod(-4l, +3l));</span>
<span class="fc" id="L1872">        assertEquals(-2l, FastMath.floorMod(+4l, -3l));</span>
<span class="fc" id="L1873">        assertEquals(-1l, FastMath.floorMod(-4l, -3l));</span>
        try {
<span class="nc" id="L1875">            FastMath.floorMod(1l, 0l);</span>
<span class="nc" id="L1876">            fail(&quot;an exception should have been thrown&quot;);</span>
<span class="fc" id="L1877">        } catch (MathArithmeticException mae) {</span>
            // expected
<span class="nc" id="L1879">        }</span>
<span class="fc bfc" id="L1880" title="All 2 branches covered.">        for (long a = -100l; a &lt;= 100l; ++a) {</span>
<span class="fc bfc" id="L1881" title="All 2 branches covered.">            for (long b = -100l; b &lt;= 100l; ++b) {</span>
<span class="fc bfc" id="L1882" title="All 2 branches covered.">                if (b != 0) {</span>
<span class="fc" id="L1883">                    assertEquals(poorManFloorMod(a, b), FastMath.floorMod(a, b));</span>
                }
            }
        }
<span class="fc" id="L1887">    }</span>

    @Test
    public void testFloorDivModLong() {
<span class="fc" id="L1891">        UniformRandomProvider generator = RandomSource.create(RandomSource.WELL_1024_A,</span>
<span class="fc" id="L1892">                                                              0xb87b9bc14c96ccd5l);</span>
<span class="fc bfc" id="L1893" title="All 2 branches covered.">        for (int i = 0; i &lt; 10000; ++i) {</span>
<span class="fc" id="L1894">            long a = generator.nextLong();</span>
<span class="fc" id="L1895">            long b = generator.nextLong();</span>
<span class="pc bpc" id="L1896" title="1 of 2 branches missed.">            if (b == 0) {</span>
                try {
<span class="nc" id="L1898">                    FastMath.floorDiv(a, b);</span>
<span class="nc" id="L1899">                    fail(&quot;an exception should have been thrown&quot;);</span>
<span class="nc" id="L1900">                } catch (MathArithmeticException mae) {</span>
                    // expected
<span class="nc" id="L1902">                }</span>
            } else {
<span class="fc" id="L1904">                long d = FastMath.floorDiv(a, b);</span>
<span class="fc" id="L1905">                long m = FastMath.floorMod(a, b);</span>
<span class="fc" id="L1906">                assertEquals(poorManFloorDiv(a, b), d);</span>
<span class="fc" id="L1907">                assertEquals(poorManFloorMod(a, b), m);</span>
<span class="fc" id="L1908">                assertEquals(a, d * b + m);</span>
<span class="fc bfc" id="L1909" title="All 2 branches covered.">                if (b &lt; 0) {</span>
<span class="pc bpc" id="L1910" title="1 of 2 branches missed.">                    assertTrue(m &lt;= 0);</span>
<span class="pc bpc" id="L1911" title="1 of 2 branches missed.">                    assertTrue(-m &lt; -b);</span>
                } else {
<span class="pc bpc" id="L1913" title="1 of 2 branches missed.">                    assertTrue(m &gt;= 0);</span>
<span class="pc bpc" id="L1914" title="1 of 2 branches missed.">                    assertTrue(m &lt; b);</span>
                }
            }
        }
<span class="fc" id="L1918">    }</span>

    private long poorManFloorDiv(long a, long b) {

        // find q0, r0 such that a = q0 b + r0
<span class="fc" id="L1923">        BigInteger q0 = BigInteger.valueOf(a / b);</span>
<span class="fc" id="L1924">        BigInteger r0 = BigInteger.valueOf(a % b);</span>
<span class="fc" id="L1925">        BigInteger fd = BigInteger.valueOf(Integer.MIN_VALUE);</span>
<span class="fc" id="L1926">        BigInteger bigB = BigInteger.valueOf(b);</span>

<span class="fc bfc" id="L1928" title="All 2 branches covered.">        for (int k = -2; k &lt; 2; ++k) {</span>
            // find another pair q, r such that a = q b + r
<span class="fc" id="L1930">            BigInteger bigK = BigInteger.valueOf(k);</span>
<span class="fc" id="L1931">            BigInteger q = q0.subtract(bigK);</span>
<span class="fc" id="L1932">            BigInteger r = r0.add(bigK.multiply(bigB));</span>
<span class="fc bfc" id="L1933" title="All 2 branches covered.">            if (r.abs().compareTo(bigB.abs()) &lt; 0 &amp;&amp;</span>
<span class="fc bfc" id="L1934" title="All 4 branches covered.">                (r.longValue() == 0l || ((r.longValue() ^ b) &amp; 0x8000000000000000l) == 0)) {</span>
<span class="pc bpc" id="L1935" title="1 of 2 branches missed.">                if (fd.compareTo(q) &lt; 0) {</span>
<span class="fc" id="L1936">                    fd = q;</span>
                }
            }
        }

<span class="fc" id="L1941">        return fd.longValue();</span>

    }

    private long poorManFloorMod(long a, long b) {
<span class="fc" id="L1946">        return a - b * poorManFloorDiv(a, b);</span>
    }

    /**
     * http://bugs.java.com/bugdatabase/view_bug.do?bug_id=6430675
     */
    @Test
    public void testRoundDown() {
<span class="fc" id="L1954">        double x = 0x1.fffffffffffffp-2; // greatest floating point value less than 0.5</span>
<span class="pc bpc" id="L1955" title="1 of 2 branches missed.">        assertTrue(x &lt; 0.5d);</span>
<span class="fc" id="L1956">        assertEquals(0, FastMath.round(x));</span>

<span class="fc" id="L1958">        x = 4503599627370497.0; // x = Math.pow(2, 52) + 1;</span>
<span class="fc" id="L1959">        assertEquals(&quot;4503599627370497&quot;, new BigDecimal(x).toString());</span>
<span class="pc bpc" id="L1960" title="1 of 2 branches missed.">        assertTrue(x == Math.rint(x));</span>
<span class="pc bpc" id="L1961" title="1 of 2 branches missed.">        assertTrue(x == FastMath.round(x));</span>
        //assertTrue(x == Math.round(x)); // fails with Java 7, fixed in Java 8
<span class="fc" id="L1963">    }</span>

}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.1.201803210924</span></div></body></html>