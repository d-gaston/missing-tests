<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>FieldRotationDSTest.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">commons_math4$All_in_commons_math4.exec</a> &gt; <a href="index.source.html" class="el_package">org.apache.commons.math4.geometry.euclidean.threed</a> &gt; <span class="el_source">FieldRotationDSTest.java</span></div><h1>FieldRotationDSTest.java</h1><pre class="source lang-java linenums">/*
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the &quot;License&quot;); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package org.apache.commons.math4.geometry.euclidean.threed;

import org.junit.Assert;
import org.junit.Test;
import org.apache.commons.numbers.angle.PlaneAngleRadians;
import org.apache.commons.rng.UniformRandomProvider;
import org.apache.commons.rng.simple.RandomSource;
import org.apache.commons.rng.sampling.UnitSphereSampler;
import org.apache.commons.math4.analysis.differentiation.DerivativeStructure;
import org.apache.commons.math4.exception.MathArithmeticException;
import org.apache.commons.math4.exception.MathIllegalArgumentException;
import org.apache.commons.math4.geometry.euclidean.threed.CardanEulerSingularityException;
import org.apache.commons.math4.geometry.euclidean.threed.FieldRotation;
import org.apache.commons.math4.geometry.euclidean.threed.FieldVector3D;
import org.apache.commons.math4.geometry.euclidean.threed.NotARotationMatrixException;
import org.apache.commons.math4.geometry.euclidean.threed.Rotation;
import org.apache.commons.math4.geometry.euclidean.threed.RotationOrder;
import org.apache.commons.math4.geometry.euclidean.threed.Cartesian3D;
import org.apache.commons.math4.linear.MatrixUtils;
import org.apache.commons.math4.linear.RealMatrix;
import org.apache.commons.math4.util.FastMath;


<span class="fc" id="L41">public class FieldRotationDSTest {</span>

    @Test
    public void testIdentity() {

<span class="fc" id="L46">        FieldRotation&lt;DerivativeStructure&gt; r = createRotation(1, 0, 0, 0, false);</span>
<span class="fc" id="L47">        checkVector(r.applyTo(createVector(1, 0, 0)), createVector(1, 0, 0));</span>
<span class="fc" id="L48">        checkVector(r.applyTo(createVector(0, 1, 0)), createVector(0, 1, 0));</span>
<span class="fc" id="L49">        checkVector(r.applyTo(createVector(0, 0, 1)), createVector(0, 0, 1));</span>
<span class="fc" id="L50">        checkAngle(r.getAngle(), 0);</span>

<span class="fc" id="L52">        r = createRotation(-1, 0, 0, 0, false);</span>
<span class="fc" id="L53">        checkVector(r.applyTo(createVector(1, 0, 0)), createVector(1, 0, 0));</span>
<span class="fc" id="L54">        checkVector(r.applyTo(createVector(0, 1, 0)), createVector(0, 1, 0));</span>
<span class="fc" id="L55">        checkVector(r.applyTo(createVector(0, 0, 1)), createVector(0, 0, 1));</span>
<span class="fc" id="L56">        checkAngle(r.getAngle(), 0);</span>

<span class="fc" id="L58">        r = createRotation(42, 0, 0, 0, true);</span>
<span class="fc" id="L59">        checkVector(r.applyTo(createVector(1, 0, 0)), createVector(1, 0, 0));</span>
<span class="fc" id="L60">        checkVector(r.applyTo(createVector(0, 1, 0)), createVector(0, 1, 0));</span>
<span class="fc" id="L61">        checkVector(r.applyTo(createVector(0, 0, 1)), createVector(0, 0, 1));</span>
<span class="fc" id="L62">        checkAngle(r.getAngle(), 0);</span>

<span class="fc" id="L64">    }</span>

    @Test
    @Deprecated
    public void testAxisAngleDeprecated() throws MathIllegalArgumentException {

<span class="fc" id="L70">        FieldRotation&lt;DerivativeStructure&gt; r = new FieldRotation&lt;&gt;(createAxis(10, 10, 10), createAngle(2 * FastMath.PI / 3));</span>
<span class="fc" id="L71">        checkVector(r.applyTo(createVector(1, 0, 0)), createVector(0, 1, 0));</span>
<span class="fc" id="L72">        checkVector(r.applyTo(createVector(0, 1, 0)), createVector(0, 0, 1));</span>
<span class="fc" id="L73">        checkVector(r.applyTo(createVector(0, 0, 1)), createVector(1, 0, 0));</span>
<span class="fc" id="L74">        double s = 1 / FastMath.sqrt(3);</span>
<span class="fc" id="L75">        checkVector(r.getAxis(), createVector(s, s, s));</span>
<span class="fc" id="L76">        checkAngle(r.getAngle(), 2 * FastMath.PI / 3);</span>

        try {
<span class="nc" id="L79">            new FieldRotation&lt;&gt;(createAxis(0, 0, 0), createAngle(2 * FastMath.PI / 3));</span>
<span class="nc" id="L80">            Assert.fail(&quot;an exception should have been thrown&quot;);</span>
<span class="fc" id="L81">        } catch (MathIllegalArgumentException e) {</span>
<span class="nc" id="L82">        }</span>

<span class="fc" id="L84">        r = new FieldRotation&lt;&gt;(createAxis(0, 0, 1), createAngle(1.5 * FastMath.PI));</span>
<span class="fc" id="L85">        checkVector(r.getAxis(), createVector(0, 0, -1));</span>
<span class="fc" id="L86">        checkAngle(r.getAngle(), 0.5 * FastMath.PI);</span>

<span class="fc" id="L88">        r = new FieldRotation&lt;&gt;(createAxis(0, 1, 0), createAngle(FastMath.PI));</span>
<span class="fc" id="L89">        checkVector(r.getAxis(), createVector(0, 1, 0));</span>
<span class="fc" id="L90">        checkAngle(r.getAngle(), FastMath.PI);</span>

<span class="fc" id="L92">        checkVector(createRotation(1, 0, 0, 0, false).getAxis(), createVector(1, 0, 0));</span>

<span class="fc" id="L94">    }</span>

    @Test
    public void testAxisAngleVectorOperator() throws MathIllegalArgumentException {

<span class="fc" id="L99">        FieldRotation&lt;DerivativeStructure&gt; r = new FieldRotation&lt;&gt;(createAxis(10, 10, 10),</span>
<span class="fc" id="L100">                                                                                      createAngle(2 * FastMath.PI / 3) ,</span>
                                                                                      RotationConvention.VECTOR_OPERATOR);
<span class="fc" id="L102">        checkVector(r.applyTo(createVector(1, 0, 0)), createVector(0, 1, 0));</span>
<span class="fc" id="L103">        checkVector(r.applyTo(createVector(0, 1, 0)), createVector(0, 0, 1));</span>
<span class="fc" id="L104">        checkVector(r.applyTo(createVector(0, 0, 1)), createVector(1, 0, 0));</span>
<span class="fc" id="L105">        double s = 1 / FastMath.sqrt(3);</span>
<span class="fc" id="L106">        checkVector(r.getAxis(RotationConvention.VECTOR_OPERATOR), createVector( s,  s,  s));</span>
<span class="fc" id="L107">        checkVector(r.getAxis(RotationConvention.FRAME_TRANSFORM), createVector(-s, -s, -s));</span>
<span class="fc" id="L108">        checkAngle(r.getAngle(), 2 * FastMath.PI / 3);</span>

        try {
<span class="fc" id="L111">            new FieldRotation&lt;&gt;(createAxis(0, 0, 0),</span>
<span class="nc" id="L112">                                                   createAngle(2 * FastMath.PI / 3),</span>
                                                   RotationConvention.VECTOR_OPERATOR);
<span class="nc" id="L114">            Assert.fail(&quot;an exception should have been thrown&quot;);</span>
<span class="fc" id="L115">        } catch (MathIllegalArgumentException e) {</span>
<span class="nc" id="L116">        }</span>

<span class="fc" id="L118">        r = new FieldRotation&lt;&gt;(createAxis(0, 0, 1),</span>
<span class="fc" id="L119">                                                   createAngle(1.5 * FastMath.PI),</span>
                                                   RotationConvention.VECTOR_OPERATOR);
<span class="fc" id="L121">        checkVector(r.getAxis(RotationConvention.VECTOR_OPERATOR), createVector(0, 0, -1));</span>
<span class="fc" id="L122">        checkVector(r.getAxis(RotationConvention.FRAME_TRANSFORM), createVector(0, 0, +1));</span>
<span class="fc" id="L123">        checkAngle(r.getAngle(), 0.5 * FastMath.PI);</span>

<span class="fc" id="L125">        r = new FieldRotation&lt;&gt;(createAxis(0, 1, 0),</span>
<span class="fc" id="L126">                                                   createAngle(FastMath.PI),</span>
                                                   RotationConvention.VECTOR_OPERATOR);
<span class="fc" id="L128">        checkVector(r.getAxis(RotationConvention.VECTOR_OPERATOR), createVector(0, +1, 0));</span>
<span class="fc" id="L129">        checkVector(r.getAxis(RotationConvention.FRAME_TRANSFORM), createVector(0, -1, 0));</span>
<span class="fc" id="L130">        checkAngle(r.getAngle(), FastMath.PI);</span>

<span class="fc" id="L132">        checkVector(createRotation(1, 0, 0, 0, false).getAxis(RotationConvention.VECTOR_OPERATOR), createVector(+1, 0, 0));</span>
<span class="fc" id="L133">        checkVector(createRotation(1, 0, 0, 0, false).getAxis(RotationConvention.FRAME_TRANSFORM), createVector(-1, 0, 0));</span>

<span class="fc" id="L135">    }</span>

    @Test
    public void testAxisAngleFrameTransform() throws MathIllegalArgumentException {

<span class="fc" id="L140">        FieldRotation&lt;DerivativeStructure&gt; r = new FieldRotation&lt;&gt;(createAxis(10, 10, 10),</span>
<span class="fc" id="L141">                                                                                      createAngle(2 * FastMath.PI / 3) ,</span>
                                                                                      RotationConvention.FRAME_TRANSFORM);
<span class="fc" id="L143">        checkVector(r.applyTo(createVector(1, 0, 0)), createVector(0, 0, 1));</span>
<span class="fc" id="L144">        checkVector(r.applyTo(createVector(0, 1, 0)), createVector(1, 0, 0));</span>
<span class="fc" id="L145">        checkVector(r.applyTo(createVector(0, 0, 1)), createVector(0, 1, 0));</span>
<span class="fc" id="L146">        double s = 1 / FastMath.sqrt(3);</span>
<span class="fc" id="L147">        checkVector(r.getAxis(RotationConvention.FRAME_TRANSFORM), createVector( s,  s,  s));</span>
<span class="fc" id="L148">        checkVector(r.getAxis(RotationConvention.VECTOR_OPERATOR), createVector(-s, -s, -s));</span>
<span class="fc" id="L149">        checkAngle(r.getAngle(), 2 * FastMath.PI / 3);</span>

        try {
<span class="fc" id="L152">            new FieldRotation&lt;&gt;(createAxis(0, 0, 0),</span>
<span class="nc" id="L153">                                                   createAngle(2 * FastMath.PI / 3),</span>
                                                   RotationConvention.FRAME_TRANSFORM);
<span class="nc" id="L155">            Assert.fail(&quot;an exception should have been thrown&quot;);</span>
<span class="fc" id="L156">        } catch (MathIllegalArgumentException e) {</span>
<span class="nc" id="L157">        }</span>

<span class="fc" id="L159">        r = new FieldRotation&lt;&gt;(createAxis(0, 0, 1),</span>
<span class="fc" id="L160">                                                   createAngle(1.5 * FastMath.PI),</span>
                                                   RotationConvention.FRAME_TRANSFORM);
<span class="fc" id="L162">        checkVector(r.getAxis(RotationConvention.FRAME_TRANSFORM), createVector(0, 0, -1));</span>
<span class="fc" id="L163">        checkVector(r.getAxis(RotationConvention.VECTOR_OPERATOR), createVector(0, 0, +1));</span>
<span class="fc" id="L164">        checkAngle(r.getAngle(), 0.5 * FastMath.PI);</span>

<span class="fc" id="L166">        r = new FieldRotation&lt;&gt;(createAxis(0, 1, 0),</span>
<span class="fc" id="L167">                                                   createAngle(FastMath.PI),</span>
                                                   RotationConvention.FRAME_TRANSFORM);
<span class="fc" id="L169">        checkVector(r.getAxis(RotationConvention.FRAME_TRANSFORM), createVector(0, +1, 0));</span>
<span class="fc" id="L170">        checkVector(r.getAxis(RotationConvention.VECTOR_OPERATOR), createVector(0, -1, 0));</span>
<span class="fc" id="L171">        checkAngle(r.getAngle(), FastMath.PI);</span>

<span class="fc" id="L173">        checkVector(createRotation(1, 0, 0, 0, false).getAxis(RotationConvention.FRAME_TRANSFORM), createVector(-1, 0, 0));</span>
<span class="fc" id="L174">        checkVector(createRotation(1, 0, 0, 0, false).getAxis(RotationConvention.VECTOR_OPERATOR), createVector(+1, 0, 0));</span>

<span class="fc" id="L176">    }</span>

    @Test
    public void testRevert() {
<span class="fc" id="L180">        double a = 0.001;</span>
<span class="fc" id="L181">        double b = 0.36;</span>
<span class="fc" id="L182">        double c = 0.48;</span>
<span class="fc" id="L183">        double d = 0.8;</span>
<span class="fc" id="L184">        FieldRotation&lt;DerivativeStructure&gt; r = createRotation(a, b, c, d, true);</span>
<span class="fc" id="L185">        double a2 = a * a;</span>
<span class="fc" id="L186">        double b2 = b * b;</span>
<span class="fc" id="L187">        double c2 = c * c;</span>
<span class="fc" id="L188">        double d2 = d * d;</span>
<span class="fc" id="L189">        double den = (a2 + b2 + c2 + d2) * FastMath.sqrt(a2 + b2 + c2 + d2);</span>
<span class="fc" id="L190">        Assert.assertEquals((b2 + c2 + d2) / den, r.getQ0().getPartialDerivative(1, 0, 0, 0), 1.0e-15);</span>
<span class="fc" id="L191">        Assert.assertEquals(-a * b / den, r.getQ0().getPartialDerivative(0, 1, 0, 0), 1.0e-15);</span>
<span class="fc" id="L192">        Assert.assertEquals(-a * c / den, r.getQ0().getPartialDerivative(0, 0, 1, 0), 1.0e-15);</span>
<span class="fc" id="L193">        Assert.assertEquals(-a * d / den, r.getQ0().getPartialDerivative(0, 0, 0, 1), 1.0e-15);</span>
<span class="fc" id="L194">        Assert.assertEquals(-b * a / den, r.getQ1().getPartialDerivative(1, 0, 0, 0), 1.0e-15);</span>
<span class="fc" id="L195">        Assert.assertEquals((a2 + c2 + d2) / den, r.getQ1().getPartialDerivative(0, 1, 0, 0), 1.0e-15);</span>
<span class="fc" id="L196">        Assert.assertEquals(-b * c / den, r.getQ1().getPartialDerivative(0, 0, 1, 0), 1.0e-15);</span>
<span class="fc" id="L197">        Assert.assertEquals(-b * d / den, r.getQ1().getPartialDerivative(0, 0, 0, 1), 1.0e-15);</span>
<span class="fc" id="L198">        Assert.assertEquals(-c * a / den, r.getQ2().getPartialDerivative(1, 0, 0, 0), 1.0e-15);</span>
<span class="fc" id="L199">        Assert.assertEquals(-c * b / den, r.getQ2().getPartialDerivative(0, 1, 0, 0), 1.0e-15);</span>
<span class="fc" id="L200">        Assert.assertEquals((a2 + b2 + d2) / den, r.getQ2().getPartialDerivative(0, 0, 1, 0), 1.0e-15);</span>
<span class="fc" id="L201">        Assert.assertEquals(-c * d / den, r.getQ2().getPartialDerivative(0, 0, 0, 1), 1.0e-15);</span>
<span class="fc" id="L202">        Assert.assertEquals(-d * a / den, r.getQ3().getPartialDerivative(1, 0, 0, 0), 1.0e-15);</span>
<span class="fc" id="L203">        Assert.assertEquals(-d * b / den, r.getQ3().getPartialDerivative(0, 1, 0, 0), 1.0e-15);</span>
<span class="fc" id="L204">        Assert.assertEquals(-d * c / den, r.getQ3().getPartialDerivative(0, 0, 1, 0), 1.0e-15);</span>
<span class="fc" id="L205">        Assert.assertEquals((a2 + b2 + c2) / den, r.getQ3().getPartialDerivative(0, 0, 0, 1), 1.0e-15);</span>
<span class="fc" id="L206">        FieldRotation&lt;DerivativeStructure&gt; reverted = r.revert();</span>
<span class="fc" id="L207">        FieldRotation&lt;DerivativeStructure&gt; rrT = r.applyTo(reverted);</span>
<span class="fc" id="L208">        checkRotationDS(rrT, 1, 0, 0, 0);</span>
<span class="fc" id="L209">        Assert.assertEquals(0, rrT.getQ0().getPartialDerivative(1, 0, 0, 0), 1.0e-15);</span>
<span class="fc" id="L210">        Assert.assertEquals(0, rrT.getQ0().getPartialDerivative(0, 1, 0, 0), 1.0e-15);</span>
<span class="fc" id="L211">        Assert.assertEquals(0, rrT.getQ0().getPartialDerivative(0, 0, 1, 0), 1.0e-15);</span>
<span class="fc" id="L212">        Assert.assertEquals(0, rrT.getQ0().getPartialDerivative(0, 0, 0, 1), 1.0e-15);</span>
<span class="fc" id="L213">        Assert.assertEquals(0, rrT.getQ1().getPartialDerivative(1, 0, 0, 0), 1.0e-15);</span>
<span class="fc" id="L214">        Assert.assertEquals(0, rrT.getQ1().getPartialDerivative(0, 1, 0, 0), 1.0e-15);</span>
<span class="fc" id="L215">        Assert.assertEquals(0, rrT.getQ1().getPartialDerivative(0, 0, 1, 0), 1.0e-15);</span>
<span class="fc" id="L216">        Assert.assertEquals(0, rrT.getQ1().getPartialDerivative(0, 0, 0, 1), 1.0e-15);</span>
<span class="fc" id="L217">        Assert.assertEquals(0, rrT.getQ2().getPartialDerivative(1, 0, 0, 0), 1.0e-15);</span>
<span class="fc" id="L218">        Assert.assertEquals(0, rrT.getQ2().getPartialDerivative(0, 1, 0, 0), 1.0e-15);</span>
<span class="fc" id="L219">        Assert.assertEquals(0, rrT.getQ2().getPartialDerivative(0, 0, 1, 0), 1.0e-15);</span>
<span class="fc" id="L220">        Assert.assertEquals(0, rrT.getQ2().getPartialDerivative(0, 0, 0, 1), 1.0e-15);</span>
<span class="fc" id="L221">        Assert.assertEquals(0, rrT.getQ3().getPartialDerivative(1, 0, 0, 0), 1.0e-15);</span>
<span class="fc" id="L222">        Assert.assertEquals(0, rrT.getQ3().getPartialDerivative(0, 1, 0, 0), 1.0e-15);</span>
<span class="fc" id="L223">        Assert.assertEquals(0, rrT.getQ3().getPartialDerivative(0, 0, 1, 0), 1.0e-15);</span>
<span class="fc" id="L224">        Assert.assertEquals(0, rrT.getQ3().getPartialDerivative(0, 0, 0, 1), 1.0e-15);</span>
<span class="fc" id="L225">        FieldRotation&lt;DerivativeStructure&gt; rTr = reverted.applyTo(r);</span>
<span class="fc" id="L226">        checkRotationDS(rTr, 1, 0, 0, 0);</span>
<span class="fc" id="L227">        Assert.assertEquals(0, rTr.getQ0().getPartialDerivative(1, 0, 0, 0), 1.0e-15);</span>
<span class="fc" id="L228">        Assert.assertEquals(0, rTr.getQ0().getPartialDerivative(0, 1, 0, 0), 1.0e-15);</span>
<span class="fc" id="L229">        Assert.assertEquals(0, rTr.getQ0().getPartialDerivative(0, 0, 1, 0), 1.0e-15);</span>
<span class="fc" id="L230">        Assert.assertEquals(0, rTr.getQ0().getPartialDerivative(0, 0, 0, 1), 1.0e-15);</span>
<span class="fc" id="L231">        Assert.assertEquals(0, rTr.getQ1().getPartialDerivative(1, 0, 0, 0), 1.0e-15);</span>
<span class="fc" id="L232">        Assert.assertEquals(0, rTr.getQ1().getPartialDerivative(0, 1, 0, 0), 1.0e-15);</span>
<span class="fc" id="L233">        Assert.assertEquals(0, rTr.getQ1().getPartialDerivative(0, 0, 1, 0), 1.0e-15);</span>
<span class="fc" id="L234">        Assert.assertEquals(0, rTr.getQ1().getPartialDerivative(0, 0, 0, 1), 1.0e-15);</span>
<span class="fc" id="L235">        Assert.assertEquals(0, rTr.getQ2().getPartialDerivative(1, 0, 0, 0), 1.0e-15);</span>
<span class="fc" id="L236">        Assert.assertEquals(0, rTr.getQ2().getPartialDerivative(0, 1, 0, 0), 1.0e-15);</span>
<span class="fc" id="L237">        Assert.assertEquals(0, rTr.getQ2().getPartialDerivative(0, 0, 1, 0), 1.0e-15);</span>
<span class="fc" id="L238">        Assert.assertEquals(0, rTr.getQ2().getPartialDerivative(0, 0, 0, 1), 1.0e-15);</span>
<span class="fc" id="L239">        Assert.assertEquals(0, rTr.getQ3().getPartialDerivative(1, 0, 0, 0), 1.0e-15);</span>
<span class="fc" id="L240">        Assert.assertEquals(0, rTr.getQ3().getPartialDerivative(0, 1, 0, 0), 1.0e-15);</span>
<span class="fc" id="L241">        Assert.assertEquals(0, rTr.getQ3().getPartialDerivative(0, 0, 1, 0), 1.0e-15);</span>
<span class="fc" id="L242">        Assert.assertEquals(0, rTr.getQ3().getPartialDerivative(0, 0, 0, 1), 1.0e-15);</span>
<span class="fc" id="L243">        Assert.assertEquals(r.getAngle().getReal(), reverted.getAngle().getReal(), 1.0e-15);</span>
<span class="fc" id="L244">        Assert.assertEquals(-1,</span>
<span class="fc" id="L245">                            FieldVector3D.dotProduct(r.getAxis(RotationConvention.VECTOR_OPERATOR),</span>
<span class="fc" id="L246">                                                     reverted.getAxis(RotationConvention.VECTOR_OPERATOR)).getReal(),</span>
                            1.0e-15);
<span class="fc" id="L248">    }</span>

    @Test
    public void testRevertVectorOperator() {
<span class="fc" id="L252">        double a = 0.001;</span>
<span class="fc" id="L253">        double b = 0.36;</span>
<span class="fc" id="L254">        double c = 0.48;</span>
<span class="fc" id="L255">        double d = 0.8;</span>
<span class="fc" id="L256">        FieldRotation&lt;DerivativeStructure&gt; r = createRotation(a, b, c, d, true);</span>
<span class="fc" id="L257">        double a2 = a * a;</span>
<span class="fc" id="L258">        double b2 = b * b;</span>
<span class="fc" id="L259">        double c2 = c * c;</span>
<span class="fc" id="L260">        double d2 = d * d;</span>
<span class="fc" id="L261">        double den = (a2 + b2 + c2 + d2) * FastMath.sqrt(a2 + b2 + c2 + d2);</span>
<span class="fc" id="L262">        Assert.assertEquals((b2 + c2 + d2) / den, r.getQ0().getPartialDerivative(1, 0, 0, 0), 1.0e-15);</span>
<span class="fc" id="L263">        Assert.assertEquals(-a * b / den, r.getQ0().getPartialDerivative(0, 1, 0, 0), 1.0e-15);</span>
<span class="fc" id="L264">        Assert.assertEquals(-a * c / den, r.getQ0().getPartialDerivative(0, 0, 1, 0), 1.0e-15);</span>
<span class="fc" id="L265">        Assert.assertEquals(-a * d / den, r.getQ0().getPartialDerivative(0, 0, 0, 1), 1.0e-15);</span>
<span class="fc" id="L266">        Assert.assertEquals(-b * a / den, r.getQ1().getPartialDerivative(1, 0, 0, 0), 1.0e-15);</span>
<span class="fc" id="L267">        Assert.assertEquals((a2 + c2 + d2) / den, r.getQ1().getPartialDerivative(0, 1, 0, 0), 1.0e-15);</span>
<span class="fc" id="L268">        Assert.assertEquals(-b * c / den, r.getQ1().getPartialDerivative(0, 0, 1, 0), 1.0e-15);</span>
<span class="fc" id="L269">        Assert.assertEquals(-b * d / den, r.getQ1().getPartialDerivative(0, 0, 0, 1), 1.0e-15);</span>
<span class="fc" id="L270">        Assert.assertEquals(-c * a / den, r.getQ2().getPartialDerivative(1, 0, 0, 0), 1.0e-15);</span>
<span class="fc" id="L271">        Assert.assertEquals(-c * b / den, r.getQ2().getPartialDerivative(0, 1, 0, 0), 1.0e-15);</span>
<span class="fc" id="L272">        Assert.assertEquals((a2 + b2 + d2) / den, r.getQ2().getPartialDerivative(0, 0, 1, 0), 1.0e-15);</span>
<span class="fc" id="L273">        Assert.assertEquals(-c * d / den, r.getQ2().getPartialDerivative(0, 0, 0, 1), 1.0e-15);</span>
<span class="fc" id="L274">        Assert.assertEquals(-d * a / den, r.getQ3().getPartialDerivative(1, 0, 0, 0), 1.0e-15);</span>
<span class="fc" id="L275">        Assert.assertEquals(-d * b / den, r.getQ3().getPartialDerivative(0, 1, 0, 0), 1.0e-15);</span>
<span class="fc" id="L276">        Assert.assertEquals(-d * c / den, r.getQ3().getPartialDerivative(0, 0, 1, 0), 1.0e-15);</span>
<span class="fc" id="L277">        Assert.assertEquals((a2 + b2 + c2) / den, r.getQ3().getPartialDerivative(0, 0, 0, 1), 1.0e-15);</span>
<span class="fc" id="L278">        FieldRotation&lt;DerivativeStructure&gt; reverted = r.revert();</span>
<span class="fc" id="L279">        FieldRotation&lt;DerivativeStructure&gt; rrT = r.compose(reverted, RotationConvention.VECTOR_OPERATOR);</span>
<span class="fc" id="L280">        checkRotationDS(rrT, 1, 0, 0, 0);</span>
<span class="fc" id="L281">        Assert.assertEquals(0, rrT.getQ0().getPartialDerivative(1, 0, 0, 0), 1.0e-15);</span>
<span class="fc" id="L282">        Assert.assertEquals(0, rrT.getQ0().getPartialDerivative(0, 1, 0, 0), 1.0e-15);</span>
<span class="fc" id="L283">        Assert.assertEquals(0, rrT.getQ0().getPartialDerivative(0, 0, 1, 0), 1.0e-15);</span>
<span class="fc" id="L284">        Assert.assertEquals(0, rrT.getQ0().getPartialDerivative(0, 0, 0, 1), 1.0e-15);</span>
<span class="fc" id="L285">        Assert.assertEquals(0, rrT.getQ1().getPartialDerivative(1, 0, 0, 0), 1.0e-15);</span>
<span class="fc" id="L286">        Assert.assertEquals(0, rrT.getQ1().getPartialDerivative(0, 1, 0, 0), 1.0e-15);</span>
<span class="fc" id="L287">        Assert.assertEquals(0, rrT.getQ1().getPartialDerivative(0, 0, 1, 0), 1.0e-15);</span>
<span class="fc" id="L288">        Assert.assertEquals(0, rrT.getQ1().getPartialDerivative(0, 0, 0, 1), 1.0e-15);</span>
<span class="fc" id="L289">        Assert.assertEquals(0, rrT.getQ2().getPartialDerivative(1, 0, 0, 0), 1.0e-15);</span>
<span class="fc" id="L290">        Assert.assertEquals(0, rrT.getQ2().getPartialDerivative(0, 1, 0, 0), 1.0e-15);</span>
<span class="fc" id="L291">        Assert.assertEquals(0, rrT.getQ2().getPartialDerivative(0, 0, 1, 0), 1.0e-15);</span>
<span class="fc" id="L292">        Assert.assertEquals(0, rrT.getQ2().getPartialDerivative(0, 0, 0, 1), 1.0e-15);</span>
<span class="fc" id="L293">        Assert.assertEquals(0, rrT.getQ3().getPartialDerivative(1, 0, 0, 0), 1.0e-15);</span>
<span class="fc" id="L294">        Assert.assertEquals(0, rrT.getQ3().getPartialDerivative(0, 1, 0, 0), 1.0e-15);</span>
<span class="fc" id="L295">        Assert.assertEquals(0, rrT.getQ3().getPartialDerivative(0, 0, 1, 0), 1.0e-15);</span>
<span class="fc" id="L296">        Assert.assertEquals(0, rrT.getQ3().getPartialDerivative(0, 0, 0, 1), 1.0e-15);</span>
<span class="fc" id="L297">        FieldRotation&lt;DerivativeStructure&gt; rTr = reverted.compose(r, RotationConvention.VECTOR_OPERATOR);</span>
<span class="fc" id="L298">        checkRotationDS(rTr, 1, 0, 0, 0);</span>
<span class="fc" id="L299">        Assert.assertEquals(0, rTr.getQ0().getPartialDerivative(1, 0, 0, 0), 1.0e-15);</span>
<span class="fc" id="L300">        Assert.assertEquals(0, rTr.getQ0().getPartialDerivative(0, 1, 0, 0), 1.0e-15);</span>
<span class="fc" id="L301">        Assert.assertEquals(0, rTr.getQ0().getPartialDerivative(0, 0, 1, 0), 1.0e-15);</span>
<span class="fc" id="L302">        Assert.assertEquals(0, rTr.getQ0().getPartialDerivative(0, 0, 0, 1), 1.0e-15);</span>
<span class="fc" id="L303">        Assert.assertEquals(0, rTr.getQ1().getPartialDerivative(1, 0, 0, 0), 1.0e-15);</span>
<span class="fc" id="L304">        Assert.assertEquals(0, rTr.getQ1().getPartialDerivative(0, 1, 0, 0), 1.0e-15);</span>
<span class="fc" id="L305">        Assert.assertEquals(0, rTr.getQ1().getPartialDerivative(0, 0, 1, 0), 1.0e-15);</span>
<span class="fc" id="L306">        Assert.assertEquals(0, rTr.getQ1().getPartialDerivative(0, 0, 0, 1), 1.0e-15);</span>
<span class="fc" id="L307">        Assert.assertEquals(0, rTr.getQ2().getPartialDerivative(1, 0, 0, 0), 1.0e-15);</span>
<span class="fc" id="L308">        Assert.assertEquals(0, rTr.getQ2().getPartialDerivative(0, 1, 0, 0), 1.0e-15);</span>
<span class="fc" id="L309">        Assert.assertEquals(0, rTr.getQ2().getPartialDerivative(0, 0, 1, 0), 1.0e-15);</span>
<span class="fc" id="L310">        Assert.assertEquals(0, rTr.getQ2().getPartialDerivative(0, 0, 0, 1), 1.0e-15);</span>
<span class="fc" id="L311">        Assert.assertEquals(0, rTr.getQ3().getPartialDerivative(1, 0, 0, 0), 1.0e-15);</span>
<span class="fc" id="L312">        Assert.assertEquals(0, rTr.getQ3().getPartialDerivative(0, 1, 0, 0), 1.0e-15);</span>
<span class="fc" id="L313">        Assert.assertEquals(0, rTr.getQ3().getPartialDerivative(0, 0, 1, 0), 1.0e-15);</span>
<span class="fc" id="L314">        Assert.assertEquals(0, rTr.getQ3().getPartialDerivative(0, 0, 0, 1), 1.0e-15);</span>
<span class="fc" id="L315">        Assert.assertEquals(r.getAngle().getReal(), reverted.getAngle().getReal(), 1.0e-15);</span>
<span class="fc" id="L316">        Assert.assertEquals(-1,</span>
<span class="fc" id="L317">                            FieldVector3D.dotProduct(r.getAxis(RotationConvention.VECTOR_OPERATOR),</span>
<span class="fc" id="L318">                                                     reverted.getAxis(RotationConvention.VECTOR_OPERATOR)).getReal(),</span>
                            1.0e-15);
<span class="fc" id="L320">    }</span>

    @Test
    public void testRevertFrameTransform() {
<span class="fc" id="L324">        double a = 0.001;</span>
<span class="fc" id="L325">        double b = 0.36;</span>
<span class="fc" id="L326">        double c = 0.48;</span>
<span class="fc" id="L327">        double d = 0.8;</span>
<span class="fc" id="L328">        FieldRotation&lt;DerivativeStructure&gt; r = createRotation(a, b, c, d, true);</span>
<span class="fc" id="L329">        double a2 = a * a;</span>
<span class="fc" id="L330">        double b2 = b * b;</span>
<span class="fc" id="L331">        double c2 = c * c;</span>
<span class="fc" id="L332">        double d2 = d * d;</span>
<span class="fc" id="L333">        double den = (a2 + b2 + c2 + d2) * FastMath.sqrt(a2 + b2 + c2 + d2);</span>
<span class="fc" id="L334">        Assert.assertEquals((b2 + c2 + d2) / den, r.getQ0().getPartialDerivative(1, 0, 0, 0), 1.0e-15);</span>
<span class="fc" id="L335">        Assert.assertEquals(-a * b / den, r.getQ0().getPartialDerivative(0, 1, 0, 0), 1.0e-15);</span>
<span class="fc" id="L336">        Assert.assertEquals(-a * c / den, r.getQ0().getPartialDerivative(0, 0, 1, 0), 1.0e-15);</span>
<span class="fc" id="L337">        Assert.assertEquals(-a * d / den, r.getQ0().getPartialDerivative(0, 0, 0, 1), 1.0e-15);</span>
<span class="fc" id="L338">        Assert.assertEquals(-b * a / den, r.getQ1().getPartialDerivative(1, 0, 0, 0), 1.0e-15);</span>
<span class="fc" id="L339">        Assert.assertEquals((a2 + c2 + d2) / den, r.getQ1().getPartialDerivative(0, 1, 0, 0), 1.0e-15);</span>
<span class="fc" id="L340">        Assert.assertEquals(-b * c / den, r.getQ1().getPartialDerivative(0, 0, 1, 0), 1.0e-15);</span>
<span class="fc" id="L341">        Assert.assertEquals(-b * d / den, r.getQ1().getPartialDerivative(0, 0, 0, 1), 1.0e-15);</span>
<span class="fc" id="L342">        Assert.assertEquals(-c * a / den, r.getQ2().getPartialDerivative(1, 0, 0, 0), 1.0e-15);</span>
<span class="fc" id="L343">        Assert.assertEquals(-c * b / den, r.getQ2().getPartialDerivative(0, 1, 0, 0), 1.0e-15);</span>
<span class="fc" id="L344">        Assert.assertEquals((a2 + b2 + d2) / den, r.getQ2().getPartialDerivative(0, 0, 1, 0), 1.0e-15);</span>
<span class="fc" id="L345">        Assert.assertEquals(-c * d / den, r.getQ2().getPartialDerivative(0, 0, 0, 1), 1.0e-15);</span>
<span class="fc" id="L346">        Assert.assertEquals(-d * a / den, r.getQ3().getPartialDerivative(1, 0, 0, 0), 1.0e-15);</span>
<span class="fc" id="L347">        Assert.assertEquals(-d * b / den, r.getQ3().getPartialDerivative(0, 1, 0, 0), 1.0e-15);</span>
<span class="fc" id="L348">        Assert.assertEquals(-d * c / den, r.getQ3().getPartialDerivative(0, 0, 1, 0), 1.0e-15);</span>
<span class="fc" id="L349">        Assert.assertEquals((a2 + b2 + c2) / den, r.getQ3().getPartialDerivative(0, 0, 0, 1), 1.0e-15);</span>
<span class="fc" id="L350">        FieldRotation&lt;DerivativeStructure&gt; reverted = r.revert();</span>
<span class="fc" id="L351">        FieldRotation&lt;DerivativeStructure&gt; rrT = r.compose(reverted, RotationConvention.FRAME_TRANSFORM);</span>
<span class="fc" id="L352">        checkRotationDS(rrT, 1, 0, 0, 0);</span>
<span class="fc" id="L353">        Assert.assertEquals(0, rrT.getQ0().getPartialDerivative(1, 0, 0, 0), 1.0e-15);</span>
<span class="fc" id="L354">        Assert.assertEquals(0, rrT.getQ0().getPartialDerivative(0, 1, 0, 0), 1.0e-15);</span>
<span class="fc" id="L355">        Assert.assertEquals(0, rrT.getQ0().getPartialDerivative(0, 0, 1, 0), 1.0e-15);</span>
<span class="fc" id="L356">        Assert.assertEquals(0, rrT.getQ0().getPartialDerivative(0, 0, 0, 1), 1.0e-15);</span>
<span class="fc" id="L357">        Assert.assertEquals(0, rrT.getQ1().getPartialDerivative(1, 0, 0, 0), 1.0e-15);</span>
<span class="fc" id="L358">        Assert.assertEquals(0, rrT.getQ1().getPartialDerivative(0, 1, 0, 0), 1.0e-15);</span>
<span class="fc" id="L359">        Assert.assertEquals(0, rrT.getQ1().getPartialDerivative(0, 0, 1, 0), 1.0e-15);</span>
<span class="fc" id="L360">        Assert.assertEquals(0, rrT.getQ1().getPartialDerivative(0, 0, 0, 1), 1.0e-15);</span>
<span class="fc" id="L361">        Assert.assertEquals(0, rrT.getQ2().getPartialDerivative(1, 0, 0, 0), 1.0e-15);</span>
<span class="fc" id="L362">        Assert.assertEquals(0, rrT.getQ2().getPartialDerivative(0, 1, 0, 0), 1.0e-15);</span>
<span class="fc" id="L363">        Assert.assertEquals(0, rrT.getQ2().getPartialDerivative(0, 0, 1, 0), 1.0e-15);</span>
<span class="fc" id="L364">        Assert.assertEquals(0, rrT.getQ2().getPartialDerivative(0, 0, 0, 1), 1.0e-15);</span>
<span class="fc" id="L365">        Assert.assertEquals(0, rrT.getQ3().getPartialDerivative(1, 0, 0, 0), 1.0e-15);</span>
<span class="fc" id="L366">        Assert.assertEquals(0, rrT.getQ3().getPartialDerivative(0, 1, 0, 0), 1.0e-15);</span>
<span class="fc" id="L367">        Assert.assertEquals(0, rrT.getQ3().getPartialDerivative(0, 0, 1, 0), 1.0e-15);</span>
<span class="fc" id="L368">        Assert.assertEquals(0, rrT.getQ3().getPartialDerivative(0, 0, 0, 1), 1.0e-15);</span>
<span class="fc" id="L369">        FieldRotation&lt;DerivativeStructure&gt; rTr = reverted.compose(r, RotationConvention.FRAME_TRANSFORM);</span>
<span class="fc" id="L370">        checkRotationDS(rTr, 1, 0, 0, 0);</span>
<span class="fc" id="L371">        Assert.assertEquals(0, rTr.getQ0().getPartialDerivative(1, 0, 0, 0), 1.0e-15);</span>
<span class="fc" id="L372">        Assert.assertEquals(0, rTr.getQ0().getPartialDerivative(0, 1, 0, 0), 1.0e-15);</span>
<span class="fc" id="L373">        Assert.assertEquals(0, rTr.getQ0().getPartialDerivative(0, 0, 1, 0), 1.0e-15);</span>
<span class="fc" id="L374">        Assert.assertEquals(0, rTr.getQ0().getPartialDerivative(0, 0, 0, 1), 1.0e-15);</span>
<span class="fc" id="L375">        Assert.assertEquals(0, rTr.getQ1().getPartialDerivative(1, 0, 0, 0), 1.0e-15);</span>
<span class="fc" id="L376">        Assert.assertEquals(0, rTr.getQ1().getPartialDerivative(0, 1, 0, 0), 1.0e-15);</span>
<span class="fc" id="L377">        Assert.assertEquals(0, rTr.getQ1().getPartialDerivative(0, 0, 1, 0), 1.0e-15);</span>
<span class="fc" id="L378">        Assert.assertEquals(0, rTr.getQ1().getPartialDerivative(0, 0, 0, 1), 1.0e-15);</span>
<span class="fc" id="L379">        Assert.assertEquals(0, rTr.getQ2().getPartialDerivative(1, 0, 0, 0), 1.0e-15);</span>
<span class="fc" id="L380">        Assert.assertEquals(0, rTr.getQ2().getPartialDerivative(0, 1, 0, 0), 1.0e-15);</span>
<span class="fc" id="L381">        Assert.assertEquals(0, rTr.getQ2().getPartialDerivative(0, 0, 1, 0), 1.0e-15);</span>
<span class="fc" id="L382">        Assert.assertEquals(0, rTr.getQ2().getPartialDerivative(0, 0, 0, 1), 1.0e-15);</span>
<span class="fc" id="L383">        Assert.assertEquals(0, rTr.getQ3().getPartialDerivative(1, 0, 0, 0), 1.0e-15);</span>
<span class="fc" id="L384">        Assert.assertEquals(0, rTr.getQ3().getPartialDerivative(0, 1, 0, 0), 1.0e-15);</span>
<span class="fc" id="L385">        Assert.assertEquals(0, rTr.getQ3().getPartialDerivative(0, 0, 1, 0), 1.0e-15);</span>
<span class="fc" id="L386">        Assert.assertEquals(0, rTr.getQ3().getPartialDerivative(0, 0, 0, 1), 1.0e-15);</span>
<span class="fc" id="L387">        Assert.assertEquals(r.getAngle().getReal(), reverted.getAngle().getReal(), 1.0e-15);</span>
<span class="fc" id="L388">        Assert.assertEquals(-1,</span>
<span class="fc" id="L389">                            FieldVector3D.dotProduct(r.getAxis(RotationConvention.FRAME_TRANSFORM),</span>
<span class="fc" id="L390">                                                     reverted.getAxis(RotationConvention.FRAME_TRANSFORM)).getReal(),</span>
                            1.0e-15);
<span class="fc" id="L392">    }</span>

    @Test
    public void testVectorOnePair() throws MathArithmeticException {

<span class="fc" id="L397">        FieldVector3D&lt;DerivativeStructure&gt; u = createVector(3, 2, 1);</span>
<span class="fc" id="L398">        FieldVector3D&lt;DerivativeStructure&gt; v = createVector(-4, 2, 2);</span>
<span class="fc" id="L399">        FieldRotation&lt;DerivativeStructure&gt; r = new FieldRotation&lt;&gt;(u, v);</span>
<span class="fc" id="L400">        checkVector(r.applyTo(u.scalarMultiply(v.getNorm())), v.scalarMultiply(u.getNorm()));</span>

<span class="fc" id="L402">        checkAngle(new FieldRotation&lt;&gt;(u, u.negate()).getAngle(), FastMath.PI);</span>

        try {
<span class="nc" id="L405">            new FieldRotation&lt;&gt;(u, createVector(0, 0, 0));</span>
<span class="nc" id="L406">            Assert.fail(&quot;an exception should have been thrown&quot;);</span>
<span class="fc" id="L407">        } catch (MathArithmeticException e) {</span>
            // expected behavior
<span class="nc" id="L409">        }</span>

<span class="fc" id="L411">    }</span>

    @Test
    public void testVectorTwoPairs() throws MathArithmeticException {

<span class="fc" id="L416">        FieldVector3D&lt;DerivativeStructure&gt; u1 = createVector(3, 0, 0);</span>
<span class="fc" id="L417">        FieldVector3D&lt;DerivativeStructure&gt; u2 = createVector(0, 5, 0);</span>
<span class="fc" id="L418">        FieldVector3D&lt;DerivativeStructure&gt; v1 = createVector(0, 0, 2);</span>
<span class="fc" id="L419">        FieldVector3D&lt;DerivativeStructure&gt; v2 = createVector(-2, 0, 2);</span>
<span class="fc" id="L420">        FieldRotation&lt;DerivativeStructure&gt; r = new FieldRotation&lt;&gt;(u1, u2, v1, v2);</span>
<span class="fc" id="L421">        checkVector(r.applyTo(createVector(1, 0, 0)), createVector(0, 0, 1));</span>
<span class="fc" id="L422">        checkVector(r.applyTo(createVector(0, 1, 0)), createVector(-1, 0, 0));</span>

<span class="fc" id="L424">        r = new FieldRotation&lt;&gt;(u1, u2, u1.negate(), u2.negate());</span>
<span class="fc" id="L425">        FieldVector3D&lt;DerivativeStructure&gt; axis = r.getAxis(RotationConvention.VECTOR_OPERATOR);</span>
<span class="pc bpc" id="L426" title="1 of 2 branches missed.">        if (FieldVector3D.dotProduct(axis, createVector(0, 0, 1)).getReal() &gt; 0) {</span>
<span class="nc" id="L427">            checkVector(axis, createVector(0, 0, 1));</span>
        } else {
<span class="fc" id="L429">            checkVector(axis, createVector(0, 0, -1));</span>
        }
<span class="fc" id="L431">        checkAngle(r.getAngle(), FastMath.PI);</span>

<span class="fc" id="L433">        double sqrt = FastMath.sqrt(2) / 2;</span>
<span class="fc" id="L434">        r = new FieldRotation&lt;&gt;(createVector(1, 0, 0),  createVector(0, 1, 0),</span>
<span class="fc" id="L435">                           createVector(0.5, 0.5,  sqrt),</span>
<span class="fc" id="L436">                           createVector(0.5, 0.5, -sqrt));</span>
<span class="fc" id="L437">        checkRotationDS(r, sqrt, 0.5, 0.5, 0);</span>

<span class="fc" id="L439">        r = new FieldRotation&lt;&gt;(u1, u2, u1, FieldVector3D.crossProduct(u1, u2));</span>
<span class="fc" id="L440">        checkRotationDS(r, sqrt, -sqrt, 0, 0);</span>

<span class="fc" id="L442">        checkRotationDS(new FieldRotation&lt;&gt;(u1, u2, u1, u2), 1, 0, 0, 0);</span>

        try {
<span class="nc" id="L445">            new FieldRotation&lt;&gt;(u1, u2, createVector(0, 0, 0), v2);</span>
<span class="nc" id="L446">            Assert.fail(&quot;an exception should have been thrown&quot;);</span>
<span class="fc" id="L447">        } catch (MathArithmeticException e) {</span>
            // expected behavior
<span class="nc" id="L449">        }</span>

<span class="fc" id="L451">    }</span>

    @Test
    public void testMatrix()
            throws NotARotationMatrixException {

        try {
<span class="nc" id="L458">            createRotation(new double[][] {</span>
                { 0.0, 1.0, 0.0 },
                { 1.0, 0.0, 0.0 }
            }, 1.0e-7);
<span class="nc" id="L462">            Assert.fail(&quot;Expecting NotARotationMatrixException&quot;);</span>
<span class="fc" id="L463">        } catch (NotARotationMatrixException nrme) {</span>
            // expected behavior
<span class="nc" id="L465">        }</span>

        try {
<span class="nc" id="L468">            createRotation(new double[][] {</span>
                {  0.445888,  0.797184, -0.407040 },
                {  0.821760, -0.184320,  0.539200 },
                { -0.354816,  0.574912,  0.737280 }
            }, 1.0e-7);
<span class="nc" id="L473">            Assert.fail(&quot;Expecting NotARotationMatrixException&quot;);</span>
<span class="fc" id="L474">        } catch (NotARotationMatrixException nrme) {</span>
            // expected behavior
<span class="nc" id="L476">        }</span>

        try {
<span class="nc" id="L479">            createRotation(new double[][] {</span>
                {  0.4,  0.8, -0.4 },
                { -0.4,  0.6,  0.7 },
                {  0.8, -0.2,  0.5 }
            }, 1.0e-15);
<span class="nc" id="L484">            Assert.fail(&quot;Expecting NotARotationMatrixException&quot;);</span>
<span class="fc" id="L485">        } catch (NotARotationMatrixException nrme) {</span>
            // expected behavior
<span class="nc" id="L487">        }</span>

<span class="fc" id="L489">        checkRotationDS(createRotation(new double[][] {</span>
            {  0.445888,  0.797184, -0.407040 },
            { -0.354816,  0.574912,  0.737280 },
            {  0.821760, -0.184320,  0.539200 }
        }, 1.0e-10),
        0.8, 0.288, 0.384, 0.36);

<span class="fc" id="L496">        checkRotationDS(createRotation(new double[][] {</span>
            {  0.539200,  0.737280,  0.407040 },
            {  0.184320, -0.574912,  0.797184 },
            {  0.821760, -0.354816, -0.445888 }
        }, 1.0e-10),
        0.36, 0.8, 0.288, 0.384);

<span class="fc" id="L503">        checkRotationDS(createRotation(new double[][] {</span>
            { -0.445888,  0.797184, -0.407040 },
            {  0.354816,  0.574912,  0.737280 },
            {  0.821760,  0.184320, -0.539200 }
        }, 1.0e-10),
        0.384, 0.36, 0.8, 0.288);

<span class="fc" id="L510">        checkRotationDS(createRotation(new double[][] {</span>
            { -0.539200,  0.737280,  0.407040 },
            { -0.184320, -0.574912,  0.797184 },
            {  0.821760,  0.354816,  0.445888 }
        }, 1.0e-10),
        0.288, 0.384, 0.36, 0.8);

<span class="fc" id="L517">        double[][] m1 = { { 0.0, 1.0, 0.0 },</span>
            { 0.0, 0.0, 1.0 },
            { 1.0, 0.0, 0.0 } };
<span class="fc" id="L520">        FieldRotation&lt;DerivativeStructure&gt; r = createRotation(m1, 1.0e-7);</span>
<span class="fc" id="L521">        checkVector(r.applyTo(createVector(1, 0, 0)), createVector(0, 0, 1));</span>
<span class="fc" id="L522">        checkVector(r.applyTo(createVector(0, 1, 0)), createVector(1, 0, 0));</span>
<span class="fc" id="L523">        checkVector(r.applyTo(createVector(0, 0, 1)), createVector(0, 1, 0));</span>

<span class="fc" id="L525">        double[][] m2 = { { 0.83203, -0.55012, -0.07139 },</span>
            { 0.48293,  0.78164, -0.39474 },
            { 0.27296,  0.29396,  0.91602 } };
<span class="fc" id="L528">        r = createRotation(m2, 1.0e-12);</span>

<span class="fc" id="L530">        DerivativeStructure[][] m3 = r.getMatrix();</span>
<span class="fc" id="L531">        double d00 = m2[0][0] - m3[0][0].getReal();</span>
<span class="fc" id="L532">        double d01 = m2[0][1] - m3[0][1].getReal();</span>
<span class="fc" id="L533">        double d02 = m2[0][2] - m3[0][2].getReal();</span>
<span class="fc" id="L534">        double d10 = m2[1][0] - m3[1][0].getReal();</span>
<span class="fc" id="L535">        double d11 = m2[1][1] - m3[1][1].getReal();</span>
<span class="fc" id="L536">        double d12 = m2[1][2] - m3[1][2].getReal();</span>
<span class="fc" id="L537">        double d20 = m2[2][0] - m3[2][0].getReal();</span>
<span class="fc" id="L538">        double d21 = m2[2][1] - m3[2][1].getReal();</span>
<span class="fc" id="L539">        double d22 = m2[2][2] - m3[2][2].getReal();</span>

<span class="pc bpc" id="L541" title="1 of 2 branches missed.">        Assert.assertTrue(FastMath.abs(d00) &lt; 6.0e-6);</span>
<span class="pc bpc" id="L542" title="1 of 2 branches missed.">        Assert.assertTrue(FastMath.abs(d01) &lt; 6.0e-6);</span>
<span class="pc bpc" id="L543" title="1 of 2 branches missed.">        Assert.assertTrue(FastMath.abs(d02) &lt; 6.0e-6);</span>
<span class="pc bpc" id="L544" title="1 of 2 branches missed.">        Assert.assertTrue(FastMath.abs(d10) &lt; 6.0e-6);</span>
<span class="pc bpc" id="L545" title="1 of 2 branches missed.">        Assert.assertTrue(FastMath.abs(d11) &lt; 6.0e-6);</span>
<span class="pc bpc" id="L546" title="1 of 2 branches missed.">        Assert.assertTrue(FastMath.abs(d12) &lt; 6.0e-6);</span>
<span class="pc bpc" id="L547" title="1 of 2 branches missed.">        Assert.assertTrue(FastMath.abs(d20) &lt; 6.0e-6);</span>
<span class="pc bpc" id="L548" title="1 of 2 branches missed.">        Assert.assertTrue(FastMath.abs(d21) &lt; 6.0e-6);</span>
<span class="pc bpc" id="L549" title="1 of 2 branches missed.">        Assert.assertTrue(FastMath.abs(d22) &lt; 6.0e-6);</span>

<span class="pc bpc" id="L551" title="1 of 2 branches missed.">        Assert.assertTrue(FastMath.abs(d00) &gt; 4.0e-7);</span>
<span class="pc bpc" id="L552" title="1 of 2 branches missed.">        Assert.assertTrue(FastMath.abs(d01) &gt; 4.0e-7);</span>
<span class="pc bpc" id="L553" title="1 of 2 branches missed.">        Assert.assertTrue(FastMath.abs(d02) &gt; 4.0e-7);</span>
<span class="pc bpc" id="L554" title="1 of 2 branches missed.">        Assert.assertTrue(FastMath.abs(d10) &gt; 4.0e-7);</span>
<span class="pc bpc" id="L555" title="1 of 2 branches missed.">        Assert.assertTrue(FastMath.abs(d11) &gt; 4.0e-7);</span>
<span class="pc bpc" id="L556" title="1 of 2 branches missed.">        Assert.assertTrue(FastMath.abs(d12) &gt; 4.0e-7);</span>
<span class="pc bpc" id="L557" title="1 of 2 branches missed.">        Assert.assertTrue(FastMath.abs(d20) &gt; 4.0e-7);</span>
<span class="pc bpc" id="L558" title="1 of 2 branches missed.">        Assert.assertTrue(FastMath.abs(d21) &gt; 4.0e-7);</span>
<span class="pc bpc" id="L559" title="1 of 2 branches missed.">        Assert.assertTrue(FastMath.abs(d22) &gt; 4.0e-7);</span>

<span class="fc bfc" id="L561" title="All 2 branches covered.">        for (int i = 0; i &lt; 3; ++i) {</span>
<span class="fc bfc" id="L562" title="All 2 branches covered.">            for (int j = 0; j &lt; 3; ++j) {</span>
<span class="fc" id="L563">                double m3tm3 = m3[i][0].getReal() * m3[j][0].getReal() +</span>
<span class="fc" id="L564">                               m3[i][1].getReal() * m3[j][1].getReal() +</span>
<span class="fc" id="L565">                               m3[i][2].getReal() * m3[j][2].getReal();</span>
<span class="fc bfc" id="L566" title="All 2 branches covered.">                if (i == j) {</span>
<span class="pc bpc" id="L567" title="1 of 2 branches missed.">                    Assert.assertTrue(FastMath.abs(m3tm3 - 1.0) &lt; 1.0e-10);</span>
                } else {
<span class="pc bpc" id="L569" title="1 of 2 branches missed.">                    Assert.assertTrue(FastMath.abs(m3tm3) &lt; 1.0e-10);</span>
                }
            }
        }

<span class="fc" id="L574">        checkVector(r.applyTo(createVector(1, 0, 0)),</span>
                    new FieldVector3D&lt;&gt;(m3[0][0], m3[1][0], m3[2][0]));
<span class="fc" id="L576">        checkVector(r.applyTo(createVector(0, 1, 0)),</span>
                    new FieldVector3D&lt;&gt;(m3[0][1], m3[1][1], m3[2][1]));
<span class="fc" id="L578">        checkVector(r.applyTo(createVector(0, 0, 1)),</span>
                    new FieldVector3D&lt;&gt;(m3[0][2], m3[1][2], m3[2][2]));

<span class="fc" id="L581">        double[][] m4 = { { 1.0,  0.0,  0.0 },</span>
            { 0.0, -1.0,  0.0 },
            { 0.0,  0.0, -1.0 } };
<span class="fc" id="L584">        r = createRotation(m4, 1.0e-7);</span>
<span class="fc" id="L585">        checkAngle(r.getAngle(), FastMath.PI);</span>

        try {
<span class="fc" id="L588">            double[][] m5 = { { 0.0, 0.0, 1.0 },</span>
                { 0.0, 1.0, 0.0 },
                { 1.0, 0.0, 0.0 } };
<span class="nc" id="L591">            r = createRotation(m5, 1.0e-7);</span>
<span class="nc" id="L592">            Assert.fail(&quot;got &quot; + r + &quot;, should have caught an exception&quot;);</span>
<span class="fc" id="L593">        } catch (NotARotationMatrixException e) {</span>
            // expected
<span class="nc" id="L595">        }</span>

<span class="fc" id="L597">    }</span>

    @Test
    @Deprecated
    public void testAnglesDeprecated()
            throws CardanEulerSingularityException {

<span class="fc" id="L604">        RotationOrder[] CardanOrders = {</span>
            RotationOrder.XYZ, RotationOrder.XZY, RotationOrder.YXZ,
            RotationOrder.YZX, RotationOrder.ZXY, RotationOrder.ZYX
        };

<span class="fc bfc" id="L609" title="All 2 branches covered.">        for (int i = 0; i &lt; CardanOrders.length; ++i) {</span>
<span class="fc bfc" id="L610" title="All 2 branches covered.">            for (double alpha1 = 0.1; alpha1 &lt; 6.2; alpha1 += 0.3) {</span>
<span class="fc bfc" id="L611" title="All 2 branches covered.">                for (double alpha2 = -1.55; alpha2 &lt; 1.55; alpha2 += 0.3) {</span>
<span class="fc bfc" id="L612" title="All 2 branches covered.">                    for (double alpha3 = 0.1; alpha3 &lt; 6.2; alpha3 += 0.3) {</span>
<span class="fc" id="L613">                        FieldRotation&lt;DerivativeStructure&gt; r = new FieldRotation&lt;&gt;(CardanOrders[i],</span>
                                                      new DerivativeStructure(3, 1, 0, alpha1),
                                                      new DerivativeStructure(3, 1, 1, alpha2),
                                                      new DerivativeStructure(3, 1, 2, alpha3));
<span class="fc" id="L617">                        DerivativeStructure[] angles = r.getAngles(CardanOrders[i]);</span>
<span class="fc" id="L618">                        checkAngle(angles[0], alpha1);</span>
<span class="fc" id="L619">                        checkAngle(angles[1], alpha2);</span>
<span class="fc" id="L620">                        checkAngle(angles[2], alpha3);</span>
                    }
                }
            }
        }

<span class="fc" id="L626">        RotationOrder[] EulerOrders = {</span>
            RotationOrder.XYX, RotationOrder.XZX, RotationOrder.YXY,
            RotationOrder.YZY, RotationOrder.ZXZ, RotationOrder.ZYZ
        };

<span class="fc bfc" id="L631" title="All 2 branches covered.">        for (int i = 0; i &lt; EulerOrders.length; ++i) {</span>
<span class="fc bfc" id="L632" title="All 2 branches covered.">            for (double alpha1 = 0.1; alpha1 &lt; 6.2; alpha1 += 0.3) {</span>
<span class="fc bfc" id="L633" title="All 2 branches covered.">                for (double alpha2 = 0.05; alpha2 &lt; 3.1; alpha2 += 0.3) {</span>
<span class="fc bfc" id="L634" title="All 2 branches covered.">                    for (double alpha3 = 0.1; alpha3 &lt; 6.2; alpha3 += 0.3) {</span>
<span class="fc" id="L635">                        FieldRotation&lt;DerivativeStructure&gt; r = new FieldRotation&lt;&gt;(EulerOrders[i],</span>
                                                      new DerivativeStructure(3, 1, 0, alpha1),
                                                      new DerivativeStructure(3, 1, 1, alpha2),
                                                      new DerivativeStructure(3, 1, 2, alpha3));
<span class="fc" id="L639">                        DerivativeStructure[] angles = r.getAngles(EulerOrders[i]);</span>
<span class="fc" id="L640">                        checkAngle(angles[0], alpha1);</span>
<span class="fc" id="L641">                        checkAngle(angles[1], alpha2);</span>
<span class="fc" id="L642">                        checkAngle(angles[2], alpha3);</span>
                    }
                }
            }
        }

<span class="fc" id="L648">    }</span>

    @Test
    public void testAngles()
        throws CardanEulerSingularityException {

<span class="fc bfc" id="L654" title="All 2 branches covered.">        for (RotationConvention convention : RotationConvention.values()) {</span>
<span class="fc" id="L655">            RotationOrder[] CardanOrders = {</span>
                RotationOrder.XYZ, RotationOrder.XZY, RotationOrder.YXZ,
                RotationOrder.YZX, RotationOrder.ZXY, RotationOrder.ZYX
            };

<span class="fc bfc" id="L660" title="All 2 branches covered.">            for (int i = 0; i &lt; CardanOrders.length; ++i) {</span>
<span class="fc bfc" id="L661" title="All 2 branches covered.">                for (double alpha1 = 0.1; alpha1 &lt; 6.2; alpha1 += 0.3) {</span>
<span class="fc bfc" id="L662" title="All 2 branches covered.">                    for (double alpha2 = -1.55; alpha2 &lt; 1.55; alpha2 += 0.3) {</span>
<span class="fc bfc" id="L663" title="All 2 branches covered.">                        for (double alpha3 = 0.1; alpha3 &lt; 6.2; alpha3 += 0.3) {</span>
<span class="fc" id="L664">                            FieldRotation&lt;DerivativeStructure&gt; r =</span>
                                            new FieldRotation&lt;&gt;(CardanOrders[i],
                                                                                   convention,
                                                                                   new DerivativeStructure(3, 1, 0, alpha1),
                                                                                   new DerivativeStructure(3, 1, 1, alpha2),
                                                                                   new DerivativeStructure(3, 1, 2, alpha3));
<span class="fc" id="L670">                            DerivativeStructure[] angles = r.getAngles(CardanOrders[i], convention);</span>
<span class="fc" id="L671">                            checkAngle(angles[0], alpha1);</span>
<span class="fc" id="L672">                            checkAngle(angles[1], alpha2);</span>
<span class="fc" id="L673">                            checkAngle(angles[2], alpha3);</span>
                        }
                    }
                }
            }

<span class="fc" id="L679">            RotationOrder[] EulerOrders = {</span>
                RotationOrder.XYX, RotationOrder.XZX, RotationOrder.YXY,
                RotationOrder.YZY, RotationOrder.ZXZ, RotationOrder.ZYZ
            };

<span class="fc bfc" id="L684" title="All 2 branches covered.">            for (int i = 0; i &lt; EulerOrders.length; ++i) {</span>
<span class="fc bfc" id="L685" title="All 2 branches covered.">                for (double alpha1 = 0.1; alpha1 &lt; 6.2; alpha1 += 0.3) {</span>
<span class="fc bfc" id="L686" title="All 2 branches covered.">                    for (double alpha2 = 0.05; alpha2 &lt; 3.1; alpha2 += 0.3) {</span>
<span class="fc bfc" id="L687" title="All 2 branches covered.">                        for (double alpha3 = 0.1; alpha3 &lt; 6.2; alpha3 += 0.3) {</span>
<span class="fc" id="L688">                            FieldRotation&lt;DerivativeStructure&gt; r =</span>
                                            new FieldRotation&lt;&gt;(EulerOrders[i],
                                                                                   convention,
                                                                                   new DerivativeStructure(3, 1, 0, alpha1),
                                                                                   new DerivativeStructure(3, 1, 1, alpha2),
                                                                                   new DerivativeStructure(3, 1, 2, alpha3));
<span class="fc" id="L694">                            DerivativeStructure[] angles = r.getAngles(EulerOrders[i], convention);</span>
<span class="fc" id="L695">                            checkAngle(angles[0], alpha1);</span>
<span class="fc" id="L696">                            checkAngle(angles[1], alpha2);</span>
<span class="fc" id="L697">                            checkAngle(angles[2], alpha3);</span>
                        }
                    }
                }
            }
        }

<span class="fc" id="L704">    }</span>

    @Test
    public void testSingularities() {

<span class="fc bfc" id="L709" title="All 2 branches covered.">        for (RotationConvention convention : RotationConvention.values()) {</span>
<span class="fc" id="L710">            RotationOrder[] CardanOrders = {</span>
                RotationOrder.XYZ, RotationOrder.XZY, RotationOrder.YXZ,
                RotationOrder.YZX, RotationOrder.ZXY, RotationOrder.ZYX
            };

<span class="fc" id="L715">            double[] singularCardanAngle = { FastMath.PI / 2, -FastMath.PI / 2 };</span>
<span class="fc bfc" id="L716" title="All 2 branches covered.">            for (int i = 0; i &lt; CardanOrders.length; ++i) {</span>
<span class="fc bfc" id="L717" title="All 2 branches covered.">                for (int j = 0; j &lt; singularCardanAngle.length; ++j) {</span>
<span class="fc" id="L718">                    FieldRotation&lt;DerivativeStructure&gt; r =</span>
                                    new FieldRotation&lt;&gt;(CardanOrders[i],
                                                                           convention,
                                                                           new DerivativeStructure(3, 1, 0, 0.1),
                                                                           new DerivativeStructure(3, 1, 1, singularCardanAngle[j]),
                                                                           new DerivativeStructure(3, 1, 2, 0.3));
                    try {
<span class="nc" id="L725">                        r.getAngles(CardanOrders[i], convention);</span>
<span class="nc" id="L726">                        Assert.fail(&quot;an exception should have been caught&quot;);</span>
<span class="fc" id="L727">                    } catch (CardanEulerSingularityException cese) {</span>
                        // expected behavior
<span class="nc" id="L729">                    }</span>
                }
            }

<span class="fc" id="L733">            RotationOrder[] EulerOrders = {</span>
                RotationOrder.XYX, RotationOrder.XZX, RotationOrder.YXY,
                RotationOrder.YZY, RotationOrder.ZXZ, RotationOrder.ZYZ
            };

<span class="fc" id="L738">            double[] singularEulerAngle = { 0, FastMath.PI };</span>
<span class="fc bfc" id="L739" title="All 2 branches covered.">            for (int i = 0; i &lt; EulerOrders.length; ++i) {</span>
<span class="fc bfc" id="L740" title="All 2 branches covered.">                for (int j = 0; j &lt; singularEulerAngle.length; ++j) {</span>
<span class="fc" id="L741">                    FieldRotation&lt;DerivativeStructure&gt; r =</span>
                                    new FieldRotation&lt;&gt;(EulerOrders[i],
                                                                           convention,
                                                                           new DerivativeStructure(3, 1, 0, 0.1),
                                                                           new DerivativeStructure(3, 1, 1, singularEulerAngle[j]),
                                                                           new DerivativeStructure(3, 1, 2, 0.3));
                    try {
<span class="nc" id="L748">                        r.getAngles(EulerOrders[i], convention);</span>
<span class="nc" id="L749">                        Assert.fail(&quot;an exception should have been caught&quot;);</span>
<span class="fc" id="L750">                    } catch (CardanEulerSingularityException cese) {</span>
                        // expected behavior
<span class="nc" id="L752">                    }</span>
                }
            }

        }
<span class="fc" id="L757">    }</span>

    @Test
    public void testQuaternion() throws MathIllegalArgumentException {

<span class="fc" id="L762">        FieldRotation&lt;DerivativeStructure&gt; r1 = new FieldRotation&lt;&gt;(createVector(2, -3, 5),</span>
<span class="fc" id="L763">                                                                                       createAngle(1.7),</span>
                                                                                       RotationConvention.VECTOR_OPERATOR);
<span class="fc" id="L765">        double n = 23.5;</span>
<span class="fc" id="L766">        FieldRotation&lt;DerivativeStructure&gt; r2 = new FieldRotation&lt;&gt;(r1.getQ0().multiply(n), r1.getQ1().multiply(n),</span>
<span class="fc" id="L767">                                       r1.getQ2().multiply(n), r1.getQ3().multiply(n),</span>
                                       true);
<span class="fc bfc" id="L769" title="All 2 branches covered.">        for (double x = -0.9; x &lt; 0.9; x += 0.2) {</span>
<span class="fc bfc" id="L770" title="All 2 branches covered.">            for (double y = -0.9; y &lt; 0.9; y += 0.2) {</span>
<span class="fc bfc" id="L771" title="All 2 branches covered.">                for (double z = -0.9; z &lt; 0.9; z += 0.2) {</span>
<span class="fc" id="L772">                    FieldVector3D&lt;DerivativeStructure&gt; u = createVector(x, y, z);</span>
<span class="fc" id="L773">                    checkVector(r2.applyTo(u), r1.applyTo(u));</span>
                }
            }
        }

<span class="fc" id="L778">        r1 = createRotation(0.288,  0.384,  0.36,  0.8, false);</span>
<span class="fc" id="L779">        checkRotationDS(r1,</span>
<span class="fc" id="L780">                        -r1.getQ0().getReal(), -r1.getQ1().getReal(),</span>
<span class="fc" id="L781">                        -r1.getQ2().getReal(), -r1.getQ3().getReal());</span>
<span class="fc" id="L782">        Assert.assertEquals(0.288, r1.toRotation().getQ0(), 1.0e-15);</span>
<span class="fc" id="L783">        Assert.assertEquals(0.384, r1.toRotation().getQ1(), 1.0e-15);</span>
<span class="fc" id="L784">        Assert.assertEquals(0.36,  r1.toRotation().getQ2(), 1.0e-15);</span>
<span class="fc" id="L785">        Assert.assertEquals(0.8,   r1.toRotation().getQ3(), 1.0e-15);</span>

<span class="fc" id="L787">    }</span>

    @Test
    public void testApplyToRotation() throws MathIllegalArgumentException {

<span class="fc" id="L792">        FieldRotation&lt;DerivativeStructure&gt; r1       = new FieldRotation&lt;&gt;(createVector(2, -3, 5),</span>
<span class="fc" id="L793">                                                                                             createAngle(1.7),</span>
                                                                                             RotationConvention.VECTOR_OPERATOR);
<span class="fc" id="L795">        FieldRotation&lt;DerivativeStructure&gt; r2       = new FieldRotation&lt;&gt;(createVector(-1, 3, 2),</span>
<span class="fc" id="L796">                                                                                             createAngle(0.3),</span>
                                                                                             RotationConvention.VECTOR_OPERATOR);
<span class="fc" id="L798">        FieldRotation&lt;DerivativeStructure&gt; r3       = r2.applyTo(r1);</span>
<span class="fc" id="L799">        FieldRotation&lt;DerivativeStructure&gt; r3Double = r2.applyTo(new Rotation(r1.getQ0().getReal(),</span>
<span class="fc" id="L800">                                                                              r1.getQ1().getReal(),</span>
<span class="fc" id="L801">                                                                              r1.getQ2().getReal(),</span>
<span class="fc" id="L802">                                                                              r1.getQ3().getReal(),</span>
                                                                              false));

<span class="fc bfc" id="L805" title="All 2 branches covered.">        for (double x = -0.9; x &lt; 0.9; x += 0.2) {</span>
<span class="fc bfc" id="L806" title="All 2 branches covered.">            for (double y = -0.9; y &lt; 0.9; y += 0.2) {</span>
<span class="fc bfc" id="L807" title="All 2 branches covered.">                for (double z = -0.9; z &lt; 0.9; z += 0.2) {</span>
<span class="fc" id="L808">                    FieldVector3D&lt;DerivativeStructure&gt; u = createVector(x, y, z);</span>
<span class="fc" id="L809">                    checkVector(r2.applyTo(r1.applyTo(u)), r3.applyTo(u));</span>
<span class="fc" id="L810">                    checkVector(r2.applyTo(r1.applyTo(u)), r3Double.applyTo(u));</span>
                }
            }
        }

<span class="fc" id="L815">    }</span>

    @Test
    public void testComposeVectorOperator() throws MathIllegalArgumentException {

<span class="fc" id="L820">        FieldRotation&lt;DerivativeStructure&gt; r1       = new FieldRotation&lt;&gt;(createVector(2, -3, 5),</span>
<span class="fc" id="L821">                                                                                             createAngle(1.7),</span>
                                                                                             RotationConvention.VECTOR_OPERATOR);
<span class="fc" id="L823">        FieldRotation&lt;DerivativeStructure&gt; r2       = new FieldRotation&lt;&gt;(createVector(-1, 3, 2),</span>
<span class="fc" id="L824">                                                                                             createAngle(0.3),</span>
                                                                                             RotationConvention.VECTOR_OPERATOR);
<span class="fc" id="L826">        FieldRotation&lt;DerivativeStructure&gt; r3       = r2.compose(r1, RotationConvention.VECTOR_OPERATOR);</span>
<span class="fc" id="L827">        FieldRotation&lt;DerivativeStructure&gt; r3Double = r2.compose(new Rotation(r1.getQ0().getReal(),</span>
<span class="fc" id="L828">                                                                              r1.getQ1().getReal(),</span>
<span class="fc" id="L829">                                                                              r1.getQ2().getReal(),</span>
<span class="fc" id="L830">                                                                              r1.getQ3().getReal(),</span>
                                                                              false),
                                                                 RotationConvention.VECTOR_OPERATOR);

<span class="fc bfc" id="L834" title="All 2 branches covered.">        for (double x = -0.9; x &lt; 0.9; x += 0.2) {</span>
<span class="fc bfc" id="L835" title="All 2 branches covered.">            for (double y = -0.9; y &lt; 0.9; y += 0.2) {</span>
<span class="fc bfc" id="L836" title="All 2 branches covered.">                for (double z = -0.9; z &lt; 0.9; z += 0.2) {</span>
<span class="fc" id="L837">                    FieldVector3D&lt;DerivativeStructure&gt; u = createVector(x, y, z);</span>
<span class="fc" id="L838">                    checkVector(r2.applyTo(r1.applyTo(u)), r3.applyTo(u));</span>
<span class="fc" id="L839">                    checkVector(r2.applyTo(r1.applyTo(u)), r3Double.applyTo(u));</span>
                }
            }
        }

<span class="fc" id="L844">    }</span>

    @Test
    public void testComposeFrameTransform() throws MathIllegalArgumentException {

<span class="fc" id="L849">        FieldRotation&lt;DerivativeStructure&gt; r1       = new FieldRotation&lt;&gt;(createVector(2, -3, 5),</span>
<span class="fc" id="L850">                                                                                             createAngle(1.7),</span>
                                                                                             RotationConvention.FRAME_TRANSFORM);
<span class="fc" id="L852">        FieldRotation&lt;DerivativeStructure&gt; r2       = new FieldRotation&lt;&gt;(createVector(-1, 3, 2),</span>
<span class="fc" id="L853">                                                                                             createAngle(0.3),</span>
                                                                                             RotationConvention.FRAME_TRANSFORM);
<span class="fc" id="L855">        FieldRotation&lt;DerivativeStructure&gt; r3       = r2.compose(r1, RotationConvention.FRAME_TRANSFORM);</span>
<span class="fc" id="L856">        FieldRotation&lt;DerivativeStructure&gt; r3Double = r2.compose(new Rotation(r1.getQ0().getReal(),</span>
<span class="fc" id="L857">                                                                              r1.getQ1().getReal(),</span>
<span class="fc" id="L858">                                                                              r1.getQ2().getReal(),</span>
<span class="fc" id="L859">                                                                              r1.getQ3().getReal(),</span>
                                                                              false),
                                                                 RotationConvention.FRAME_TRANSFORM);

<span class="fc bfc" id="L863" title="All 2 branches covered.">        for (double x = -0.9; x &lt; 0.9; x += 0.2) {</span>
<span class="fc bfc" id="L864" title="All 2 branches covered.">            for (double y = -0.9; y &lt; 0.9; y += 0.2) {</span>
<span class="fc bfc" id="L865" title="All 2 branches covered.">                for (double z = -0.9; z &lt; 0.9; z += 0.2) {</span>
<span class="fc" id="L866">                    FieldVector3D&lt;DerivativeStructure&gt; u = createVector(x, y, z);</span>
<span class="fc" id="L867">                    checkVector(r1.applyTo(r2.applyTo(u)), r3.applyTo(u));</span>
<span class="fc" id="L868">                    checkVector(r1.applyTo(r2.applyTo(u)), r3Double.applyTo(u));</span>
                }
            }
        }

<span class="fc" id="L873">    }</span>

    @Test
    public void testApplyInverseToRotation() throws MathIllegalArgumentException {

<span class="fc" id="L878">        FieldRotation&lt;DerivativeStructure&gt; r1 = new FieldRotation&lt;&gt;(createVector(2, -3, 5),</span>
<span class="fc" id="L879">                                                                                       createAngle(1.7),</span>
                                                                                       RotationConvention.VECTOR_OPERATOR);
<span class="fc" id="L881">        FieldRotation&lt;DerivativeStructure&gt; r2 = new FieldRotation&lt;&gt;(createVector(-1, 3, 2),</span>
<span class="fc" id="L882">                                                                                       createAngle(0.3),</span>
                                                                                       RotationConvention.VECTOR_OPERATOR);
<span class="fc" id="L884">        FieldRotation&lt;DerivativeStructure&gt; r3 = r2.applyInverseTo(r1);</span>
<span class="fc" id="L885">        FieldRotation&lt;DerivativeStructure&gt; r3Double = r2.applyInverseTo(new Rotation(r1.getQ0().getReal(),</span>
<span class="fc" id="L886">                                                                                     r1.getQ1().getReal(),</span>
<span class="fc" id="L887">                                                                                     r1.getQ2().getReal(),</span>
<span class="fc" id="L888">                                                                                     r1.getQ3().getReal(),</span>
                                                                                    false));

<span class="fc bfc" id="L891" title="All 2 branches covered.">        for (double x = -0.9; x &lt; 0.9; x += 0.2) {</span>
<span class="fc bfc" id="L892" title="All 2 branches covered.">            for (double y = -0.9; y &lt; 0.9; y += 0.2) {</span>
<span class="fc bfc" id="L893" title="All 2 branches covered.">                for (double z = -0.9; z &lt; 0.9; z += 0.2) {</span>
<span class="fc" id="L894">                    FieldVector3D&lt;DerivativeStructure&gt; u = createVector(x, y, z);</span>
<span class="fc" id="L895">                    checkVector(r2.applyInverseTo(r1.applyTo(u)), r3.applyTo(u));</span>
<span class="fc" id="L896">                    checkVector(r2.applyInverseTo(r1.applyTo(u)), r3Double.applyTo(u));</span>
                }
            }
        }

<span class="fc" id="L901">    }</span>

    @Test
    public void testComposeInverseVectorOperator() throws MathIllegalArgumentException {

<span class="fc" id="L906">        FieldRotation&lt;DerivativeStructure&gt; r1 = new FieldRotation&lt;&gt;(createVector(2, -3, 5),</span>
<span class="fc" id="L907">                                                                                       createAngle(1.7),</span>
                                                                                       RotationConvention.VECTOR_OPERATOR);
<span class="fc" id="L909">        FieldRotation&lt;DerivativeStructure&gt; r2 = new FieldRotation&lt;&gt;(createVector(-1, 3, 2),</span>
<span class="fc" id="L910">                                                                                       createAngle(0.3),</span>
                                                                                       RotationConvention.VECTOR_OPERATOR);
<span class="fc" id="L912">        FieldRotation&lt;DerivativeStructure&gt; r3 = r2.composeInverse(r1, RotationConvention.VECTOR_OPERATOR);</span>
<span class="fc" id="L913">        FieldRotation&lt;DerivativeStructure&gt; r3Double = r2.composeInverse(new Rotation(r1.getQ0().getReal(),</span>
<span class="fc" id="L914">                                                                                     r1.getQ1().getReal(),</span>
<span class="fc" id="L915">                                                                                     r1.getQ2().getReal(),</span>
<span class="fc" id="L916">                                                                                     r1.getQ3().getReal(),</span>
                                                                                     false),
                                                                        RotationConvention.VECTOR_OPERATOR);

<span class="fc bfc" id="L920" title="All 2 branches covered.">        for (double x = -0.9; x &lt; 0.9; x += 0.2) {</span>
<span class="fc bfc" id="L921" title="All 2 branches covered.">            for (double y = -0.9; y &lt; 0.9; y += 0.2) {</span>
<span class="fc bfc" id="L922" title="All 2 branches covered.">                for (double z = -0.9; z &lt; 0.9; z += 0.2) {</span>
<span class="fc" id="L923">                    FieldVector3D&lt;DerivativeStructure&gt; u = createVector(x, y, z);</span>
<span class="fc" id="L924">                    checkVector(r2.applyInverseTo(r1.applyTo(u)), r3.applyTo(u));</span>
<span class="fc" id="L925">                    checkVector(r2.applyInverseTo(r1.applyTo(u)), r3Double.applyTo(u));</span>
                }
            }
        }

<span class="fc" id="L930">    }</span>

    @Test
    public void testComposeInverseframeTransform() throws MathIllegalArgumentException {

<span class="fc" id="L935">        FieldRotation&lt;DerivativeStructure&gt; r1 = new FieldRotation&lt;&gt;(createVector(2, -3, 5),</span>
<span class="fc" id="L936">                                                                                       createAngle(1.7),</span>
                                                                                       RotationConvention.FRAME_TRANSFORM);
<span class="fc" id="L938">        FieldRotation&lt;DerivativeStructure&gt; r2 = new FieldRotation&lt;&gt;(createVector(-1, 3, 2),</span>
<span class="fc" id="L939">                                                                                       createAngle(0.3),</span>
                                                                                       RotationConvention.FRAME_TRANSFORM);
<span class="fc" id="L941">        FieldRotation&lt;DerivativeStructure&gt; r3 = r2.composeInverse(r1, RotationConvention.FRAME_TRANSFORM);</span>
<span class="fc" id="L942">        FieldRotation&lt;DerivativeStructure&gt; r3Double = r2.composeInverse(new Rotation(r1.getQ0().getReal(),</span>
<span class="fc" id="L943">                                                                                     r1.getQ1().getReal(),</span>
<span class="fc" id="L944">                                                                                     r1.getQ2().getReal(),</span>
<span class="fc" id="L945">                                                                                     r1.getQ3().getReal(),</span>
                                                                                     false),
                                                                        RotationConvention.FRAME_TRANSFORM);

<span class="fc bfc" id="L949" title="All 2 branches covered.">        for (double x = -0.9; x &lt; 0.9; x += 0.2) {</span>
<span class="fc bfc" id="L950" title="All 2 branches covered.">            for (double y = -0.9; y &lt; 0.9; y += 0.2) {</span>
<span class="fc bfc" id="L951" title="All 2 branches covered.">                for (double z = -0.9; z &lt; 0.9; z += 0.2) {</span>
<span class="fc" id="L952">                    FieldVector3D&lt;DerivativeStructure&gt; u = createVector(x, y, z);</span>
<span class="fc" id="L953">                    checkVector(r1.applyTo(r2.applyInverseTo(u)), r3.applyTo(u));</span>
<span class="fc" id="L954">                    checkVector(r1.applyTo(r2.applyInverseTo(u)), r3Double.applyTo(u));</span>
                }
            }
        }

<span class="fc" id="L959">    }</span>

    @Test
    public void testDoubleVectors() throws MathIllegalArgumentException {
<span class="fc" id="L963">        UniformRandomProvider random = RandomSource.create(RandomSource.WELL_1024_A,</span>
<span class="fc" id="L964">                                                           0x180b41cfeeffaf67l);</span>
<span class="fc" id="L965">        UnitSphereSampler g = new UnitSphereSampler(3, random);</span>
<span class="fc bfc" id="L966" title="All 2 branches covered.">        for (int i = 0; i &lt; 10; ++i) {</span>
<span class="fc" id="L967">            double[] unit = g.nextVector();</span>
<span class="fc" id="L968">            FieldRotation&lt;DerivativeStructure&gt; r = new FieldRotation&lt;&gt;(createVector(unit[0], unit[1], unit[2]),</span>
<span class="fc" id="L969">                                                                                          createAngle(random.nextDouble()),</span>
                                                                                          RotationConvention.VECTOR_OPERATOR);

<span class="fc bfc" id="L972" title="All 2 branches covered.">            for (double x = -0.9; x &lt; 0.9; x += 0.2) {</span>
<span class="fc bfc" id="L973" title="All 2 branches covered.">                for (double y = -0.9; y &lt; 0.9; y += 0.2) {</span>
<span class="fc bfc" id="L974" title="All 2 branches covered.">                    for (double z = -0.9; z &lt; 0.9; z += 0.2) {</span>
<span class="fc" id="L975">                        FieldVector3D&lt;DerivativeStructure&gt; uds   = createVector(x, y, z);</span>
<span class="fc" id="L976">                        FieldVector3D&lt;DerivativeStructure&gt; ruds  = r.applyTo(uds);</span>
<span class="fc" id="L977">                        FieldVector3D&lt;DerivativeStructure&gt; rIuds = r.applyInverseTo(uds);</span>
<span class="fc" id="L978">                        Cartesian3D   u     = new Cartesian3D(x, y, z);</span>
<span class="fc" id="L979">                        FieldVector3D&lt;DerivativeStructure&gt; ru    = r.applyTo(u);</span>
<span class="fc" id="L980">                        FieldVector3D&lt;DerivativeStructure&gt; rIu   = r.applyInverseTo(u);</span>
<span class="fc" id="L981">                        DerivativeStructure[] ruArray = new DerivativeStructure[3];</span>
<span class="fc" id="L982">                        r.applyTo(new double[] { x, y, z}, ruArray);</span>
<span class="fc" id="L983">                        DerivativeStructure[] rIuArray = new DerivativeStructure[3];</span>
<span class="fc" id="L984">                        r.applyInverseTo(new double[] { x, y, z}, rIuArray);</span>
<span class="fc" id="L985">                        checkVector(ruds, ru);</span>
<span class="fc" id="L986">                        checkVector(ruds, new FieldVector3D&lt;&gt;(ruArray));</span>
<span class="fc" id="L987">                        checkVector(rIuds, rIu);</span>
<span class="fc" id="L988">                        checkVector(rIuds, new FieldVector3D&lt;&gt;(rIuArray));</span>
                    }
                }
            }
        }

<span class="fc" id="L994">    }</span>

    @Test
    public void testDoubleRotations() throws MathIllegalArgumentException {
<span class="fc" id="L998">        UniformRandomProvider random = RandomSource.create(RandomSource.WELL_1024_A,</span>
<span class="fc" id="L999">                                                           0x180b41cfeeffaf67l);</span>
<span class="fc" id="L1000">        UnitSphereSampler g = new UnitSphereSampler(3, random);</span>
<span class="fc bfc" id="L1001" title="All 2 branches covered.">        for (int i = 0; i &lt; 10; ++i) {</span>
<span class="fc" id="L1002">            double[] unit1 = g.nextVector();</span>
<span class="fc" id="L1003">            Rotation r1 = new Rotation(new Cartesian3D(unit1[0], unit1[1], unit1[2]),</span>
<span class="fc" id="L1004">                                      random.nextDouble(), RotationConvention.VECTOR_OPERATOR);</span>
<span class="fc" id="L1005">            FieldRotation&lt;DerivativeStructure&gt; r1Prime = new FieldRotation&lt;&gt;(new DerivativeStructure(4, 1, 0, r1.getQ0()),</span>
<span class="fc" id="L1006">                                                new DerivativeStructure(4, 1, 1, r1.getQ1()),</span>
<span class="fc" id="L1007">                                                new DerivativeStructure(4, 1, 2, r1.getQ2()),</span>
<span class="fc" id="L1008">                                                new DerivativeStructure(4, 1, 3, r1.getQ3()),</span>
                                                false);
<span class="fc" id="L1010">            double[] unit2 = g.nextVector();</span>
<span class="fc" id="L1011">            FieldRotation&lt;DerivativeStructure&gt; r2 = new FieldRotation&lt;&gt;(createVector(unit2[0], unit2[1], unit2[2]),</span>
<span class="fc" id="L1012">                                                                                           createAngle(random.nextDouble()),</span>
                                                                                           RotationConvention.VECTOR_OPERATOR);

<span class="fc" id="L1015">            FieldRotation&lt;DerivativeStructure&gt; rA = FieldRotation.applyTo(r1, r2);</span>
<span class="fc" id="L1016">            FieldRotation&lt;DerivativeStructure&gt; rB = r1Prime.compose(r2, RotationConvention.VECTOR_OPERATOR);</span>
<span class="fc" id="L1017">            FieldRotation&lt;DerivativeStructure&gt; rC = FieldRotation.applyInverseTo(r1, r2);</span>
<span class="fc" id="L1018">            FieldRotation&lt;DerivativeStructure&gt; rD = r1Prime.composeInverse(r2, RotationConvention.VECTOR_OPERATOR);</span>

<span class="fc bfc" id="L1020" title="All 2 branches covered.">            for (double x = -0.9; x &lt; 0.9; x += 0.2) {</span>
<span class="fc bfc" id="L1021" title="All 2 branches covered.">                for (double y = -0.9; y &lt; 0.9; y += 0.2) {</span>
<span class="fc bfc" id="L1022" title="All 2 branches covered.">                    for (double z = -0.9; z &lt; 0.9; z += 0.2) {</span>

<span class="fc" id="L1024">                        FieldVector3D&lt;DerivativeStructure&gt; uds   = createVector(x, y, z);</span>
<span class="fc" id="L1025">                        checkVector(r1Prime.applyTo(uds), FieldRotation.applyTo(r1, uds));</span>
<span class="fc" id="L1026">                        checkVector(r1Prime.applyInverseTo(uds), FieldRotation.applyInverseTo(r1, uds));</span>
<span class="fc" id="L1027">                        checkVector(rA.applyTo(uds), rB.applyTo(uds));</span>
<span class="fc" id="L1028">                        checkVector(rA.applyInverseTo(uds), rB.applyInverseTo(uds));</span>
<span class="fc" id="L1029">                        checkVector(rC.applyTo(uds), rD.applyTo(uds));</span>
<span class="fc" id="L1030">                        checkVector(rC.applyInverseTo(uds), rD.applyInverseTo(uds));</span>

                    }
                }
            }
        }

<span class="fc" id="L1037">    }</span>

    @Test
    public void testDerivatives() {

<span class="fc" id="L1042">        double eps      = 5.0e-16;</span>
<span class="fc" id="L1043">        double kx       = 2;</span>
<span class="fc" id="L1044">        double ky       = -3;</span>
<span class="fc" id="L1045">        double kz       = 5;</span>
<span class="fc" id="L1046">        double n2       = kx * kx + ky * ky + kz * kz;</span>
<span class="fc" id="L1047">        double n        = FastMath.sqrt(n2);</span>
<span class="fc" id="L1048">        double theta    = 1.7;</span>
<span class="fc" id="L1049">        double cosTheta = FastMath.cos(theta);</span>
<span class="fc" id="L1050">        double sinTheta = FastMath.sin(theta);</span>
<span class="fc" id="L1051">        FieldRotation&lt;DerivativeStructure&gt; r    = new FieldRotation&lt;&gt;(createAxis(kx, ky, kz),</span>
<span class="fc" id="L1052">                                                                                         createAngle(theta),</span>
                                                                                         RotationConvention.VECTOR_OPERATOR);
<span class="fc" id="L1054">        Cartesian3D a      = new Cartesian3D(kx / n, ky / n, kz / n);</span>

        // Jacobian of the normalized rotation axis a with respect to the Cartesian vector k
<span class="fc" id="L1057">        RealMatrix dadk = MatrixUtils.createRealMatrix(new double[][] {</span>
            { (ky * ky + kz * kz) / ( n * n2),            -kx * ky / ( n * n2),            -kx * kz / ( n * n2) },
            {            -kx * ky / ( n * n2), (kx * kx + kz * kz) / ( n * n2),            -ky * kz / ( n * n2) },
            {            -kx * kz / ( n * n2),            -ky * kz / ( n * n2), (kx * kx + ky * ky) / ( n * n2) }
        });

<span class="fc bfc" id="L1063" title="All 2 branches covered.">        for (double x = -0.9; x &lt; 0.9; x += 0.2) {</span>
<span class="fc bfc" id="L1064" title="All 2 branches covered.">            for (double y = -0.9; y &lt; 0.9; y += 0.2) {</span>
<span class="fc bfc" id="L1065" title="All 2 branches covered.">                for (double z = -0.9; z &lt; 0.9; z += 0.2) {</span>
<span class="fc" id="L1066">                    Cartesian3D   u = new Cartesian3D(x, y, z);</span>
<span class="fc" id="L1067">                    FieldVector3D&lt;DerivativeStructure&gt; v = r.applyTo(createVector(x, y, z));</span>

                    // explicit formula for rotation of vector u around axis a with angle theta
<span class="fc" id="L1070">                    double dot     = Cartesian3D.dotProduct(u, a);</span>
<span class="fc" id="L1071">                    Cartesian3D cross = Cartesian3D.crossProduct(a, u);</span>
<span class="fc" id="L1072">                    double c1      = 1 - cosTheta;</span>
<span class="fc" id="L1073">                    double c2      = c1 * dot;</span>
<span class="fc" id="L1074">                    Cartesian3D rt    = new Cartesian3D(cosTheta, u, c2, a, sinTheta, cross);</span>
<span class="fc" id="L1075">                    Assert.assertEquals(rt.getX(), v.getX().getReal(), eps);</span>
<span class="fc" id="L1076">                    Assert.assertEquals(rt.getY(), v.getY().getReal(), eps);</span>
<span class="fc" id="L1077">                    Assert.assertEquals(rt.getZ(), v.getZ().getReal(), eps);</span>

                    // Jacobian of the image v = r(u) with respect to rotation axis a
                    // (analytical differentiation of the explicit formula)
<span class="fc" id="L1081">                    RealMatrix dvda = MatrixUtils.createRealMatrix(new double[][] {</span>
<span class="fc" id="L1082">                        { c1 * x * a.getX() + c2,           c1 * y * a.getX() + sinTheta * z, c1 * z * a.getX() - sinTheta * y },</span>
<span class="fc" id="L1083">                        { c1 * x * a.getY() - sinTheta * z, c1 * y * a.getY() + c2,           c1 * z * a.getY() + sinTheta * x },</span>
<span class="fc" id="L1084">                        { c1 * x * a.getZ() + sinTheta * y, c1 * y * a.getZ() - sinTheta * x, c1 * z * a.getZ() + c2           }</span>
                    });

                    // compose Jacobians
<span class="fc" id="L1088">                    RealMatrix dvdk = dvda.multiply(dadk);</span>

                    // derivatives with respect to un-normalized axis
<span class="fc" id="L1091">                    Assert.assertEquals(dvdk.getEntry(0, 0), v.getX().getPartialDerivative(1, 0, 0, 0), eps);</span>
<span class="fc" id="L1092">                    Assert.assertEquals(dvdk.getEntry(0, 1), v.getX().getPartialDerivative(0, 1, 0, 0), eps);</span>
<span class="fc" id="L1093">                    Assert.assertEquals(dvdk.getEntry(0, 2), v.getX().getPartialDerivative(0, 0, 1, 0), eps);</span>
<span class="fc" id="L1094">                    Assert.assertEquals(dvdk.getEntry(1, 0), v.getY().getPartialDerivative(1, 0, 0, 0), eps);</span>
<span class="fc" id="L1095">                    Assert.assertEquals(dvdk.getEntry(1, 1), v.getY().getPartialDerivative(0, 1, 0, 0), eps);</span>
<span class="fc" id="L1096">                    Assert.assertEquals(dvdk.getEntry(1, 2), v.getY().getPartialDerivative(0, 0, 1, 0), eps);</span>
<span class="fc" id="L1097">                    Assert.assertEquals(dvdk.getEntry(2, 0), v.getZ().getPartialDerivative(1, 0, 0, 0), eps);</span>
<span class="fc" id="L1098">                    Assert.assertEquals(dvdk.getEntry(2, 1), v.getZ().getPartialDerivative(0, 1, 0, 0), eps);</span>
<span class="fc" id="L1099">                    Assert.assertEquals(dvdk.getEntry(2, 2), v.getZ().getPartialDerivative(0, 0, 1, 0), eps);</span>

                    // derivative with respect to rotation angle
                    // (analytical differentiation of the explicit formula)
<span class="fc" id="L1103">                    Cartesian3D dvdTheta =</span>
                            new Cartesian3D(-sinTheta, u, sinTheta * dot, a, cosTheta, cross);
<span class="fc" id="L1105">                    Assert.assertEquals(dvdTheta.getX(), v.getX().getPartialDerivative(0, 0, 0, 1), eps);</span>
<span class="fc" id="L1106">                    Assert.assertEquals(dvdTheta.getY(), v.getY().getPartialDerivative(0, 0, 0, 1), eps);</span>
<span class="fc" id="L1107">                    Assert.assertEquals(dvdTheta.getZ(), v.getZ().getPartialDerivative(0, 0, 0, 1), eps);</span>

                }
            }
        }
<span class="fc" id="L1112">     }</span>

    @Test
    public void testArray() throws MathIllegalArgumentException {

<span class="fc" id="L1117">        FieldRotation&lt;DerivativeStructure&gt; r = new FieldRotation&lt;&gt;(createAxis(2, -3, 5),</span>
<span class="fc" id="L1118">                                                                                      createAngle(1.7),</span>
                                                                                      RotationConvention.VECTOR_OPERATOR);

<span class="fc bfc" id="L1121" title="All 2 branches covered.">        for (double x = -0.9; x &lt; 0.9; x += 0.2) {</span>
<span class="fc bfc" id="L1122" title="All 2 branches covered.">            for (double y = -0.9; y &lt; 0.9; y += 0.2) {</span>
<span class="fc bfc" id="L1123" title="All 2 branches covered.">                for (double z = -0.9; z &lt; 0.9; z += 0.2) {</span>
<span class="fc" id="L1124">                    FieldVector3D&lt;DerivativeStructure&gt; u = createVector(x, y, z);</span>
<span class="fc" id="L1125">                    FieldVector3D&lt;DerivativeStructure&gt; v = r.applyTo(u);</span>
<span class="fc" id="L1126">                    DerivativeStructure[] out = new DerivativeStructure[3];</span>
<span class="fc" id="L1127">                    r.applyTo(new DerivativeStructure[] { u.getX(), u.getY(), u.getZ() }, out);</span>
<span class="fc" id="L1128">                    Assert.assertEquals(v.getX().getReal(), out[0].getReal(), 1.0e-10);</span>
<span class="fc" id="L1129">                    Assert.assertEquals(v.getY().getReal(), out[1].getReal(), 1.0e-10);</span>
<span class="fc" id="L1130">                    Assert.assertEquals(v.getZ().getReal(), out[2].getReal(), 1.0e-10);</span>
<span class="fc" id="L1131">                    r.applyInverseTo(out, out);</span>
<span class="fc" id="L1132">                    Assert.assertEquals(u.getX().getReal(), out[0].getReal(), 1.0e-10);</span>
<span class="fc" id="L1133">                    Assert.assertEquals(u.getY().getReal(), out[1].getReal(), 1.0e-10);</span>
<span class="fc" id="L1134">                    Assert.assertEquals(u.getZ().getReal(), out[2].getReal(), 1.0e-10);</span>
                }
            }
        }

<span class="fc" id="L1139">    }</span>

    @Test
    public void testApplyInverseTo() throws MathIllegalArgumentException {

<span class="fc" id="L1144">        DerivativeStructure[] in      = new DerivativeStructure[3];</span>
<span class="fc" id="L1145">        DerivativeStructure[] out     = new DerivativeStructure[3];</span>
<span class="fc" id="L1146">        DerivativeStructure[] rebuilt = new DerivativeStructure[3];</span>
<span class="fc" id="L1147">        FieldRotation&lt;DerivativeStructure&gt; r = new FieldRotation&lt;&gt;(createVector(2, -3, 5),</span>
<span class="fc" id="L1148">                                                                                      createAngle(1.7),</span>
                                                                                      RotationConvention.VECTOR_OPERATOR);
<span class="fc bfc" id="L1150" title="All 2 branches covered.">        for (double lambda = 0; lambda &lt; 6.2; lambda += 0.2) {</span>
<span class="fc bfc" id="L1151" title="All 2 branches covered.">            for (double phi = -1.55; phi &lt; 1.55; phi += 0.2) {</span>
<span class="fc" id="L1152">                FieldVector3D&lt;DerivativeStructure&gt; u = createVector(FastMath.cos(lambda) * FastMath.cos(phi),</span>
<span class="fc" id="L1153">                                          FastMath.sin(lambda) * FastMath.cos(phi),</span>
<span class="fc" id="L1154">                                          FastMath.sin(phi));</span>
<span class="fc" id="L1155">                r.applyInverseTo(r.applyTo(u));</span>
<span class="fc" id="L1156">                checkVector(u, r.applyInverseTo(r.applyTo(u)));</span>
<span class="fc" id="L1157">                checkVector(u, r.applyTo(r.applyInverseTo(u)));</span>
<span class="fc" id="L1158">                in[0] = u.getX();</span>
<span class="fc" id="L1159">                in[1] = u.getY();</span>
<span class="fc" id="L1160">                in[2] = u.getZ();</span>
<span class="fc" id="L1161">                r.applyTo(in, out);</span>
<span class="fc" id="L1162">                r.applyInverseTo(out, rebuilt);</span>
<span class="fc" id="L1163">                Assert.assertEquals(in[0].getReal(), rebuilt[0].getReal(), 1.0e-12);</span>
<span class="fc" id="L1164">                Assert.assertEquals(in[1].getReal(), rebuilt[1].getReal(), 1.0e-12);</span>
<span class="fc" id="L1165">                Assert.assertEquals(in[2].getReal(), rebuilt[2].getReal(), 1.0e-12);</span>
            }
        }

<span class="fc" id="L1169">        r = createRotation(1, 0, 0, 0, false);</span>
<span class="fc bfc" id="L1170" title="All 2 branches covered.">        for (double lambda = 0; lambda &lt; 6.2; lambda += 0.2) {</span>
<span class="fc bfc" id="L1171" title="All 2 branches covered.">            for (double phi = -1.55; phi &lt; 1.55; phi += 0.2) {</span>
<span class="fc" id="L1172">                FieldVector3D&lt;DerivativeStructure&gt; u = createVector(FastMath.cos(lambda) * FastMath.cos(phi),</span>
<span class="fc" id="L1173">                                          FastMath.sin(lambda) * FastMath.cos(phi),</span>
<span class="fc" id="L1174">                                          FastMath.sin(phi));</span>
<span class="fc" id="L1175">                checkVector(u, r.applyInverseTo(r.applyTo(u)));</span>
<span class="fc" id="L1176">                checkVector(u, r.applyTo(r.applyInverseTo(u)));</span>
            }
        }

<span class="fc" id="L1180">        r = new FieldRotation&lt;&gt;(createVector(0, 0, 1),</span>
<span class="fc" id="L1181">                                                   createAngle(FastMath.PI),</span>
                                                   RotationConvention.VECTOR_OPERATOR);
<span class="fc bfc" id="L1183" title="All 2 branches covered.">        for (double lambda = 0; lambda &lt; 6.2; lambda += 0.2) {</span>
<span class="fc bfc" id="L1184" title="All 2 branches covered.">            for (double phi = -1.55; phi &lt; 1.55; phi += 0.2) {</span>
<span class="fc" id="L1185">                FieldVector3D&lt;DerivativeStructure&gt; u = createVector(FastMath.cos(lambda) * FastMath.cos(phi),</span>
<span class="fc" id="L1186">                                          FastMath.sin(lambda) * FastMath.cos(phi),</span>
<span class="fc" id="L1187">                                          FastMath.sin(phi));</span>
<span class="fc" id="L1188">                checkVector(u, r.applyInverseTo(r.applyTo(u)));</span>
<span class="fc" id="L1189">                checkVector(u, r.applyTo(r.applyInverseTo(u)));</span>
            }
        }

<span class="fc" id="L1193">    }</span>

    @Test
    public void testIssue639() throws MathArithmeticException{
<span class="fc" id="L1197">        FieldVector3D&lt;DerivativeStructure&gt; u1 = createVector(-1321008684645961.0 /  268435456.0,</span>
                                   -5774608829631843.0 /  268435456.0,
                                   -3822921525525679.0 / 4294967296.0);
<span class="fc" id="L1200">        FieldVector3D&lt;DerivativeStructure&gt; u2 =createVector( -5712344449280879.0 /    2097152.0,</span>
                                   -2275058564560979.0 /    1048576.0,
                                   4423475992255071.0 /      65536.0);
<span class="fc" id="L1203">        FieldRotation&lt;DerivativeStructure&gt; rot = new FieldRotation&lt;&gt;(u1, u2, createVector(1, 0, 0),createVector(0, 0, 1));</span>
<span class="fc" id="L1204">        Assert.assertEquals( 0.6228370359608200639829222, rot.getQ0().getReal(), 1.0e-15);</span>
<span class="fc" id="L1205">        Assert.assertEquals( 0.0257707621456498790029987, rot.getQ1().getReal(), 1.0e-15);</span>
<span class="fc" id="L1206">        Assert.assertEquals(-0.0000000002503012255839931, rot.getQ2().getReal(), 1.0e-15);</span>
<span class="fc" id="L1207">        Assert.assertEquals(-0.7819270390861109450724902, rot.getQ3().getReal(), 1.0e-15);</span>
<span class="fc" id="L1208">    }</span>

    @Test
    public void testIssue801() throws MathArithmeticException {
<span class="fc" id="L1212">        FieldVector3D&lt;DerivativeStructure&gt; u1 = createVector(0.9999988431610581, -0.0015210774290851095, 0.0);</span>
<span class="fc" id="L1213">        FieldVector3D&lt;DerivativeStructure&gt; u2 = createVector(0.0, 0.0, 1.0);</span>

<span class="fc" id="L1215">        FieldVector3D&lt;DerivativeStructure&gt; v1 = createVector(0.9999999999999999, 0.0, 0.0);</span>
<span class="fc" id="L1216">        FieldVector3D&lt;DerivativeStructure&gt; v2 = createVector(0.0, 0.0, -1.0);</span>

<span class="fc" id="L1218">        FieldRotation&lt;DerivativeStructure&gt; quat = new FieldRotation&lt;&gt;(u1, u2, v1, v2);</span>
<span class="fc" id="L1219">        double q2 = quat.getQ0().getReal() * quat.getQ0().getReal() +</span>
<span class="fc" id="L1220">                    quat.getQ1().getReal() * quat.getQ1().getReal() +</span>
<span class="fc" id="L1221">                    quat.getQ2().getReal() * quat.getQ2().getReal() +</span>
<span class="fc" id="L1222">                    quat.getQ3().getReal() * quat.getQ3().getReal();</span>
<span class="fc" id="L1223">        Assert.assertEquals(1.0, q2, 1.0e-14);</span>
<span class="fc" id="L1224">        Assert.assertEquals(0.0, FieldVector3D.angle(v1, quat.applyTo(u1)).getReal(), 1.0e-14);</span>
<span class="fc" id="L1225">        Assert.assertEquals(0.0, FieldVector3D.angle(v2, quat.applyTo(u2)).getReal(), 1.0e-14);</span>

<span class="fc" id="L1227">    }</span>

    private void checkAngle(DerivativeStructure a1, double a2) {
<span class="fc" id="L1230">        Assert.assertEquals(a1.getReal(), PlaneAngleRadians.normalize(a2, a1.getReal()), 1.0e-10);</span>
<span class="fc" id="L1231">    }</span>

    private void checkRotationDS(FieldRotation&lt;DerivativeStructure&gt; r, double q0, double q1, double q2, double q3) {
<span class="fc" id="L1234">        FieldRotation&lt;DerivativeStructure&gt; rPrime = createRotation(q0, q1, q2, q3, false);</span>
<span class="fc" id="L1235">        Assert.assertEquals(0, FieldRotation.distance(r, rPrime).getReal(), 1.0e-12);</span>
<span class="fc" id="L1236">    }</span>

    private FieldRotation&lt;DerivativeStructure&gt; createRotation(double q0, double q1, double q2, double q3,
                                      boolean needsNormalization) {
<span class="fc" id="L1240">        return new FieldRotation&lt;&gt;(new DerivativeStructure(4, 1, 0, q0),</span>
                              new DerivativeStructure(4, 1, 1, q1),
                              new DerivativeStructure(4, 1, 2, q2),
                              new DerivativeStructure(4, 1, 3, q3),
                              needsNormalization);
    }

    private FieldRotation&lt;DerivativeStructure&gt; createRotation(double[][] m, double threshold) {
<span class="fc" id="L1248">        DerivativeStructure[][] mds = new DerivativeStructure[m.length][m[0].length];</span>
<span class="fc" id="L1249">        int index = 0;</span>
<span class="fc bfc" id="L1250" title="All 2 branches covered.">        for (int i = 0; i &lt; m.length; ++i) {</span>
<span class="fc bfc" id="L1251" title="All 2 branches covered.">            for (int j = 0; j &lt; m[i].length; ++j) {</span>
<span class="fc" id="L1252">                mds[i][j] = new DerivativeStructure(4, 1, index, m[i][j]);</span>
<span class="fc" id="L1253">                index = (index + 1) % 4;</span>
            }
        }
<span class="fc" id="L1256">        return new FieldRotation&lt;&gt;(mds, threshold);</span>
    }

    private FieldVector3D&lt;DerivativeStructure&gt; createVector(double x, double y, double z) {
<span class="fc" id="L1260">        return new FieldVector3D&lt;&gt;(new DerivativeStructure(4, 1, x),</span>
                              new DerivativeStructure(4, 1, y),
                              new DerivativeStructure(4, 1, z));
    }

    private FieldVector3D&lt;DerivativeStructure&gt; createAxis(double x, double y, double z) {
<span class="fc" id="L1266">        return new FieldVector3D&lt;&gt;(new DerivativeStructure(4, 1, 0, x),</span>
                              new DerivativeStructure(4, 1, 1, y),
                              new DerivativeStructure(4, 1, 2, z));
    }

    private DerivativeStructure createAngle(double alpha) {
<span class="fc" id="L1272">        return new DerivativeStructure(4, 1, 3, alpha);</span>
    }

    private void checkVector(FieldVector3D&lt;DerivativeStructure&gt; u, FieldVector3D&lt;DerivativeStructure&gt; v) {
<span class="fc" id="L1276">        Assert.assertEquals(u.getX().getReal(), v.getX().getReal(), 1.0e-12);</span>
<span class="fc" id="L1277">        Assert.assertEquals(u.getY().getReal(), v.getY().getReal(), 1.0e-12);</span>
<span class="fc" id="L1278">        Assert.assertEquals(u.getZ().getReal(), v.getZ().getReal(), 1.0e-12);</span>
<span class="fc" id="L1279">    }</span>

}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.1.201803210924</span></div></body></html>