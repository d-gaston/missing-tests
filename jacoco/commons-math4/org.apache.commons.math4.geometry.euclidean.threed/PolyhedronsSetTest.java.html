<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>PolyhedronsSetTest.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">commons_math4$All_in_commons_math4.exec</a> &gt; <a href="index.source.html" class="el_package">org.apache.commons.math4.geometry.euclidean.threed</a> &gt; <span class="el_source">PolyhedronsSetTest.java</span></div><h1>PolyhedronsSetTest.java</h1><pre class="source lang-java linenums">/*
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the &quot;License&quot;); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.commons.math4.geometry.euclidean.threed;

import java.io.IOException;
import java.io.InputStream;
import java.io.InputStreamReader;
import java.io.Reader;
import java.lang.reflect.Field;
import java.text.ParseException;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.List;

import org.apache.commons.math3.util.Precision;
import org.apache.commons.math4.exception.MathArithmeticException;
import org.apache.commons.math4.exception.MathIllegalArgumentException;
import org.apache.commons.math4.exception.util.ExceptionContext;
import org.apache.commons.math4.exception.util.Localizable;
import org.apache.commons.math4.exception.util.LocalizedFormats;
import org.apache.commons.math4.geometry.GeometryTestUtils;
import org.apache.commons.math4.geometry.euclidean.twod.Cartesian2D;
import org.apache.commons.math4.geometry.euclidean.twod.Euclidean2D;
import org.apache.commons.math4.geometry.euclidean.twod.PolygonsSet;
import org.apache.commons.math4.geometry.euclidean.twod.SubLine;
import org.apache.commons.math4.geometry.partitioning.BSPTree;
import org.apache.commons.math4.geometry.partitioning.BSPTreeVisitor;
import org.apache.commons.math4.geometry.partitioning.BoundaryAttribute;
import org.apache.commons.math4.geometry.partitioning.BoundaryProjection;
import org.apache.commons.math4.geometry.partitioning.Region;
import org.apache.commons.math4.geometry.partitioning.RegionDumper;
import org.apache.commons.math4.geometry.partitioning.RegionFactory;
import org.apache.commons.math4.geometry.partitioning.RegionParser;
import org.apache.commons.math4.geometry.partitioning.SubHyperplane;
import org.apache.commons.math4.util.FastMath;
import org.apache.commons.rng.UniformRandomProvider;
import org.apache.commons.rng.simple.RandomSource;
import org.junit.Assert;
import org.junit.Test;

<span class="fc" id="L55">public class PolyhedronsSetTest {</span>

    private static final double TEST_TOLERANCE = 1e-10;

    @Test
    public void testWholeSpace() {
        // act
<span class="fc" id="L62">        PolyhedronsSet polySet = new PolyhedronsSet(TEST_TOLERANCE);</span>

        // assert
<span class="fc" id="L65">        Assert.assertEquals(TEST_TOLERANCE, polySet.getTolerance(), Precision.EPSILON);</span>
<span class="fc" id="L66">        GeometryTestUtils.assertPositiveInfinity(polySet.getSize());</span>
<span class="fc" id="L67">        Assert.assertEquals(0.0, polySet.getBoundarySize(), TEST_TOLERANCE);</span>
<span class="fc" id="L68">        GeometryTestUtils.assertVectorEquals(Cartesian3D.NaN, (Cartesian3D) polySet.getBarycenter(), TEST_TOLERANCE);</span>
<span class="fc" id="L69">        Assert.assertFalse(polySet.isEmpty());</span>
<span class="fc" id="L70">        Assert.assertTrue(polySet.isFull());</span>

<span class="fc" id="L72">        checkPoints(Region.Location.INSIDE, polySet,</span>
                new Cartesian3D(-Double.MAX_VALUE, -Double.MAX_VALUE, -Double.MAX_VALUE),
                new Cartesian3D(-100, -100, -100),
                new Cartesian3D(0, 0, 0),
                new Cartesian3D(100, 100, 100),
                new Cartesian3D(Double.MAX_VALUE, Double.MAX_VALUE, Double.MAX_VALUE));
<span class="fc" id="L78">    }</span>

    @Test
    public void testEmptyRegion() {
        // act
<span class="fc" id="L83">        PolyhedronsSet polySet = new PolyhedronsSet(new BSPTree&lt;Euclidean3D&gt;(Boolean.FALSE), TEST_TOLERANCE);</span>

        // assert
<span class="fc" id="L86">        Assert.assertEquals(TEST_TOLERANCE, polySet.getTolerance(), Precision.EPSILON);</span>
<span class="fc" id="L87">        Assert.assertEquals(0.0, polySet.getSize(), TEST_TOLERANCE);</span>
<span class="fc" id="L88">        Assert.assertEquals(0.0, polySet.getBoundarySize(), TEST_TOLERANCE);</span>
<span class="fc" id="L89">        GeometryTestUtils.assertVectorEquals(Cartesian3D.NaN, (Cartesian3D) polySet.getBarycenter(), TEST_TOLERANCE);</span>
<span class="fc" id="L90">        Assert.assertTrue(polySet.isEmpty());</span>
<span class="fc" id="L91">        Assert.assertFalse(polySet.isFull());</span>

<span class="fc" id="L93">        checkPoints(Region.Location.OUTSIDE, polySet,</span>
                new Cartesian3D(-Double.MAX_VALUE, -Double.MAX_VALUE, -Double.MAX_VALUE),
                new Cartesian3D(-100, -100, -100),
                new Cartesian3D(0, 0, 0),
                new Cartesian3D(100, 100, 100),
                new Cartesian3D(Double.MAX_VALUE, Double.MAX_VALUE, Double.MAX_VALUE));
<span class="fc" id="L99">    }</span>

    @Test
    public void testHalfSpace() {
        // arrange
<span class="fc" id="L104">        List&lt;SubHyperplane&lt;Euclidean3D&gt;&gt; boundaries = new ArrayList&lt;&gt;();</span>
<span class="fc" id="L105">        boundaries.add(new SubPlane(new Plane(Cartesian3D.ZERO, Cartesian3D.PLUS_J, TEST_TOLERANCE),</span>
                new PolygonsSet(TEST_TOLERANCE)));

        // act
<span class="fc" id="L109">        PolyhedronsSet polySet = new PolyhedronsSet(boundaries, TEST_TOLERANCE);</span>

        // assert
<span class="fc" id="L112">        Assert.assertEquals(TEST_TOLERANCE, polySet.getTolerance(), Precision.EPSILON);</span>
<span class="fc" id="L113">        GeometryTestUtils.assertPositiveInfinity(polySet.getSize());</span>
<span class="fc" id="L114">        GeometryTestUtils.assertPositiveInfinity(polySet.getBoundarySize());</span>
<span class="fc" id="L115">        GeometryTestUtils.assertVectorEquals(Cartesian3D.NaN, (Cartesian3D) polySet.getBarycenter(), TEST_TOLERANCE);</span>
<span class="fc" id="L116">        Assert.assertFalse(polySet.isEmpty());</span>
<span class="fc" id="L117">        Assert.assertFalse(polySet.isFull());</span>

<span class="fc" id="L119">        checkPoints(Region.Location.INSIDE, polySet,</span>
                new Cartesian3D(-Double.MAX_VALUE, -Double.MAX_VALUE, -Double.MAX_VALUE),
                new Cartesian3D(-100, -100, -100));
<span class="fc" id="L122">        checkPoints(Region.Location.BOUNDARY, polySet, new Cartesian3D(0, 0, 0));</span>
<span class="fc" id="L123">        checkPoints(Region.Location.OUTSIDE, polySet,</span>
                new Cartesian3D(100, 100, 100),
                new Cartesian3D(Double.MAX_VALUE, Double.MAX_VALUE, Double.MAX_VALUE));
<span class="fc" id="L126">    }</span>

    @Test
    public void testInvertedRegion() {
        // arrange
<span class="fc" id="L131">        List&lt;SubHyperplane&lt;Euclidean3D&gt;&gt; boundaries = createBoxBoundaries(Cartesian3D.ZERO, 1.0, TEST_TOLERANCE);</span>
<span class="fc" id="L132">        PolyhedronsSet box = new PolyhedronsSet(boundaries, TEST_TOLERANCE);;</span>

        // act
<span class="fc" id="L135">        PolyhedronsSet polySet = (PolyhedronsSet) new RegionFactory&lt;Euclidean3D&gt;().getComplement(box);</span>

        // assert
<span class="fc" id="L138">        Assert.assertEquals(TEST_TOLERANCE, polySet.getTolerance(), Precision.EPSILON);</span>
<span class="fc" id="L139">        GeometryTestUtils.assertPositiveInfinity(polySet.getSize());</span>
<span class="fc" id="L140">        Assert.assertEquals(6, polySet.getBoundarySize(), TEST_TOLERANCE);</span>
<span class="fc" id="L141">        GeometryTestUtils.assertVectorEquals(Cartesian3D.NaN, (Cartesian3D) polySet.getBarycenter(), TEST_TOLERANCE);</span>
<span class="fc" id="L142">        Assert.assertFalse(polySet.isEmpty());</span>
<span class="fc" id="L143">        Assert.assertFalse(polySet.isFull());</span>

<span class="fc" id="L145">        checkPoints(Region.Location.INSIDE, polySet,</span>
                new Cartesian3D(-Double.MAX_VALUE, -Double.MAX_VALUE, -Double.MAX_VALUE),
                new Cartesian3D(-100, -100, -100),
                new Cartesian3D(100, 100, 100),
                new Cartesian3D(Double.MAX_VALUE, Double.MAX_VALUE, Double.MAX_VALUE));
<span class="fc" id="L150">        checkPoints(Region.Location.OUTSIDE, polySet,</span>
                new Cartesian3D(0, 0, 0));
<span class="fc" id="L152">    }</span>

    @Test
    public void testCreateFromBoundaries_noBoundaries_treeRepresentsWholeSpace() {
        // arrange
<span class="fc" id="L157">        List&lt;SubHyperplane&lt;Euclidean3D&gt;&gt; boundaries = new ArrayList&lt;&gt;();</span>

        // act
<span class="fc" id="L160">        PolyhedronsSet polySet = new PolyhedronsSet(boundaries, TEST_TOLERANCE);</span>

        // assert
<span class="fc" id="L163">        Assert.assertEquals(TEST_TOLERANCE, polySet.getTolerance(), Precision.EPSILON);</span>
<span class="fc" id="L164">        GeometryTestUtils.assertPositiveInfinity(polySet.getSize());</span>
<span class="fc" id="L165">        Assert.assertEquals(0.0, polySet.getBoundarySize(), TEST_TOLERANCE);</span>
<span class="fc" id="L166">        GeometryTestUtils.assertVectorEquals(Cartesian3D.NaN, (Cartesian3D) polySet.getBarycenter(), TEST_TOLERANCE);</span>
<span class="fc" id="L167">        Assert.assertFalse(polySet.isEmpty());</span>
<span class="fc" id="L168">        Assert.assertTrue(polySet.isFull());</span>
<span class="fc" id="L169">    }</span>

    @Test
    public void testCreateFromBoundaries_unitBox() {
        // arrange
<span class="fc" id="L174">        List&lt;SubHyperplane&lt;Euclidean3D&gt;&gt; boundaries = createBoxBoundaries(Cartesian3D.ZERO, 1.0, TEST_TOLERANCE);</span>

        // act
<span class="fc" id="L177">        PolyhedronsSet polySet = new PolyhedronsSet(boundaries, TEST_TOLERANCE);</span>

        // assert
<span class="fc" id="L180">        Assert.assertEquals(TEST_TOLERANCE, polySet.getTolerance(), Precision.EPSILON);</span>
<span class="fc" id="L181">        Assert.assertEquals(1.0, polySet.getSize(), TEST_TOLERANCE);</span>
<span class="fc" id="L182">        Assert.assertEquals(6.0, polySet.getBoundarySize(), TEST_TOLERANCE);</span>
<span class="fc" id="L183">        GeometryTestUtils.assertVectorEquals(Cartesian3D.ZERO, (Cartesian3D) polySet.getBarycenter(), TEST_TOLERANCE);</span>
<span class="fc" id="L184">        Assert.assertFalse(polySet.isEmpty());</span>
<span class="fc" id="L185">        Assert.assertFalse(polySet.isFull());</span>

<span class="fc" id="L187">        checkPoints(Region.Location.OUTSIDE, polySet,</span>
                new Cartesian3D(-1, 0, 0),
                new Cartesian3D(1, 0, 0),
                new Cartesian3D(0, -1, 0),
                new Cartesian3D(0, 1, 0),
                new Cartesian3D(0, 0, -1),
                new Cartesian3D(0, 0, 1),

                new Cartesian3D(1, 1, 1),
                new Cartesian3D(1, 1, -1),
                new Cartesian3D(1, -1, 1),
                new Cartesian3D(1, -1, -1),
                new Cartesian3D(-1, 1, 1),
                new Cartesian3D(-1, 1, -1),
                new Cartesian3D(-1, -1, 1),
                new Cartesian3D(-1, -1, -1));

<span class="fc" id="L204">        checkPoints(Region.Location.BOUNDARY, polySet,</span>
                new Cartesian3D(0.5, 0, 0),
                new Cartesian3D(-0.5, 0, 0),
                new Cartesian3D(0, 0.5, 0),
                new Cartesian3D(0, -0.5, 0),
                new Cartesian3D(0, 0, 0.5),
                new Cartesian3D(0, 0, -0.5),

                new Cartesian3D(0.5, 0.5, 0.5),
                new Cartesian3D(0.5, 0.5, -0.5),
                new Cartesian3D(0.5, -0.5, 0.5),
                new Cartesian3D(0.5, -0.5, -0.5),
                new Cartesian3D(-0.5, 0.5, 0.5),
                new Cartesian3D(-0.5, 0.5, -0.5),
                new Cartesian3D(-0.5, -0.5, 0.5),
                new Cartesian3D(-0.5, -0.5, -0.5));

<span class="fc" id="L221">        checkPoints(Region.Location.INSIDE, polySet,</span>
                new Cartesian3D(0, 0, 0),

                new Cartesian3D(0.4, 0.4, 0.4),
                new Cartesian3D(0.4, 0.4, -0.4),
                new Cartesian3D(0.4, -0.4, 0.4),
                new Cartesian3D(0.4, -0.4, -0.4),
                new Cartesian3D(-0.4, 0.4, 0.4),
                new Cartesian3D(-0.4, 0.4, -0.4),
                new Cartesian3D(-0.4, -0.4, 0.4),
                new Cartesian3D(-0.4, -0.4, -0.4));
<span class="fc" id="L232">    }</span>

    @Test
    public void testCreateFromBoundaries_twoBoxes_disjoint() {
        // arrange
<span class="fc" id="L237">        List&lt;SubHyperplane&lt;Euclidean3D&gt;&gt; boundaries = new ArrayList&lt;&gt;();</span>
<span class="fc" id="L238">        boundaries.addAll(createBoxBoundaries(Cartesian3D.ZERO, 1.0, TEST_TOLERANCE));</span>
<span class="fc" id="L239">        boundaries.addAll(createBoxBoundaries(new Cartesian3D(2, 0, 0), 1.0, TEST_TOLERANCE));</span>

        // act
<span class="fc" id="L242">        PolyhedronsSet polySet = new PolyhedronsSet(boundaries, TEST_TOLERANCE);</span>

        // assert
<span class="fc" id="L245">        Assert.assertEquals(TEST_TOLERANCE, polySet.getTolerance(), Precision.EPSILON);</span>
<span class="fc" id="L246">        Assert.assertEquals(2.0, polySet.getSize(), TEST_TOLERANCE);</span>
<span class="fc" id="L247">        Assert.assertEquals(12.0, polySet.getBoundarySize(), TEST_TOLERANCE);</span>
<span class="fc" id="L248">        GeometryTestUtils.assertVectorEquals(new Cartesian3D(1, 0, 0), (Cartesian3D) polySet.getBarycenter(), TEST_TOLERANCE);</span>
<span class="fc" id="L249">        Assert.assertFalse(polySet.isEmpty());</span>
<span class="fc" id="L250">        Assert.assertFalse(polySet.isFull());</span>

<span class="fc" id="L252">        checkPoints(Region.Location.OUTSIDE, polySet,</span>
                new Cartesian3D(-1, 0, 0),
                new Cartesian3D(1, 0, 0),
                new Cartesian3D(3, 0, 0));

<span class="fc" id="L257">        checkPoints(Region.Location.INSIDE, polySet,</span>
                new Cartesian3D(0, 0, 0),
                new Cartesian3D(2, 0, 0));
<span class="fc" id="L260">    }</span>

    @Test
    public void testCreateFromBoundaries_twoBoxes_sharedSide() {
        // arrange
<span class="fc" id="L265">        List&lt;SubHyperplane&lt;Euclidean3D&gt;&gt; boundaries = new ArrayList&lt;&gt;();</span>
<span class="fc" id="L266">        boundaries.addAll(createBoxBoundaries(new Cartesian3D(0, 0, 0), 1.0, TEST_TOLERANCE));</span>
<span class="fc" id="L267">        boundaries.addAll(createBoxBoundaries(new Cartesian3D(1, 0, 0), 1.0, TEST_TOLERANCE));</span>

        // act
<span class="fc" id="L270">        PolyhedronsSet polySet = new PolyhedronsSet(boundaries, TEST_TOLERANCE);</span>

        // assert
<span class="fc" id="L273">        Assert.assertEquals(TEST_TOLERANCE, polySet.getTolerance(), Precision.EPSILON);</span>
<span class="fc" id="L274">        Assert.assertEquals(2.0, polySet.getSize(), TEST_TOLERANCE);</span>
<span class="fc" id="L275">        Assert.assertEquals(10.0, polySet.getBoundarySize(), TEST_TOLERANCE);</span>
<span class="fc" id="L276">        GeometryTestUtils.assertVectorEquals(new Cartesian3D(0.5, 0, 0), (Cartesian3D) polySet.getBarycenter(), TEST_TOLERANCE);</span>
<span class="fc" id="L277">        Assert.assertFalse(polySet.isEmpty());</span>
<span class="fc" id="L278">        Assert.assertFalse(polySet.isFull());</span>

<span class="fc" id="L280">        checkPoints(Region.Location.OUTSIDE, polySet,</span>
                new Cartesian3D(-1, 0, 0),
                new Cartesian3D(2, 0, 0));

<span class="fc" id="L284">        checkPoints(Region.Location.INSIDE, polySet,</span>
                new Cartesian3D(0, 0, 0),
                new Cartesian3D(1, 0, 0));
<span class="fc" id="L287">    }</span>

    @Test
    public void testCreateFromBoundaries_twoBoxes_separationLessThanTolerance() {
        // arrange
<span class="fc" id="L292">        double tolerance = 1e-6;</span>
<span class="fc" id="L293">        List&lt;SubHyperplane&lt;Euclidean3D&gt;&gt; boundaries = new ArrayList&lt;&gt;();</span>
<span class="fc" id="L294">        boundaries.addAll(createBoxBoundaries(new Cartesian3D(0, 0, 0), 1.0, tolerance));</span>
<span class="fc" id="L295">        boundaries.addAll(createBoxBoundaries(new Cartesian3D(1 + 1e-7, 0, 0), 1.0, tolerance));</span>

        // act
<span class="fc" id="L298">        PolyhedronsSet polySet = new PolyhedronsSet(boundaries, tolerance);</span>

        // assert
<span class="fc" id="L301">        Assert.assertEquals(tolerance, polySet.getTolerance(), Precision.EPSILON);</span>
<span class="fc" id="L302">        Assert.assertEquals(2.0, polySet.getSize(), tolerance);</span>
<span class="fc" id="L303">        Assert.assertEquals(10.0, polySet.getBoundarySize(), tolerance);</span>
<span class="fc" id="L304">        GeometryTestUtils.assertVectorEquals(new Cartesian3D(0.5 + 5e-8, 0, 0), (Cartesian3D) polySet.getBarycenter(), TEST_TOLERANCE);</span>
<span class="fc" id="L305">        Assert.assertFalse(polySet.isEmpty());</span>
<span class="fc" id="L306">        Assert.assertFalse(polySet.isFull());</span>

<span class="fc" id="L308">        checkPoints(Region.Location.OUTSIDE, polySet,</span>
                new Cartesian3D(-1, 0, 0),
                new Cartesian3D(2, 0, 0));

<span class="fc" id="L312">        checkPoints(Region.Location.INSIDE, polySet,</span>
                new Cartesian3D(0, 0, 0),
                new Cartesian3D(1, 0, 0));
<span class="fc" id="L315">    }</span>

    @Test
    public void testCreateFromBoundaries_twoBoxes_sharedEdge() {
        // arrange
<span class="fc" id="L320">        List&lt;SubHyperplane&lt;Euclidean3D&gt;&gt; boundaries = new ArrayList&lt;&gt;();</span>
<span class="fc" id="L321">        boundaries.addAll(createBoxBoundaries(new Cartesian3D(0, 0, 0), 1.0, TEST_TOLERANCE));</span>
<span class="fc" id="L322">        boundaries.addAll(createBoxBoundaries(new Cartesian3D(1, 1, 0), 1.0, TEST_TOLERANCE));</span>

        // act
<span class="fc" id="L325">        PolyhedronsSet polySet = new PolyhedronsSet(boundaries, TEST_TOLERANCE);</span>

        // assert
<span class="fc" id="L328">        Assert.assertEquals(TEST_TOLERANCE, polySet.getTolerance(), Precision.EPSILON);</span>
<span class="fc" id="L329">        Assert.assertEquals(2.0, polySet.getSize(), TEST_TOLERANCE);</span>
<span class="fc" id="L330">        Assert.assertEquals(12.0, polySet.getBoundarySize(), TEST_TOLERANCE);</span>
<span class="fc" id="L331">        GeometryTestUtils.assertVectorEquals(new Cartesian3D(0.5, 0.5, 0), (Cartesian3D) polySet.getBarycenter(), TEST_TOLERANCE);</span>
<span class="fc" id="L332">        Assert.assertFalse(polySet.isEmpty());</span>
<span class="fc" id="L333">        Assert.assertFalse(polySet.isFull());</span>

<span class="fc" id="L335">        checkPoints(Region.Location.OUTSIDE, polySet,</span>
                new Cartesian3D(-1, 0, 0),
                new Cartesian3D(1, 0, 0),
                new Cartesian3D(0, 1, 0),
                new Cartesian3D(2, 1, 0));

<span class="fc" id="L341">        checkPoints(Region.Location.INSIDE, polySet,</span>
                new Cartesian3D(0, 0, 0),
                new Cartesian3D(1, 1, 0));
<span class="fc" id="L344">    }</span>

    @Test
    public void testCreateFromBoundaries_twoBoxes_sharedPoint() {
        // arrange
<span class="fc" id="L349">        List&lt;SubHyperplane&lt;Euclidean3D&gt;&gt; boundaries = new ArrayList&lt;&gt;();</span>
<span class="fc" id="L350">        boundaries.addAll(createBoxBoundaries(new Cartesian3D(0, 0, 0), 1.0, TEST_TOLERANCE));</span>
<span class="fc" id="L351">        boundaries.addAll(createBoxBoundaries(new Cartesian3D(1, 1, 1), 1.0, TEST_TOLERANCE));</span>

        // act
<span class="fc" id="L354">        PolyhedronsSet polySet = new PolyhedronsSet(boundaries, TEST_TOLERANCE);</span>

        // assert
<span class="fc" id="L357">        Assert.assertEquals(TEST_TOLERANCE, polySet.getTolerance(), Precision.EPSILON);</span>
<span class="fc" id="L358">        Assert.assertEquals(2.0, polySet.getSize(), TEST_TOLERANCE);</span>
<span class="fc" id="L359">        Assert.assertEquals(12.0, polySet.getBoundarySize(), TEST_TOLERANCE);</span>
<span class="fc" id="L360">        GeometryTestUtils.assertVectorEquals(new Cartesian3D(0.5, 0.5, 0.5), (Cartesian3D) polySet.getBarycenter(), TEST_TOLERANCE);</span>
<span class="fc" id="L361">        Assert.assertFalse(polySet.isEmpty());</span>
<span class="fc" id="L362">        Assert.assertFalse(polySet.isFull());</span>

<span class="fc" id="L364">        checkPoints(Region.Location.OUTSIDE, polySet,</span>
                new Cartesian3D(-1, 0, 0),
                new Cartesian3D(1, 0, 0),
                new Cartesian3D(0, 1, 1),
                new Cartesian3D(2, 1, 1));

<span class="fc" id="L370">        checkPoints(Region.Location.INSIDE, polySet,</span>
                new Cartesian3D(0, 0, 0),
                new Cartesian3D(1, 1, 1));
<span class="fc" id="L373">    }</span>

    @Test
    public void testCreateBox() {
        // act
<span class="fc" id="L378">        PolyhedronsSet tree = new PolyhedronsSet(0, 1, 0, 1, 0, 1, TEST_TOLERANCE);</span>

        // assert
<span class="fc" id="L381">        Assert.assertEquals(1.0, tree.getSize(), TEST_TOLERANCE);</span>
<span class="fc" id="L382">        Assert.assertEquals(6.0, tree.getBoundarySize(), TEST_TOLERANCE);</span>
<span class="fc" id="L383">        GeometryTestUtils.assertVectorEquals(new Cartesian3D(0.5, 0.5, 0.5), (Cartesian3D) tree.getBarycenter(), TEST_TOLERANCE);</span>

<span class="fc bfc" id="L385" title="All 2 branches covered.">        for (double x = -0.25; x &lt; 1.25; x += 0.1) {</span>
<span class="fc bfc" id="L386" title="All 4 branches covered.">            boolean xOK = (x &gt;= 0.0) &amp;&amp; (x &lt;= 1.0);</span>
<span class="fc bfc" id="L387" title="All 2 branches covered.">            for (double y = -0.25; y &lt; 1.25; y += 0.1) {</span>
<span class="fc bfc" id="L388" title="All 4 branches covered.">                boolean yOK = (y &gt;= 0.0) &amp;&amp; (y &lt;= 1.0);</span>
<span class="fc bfc" id="L389" title="All 2 branches covered.">                for (double z = -0.25; z &lt; 1.25; z += 0.1) {</span>
<span class="fc bfc" id="L390" title="All 4 branches covered.">                    boolean zOK = (z &gt;= 0.0) &amp;&amp; (z &lt;= 1.0);</span>
<span class="fc bfc" id="L391" title="All 6 branches covered.">                    Region.Location expected =</span>
                        (xOK &amp;&amp; yOK &amp;&amp; zOK) ? Region.Location.INSIDE : Region.Location.OUTSIDE;
<span class="fc" id="L393">                    Assert.assertEquals(expected, tree.checkPoint(new Cartesian3D(x, y, z)));</span>
                }
            }
        }
<span class="fc" id="L397">        checkPoints(Region.Location.BOUNDARY, tree, new Cartesian3D[] {</span>
            new Cartesian3D(0.0, 0.5, 0.5),
            new Cartesian3D(1.0, 0.5, 0.5),
            new Cartesian3D(0.5, 0.0, 0.5),
            new Cartesian3D(0.5, 1.0, 0.5),
            new Cartesian3D(0.5, 0.5, 0.0),
            new Cartesian3D(0.5, 0.5, 1.0)
        });
<span class="fc" id="L405">        checkPoints(Region.Location.OUTSIDE, tree, new Cartesian3D[] {</span>
            new Cartesian3D(0.0, 1.2, 1.2),
            new Cartesian3D(1.0, 1.2, 1.2),
            new Cartesian3D(1.2, 0.0, 1.2),
            new Cartesian3D(1.2, 1.0, 1.2),
            new Cartesian3D(1.2, 1.2, 0.0),
            new Cartesian3D(1.2, 1.2, 1.0)
        });
<span class="fc" id="L413">    }</span>

    @Test
    public void testInvertedBox() {
        // arrange
<span class="fc" id="L418">        PolyhedronsSet tree = new PolyhedronsSet(0, 1, 0, 1, 0, 1, 1.0e-10);</span>

        // act
<span class="fc" id="L421">        tree = (PolyhedronsSet) new RegionFactory&lt;Euclidean3D&gt;().getComplement(tree);</span>

        // assert
<span class="fc" id="L424">        GeometryTestUtils.assertPositiveInfinity(tree.getSize());</span>
<span class="fc" id="L425">        Assert.assertEquals(6.0, tree.getBoundarySize(), 1.0e-10);</span>

<span class="fc" id="L427">        Cartesian3D barycenter = (Cartesian3D) tree.getBarycenter();</span>
<span class="fc" id="L428">        Assert.assertTrue(Double.isNaN(barycenter.getX()));</span>
<span class="fc" id="L429">        Assert.assertTrue(Double.isNaN(barycenter.getY()));</span>
<span class="fc" id="L430">        Assert.assertTrue(Double.isNaN(barycenter.getZ()));</span>

<span class="fc bfc" id="L432" title="All 2 branches covered.">        for (double x = -0.25; x &lt; 1.25; x += 0.1) {</span>
<span class="fc bfc" id="L433" title="All 4 branches covered.">            boolean xOK = (x &lt; 0.0) || (x &gt; 1.0);</span>
<span class="fc bfc" id="L434" title="All 2 branches covered.">            for (double y = -0.25; y &lt; 1.25; y += 0.1) {</span>
<span class="fc bfc" id="L435" title="All 4 branches covered.">                boolean yOK = (y &lt; 0.0) || (y &gt; 1.0);</span>
<span class="fc bfc" id="L436" title="All 2 branches covered.">                for (double z = -0.25; z &lt; 1.25; z += 0.1) {</span>
<span class="fc bfc" id="L437" title="All 4 branches covered.">                    boolean zOK = (z &lt; 0.0) || (z &gt; 1.0);</span>
<span class="fc bfc" id="L438" title="All 6 branches covered.">                    Region.Location expected =</span>
                        (xOK || yOK || zOK) ? Region.Location.INSIDE : Region.Location.OUTSIDE;
<span class="fc" id="L440">                    Assert.assertEquals(expected, tree.checkPoint(new Cartesian3D(x, y, z)));</span>
                }
            }
        }
<span class="fc" id="L444">        checkPoints(Region.Location.BOUNDARY, tree, new Cartesian3D[] {</span>
            new Cartesian3D(0.0, 0.5, 0.5),
            new Cartesian3D(1.0, 0.5, 0.5),
            new Cartesian3D(0.5, 0.0, 0.5),
            new Cartesian3D(0.5, 1.0, 0.5),
            new Cartesian3D(0.5, 0.5, 0.0),
            new Cartesian3D(0.5, 0.5, 1.0)
        });
<span class="fc" id="L452">        checkPoints(Region.Location.INSIDE, tree, new Cartesian3D[] {</span>
            new Cartesian3D(0.0, 1.2, 1.2),
            new Cartesian3D(1.0, 1.2, 1.2),
            new Cartesian3D(1.2, 0.0, 1.2),
            new Cartesian3D(1.2, 1.0, 1.2),
            new Cartesian3D(1.2, 1.2, 0.0),
            new Cartesian3D(1.2, 1.2, 1.0)
        });
<span class="fc" id="L460">    }</span>

    @Test
    public void testTetrahedron() throws MathArithmeticException {
        // arrange
<span class="fc" id="L465">        Cartesian3D vertex1 = new Cartesian3D(1, 2, 3);</span>
<span class="fc" id="L466">        Cartesian3D vertex2 = new Cartesian3D(2, 2, 4);</span>
<span class="fc" id="L467">        Cartesian3D vertex3 = new Cartesian3D(2, 3, 3);</span>
<span class="fc" id="L468">        Cartesian3D vertex4 = new Cartesian3D(1, 3, 4);</span>

        // act
<span class="fc" id="L471">        PolyhedronsSet tree =</span>
<span class="fc" id="L472">            (PolyhedronsSet) new RegionFactory&lt;Euclidean3D&gt;().buildConvex(</span>
                new Plane(vertex3, vertex2, vertex1, TEST_TOLERANCE),
                new Plane(vertex2, vertex3, vertex4, TEST_TOLERANCE),
                new Plane(vertex4, vertex3, vertex1, TEST_TOLERANCE),
                new Plane(vertex1, vertex2, vertex4, TEST_TOLERANCE));

        // assert
<span class="fc" id="L479">        Assert.assertEquals(1.0 / 3.0, tree.getSize(), TEST_TOLERANCE);</span>
<span class="fc" id="L480">        Assert.assertEquals(2.0 * FastMath.sqrt(3.0), tree.getBoundarySize(), TEST_TOLERANCE);</span>
<span class="fc" id="L481">        GeometryTestUtils.assertVectorEquals(new Cartesian3D(1.5, 2.5, 3.5), (Cartesian3D) tree.getBarycenter(), TEST_TOLERANCE);</span>

<span class="fc" id="L483">        double third = 1.0 / 3.0;</span>
<span class="fc" id="L484">        checkPoints(Region.Location.BOUNDARY, tree, new Cartesian3D[] {</span>
            vertex1, vertex2, vertex3, vertex4,
            new Cartesian3D(third, vertex1, third, vertex2, third, vertex3),
            new Cartesian3D(third, vertex2, third, vertex3, third, vertex4),
            new Cartesian3D(third, vertex3, third, vertex4, third, vertex1),
            new Cartesian3D(third, vertex4, third, vertex1, third, vertex2)
        });
<span class="fc" id="L491">        checkPoints(Region.Location.OUTSIDE, tree, new Cartesian3D[] {</span>
            new Cartesian3D(1, 2, 4),
            new Cartesian3D(2, 2, 3),
            new Cartesian3D(2, 3, 4),
            new Cartesian3D(1, 3, 3)
        });
<span class="fc" id="L497">    }</span>

    @Test
    public void testSphere() {
        // arrange
        // (use a high tolerance value here since the sphere is only an approximation)
<span class="fc" id="L503">        double approximationTolerance = 0.2;</span>
<span class="fc" id="L504">        double radius = 1.0;</span>

        // act
<span class="fc" id="L507">        PolyhedronsSet polySet = createSphere(new Cartesian3D(1, 2, 3), radius, 8, 16);</span>

        // assert
<span class="fc" id="L510">        Assert.assertEquals(sphereVolume(radius), polySet.getSize(), approximationTolerance);</span>
<span class="fc" id="L511">        Assert.assertEquals(sphereSurface(radius), polySet.getBoundarySize(), approximationTolerance);</span>
<span class="fc" id="L512">        GeometryTestUtils.assertVectorEquals(new Cartesian3D(1, 2, 3), (Cartesian3D) polySet.getBarycenter(), TEST_TOLERANCE);</span>
<span class="fc" id="L513">        Assert.assertFalse(polySet.isEmpty());</span>
<span class="fc" id="L514">        Assert.assertFalse(polySet.isFull());</span>

<span class="fc" id="L516">        checkPoints(Region.Location.OUTSIDE, polySet,</span>
                new Cartesian3D(-0.1, 2, 3),
                new Cartesian3D(2.1, 2, 3),
                new Cartesian3D(1, 0.9, 3),
                new Cartesian3D(1, 3.1, 3),
                new Cartesian3D(1, 2, 1.9),
                new Cartesian3D(1, 2, 4.1),
                new Cartesian3D(1.6, 2.6, 3.6));

<span class="fc" id="L525">        checkPoints(Region.Location.INSIDE, polySet,</span>
                new Cartesian3D(1, 2, 3),
                new Cartesian3D(0.1, 2, 3),
                new Cartesian3D(1.9, 2, 3),
                new Cartesian3D(1, 2.1, 3),
                new Cartesian3D(1, 2.9, 3),
                new Cartesian3D(1, 2, 2.1),
                new Cartesian3D(1, 2, 3.9),
                new Cartesian3D(1.5, 2.5, 3.5));
<span class="fc" id="L534">    }</span>

    @Test
    public void testIsometry() throws MathArithmeticException, MathIllegalArgumentException {
        // arrange
<span class="fc" id="L539">        Cartesian3D vertex1 = new Cartesian3D(1.1, 2.2, 3.3);</span>
<span class="fc" id="L540">        Cartesian3D vertex2 = new Cartesian3D(2.0, 2.4, 4.2);</span>
<span class="fc" id="L541">        Cartesian3D vertex3 = new Cartesian3D(2.8, 3.3, 3.7);</span>
<span class="fc" id="L542">        Cartesian3D vertex4 = new Cartesian3D(1.0, 3.6, 4.5);</span>

        // act
<span class="fc" id="L545">        PolyhedronsSet tree =</span>
<span class="fc" id="L546">            (PolyhedronsSet) new RegionFactory&lt;Euclidean3D&gt;().buildConvex(</span>
                new Plane(vertex3, vertex2, vertex1, TEST_TOLERANCE),
                new Plane(vertex2, vertex3, vertex4, TEST_TOLERANCE),
                new Plane(vertex4, vertex3, vertex1, TEST_TOLERANCE),
                new Plane(vertex1, vertex2, vertex4, TEST_TOLERANCE));

        // assert
<span class="fc" id="L553">        Cartesian3D barycenter = (Cartesian3D) tree.getBarycenter();</span>
<span class="fc" id="L554">        Cartesian3D s = new Cartesian3D(10.2, 4.3, -6.7);</span>
<span class="fc" id="L555">        Cartesian3D c = new Cartesian3D(-0.2, 2.1, -3.2);</span>
<span class="fc" id="L556">        Rotation r = new Rotation(new Cartesian3D(6.2, -4.4, 2.1), 0.12, RotationConvention.VECTOR_OPERATOR);</span>

<span class="fc" id="L558">        tree = tree.rotate(c, r).translate(s);</span>

<span class="fc" id="L560">        Cartesian3D newB =</span>
            new Cartesian3D(1.0, s,
                         1.0, c,
<span class="fc" id="L563">                         1.0, r.applyTo(barycenter.subtract(c)));</span>
<span class="fc" id="L564">        Assert.assertEquals(0.0,</span>
<span class="fc" id="L565">                            newB.subtract((Cartesian3D) tree.getBarycenter()).getNorm(),</span>
                            TEST_TOLERANCE);

<span class="fc" id="L568">        final Cartesian3D[] expectedV = new Cartesian3D[] {</span>
            new Cartesian3D(1.0, s,
                         1.0, c,
<span class="fc" id="L571">                         1.0, r.applyTo(vertex1.subtract(c))),</span>
                         new Cartesian3D(1.0, s,
                                      1.0, c,
<span class="fc" id="L574">                                      1.0, r.applyTo(vertex2.subtract(c))),</span>
                                      new Cartesian3D(1.0, s,
                                                   1.0, c,
<span class="fc" id="L577">                                                   1.0, r.applyTo(vertex3.subtract(c))),</span>
                                                   new Cartesian3D(1.0, s,
                                                                1.0, c,
<span class="fc" id="L580">                                                                1.0, r.applyTo(vertex4.subtract(c)))</span>
        };
<span class="fc" id="L582">        tree.getTree(true).visit(new BSPTreeVisitor&lt;Euclidean3D&gt;() {</span>

            @Override
            public Order visitOrder(BSPTree&lt;Euclidean3D&gt; node) {
<span class="fc" id="L586">                return Order.MINUS_SUB_PLUS;</span>
            }

            @Override
            public void visitInternalNode(BSPTree&lt;Euclidean3D&gt; node) {
                @SuppressWarnings(&quot;unchecked&quot;)
<span class="fc" id="L592">                BoundaryAttribute&lt;Euclidean3D&gt; attribute =</span>
<span class="fc" id="L593">                    (BoundaryAttribute&lt;Euclidean3D&gt;) node.getAttribute();</span>
<span class="pc bpc" id="L594" title="1 of 2 branches missed.">                if (attribute.getPlusOutside() != null) {</span>
<span class="fc" id="L595">                    checkFacet((SubPlane) attribute.getPlusOutside());</span>
                }
<span class="pc bpc" id="L597" title="1 of 2 branches missed.">                if (attribute.getPlusInside() != null) {</span>
<span class="nc" id="L598">                    checkFacet((SubPlane) attribute.getPlusInside());</span>
                }
<span class="fc" id="L600">            }</span>

            @Override
            public void visitLeafNode(BSPTree&lt;Euclidean3D&gt; node) {
<span class="fc" id="L604">            }</span>

            private void checkFacet(SubPlane facet) {
<span class="fc" id="L607">                Plane plane = (Plane) facet.getHyperplane();</span>
<span class="fc" id="L608">                Cartesian2D[][] vertices =</span>
<span class="fc" id="L609">                    ((PolygonsSet) facet.getRemainingRegion()).getVertices();</span>
<span class="fc" id="L610">                Assert.assertEquals(1, vertices.length);</span>
<span class="fc bfc" id="L611" title="All 2 branches covered.">                for (int i = 0; i &lt; vertices[0].length; ++i) {</span>
<span class="fc" id="L612">                    Cartesian3D v = plane.toSpace(vertices[0][i]);</span>
<span class="fc" id="L613">                    double d = Double.POSITIVE_INFINITY;</span>
<span class="fc bfc" id="L614" title="All 2 branches covered.">                    for (int k = 0; k &lt; expectedV.length; ++k) {</span>
<span class="fc" id="L615">                        d = FastMath.min(d, v.subtract(expectedV[k]).getNorm());</span>
                    }
<span class="fc" id="L617">                    Assert.assertEquals(0, d, TEST_TOLERANCE);</span>
                }
<span class="fc" id="L619">            }</span>

        });

<span class="fc" id="L623">    }</span>

    @Test
    public void testBuildBox() {
        // arrange
<span class="fc" id="L628">        double x = 1.0;</span>
<span class="fc" id="L629">        double y = 2.0;</span>
<span class="fc" id="L630">        double z = 3.0;</span>
<span class="fc" id="L631">        double w = 0.1;</span>
<span class="fc" id="L632">        double l = 1.0;</span>

        // act
<span class="fc" id="L635">        PolyhedronsSet tree =</span>
            new PolyhedronsSet(x - l, x + l, y - w, y + w, z - w, z + w, TEST_TOLERANCE);

        // assert
<span class="fc" id="L639">        GeometryTestUtils.assertVectorEquals(new Cartesian3D(x, y, z), (Cartesian3D) tree.getBarycenter(), TEST_TOLERANCE);</span>
<span class="fc" id="L640">        Assert.assertEquals(8 * l * w * w, tree.getSize(), TEST_TOLERANCE);</span>
<span class="fc" id="L641">        Assert.assertEquals(8 * w * (2 * l + w), tree.getBoundarySize(), TEST_TOLERANCE);</span>
<span class="fc" id="L642">    }</span>

    @Test
    public void testCross() {
        // arrange
<span class="fc" id="L647">        double x = 1.0;</span>
<span class="fc" id="L648">        double y = 2.0;</span>
<span class="fc" id="L649">        double z = 3.0;</span>
<span class="fc" id="L650">        double w = 0.1;</span>
<span class="fc" id="L651">        double l = 1.0;</span>
<span class="fc" id="L652">        PolyhedronsSet xBeam =</span>
            new PolyhedronsSet(x - l, x + l, y - w, y + w, z - w, z + w, TEST_TOLERANCE);
<span class="fc" id="L654">        PolyhedronsSet yBeam =</span>
            new PolyhedronsSet(x - w, x + w, y - l, y + l, z - w, z + w, TEST_TOLERANCE);
<span class="fc" id="L656">        PolyhedronsSet zBeam =</span>
            new PolyhedronsSet(x - w, x + w, y - w, y + w, z - l, z + l, TEST_TOLERANCE);
<span class="fc" id="L658">        RegionFactory&lt;Euclidean3D&gt; factory = new RegionFactory&lt;&gt;();</span>

        // act
<span class="fc" id="L661">        PolyhedronsSet tree = (PolyhedronsSet) factory.union(xBeam, factory.union(yBeam, zBeam));</span>

        // assert
<span class="fc" id="L664">        GeometryTestUtils.assertVectorEquals(new Cartesian3D(x, y, z), (Cartesian3D) tree.getBarycenter(), TEST_TOLERANCE);</span>
<span class="fc" id="L665">        Assert.assertEquals(8 * w * w * (3 * l - 2 * w), tree.getSize(), TEST_TOLERANCE);</span>
<span class="fc" id="L666">        Assert.assertEquals(24 * w * (2 * l - w), tree.getBoundarySize(), TEST_TOLERANCE);</span>
<span class="fc" id="L667">    }</span>

    // Issue MATH-780
    // See https://issues.apache.org/jira/browse/MATH-780
    @Test
    public void testCreateFromBoundaries_handlesSmallBoundariesCreatedDuringConstruction() throws MathArithmeticException {
        // arrange
<span class="fc" id="L674">        float[] coords = {</span>
            1.000000f, -1.000000f, -1.000000f,
            1.000000f, -1.000000f, 1.000000f,
            -1.000000f, -1.000000f, 1.000000f,
            -1.000000f, -1.000000f, -1.000000f,
            1.000000f, 1.000000f, -1f,
            0.999999f, 1.000000f, 1.000000f,   // 1.000000f, 1.000000f, 1.000000f,
            -1.000000f, 1.000000f, 1.000000f,
            -1.000000f, 1.000000f, -1.000000f};
<span class="fc" id="L683">        int[] indices = {</span>
            0, 1, 2, 0, 2, 3,
            4, 7, 6, 4, 6, 5,
            0, 4, 5, 0, 5, 1,
            1, 5, 6, 1, 6, 2,
            2, 6, 7, 2, 7, 3,
            4, 0, 3, 4, 3, 7};
<span class="fc" id="L690">        ArrayList&lt;SubHyperplane&lt;Euclidean3D&gt;&gt; subHyperplaneList = new ArrayList&lt;&gt;();</span>
<span class="fc bfc" id="L691" title="All 2 branches covered.">        for (int idx = 0; idx &lt; indices.length; idx += 3) {</span>
<span class="fc" id="L692">            int idxA = indices[idx] * 3;</span>
<span class="fc" id="L693">            int idxB = indices[idx + 1] * 3;</span>
<span class="fc" id="L694">            int idxC = indices[idx + 2] * 3;</span>
<span class="fc" id="L695">            Cartesian3D v_1 = new Cartesian3D(coords[idxA], coords[idxA + 1], coords[idxA + 2]);</span>
<span class="fc" id="L696">            Cartesian3D v_2 = new Cartesian3D(coords[idxB], coords[idxB + 1], coords[idxB + 2]);</span>
<span class="fc" id="L697">            Cartesian3D v_3 = new Cartesian3D(coords[idxC], coords[idxC + 1], coords[idxC + 2]);</span>
<span class="fc" id="L698">            Cartesian3D[] vertices = {v_1, v_2, v_3};</span>
<span class="fc" id="L699">            Plane polyPlane = new Plane(v_1, v_2, v_3, TEST_TOLERANCE);</span>
<span class="fc" id="L700">            ArrayList&lt;SubHyperplane&lt;Euclidean2D&gt;&gt; lines = new ArrayList&lt;&gt;();</span>

<span class="fc" id="L702">            Cartesian2D[] projPts = new Cartesian2D[vertices.length];</span>
<span class="fc bfc" id="L703" title="All 2 branches covered.">            for (int ptIdx = 0; ptIdx &lt; projPts.length; ptIdx++) {</span>
<span class="fc" id="L704">                projPts[ptIdx] = polyPlane.toSubSpace(vertices[ptIdx]);</span>
            }

<span class="fc" id="L707">            SubLine lineInPlane = null;</span>
<span class="fc bfc" id="L708" title="All 2 branches covered.">            for (int ptIdx = 0; ptIdx &lt; projPts.length; ptIdx++) {</span>
<span class="fc" id="L709">                lineInPlane = new SubLine(projPts[ptIdx], projPts[(ptIdx + 1) % projPts.length], TEST_TOLERANCE);</span>
<span class="fc" id="L710">                lines.add(lineInPlane);</span>
            }
<span class="fc" id="L712">            Region&lt;Euclidean2D&gt; polyRegion = new PolygonsSet(lines, TEST_TOLERANCE);</span>
<span class="fc" id="L713">            SubPlane polygon = new SubPlane(polyPlane, polyRegion);</span>
<span class="fc" id="L714">            subHyperplaneList.add(polygon);</span>
        }

        // act
<span class="fc" id="L718">        PolyhedronsSet polyhedronsSet = new PolyhedronsSet(subHyperplaneList, TEST_TOLERANCE);</span>

        // assert
<span class="fc" id="L721">        Assert.assertEquals(8.0, polyhedronsSet.getSize(), 3.0e-6);</span>
<span class="fc" id="L722">        Assert.assertEquals(24.0, polyhedronsSet.getBoundarySize(), 5.0e-6);</span>
<span class="fc" id="L723">    }</span>

    @Test
    public void testTooThinBox() {
        // act
<span class="fc" id="L728">        PolyhedronsSet polyhedronsSet = new PolyhedronsSet(0.0, 0.0, 0.0, 1.0, 0.0, 1.0, TEST_TOLERANCE);</span>

        // assert
<span class="fc" id="L731">        Assert.assertEquals(0.0, polyhedronsSet.getSize(), TEST_TOLERANCE);</span>
<span class="fc" id="L732">    }</span>

    @Test
    public void testWrongUsage() {
        // the following is a wrong usage of the constructor.
        // as explained in the javadoc, the failure is NOT detected at construction
        // time but occurs later on
<span class="fc" id="L739">        PolyhedronsSet ps = new PolyhedronsSet(new BSPTree&lt;Euclidean3D&gt;(), TEST_TOLERANCE);</span>
<span class="fc" id="L740">        Assert.assertNotNull(ps);</span>
        try {
<span class="nc" id="L742">            ps.checkPoint(Cartesian3D.ZERO);</span>
<span class="nc" id="L743">            Assert.fail(&quot;an exception should have been thrown&quot;);</span>
<span class="fc" id="L744">        } catch (NullPointerException npe) {</span>
            // this is expected
<span class="nc" id="L746">        }</span>
<span class="fc" id="L747">    }</span>

    @Test
    public void testDumpParse() throws IOException, ParseException {
        // arrange
<span class="fc" id="L752">        double tol=1e-8;</span>

<span class="fc" id="L754">        Cartesian3D[] verts=new Cartesian3D[8];</span>
<span class="fc" id="L755">        double xmin=-1,xmax=1;</span>
<span class="fc" id="L756">        double ymin=-1,ymax=1;</span>
<span class="fc" id="L757">        double zmin=-1,zmax=1;</span>
<span class="fc" id="L758">        verts[0]=new Cartesian3D(xmin,ymin,zmin);</span>
<span class="fc" id="L759">        verts[1]=new Cartesian3D(xmax,ymin,zmin);</span>
<span class="fc" id="L760">        verts[2]=new Cartesian3D(xmax,ymax,zmin);</span>
<span class="fc" id="L761">        verts[3]=new Cartesian3D(xmin,ymax,zmin);</span>
<span class="fc" id="L762">        verts[4]=new Cartesian3D(xmin,ymin,zmax);</span>
<span class="fc" id="L763">        verts[5]=new Cartesian3D(xmax,ymin,zmax);</span>
<span class="fc" id="L764">        verts[6]=new Cartesian3D(xmax,ymax,zmax);</span>
<span class="fc" id="L765">        verts[7]=new Cartesian3D(xmin,ymax,zmax);</span>
        //
<span class="fc" id="L767">        int[][] faces=new int[12][];</span>
<span class="fc" id="L768">        faces[0]=new int[]{3,1,0};  // bottom (-z)</span>
<span class="fc" id="L769">        faces[1]=new int[]{1,3,2};  // bottom (-z)</span>
<span class="fc" id="L770">        faces[2]=new int[]{5,7,4};  // top (+z)</span>
<span class="fc" id="L771">        faces[3]=new int[]{7,5,6};  // top (+z)</span>
<span class="fc" id="L772">        faces[4]=new int[]{2,5,1};  // right (+x)</span>
<span class="fc" id="L773">        faces[5]=new int[]{5,2,6};  // right (+x)</span>
<span class="fc" id="L774">        faces[6]=new int[]{4,3,0};  // left (-x)</span>
<span class="fc" id="L775">        faces[7]=new int[]{3,4,7};  // left (-x)</span>
<span class="fc" id="L776">        faces[8]=new int[]{4,1,5};  // front (-y)</span>
<span class="fc" id="L777">        faces[9]=new int[]{1,4,0};  // front (-y)</span>
<span class="fc" id="L778">        faces[10]=new int[]{3,6,2}; // back (+y)</span>
<span class="fc" id="L779">        faces[11]=new int[]{6,3,7}; // back (+y)</span>

<span class="fc" id="L781">        PolyhedronsSet polyset = new PolyhedronsSet(Arrays.asList(verts), Arrays.asList(faces), tol);</span>

        // act
<span class="fc" id="L784">        String dump = RegionDumper.dump(polyset);</span>
<span class="fc" id="L785">        PolyhedronsSet parsed = RegionParser.parsePolyhedronsSet(dump);</span>

        // assert
<span class="fc" id="L788">        Assert.assertEquals(8.0, polyset.getSize(), TEST_TOLERANCE);</span>
<span class="fc" id="L789">        Assert.assertEquals(24.0, polyset.getBoundarySize(), TEST_TOLERANCE);</span>

<span class="fc" id="L791">        Assert.assertEquals(8.0, parsed.getSize(), TEST_TOLERANCE);</span>
<span class="fc" id="L792">        Assert.assertEquals(24.0, parsed.getBoundarySize(), TEST_TOLERANCE);</span>
<span class="fc" id="L793">        Assert.assertTrue(new RegionFactory&lt;Euclidean3D&gt;().difference(polyset, parsed).isEmpty());</span>
<span class="fc" id="L794">    }</span>

    @Test
    public void testCreateFromBRep_connectedFacets() throws IOException, ParseException {
<span class="fc" id="L798">        InputStream stream = getClass().getResourceAsStream(&quot;pentomino-N.ply&quot;);</span>
<span class="fc" id="L799">        PLYParser   parser = new PLYParser(stream);</span>
<span class="fc" id="L800">        stream.close();</span>
<span class="fc" id="L801">        PolyhedronsSet polyhedron = new PolyhedronsSet(parser.getVertices(), parser.getFaces(), TEST_TOLERANCE);</span>
<span class="fc" id="L802">        Assert.assertEquals( 5.0, polyhedron.getSize(), TEST_TOLERANCE);</span>
<span class="fc" id="L803">        Assert.assertEquals(22.0, polyhedron.getBoundarySize(), TEST_TOLERANCE);</span>
<span class="fc" id="L804">    }</span>

    @Test
    public void testCreateFromBRep_verticesTooClose() throws IOException, ParseException {
<span class="fc" id="L808">        checkError(&quot;pentomino-N-too-close.ply&quot;, LocalizedFormats.CLOSE_VERTICES);</span>
<span class="fc" id="L809">    }</span>

    @Test
    public void testCreateFromBRep_hole() throws IOException, ParseException {
<span class="fc" id="L813">        checkError(&quot;pentomino-N-hole.ply&quot;, LocalizedFormats.EDGE_CONNECTED_TO_ONE_FACET);</span>
<span class="fc" id="L814">    }</span>

    @Test
    public void testCreateFromBRep_nonPlanar() throws IOException, ParseException {
<span class="fc" id="L818">        checkError(&quot;pentomino-N-out-of-plane.ply&quot;, LocalizedFormats.OUT_OF_PLANE);</span>
<span class="fc" id="L819">    }</span>

    @Test
    public void testCreateFromBRep_badOrientation() throws IOException, ParseException {
<span class="fc" id="L823">        checkError(&quot;pentomino-N-bad-orientation.ply&quot;, LocalizedFormats.FACET_ORIENTATION_MISMATCH);</span>
<span class="fc" id="L824">    }</span>

    @Test
    public void testCreateFromBRep_wrongNumberOfPoints() throws IOException, ParseException {
<span class="fc" id="L828">        checkError(Arrays.asList(Cartesian3D.ZERO, Cartesian3D.PLUS_I, Cartesian3D.PLUS_J, Cartesian3D.PLUS_K),</span>
<span class="fc" id="L829">                   Arrays.asList(new int[] { 0, 1, 2 }, new int[] {2, 3}),</span>
                   LocalizedFormats.WRONG_NUMBER_OF_POINTS);
<span class="fc" id="L831">    }</span>

    private void checkError(final String resourceName, final LocalizedFormats expected) {
<span class="fc" id="L834">        try (InputStream stream = getClass().getResourceAsStream(resourceName)) {</span>
<span class="fc" id="L835">            PLYParser   parser = new PLYParser(stream);</span>
<span class="fc" id="L836">            checkError(parser.getVertices(), parser.getFaces(), expected);</span>
<span class="nc" id="L837">        } catch (IOException ioe) {</span>
<span class="nc" id="L838">            Assert.fail(ioe.getLocalizedMessage());</span>
<span class="nc" id="L839">        } catch (ParseException pe) {</span>
<span class="nc" id="L840">            Assert.fail(pe.getLocalizedMessage());</span>
<span class="pc" id="L841">        }</span>
<span class="fc" id="L842">    }</span>

    private void checkError(final List&lt;Cartesian3D&gt; vertices, final List&lt;int[]&gt; facets,
                            final LocalizedFormats expected) {
        try {
<span class="nc" id="L847">            new PolyhedronsSet(vertices, facets, TEST_TOLERANCE);</span>
<span class="nc" id="L848">            Assert.fail(&quot;an exception should have been thrown&quot;);</span>
<span class="fc" id="L849">        } catch (MathIllegalArgumentException miae) {</span>
            try {
<span class="fc" id="L851">                Field msgPatterns = ExceptionContext.class.getDeclaredField(&quot;msgPatterns&quot;);</span>
<span class="fc" id="L852">                msgPatterns.setAccessible(true);</span>
                @SuppressWarnings(&quot;unchecked&quot;)
<span class="fc" id="L854">                List&lt;Localizable&gt; list = (List&lt;Localizable&gt;) msgPatterns.get(miae.getContext());</span>
<span class="fc" id="L855">                Assert.assertEquals(expected, list.get(0));</span>
<span class="nc" id="L856">            } catch (NoSuchFieldException nsfe) {</span>
<span class="nc" id="L857">                Assert.fail(nsfe.getLocalizedMessage());</span>
<span class="nc" id="L858">            } catch (IllegalAccessException iae) {</span>
<span class="nc" id="L859">                Assert.fail(iae.getLocalizedMessage());</span>
<span class="pc" id="L860">            }</span>
<span class="nc" id="L861">        }</span>
<span class="fc" id="L862">    }</span>

    @Test
    public void testFirstIntersection() {
        // arrange
<span class="fc" id="L867">        List&lt;SubHyperplane&lt;Euclidean3D&gt;&gt; boundaries = createBoxBoundaries(Cartesian3D.ZERO, 2.0, TEST_TOLERANCE);</span>
<span class="fc" id="L868">        PolyhedronsSet polySet = new PolyhedronsSet(boundaries, TEST_TOLERANCE);</span>

<span class="fc" id="L870">        Line xPlus = new Line(Cartesian3D.ZERO, Cartesian3D.PLUS_I, TEST_TOLERANCE);</span>
<span class="fc" id="L871">        Line xMinus = new Line(Cartesian3D.ZERO, Cartesian3D.MINUS_I, TEST_TOLERANCE);</span>

<span class="fc" id="L873">        Line yPlus = new Line(Cartesian3D.ZERO, Cartesian3D.PLUS_J, TEST_TOLERANCE);</span>
<span class="fc" id="L874">        Line yMinus = new Line(Cartesian3D.ZERO, Cartesian3D.MINUS_J, TEST_TOLERANCE);</span>

<span class="fc" id="L876">        Line zPlus = new Line(Cartesian3D.ZERO, Cartesian3D.PLUS_K, TEST_TOLERANCE);</span>
<span class="fc" id="L877">        Line zMinus = new Line(Cartesian3D.ZERO, Cartesian3D.MINUS_K, TEST_TOLERANCE);</span>

        // act/assert
<span class="fc" id="L880">        assertSubPlaneNormal(new Cartesian3D(-1, 0, 0), polySet.firstIntersection(new Cartesian3D(-1.1, 0, 0), xPlus));</span>
<span class="fc" id="L881">        assertSubPlaneNormal(new Cartesian3D(-1, 0, 0), polySet.firstIntersection(new Cartesian3D(-1, 0, 0), xPlus));</span>
<span class="fc" id="L882">        assertSubPlaneNormal(new Cartesian3D(1, 0, 0), polySet.firstIntersection(new Cartesian3D(-0.9, 0, 0), xPlus));</span>
<span class="fc" id="L883">        Assert.assertEquals(null, polySet.firstIntersection(new Cartesian3D(1.1, 0, 0), xPlus));</span>

<span class="fc" id="L885">        assertSubPlaneNormal(new Cartesian3D(1, 0, 0), polySet.firstIntersection(new Cartesian3D(1.1, 0, 0), xMinus));</span>
<span class="fc" id="L886">        assertSubPlaneNormal(new Cartesian3D(1, 0, 0), polySet.firstIntersection(new Cartesian3D(1, 0, 0), xMinus));</span>
<span class="fc" id="L887">        assertSubPlaneNormal(new Cartesian3D(-1, 0, 0), polySet.firstIntersection(new Cartesian3D(0.9, 0, 0), xMinus));</span>
<span class="fc" id="L888">        Assert.assertEquals(null, polySet.firstIntersection(new Cartesian3D(-1.1, 0, 0), xMinus));</span>

<span class="fc" id="L890">        assertSubPlaneNormal(new Cartesian3D(0, -1, 0), polySet.firstIntersection(new Cartesian3D(0, -1.1, 0), yPlus));</span>
<span class="fc" id="L891">        assertSubPlaneNormal(new Cartesian3D(0, -1, 0), polySet.firstIntersection(new Cartesian3D(0, -1, 0), yPlus));</span>
<span class="fc" id="L892">        assertSubPlaneNormal(new Cartesian3D(0, 1, 0), polySet.firstIntersection(new Cartesian3D(0, -0.9, 0), yPlus));</span>
<span class="fc" id="L893">        Assert.assertEquals(null, polySet.firstIntersection(new Cartesian3D(0, 1.1, 0), yPlus));</span>

<span class="fc" id="L895">        assertSubPlaneNormal(new Cartesian3D(0, 1, 0), polySet.firstIntersection(new Cartesian3D(0, 1.1, 0), yMinus));</span>
<span class="fc" id="L896">        assertSubPlaneNormal(new Cartesian3D(0, 1, 0), polySet.firstIntersection(new Cartesian3D(0, 1, 0), yMinus));</span>
<span class="fc" id="L897">        assertSubPlaneNormal(new Cartesian3D(0, -1, 0), polySet.firstIntersection(new Cartesian3D(0, 0.9, 0), yMinus));</span>
<span class="fc" id="L898">        Assert.assertEquals(null, polySet.firstIntersection(new Cartesian3D(0, -1.1, 0), yMinus));</span>

<span class="fc" id="L900">        assertSubPlaneNormal(new Cartesian3D(0, 0, -1), polySet.firstIntersection(new Cartesian3D(0, 0, -1.1), zPlus));</span>
<span class="fc" id="L901">        assertSubPlaneNormal(new Cartesian3D(0, 0, -1), polySet.firstIntersection(new Cartesian3D(0, 0, -1), zPlus));</span>
<span class="fc" id="L902">        assertSubPlaneNormal(new Cartesian3D(0, 0, 1), polySet.firstIntersection(new Cartesian3D(0, 0, -0.9), zPlus));</span>
<span class="fc" id="L903">        Assert.assertEquals(null, polySet.firstIntersection(new Cartesian3D(0, 0, 1.1), zPlus));</span>

<span class="fc" id="L905">        assertSubPlaneNormal(new Cartesian3D(0, 0, 1), polySet.firstIntersection(new Cartesian3D(0, 0, 1.1), zMinus));</span>
<span class="fc" id="L906">        assertSubPlaneNormal(new Cartesian3D(0, 0, 1), polySet.firstIntersection(new Cartesian3D(0, 0, 1), zMinus));</span>
<span class="fc" id="L907">        assertSubPlaneNormal(new Cartesian3D(0, 0, -1), polySet.firstIntersection(new Cartesian3D(0, 0, 0.9), zMinus));</span>
<span class="fc" id="L908">        Assert.assertEquals(null, polySet.firstIntersection(new Cartesian3D(0, 0, -1.1), zMinus));</span>
<span class="fc" id="L909">    }</span>

    // Issue 1211
    // See https://issues.apache.org/jira/browse/MATH-1211
    @Test
    public void testFirstIntersection_onlyReturnsPointsInDirectionOfRay() throws IOException, ParseException {
        // arrange
<span class="fc" id="L916">        PolyhedronsSet polyset = RegionParser.parsePolyhedronsSet(loadTestData(&quot;issue-1211.bsp&quot;));</span>
<span class="fc" id="L917">        UniformRandomProvider random = RandomSource.create(RandomSource.WELL_1024_A, 0xb97c9d1ade21e40al);</span>

        // act/assert
<span class="fc" id="L920">        int nrays = 1000;</span>
<span class="fc bfc" id="L921" title="All 2 branches covered.">        for (int i = 0; i &lt; nrays; i++) {</span>
<span class="fc" id="L922">            Cartesian3D origin    = Cartesian3D.ZERO;</span>
<span class="fc" id="L923">            Cartesian3D direction = new Cartesian3D(2 * random.nextDouble() - 1,</span>
<span class="fc" id="L924">                                              2 * random.nextDouble() - 1,</span>
<span class="fc" id="L925">                                              2 * random.nextDouble() - 1).normalize();</span>
<span class="fc" id="L926">            Line line = new Line(origin, origin.add(direction), polyset.getTolerance());</span>
<span class="fc" id="L927">            SubHyperplane&lt;Euclidean3D&gt; plane = polyset.firstIntersection(origin, line);</span>
<span class="pc bpc" id="L928" title="1 of 2 branches missed.">            if (plane != null) {</span>
<span class="fc" id="L929">                Cartesian3D intersectionPoint = ((Plane)plane.getHyperplane()).intersection(line);</span>
<span class="fc" id="L930">                double dotProduct = direction.dotProduct(intersectionPoint.subtract(origin));</span>
<span class="pc bpc" id="L931" title="1 of 2 branches missed.">                Assert.assertTrue(dotProduct &gt; 0);</span>
            }
        }
<span class="fc" id="L934">    }</span>

    @Test
    public void testBoolean_union() throws IOException {
        // arrange
<span class="fc" id="L939">        double tolerance = 0.05;</span>
<span class="fc" id="L940">        double size = 1.0;</span>
<span class="fc" id="L941">        double radius = size * 0.5;</span>
<span class="fc" id="L942">        PolyhedronsSet box = new PolyhedronsSet(0, size, 0, size, 0, size, TEST_TOLERANCE);</span>
<span class="fc" id="L943">        PolyhedronsSet sphere = createSphere(new Cartesian3D(size * 0.5, size * 0.5, size), radius, 8, 16);</span>

        // act
<span class="fc" id="L946">        PolyhedronsSet result = (PolyhedronsSet) new RegionFactory&lt;Euclidean3D&gt;().union(box, sphere);</span>

        // OBJWriter.write(&quot;union.obj&quot;, result);

        // assert
<span class="fc" id="L951">        Assert.assertEquals(cubeVolume(size) + (sphereVolume(radius) * 0.5),</span>
<span class="fc" id="L952">                result.getSize(), tolerance);</span>
<span class="fc" id="L953">        Assert.assertEquals(cubeSurface(size) - circleSurface(radius) + (0.5 * sphereSurface(radius)),</span>
<span class="fc" id="L954">                result.getBoundarySize(), tolerance);</span>
<span class="fc" id="L955">        Assert.assertFalse(result.isEmpty());</span>
<span class="fc" id="L956">        Assert.assertFalse(result.isFull());</span>

<span class="fc" id="L958">        checkPoints(Region.Location.OUTSIDE, result,</span>
                new Cartesian3D(-0.1, 0.5, 0.5),
                new Cartesian3D(1.1, 0.5, 0.5),
                new Cartesian3D(0.5, -0.1, 0.5),
                new Cartesian3D(0.5, 1.1, 0.5),
                new Cartesian3D(0.5, 0.5, -0.1),
                new Cartesian3D(0.5, 0.5, 1.6));

<span class="fc" id="L966">        checkPoints(Region.Location.INSIDE, result,</span>
                new Cartesian3D(0.1, 0.5, 0.5),
                new Cartesian3D(0.9, 0.5, 0.5),
                new Cartesian3D(0.5, 0.1, 0.5),
                new Cartesian3D(0.5, 0.9, 0.5),
                new Cartesian3D(0.5, 0.5, 0.1),
                new Cartesian3D(0.5, 0.5, 1.4));
<span class="fc" id="L973">    }</span>

    @Test
    public void testUnion_self() {
        // arrange
<span class="fc" id="L978">        double tolerance = 0.2;</span>
<span class="fc" id="L979">        double radius = 1.0;</span>

<span class="fc" id="L981">        PolyhedronsSet sphere = createSphere(Cartesian3D.ZERO, radius, 8, 16);</span>

        // act
<span class="fc" id="L984">        PolyhedronsSet result = (PolyhedronsSet) new RegionFactory&lt;Euclidean3D&gt;().union(sphere, sphere.copySelf());</span>

        // assert
<span class="fc" id="L987">        Assert.assertEquals(sphereVolume(radius), result.getSize(), tolerance);</span>
<span class="fc" id="L988">        Assert.assertEquals(sphereSurface(radius), result.getBoundarySize(), tolerance);</span>
<span class="fc" id="L989">        GeometryTestUtils.assertVectorEquals(Cartesian3D.ZERO, (Cartesian3D) result.getBarycenter(), TEST_TOLERANCE);</span>
<span class="fc" id="L990">        Assert.assertFalse(result.isEmpty());</span>
<span class="fc" id="L991">        Assert.assertFalse(result.isFull());</span>

<span class="fc" id="L993">        checkPoints(Region.Location.OUTSIDE, result,</span>
                new Cartesian3D(-1.1, 0, 0),
                new Cartesian3D(1.1, 0, 0),
                new Cartesian3D(0, -1.1, 0),
                new Cartesian3D(0, 1.1, 0),
                new Cartesian3D(0, 0, -1.1),
                new Cartesian3D(0, 0, 1.1));

<span class="fc" id="L1001">        checkPoints(Region.Location.INSIDE, result,</span>
                new Cartesian3D(-0.9, 0, 0),
                new Cartesian3D(0.9, 0, 0),
                new Cartesian3D(0, -0.9, 0),
                new Cartesian3D(0, 0.9, 0),
                new Cartesian3D(0, 0, -0.9),
                new Cartesian3D(0, 0, 0.9),
                Cartesian3D.ZERO);
<span class="fc" id="L1009">    }</span>

    @Test
    public void testBoolean_intersection() throws IOException {
        // arrange
<span class="fc" id="L1014">        double tolerance = 0.05;</span>
<span class="fc" id="L1015">        double size = 1.0;</span>
<span class="fc" id="L1016">        double radius = size * 0.5;</span>
<span class="fc" id="L1017">        PolyhedronsSet box = new PolyhedronsSet(0, size, 0, size, 0, size, TEST_TOLERANCE);</span>
<span class="fc" id="L1018">        PolyhedronsSet sphere = createSphere(new Cartesian3D(size * 0.5, size * 0.5, size), radius, 8, 16);</span>

        // act
<span class="fc" id="L1021">        PolyhedronsSet result = (PolyhedronsSet) new RegionFactory&lt;Euclidean3D&gt;().intersection(box, sphere);</span>

        // OBJWriter.write(&quot;intersection.obj&quot;, result);

        // assert
<span class="fc" id="L1026">        Assert.assertEquals((sphereVolume(radius) * 0.5), result.getSize(), tolerance);</span>
<span class="fc" id="L1027">        Assert.assertEquals(circleSurface(radius) + (0.5 * sphereSurface(radius)),</span>
<span class="fc" id="L1028">                result.getBoundarySize(), tolerance);</span>
<span class="fc" id="L1029">        Assert.assertFalse(result.isEmpty());</span>
<span class="fc" id="L1030">        Assert.assertFalse(result.isFull());</span>

<span class="fc" id="L1032">        checkPoints(Region.Location.OUTSIDE, result,</span>
                new Cartesian3D(-0.1, 0.5, 1.0),
                new Cartesian3D(1.1, 0.5, 1.0),
                new Cartesian3D(0.5, -0.1, 1.0),
                new Cartesian3D(0.5, 1.1, 1.0),
                new Cartesian3D(0.5, 0.5, 0.4),
                new Cartesian3D(0.5, 0.5, 1.1));

<span class="fc" id="L1040">        checkPoints(Region.Location.INSIDE, result,</span>
                new Cartesian3D(0.1, 0.5, 0.9),
                new Cartesian3D(0.9, 0.5, 0.9),
                new Cartesian3D(0.5, 0.1, 0.9),
                new Cartesian3D(0.5, 0.9, 0.9),
                new Cartesian3D(0.5, 0.5, 0.6),
                new Cartesian3D(0.5, 0.5, 0.9));
<span class="fc" id="L1047">    }</span>

    @Test
    public void testIntersection_self() {
        // arrange
<span class="fc" id="L1052">        double tolerance = 0.2;</span>
<span class="fc" id="L1053">        double radius = 1.0;</span>

<span class="fc" id="L1055">        PolyhedronsSet sphere = createSphere(Cartesian3D.ZERO, radius, 8, 16);</span>

        // act
<span class="fc" id="L1058">        PolyhedronsSet result = (PolyhedronsSet) new RegionFactory&lt;Euclidean3D&gt;().intersection(sphere, sphere.copySelf());</span>

        // assert
<span class="fc" id="L1061">        Assert.assertEquals(sphereVolume(radius), result.getSize(), tolerance);</span>
<span class="fc" id="L1062">        Assert.assertEquals(sphereSurface(radius), result.getBoundarySize(), tolerance);</span>
<span class="fc" id="L1063">        GeometryTestUtils.assertVectorEquals(Cartesian3D.ZERO, (Cartesian3D) result.getBarycenter(), TEST_TOLERANCE);</span>
<span class="fc" id="L1064">        Assert.assertFalse(result.isEmpty());</span>
<span class="fc" id="L1065">        Assert.assertFalse(result.isFull());</span>

<span class="fc" id="L1067">        checkPoints(Region.Location.OUTSIDE, result,</span>
                new Cartesian3D(-1.1, 0, 0),
                new Cartesian3D(1.1, 0, 0),
                new Cartesian3D(0, -1.1, 0),
                new Cartesian3D(0, 1.1, 0),
                new Cartesian3D(0, 0, -1.1),
                new Cartesian3D(0, 0, 1.1));

<span class="fc" id="L1075">        checkPoints(Region.Location.INSIDE, result,</span>
                new Cartesian3D(-0.9, 0, 0),
                new Cartesian3D(0.9, 0, 0),
                new Cartesian3D(0, -0.9, 0),
                new Cartesian3D(0, 0.9, 0),
                new Cartesian3D(0, 0, -0.9),
                new Cartesian3D(0, 0, 0.9),
                Cartesian3D.ZERO);
<span class="fc" id="L1083">    }</span>

    @Test
    public void testBoolean_xor_twoCubes() throws IOException {
        // arrange
<span class="fc" id="L1088">        double size = 1.0;</span>
<span class="fc" id="L1089">        PolyhedronsSet box1 = new PolyhedronsSet(</span>
                0, size,
                0, size,
                0, size, TEST_TOLERANCE);
<span class="fc" id="L1093">        PolyhedronsSet box2 = new PolyhedronsSet(</span>
                0.5, size + 0.5,
                0.5, size + 0.5,
                0.5, size + 0.5, TEST_TOLERANCE);

        // act
<span class="fc" id="L1099">        PolyhedronsSet result = (PolyhedronsSet) new RegionFactory&lt;Euclidean3D&gt;().xor(box1, box2);</span>

        // OBJWriter.write(&quot;xor_twoCubes.obj&quot;, result);

<span class="fc" id="L1103">        Assert.assertEquals((2 * cubeVolume(size)) - (2 * cubeVolume(size * 0.5)), result.getSize(), TEST_TOLERANCE);</span>

        // assert
<span class="fc" id="L1106">        Assert.assertEquals(2 * cubeSurface(size), result.getBoundarySize(), TEST_TOLERANCE);</span>
<span class="fc" id="L1107">        Assert.assertFalse(result.isEmpty());</span>
<span class="fc" id="L1108">        Assert.assertFalse(result.isFull());</span>

<span class="fc" id="L1110">        checkPoints(Region.Location.OUTSIDE, result,</span>
                new Cartesian3D(-0.1, -0.1, -0.1),
                new Cartesian3D(0.75, 0.75, 0.75),
                new Cartesian3D(1.6, 1.6, 1.6));

<span class="fc" id="L1115">        checkPoints(Region.Location.BOUNDARY, result,</span>
                new Cartesian3D(0, 0, 0),
                new Cartesian3D(0.5, 0.5, 0.5),
                new Cartesian3D(1, 1, 1),
                new Cartesian3D(1.5, 1.5, 1.5));

<span class="fc" id="L1121">        checkPoints(Region.Location.INSIDE, result,</span>
                new Cartesian3D(0.1, 0.1, 0.1),
                new Cartesian3D(0.4, 0.4, 0.4),
                new Cartesian3D(1.1, 1.1, 1.1),
                new Cartesian3D(1.4, 1.4, 1.4));
<span class="fc" id="L1126">    }</span>

    @Test
    public void testBoolean_xor_cubeAndSphere() throws IOException {
        // arrange
<span class="fc" id="L1131">        double tolerance = 0.05;</span>
<span class="fc" id="L1132">        double size = 1.0;</span>
<span class="fc" id="L1133">        double radius = size * 0.5;</span>
<span class="fc" id="L1134">        PolyhedronsSet box = new PolyhedronsSet(0, size, 0, size, 0, size, TEST_TOLERANCE);</span>
<span class="fc" id="L1135">        PolyhedronsSet sphere = createSphere(new Cartesian3D(size * 0.5, size * 0.5, size), radius, 8, 16);</span>

        // act
<span class="fc" id="L1138">        PolyhedronsSet result = (PolyhedronsSet) new RegionFactory&lt;Euclidean3D&gt;().xor(box, sphere);</span>

        // OBJWriter.write(&quot;xor_cubeAndSphere.obj&quot;, result);

<span class="fc" id="L1142">        Assert.assertEquals(cubeVolume(size), result.getSize(), tolerance);</span>

        // assert
<span class="fc" id="L1145">        Assert.assertEquals(cubeSurface(size) + (sphereSurface(radius)),</span>
<span class="fc" id="L1146">                result.getBoundarySize(), tolerance);</span>
<span class="fc" id="L1147">        Assert.assertFalse(result.isEmpty());</span>
<span class="fc" id="L1148">        Assert.assertFalse(result.isFull());</span>

<span class="fc" id="L1150">        checkPoints(Region.Location.OUTSIDE, result,</span>
                new Cartesian3D(-0.1, 0.5, 0.5),
                new Cartesian3D(1.1, 0.5, 0.5),
                new Cartesian3D(0.5, -0.1, 0.5),
                new Cartesian3D(0.5, 1.1, 0.5),
                new Cartesian3D(0.5, 0.5, -0.1),
                new Cartesian3D(0.5, 0.5, 1.6),
                new Cartesian3D(0.5, 0.5, 0.9));

<span class="fc" id="L1159">        checkPoints(Region.Location.INSIDE, result,</span>
                new Cartesian3D(0.1, 0.5, 0.5),
                new Cartesian3D(0.9, 0.5, 0.5),
                new Cartesian3D(0.5, 0.1, 0.5),
                new Cartesian3D(0.5, 0.9, 0.5),
                new Cartesian3D(0.5, 0.5, 0.1),
                new Cartesian3D(0.5, 0.5, 1.4));
<span class="fc" id="L1166">    }</span>

    @Test
    public void testXor_self() {
        // arrange
<span class="fc" id="L1171">        double radius = 1.0;</span>

<span class="fc" id="L1173">        PolyhedronsSet sphere = createSphere(Cartesian3D.ZERO, radius, 8, 16);</span>

        // act
<span class="fc" id="L1176">        PolyhedronsSet result = (PolyhedronsSet) new RegionFactory&lt;Euclidean3D&gt;().xor(sphere, sphere.copySelf());</span>

        // assert
<span class="fc" id="L1179">        Assert.assertEquals(0.0, result.getSize(), TEST_TOLERANCE);</span>
<span class="fc" id="L1180">        Assert.assertEquals(0.0, result.getBoundarySize(), TEST_TOLERANCE);</span>
<span class="fc" id="L1181">        GeometryTestUtils.assertVectorEquals(Cartesian3D.NaN, (Cartesian3D) result.getBarycenter(), TEST_TOLERANCE);</span>
<span class="fc" id="L1182">        Assert.assertTrue(result.isEmpty());</span>
<span class="fc" id="L1183">        Assert.assertFalse(result.isFull());</span>

<span class="fc" id="L1185">        checkPoints(Region.Location.OUTSIDE, result,</span>
                new Cartesian3D(-1.1, 0, 0),
                new Cartesian3D(1.1, 0, 0),
                new Cartesian3D(0, -1.1, 0),
                new Cartesian3D(0, 1.1, 0),
                new Cartesian3D(0, 0, -1.1),
                new Cartesian3D(0, 0, 1.1),
                new Cartesian3D(-0.9, 0, 0),
                new Cartesian3D(0.9, 0, 0),
                new Cartesian3D(0, -0.9, 0),
                new Cartesian3D(0, 0.9, 0),
                new Cartesian3D(0, 0, -0.9),
                new Cartesian3D(0, 0, 0.9),
                Cartesian3D.ZERO);
<span class="fc" id="L1199">    }</span>

    @Test
    public void testBoolean_difference() throws IOException {
        // arrange
<span class="fc" id="L1204">        double tolerance = 0.05;</span>
<span class="fc" id="L1205">        double size = 1.0;</span>
<span class="fc" id="L1206">        double radius = size * 0.5;</span>
<span class="fc" id="L1207">        PolyhedronsSet box = new PolyhedronsSet(0, size, 0, size, 0, size, TEST_TOLERANCE);</span>
<span class="fc" id="L1208">        PolyhedronsSet sphere = createSphere(new Cartesian3D(size * 0.5, size * 0.5, size), radius, 8, 16);</span>

        // act
<span class="fc" id="L1211">        PolyhedronsSet result = (PolyhedronsSet) new RegionFactory&lt;Euclidean3D&gt;().difference(box, sphere);</span>

        // OBJWriter.write(&quot;difference.obj&quot;, result);

        // assert
<span class="fc" id="L1216">        Assert.assertEquals(cubeVolume(size) - (sphereVolume(radius) * 0.5), result.getSize(), tolerance);</span>
<span class="fc" id="L1217">        Assert.assertEquals(cubeSurface(size) - circleSurface(radius) + (0.5 * sphereSurface(radius)),</span>
<span class="fc" id="L1218">                result.getBoundarySize(), tolerance);</span>
<span class="fc" id="L1219">        Assert.assertFalse(result.isEmpty());</span>
<span class="fc" id="L1220">        Assert.assertFalse(result.isFull());</span>

<span class="fc" id="L1222">        checkPoints(Region.Location.OUTSIDE, result,</span>
                new Cartesian3D(-0.1, 0.5, 1.0),
                new Cartesian3D(1.1, 0.5, 1.0),
                new Cartesian3D(0.5, -0.1, 1.0),
                new Cartesian3D(0.5, 1.1, 1.0),
                new Cartesian3D(0.5, 0.5, -0.1),
                new Cartesian3D(0.5, 0.5, 0.6));

<span class="fc" id="L1230">        checkPoints(Region.Location.INSIDE, result,</span>
                new Cartesian3D(0.1, 0.5, 0.4),
                new Cartesian3D(0.9, 0.5, 0.4),
                new Cartesian3D(0.5, 0.1, 0.4),
                new Cartesian3D(0.5, 0.9, 0.4),
                new Cartesian3D(0.5, 0.5, 0.1),
                new Cartesian3D(0.5, 0.5, 0.4));
<span class="fc" id="L1237">    }</span>

    @Test
    public void testDifference_self() {
        // arrange
<span class="fc" id="L1242">        double radius = 1.0;</span>

<span class="fc" id="L1244">        PolyhedronsSet sphere = createSphere(Cartesian3D.ZERO, radius, 8, 16);</span>

        // act
<span class="fc" id="L1247">        PolyhedronsSet result = (PolyhedronsSet) new RegionFactory&lt;Euclidean3D&gt;().difference(sphere, sphere.copySelf());</span>

        // assert
<span class="fc" id="L1250">        Assert.assertEquals(0.0, result.getSize(), TEST_TOLERANCE);</span>
<span class="fc" id="L1251">        Assert.assertEquals(0.0, result.getBoundarySize(), TEST_TOLERANCE);</span>
<span class="fc" id="L1252">        GeometryTestUtils.assertVectorEquals(Cartesian3D.NaN, (Cartesian3D) result.getBarycenter(), TEST_TOLERANCE);</span>
<span class="fc" id="L1253">        Assert.assertTrue(result.isEmpty());</span>
<span class="fc" id="L1254">        Assert.assertFalse(result.isFull());</span>

<span class="fc" id="L1256">        checkPoints(Region.Location.OUTSIDE, result,</span>
                new Cartesian3D(-1.1, 0, 0),
                new Cartesian3D(1.1, 0, 0),
                new Cartesian3D(0, -1.1, 0),
                new Cartesian3D(0, 1.1, 0),
                new Cartesian3D(0, 0, -1.1),
                new Cartesian3D(0, 0, 1.1),
                new Cartesian3D(-0.9, 0, 0),
                new Cartesian3D(0.9, 0, 0),
                new Cartesian3D(0, -0.9, 0),
                new Cartesian3D(0, 0.9, 0),
                new Cartesian3D(0, 0, -0.9),
                new Cartesian3D(0, 0, 0.9),
                Cartesian3D.ZERO);
<span class="fc" id="L1270">    }</span>

    @Test
    public void testBoolean_multiple() throws IOException {
        // arrange
<span class="fc" id="L1275">        double tolerance = 0.05;</span>
<span class="fc" id="L1276">        double size = 1.0;</span>
<span class="fc" id="L1277">        double radius = size * 0.5;</span>
<span class="fc" id="L1278">        PolyhedronsSet box = new PolyhedronsSet(0, size, 0, size, 0, size, TEST_TOLERANCE);</span>
<span class="fc" id="L1279">        PolyhedronsSet sphereToAdd = createSphere(new Cartesian3D(size * 0.5, size * 0.5, size), radius, 8, 16);</span>
<span class="fc" id="L1280">        PolyhedronsSet sphereToRemove1 = createSphere(new Cartesian3D(size * 0.5, 0, size * 0.5), radius, 8, 16);</span>
<span class="fc" id="L1281">        PolyhedronsSet sphereToRemove2 = createSphere(new Cartesian3D(size * 0.5, 1, size * 0.5), radius, 8, 16);</span>

<span class="fc" id="L1283">        RegionFactory&lt;Euclidean3D&gt; factory = new RegionFactory&lt;Euclidean3D&gt;();</span>

        // act
<span class="fc" id="L1286">        PolyhedronsSet result = (PolyhedronsSet) factory.union(box, sphereToAdd);</span>
<span class="fc" id="L1287">        result = (PolyhedronsSet) factory.difference(result, sphereToRemove1);</span>
<span class="fc" id="L1288">        result = (PolyhedronsSet) factory.difference(result, sphereToRemove2);</span>

        // OBJWriter.write(&quot;multiple.obj&quot;, result);

        // assert
<span class="fc" id="L1293">        Assert.assertEquals(cubeVolume(size) - (sphereVolume(radius) * 0.5),</span>
<span class="fc" id="L1294">                result.getSize(), tolerance);</span>
<span class="fc" id="L1295">        Assert.assertEquals(cubeSurface(size) - (3.0 * circleSurface(radius)) + (1.5 * sphereSurface(radius)),</span>
<span class="fc" id="L1296">                result.getBoundarySize(), tolerance);</span>
<span class="fc" id="L1297">        Assert.assertFalse(result.isEmpty());</span>
<span class="fc" id="L1298">        Assert.assertFalse(result.isFull());</span>

<span class="fc" id="L1300">        checkPoints(Region.Location.OUTSIDE, result,</span>
                new Cartesian3D(-0.1, 0.5, 0.5),
                new Cartesian3D(1.1, 0.5, 0.5),
                new Cartesian3D(0.5, 0.4, 0.5),
                new Cartesian3D(0.5, 0.6, 0.5),
                new Cartesian3D(0.5, 0.5, -0.1),
                new Cartesian3D(0.5, 0.5, 1.6));

<span class="fc" id="L1308">        checkPoints(Region.Location.INSIDE, result,</span>
                new Cartesian3D(0.1, 0.5, 0.1),
                new Cartesian3D(0.9, 0.5, 0.1),
                new Cartesian3D(0.5, 0.4, 0.1),
                new Cartesian3D(0.5, 0.6, 0.1),
                new Cartesian3D(0.5, 0.5, 0.1),
                new Cartesian3D(0.5, 0.5, 1.4));
<span class="fc" id="L1315">    }</span>

    @Test
    public void testProjectToBoundary() {
        // arrange
<span class="fc" id="L1320">        PolyhedronsSet polySet = new PolyhedronsSet(0, 1, 0, 1, 0, 1, TEST_TOLERANCE);</span>

        // act/assert
<span class="fc" id="L1323">        checkProjectToBoundary(polySet, new Cartesian3D(0.4, 0.5, 0.5),</span>
                new Cartesian3D(0, 0.5, 0.5), -0.4);
<span class="fc" id="L1325">        checkProjectToBoundary(polySet, new Cartesian3D(1.5, 0.5, 0.5),</span>
                new Cartesian3D(1, 0.5, 0.5), 0.5);
<span class="fc" id="L1327">        checkProjectToBoundary(polySet, new Cartesian3D(2, 2, 2),</span>
<span class="fc" id="L1328">                new Cartesian3D(1, 1, 1), FastMath.sqrt(3));</span>
<span class="fc" id="L1329">    }</span>

    @Test
    public void testProjectToBoundary_invertedRegion() {
        // arrange
<span class="fc" id="L1334">        PolyhedronsSet polySet = new PolyhedronsSet(0, 1, 0, 1, 0, 1, TEST_TOLERANCE);</span>
<span class="fc" id="L1335">        polySet = (PolyhedronsSet) new RegionFactory&lt;Euclidean3D&gt;().getComplement(polySet);</span>

        // act/assert
<span class="fc" id="L1338">        checkProjectToBoundary(polySet, new Cartesian3D(0.4, 0.5, 0.5),</span>
                new Cartesian3D(0, 0.5, 0.5), 0.4);
<span class="fc" id="L1340">        checkProjectToBoundary(polySet, new Cartesian3D(1.5, 0.5, 0.5),</span>
                new Cartesian3D(1, 0.5, 0.5), -0.5);
<span class="fc" id="L1342">        checkProjectToBoundary(polySet, new Cartesian3D(2, 2, 2),</span>
<span class="fc" id="L1343">                new Cartesian3D(1, 1, 1), -FastMath.sqrt(3));</span>
<span class="fc" id="L1344">    }</span>

    private void checkProjectToBoundary(PolyhedronsSet poly, Cartesian3D toProject,
            Cartesian3D expectedPoint, double expectedOffset) {
<span class="fc" id="L1348">        BoundaryProjection&lt;Euclidean3D&gt; proj = poly.projectToBoundary(toProject);</span>

<span class="fc" id="L1350">        GeometryTestUtils.assertVectorEquals(toProject, (Cartesian3D) proj.getOriginal(), TEST_TOLERANCE);</span>
<span class="fc" id="L1351">        GeometryTestUtils.assertVectorEquals(expectedPoint, (Cartesian3D) proj.getProjected(), TEST_TOLERANCE);</span>
<span class="fc" id="L1352">        Assert.assertEquals(expectedOffset, proj.getOffset(), TEST_TOLERANCE);</span>
<span class="fc" id="L1353">    }</span>

    private String loadTestData(final String resourceName)
            throws IOException {
<span class="fc" id="L1357">        try (Reader reader = new InputStreamReader(getClass().getResourceAsStream(resourceName), &quot;UTF-8&quot;)) {</span>
<span class="fc" id="L1358">            StringBuilder builder = new StringBuilder();</span>
<span class="fc bfc" id="L1359" title="All 2 branches covered.">            for (int c = reader.read(); c &gt;= 0; c = reader.read()) {</span>
<span class="fc" id="L1360">                builder.append((char) c);</span>
            }
<span class="fc" id="L1362">            return builder.toString();</span>
        }
    }

    private void checkPoints(Region.Location expected, PolyhedronsSet poly, Cartesian3D ... points) {
<span class="fc bfc" id="L1367" title="All 2 branches covered.">        for (int i = 0; i &lt; points.length; ++i) {</span>
<span class="fc" id="L1368">            Assert.assertEquals(&quot;Incorrect location for &quot; + points[i], expected, poly.checkPoint(points[i]));</span>
        }
<span class="fc" id="L1370">    }</span>

    private List&lt;SubHyperplane&lt;Euclidean3D&gt;&gt; createBoxBoundaries(Cartesian3D center, double size, double tolerance) {
<span class="fc" id="L1373">        List&lt;SubHyperplane&lt;Euclidean3D&gt;&gt; boundaries = new ArrayList&lt;&gt;();</span>

<span class="fc" id="L1375">        double offset = size * 0.5;</span>

<span class="fc" id="L1377">        Plane xMinus = new Plane(center.add(new Cartesian3D(-offset, 0, 0)), Cartesian3D.MINUS_I, tolerance);</span>
<span class="fc" id="L1378">        Plane xPlus = new Plane(center.add(new Cartesian3D(offset, 0, 0)), Cartesian3D.PLUS_I, tolerance);</span>
<span class="fc" id="L1379">        Plane yPlus = new Plane(center.add(new Cartesian3D(0, offset, 0)), Cartesian3D.PLUS_J, tolerance);</span>
<span class="fc" id="L1380">        Plane yMinus = new Plane(center.add(new Cartesian3D(0, -offset, 0)), Cartesian3D.MINUS_J, tolerance);</span>
<span class="fc" id="L1381">        Plane zPlus = new Plane(center.add(new Cartesian3D(0, 0, offset)), Cartesian3D.PLUS_K, tolerance);</span>
<span class="fc" id="L1382">        Plane zMinus = new Plane(center.add(new Cartesian3D(0, 0, -offset)), Cartesian3D.MINUS_K, tolerance);</span>

        // +x
<span class="fc" id="L1385">        boundaries.add(createSubPlane(xPlus,</span>
<span class="fc" id="L1386">                        center.add(new Cartesian3D(offset, offset, offset)),</span>
<span class="fc" id="L1387">                        center.add(new Cartesian3D(offset, -offset, offset)),</span>
<span class="fc" id="L1388">                        center.add(new Cartesian3D(offset, -offset, -offset)),</span>
<span class="fc" id="L1389">                        center.add(new Cartesian3D(offset, offset, -offset))));</span>

        // -x
<span class="fc" id="L1392">        boundaries.add(createSubPlane(xMinus,</span>
<span class="fc" id="L1393">                        center.add(new Cartesian3D(-offset, -offset, offset)),</span>
<span class="fc" id="L1394">                        center.add(new Cartesian3D(-offset, offset, offset)),</span>
<span class="fc" id="L1395">                        center.add(new Cartesian3D(-offset, offset, -offset)),</span>
<span class="fc" id="L1396">                        center.add(new Cartesian3D(-offset, -offset, -offset))));</span>

        // +y
<span class="fc" id="L1399">        boundaries.add(createSubPlane(yPlus,</span>
<span class="fc" id="L1400">                        center.add(new Cartesian3D(-offset, offset, offset)),</span>
<span class="fc" id="L1401">                        center.add(new Cartesian3D(offset, offset, offset)),</span>
<span class="fc" id="L1402">                        center.add(new Cartesian3D(offset, offset, -offset)),</span>
<span class="fc" id="L1403">                        center.add(new Cartesian3D(-offset, offset, -offset))));</span>

        // -y
<span class="fc" id="L1406">        boundaries.add(createSubPlane(yMinus,</span>
<span class="fc" id="L1407">                        center.add(new Cartesian3D(-offset, -offset, offset)),</span>
<span class="fc" id="L1408">                        center.add(new Cartesian3D(-offset, -offset, -offset)),</span>
<span class="fc" id="L1409">                        center.add(new Cartesian3D(offset, -offset, -offset)),</span>
<span class="fc" id="L1410">                        center.add(new Cartesian3D(offset, -offset, offset))));</span>

        // +z
<span class="fc" id="L1413">        boundaries.add(createSubPlane(zPlus,</span>
<span class="fc" id="L1414">                        center.add(new Cartesian3D(-offset, -offset, offset)),</span>
<span class="fc" id="L1415">                        center.add(new Cartesian3D(offset, -offset, offset)),</span>
<span class="fc" id="L1416">                        center.add(new Cartesian3D(offset, offset, offset)),</span>
<span class="fc" id="L1417">                        center.add(new Cartesian3D(-offset, offset, offset))));</span>

        // -z
<span class="fc" id="L1420">        boundaries.add(createSubPlane(zMinus,</span>
<span class="fc" id="L1421">                        center.add(new Cartesian3D(-offset, -offset, -offset)),</span>
<span class="fc" id="L1422">                        center.add(new Cartesian3D(-offset, offset, -offset)),</span>
<span class="fc" id="L1423">                        center.add(new Cartesian3D(offset, offset, -offset)),</span>
<span class="fc" id="L1424">                        center.add(new Cartesian3D(offset, -offset, -offset))));</span>

<span class="fc" id="L1426">        return boundaries;</span>
    }

    private SubPlane createSubPlane(Plane plane, Cartesian3D...points) {
<span class="fc" id="L1430">        Cartesian2D[] points2d = new Cartesian2D[points.length];</span>
<span class="fc bfc" id="L1431" title="All 2 branches covered.">        for (int i=0; i&lt;points.length; ++i) {</span>
<span class="fc" id="L1432">            points2d[i] = plane.toSubSpace(points[i]);</span>
        }

<span class="fc" id="L1435">        PolygonsSet polygon = new PolygonsSet(plane.getTolerance(), points2d);</span>

<span class="fc" id="L1437">        return new SubPlane(plane, polygon);</span>
    }

    private PolyhedronsSet createSphere(Cartesian3D center, double radius, int stacks, int slices) {
<span class="fc" id="L1441">        List&lt;Plane&gt; planes = new ArrayList&lt;&gt;();</span>

        // add top and bottom planes (+/- z)
<span class="fc" id="L1444">        Cartesian3D topZ = new Cartesian3D(center.getX(), center.getY(), center.getZ() + radius);</span>
<span class="fc" id="L1445">        Cartesian3D bottomZ = new Cartesian3D(center.getX(), center.getY(), center.getZ() - radius);</span>

<span class="fc" id="L1447">        planes.add(new Plane(topZ, Cartesian3D.PLUS_K, TEST_TOLERANCE));</span>
<span class="fc" id="L1448">        planes.add(new Plane(bottomZ, Cartesian3D.MINUS_K, TEST_TOLERANCE));</span>

        // add the side planes
<span class="fc" id="L1451">        double vDelta = FastMath.PI / stacks;</span>
<span class="fc" id="L1452">        double hDelta = FastMath.PI * 2 / slices;</span>

<span class="fc" id="L1454">        double adjustedRadius = (radius + (radius * FastMath.cos(vDelta * 0.5))) / 2.0;</span>

        double vAngle;
        double hAngle;
        double stackRadius;
        double stackHeight;
        double x, y;
        Cartesian3D norm, pt;

<span class="fc" id="L1463">        vAngle = -0.5 * vDelta;</span>
<span class="fc bfc" id="L1464" title="All 2 branches covered.">        for (int v=0; v&lt;stacks; ++v) {</span>
<span class="fc" id="L1465">            vAngle += vDelta;</span>

<span class="fc" id="L1467">            stackRadius = FastMath.sin(vAngle) * adjustedRadius;</span>
<span class="fc" id="L1468">            stackHeight = FastMath.cos(vAngle) * adjustedRadius;</span>

<span class="fc" id="L1470">            hAngle = -0.5 * hDelta;</span>
<span class="fc bfc" id="L1471" title="All 2 branches covered.">            for (int h=0; h&lt;slices; ++h) {</span>
<span class="fc" id="L1472">                hAngle += hDelta;</span>

<span class="fc" id="L1474">                x = FastMath.cos(hAngle) * stackRadius;</span>
<span class="fc" id="L1475">                y = FastMath.sin(hAngle) * stackRadius;</span>

<span class="fc" id="L1477">                norm = new Cartesian3D(x, y, stackHeight).normalize();</span>
<span class="fc" id="L1478">                pt = norm.scalarMultiply(adjustedRadius).add(center);</span>

<span class="fc" id="L1480">                planes.add(new Plane(pt, norm, TEST_TOLERANCE));</span>
            }
        }

<span class="fc" id="L1484">        return (PolyhedronsSet) new RegionFactory&lt;Euclidean3D&gt;().buildConvex(planes.toArray(new Plane[0]));</span>
    }

    private void assertSubPlaneNormal(Cartesian3D expectedNormal, SubHyperplane&lt;Euclidean3D&gt; sub) {
<span class="fc" id="L1488">        Cartesian3D norm = ((Plane) sub.getHyperplane()).getNormal();</span>
<span class="fc" id="L1489">        GeometryTestUtils.assertVectorEquals(expectedNormal, norm, TEST_TOLERANCE);</span>
<span class="fc" id="L1490">    }</span>

    private double cubeVolume(double size) {
<span class="fc" id="L1493">        return size * size * size;</span>
    }

    private double cubeSurface(double size) {
<span class="fc" id="L1497">        return 6.0 * size * size;</span>
    }

    private double sphereVolume(double radius) {
<span class="fc" id="L1501">        return 4.0 * FastMath.PI * radius * radius * radius / 3.0;</span>
    }

    private double sphereSurface(double radius) {
<span class="fc" id="L1505">        return 4.0 * FastMath.PI * radius * radius;</span>
    }

    private double circleSurface(double radius) {
<span class="fc" id="L1509">        return FastMath.PI * radius * radius;</span>
    }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.1.201803210924</span></div></body></html>