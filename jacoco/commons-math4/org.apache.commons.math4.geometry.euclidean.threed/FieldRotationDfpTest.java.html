<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>FieldRotationDfpTest.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">commons_math4$All_in_commons_math4.exec</a> &gt; <a href="index.source.html" class="el_package">org.apache.commons.math4.geometry.euclidean.threed</a> &gt; <span class="el_source">FieldRotationDfpTest.java</span></div><h1>FieldRotationDfpTest.java</h1><pre class="source lang-java linenums">/*
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the &quot;License&quot;); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package org.apache.commons.math4.geometry.euclidean.threed;

import org.junit.Assert;
import org.junit.Test;
import org.apache.commons.numbers.angle.PlaneAngleRadians;
import org.apache.commons.rng.UniformRandomProvider;
import org.apache.commons.rng.simple.RandomSource;
import org.apache.commons.rng.sampling.UnitSphereSampler;
import org.apache.commons.numbers.angle.PlaneAngleRadians;
import org.apache.commons.math4.dfp.Dfp;
import org.apache.commons.math4.dfp.DfpField;
import org.apache.commons.math4.exception.MathArithmeticException;
import org.apache.commons.math4.exception.MathIllegalArgumentException;
import org.apache.commons.math4.geometry.euclidean.threed.CardanEulerSingularityException;
import org.apache.commons.math4.geometry.euclidean.threed.FieldRotation;
import org.apache.commons.math4.geometry.euclidean.threed.FieldVector3D;
import org.apache.commons.math4.geometry.euclidean.threed.NotARotationMatrixException;
import org.apache.commons.math4.geometry.euclidean.threed.Rotation;
import org.apache.commons.math4.geometry.euclidean.threed.RotationOrder;
import org.apache.commons.math4.geometry.euclidean.threed.Cartesian3D;
import org.apache.commons.math4.util.FastMath;

<span class="fc" id="L40">public class FieldRotationDfpTest {</span>

    @Test
    public void testIdentity() {

<span class="fc" id="L45">        FieldRotation&lt;Dfp&gt; r = createRotation(1, 0, 0, 0, false);</span>
<span class="fc" id="L46">        checkVector(r.applyTo(createVector(1, 0, 0)), createVector(1, 0, 0));</span>
<span class="fc" id="L47">        checkVector(r.applyTo(createVector(0, 1, 0)), createVector(0, 1, 0));</span>
<span class="fc" id="L48">        checkVector(r.applyTo(createVector(0, 0, 1)), createVector(0, 0, 1));</span>
<span class="fc" id="L49">        checkAngle(r.getAngle(), 0);</span>

<span class="fc" id="L51">        r = createRotation(-1, 0, 0, 0, false);</span>
<span class="fc" id="L52">        checkVector(r.applyTo(createVector(1, 0, 0)), createVector(1, 0, 0));</span>
<span class="fc" id="L53">        checkVector(r.applyTo(createVector(0, 1, 0)), createVector(0, 1, 0));</span>
<span class="fc" id="L54">        checkVector(r.applyTo(createVector(0, 0, 1)), createVector(0, 0, 1));</span>
<span class="fc" id="L55">        checkAngle(r.getAngle(), 0);</span>

<span class="fc" id="L57">        r = createRotation(42, 0, 0, 0, true);</span>
<span class="fc" id="L58">        checkVector(r.applyTo(createVector(1, 0, 0)), createVector(1, 0, 0));</span>
<span class="fc" id="L59">        checkVector(r.applyTo(createVector(0, 1, 0)), createVector(0, 1, 0));</span>
<span class="fc" id="L60">        checkVector(r.applyTo(createVector(0, 0, 1)), createVector(0, 0, 1));</span>
<span class="fc" id="L61">        checkAngle(r.getAngle(), 0);</span>

<span class="fc" id="L63">    }</span>

    @Test
    @Deprecated
    public void testAxisAngleDeprecated() throws MathIllegalArgumentException {

<span class="fc" id="L69">        FieldRotation&lt;Dfp&gt; r = new FieldRotation&lt;&gt;(createAxis(10, 10, 10), createAngle(2 * FastMath.PI / 3));</span>
<span class="fc" id="L70">        checkVector(r.applyTo(createVector(1, 0, 0)), createVector(0, 1, 0));</span>
<span class="fc" id="L71">        checkVector(r.applyTo(createVector(0, 1, 0)), createVector(0, 0, 1));</span>
<span class="fc" id="L72">        checkVector(r.applyTo(createVector(0, 0, 1)), createVector(1, 0, 0));</span>
<span class="fc" id="L73">        double s = 1 / FastMath.sqrt(3);</span>
<span class="fc" id="L74">        checkVector(r.getAxis(), createVector(s, s, s));</span>
<span class="fc" id="L75">        checkAngle(r.getAngle(), 2 * FastMath.PI / 3);</span>

        try {
<span class="nc" id="L78">            new FieldRotation&lt;&gt;(createAxis(0, 0, 0), createAngle(2 * FastMath.PI / 3));</span>
<span class="nc" id="L79">            Assert.fail(&quot;an exception should have been thrown&quot;);</span>
<span class="fc" id="L80">        } catch (MathIllegalArgumentException e) {</span>
<span class="nc" id="L81">        }</span>

<span class="fc" id="L83">        r = new FieldRotation&lt;&gt;(createAxis(0, 0, 1), createAngle(1.5 * FastMath.PI));</span>
<span class="fc" id="L84">        checkVector(r.getAxis(), createVector(0, 0, -1));</span>
<span class="fc" id="L85">        checkAngle(r.getAngle(), 0.5 * FastMath.PI);</span>

<span class="fc" id="L87">        r = new FieldRotation&lt;&gt;(createAxis(0, 1, 0), createAngle(FastMath.PI));</span>
<span class="fc" id="L88">        checkVector(r.getAxis(), createVector(0, 1, 0));</span>
<span class="fc" id="L89">        checkAngle(r.getAngle(), FastMath.PI);</span>

<span class="fc" id="L91">        checkVector(createRotation(1, 0, 0, 0, false).getAxis(), createVector(1, 0, 0));</span>

<span class="fc" id="L93">    }</span>

    @Test
    public void testAxisAngleVectorOperator() throws MathIllegalArgumentException {

<span class="fc" id="L98">        FieldRotation&lt;Dfp&gt; r = new FieldRotation&lt;&gt;(createAxis(10, 10, 10),</span>
<span class="fc" id="L99">                                                      createAngle(2 * FastMath.PI / 3) ,</span>
                                                      RotationConvention.VECTOR_OPERATOR);
<span class="fc" id="L101">        checkVector(r.applyTo(createVector(1, 0, 0)), createVector(0, 1, 0));</span>
<span class="fc" id="L102">        checkVector(r.applyTo(createVector(0, 1, 0)), createVector(0, 0, 1));</span>
<span class="fc" id="L103">        checkVector(r.applyTo(createVector(0, 0, 1)), createVector(1, 0, 0));</span>
<span class="fc" id="L104">        double s = 1 / FastMath.sqrt(3);</span>
<span class="fc" id="L105">        checkVector(r.getAxis(RotationConvention.VECTOR_OPERATOR), createVector( s,  s,  s));</span>
<span class="fc" id="L106">        checkVector(r.getAxis(RotationConvention.FRAME_TRANSFORM), createVector(-s, -s, -s));</span>
<span class="fc" id="L107">        checkAngle(r.getAngle(), 2 * FastMath.PI / 3);</span>

        try {
<span class="fc" id="L110">            new FieldRotation&lt;&gt;(createAxis(0, 0, 0),</span>
<span class="nc" id="L111">                                   createAngle(2 * FastMath.PI / 3),</span>
                                   RotationConvention.VECTOR_OPERATOR);
<span class="nc" id="L113">            Assert.fail(&quot;an exception should have been thrown&quot;);</span>
<span class="fc" id="L114">        } catch (MathIllegalArgumentException e) {</span>
<span class="nc" id="L115">        }</span>

<span class="fc" id="L117">        r = new FieldRotation&lt;&gt;(createAxis(0, 0, 1),</span>
<span class="fc" id="L118">                                   createAngle(1.5 * FastMath.PI),</span>
                                   RotationConvention.VECTOR_OPERATOR);
<span class="fc" id="L120">        checkVector(r.getAxis(RotationConvention.VECTOR_OPERATOR), createVector(0, 0, -1));</span>
<span class="fc" id="L121">        checkVector(r.getAxis(RotationConvention.FRAME_TRANSFORM), createVector(0, 0, +1));</span>
<span class="fc" id="L122">        checkAngle(r.getAngle(), 0.5 * FastMath.PI);</span>

<span class="fc" id="L124">        r = new FieldRotation&lt;&gt;(createAxis(0, 1, 0),</span>
<span class="fc" id="L125">                                   createAngle(FastMath.PI),</span>
                                   RotationConvention.VECTOR_OPERATOR);
<span class="fc" id="L127">        checkVector(r.getAxis(RotationConvention.VECTOR_OPERATOR), createVector(0, +1, 0));</span>
<span class="fc" id="L128">        checkVector(r.getAxis(RotationConvention.FRAME_TRANSFORM), createVector(0, -1, 0));</span>
<span class="fc" id="L129">        checkAngle(r.getAngle(), FastMath.PI);</span>

<span class="fc" id="L131">        checkVector(createRotation(1, 0, 0, 0, false).getAxis(RotationConvention.VECTOR_OPERATOR), createVector(+1, 0, 0));</span>
<span class="fc" id="L132">        checkVector(createRotation(1, 0, 0, 0, false).getAxis(RotationConvention.FRAME_TRANSFORM), createVector(-1, 0, 0));</span>

<span class="fc" id="L134">    }</span>

    @Test
    public void testAxisAngleFrameTransform() throws MathIllegalArgumentException {

<span class="fc" id="L139">        FieldRotation&lt;Dfp&gt; r = new FieldRotation&lt;&gt;(createAxis(10, 10, 10),</span>
<span class="fc" id="L140">                                                      createAngle(2 * FastMath.PI / 3) ,</span>
                                                      RotationConvention.FRAME_TRANSFORM);
<span class="fc" id="L142">        checkVector(r.applyTo(createVector(1, 0, 0)), createVector(0, 0, 1));</span>
<span class="fc" id="L143">        checkVector(r.applyTo(createVector(0, 1, 0)), createVector(1, 0, 0));</span>
<span class="fc" id="L144">        checkVector(r.applyTo(createVector(0, 0, 1)), createVector(0, 1, 0));</span>
<span class="fc" id="L145">        double s = 1 / FastMath.sqrt(3);</span>
<span class="fc" id="L146">        checkVector(r.getAxis(RotationConvention.FRAME_TRANSFORM), createVector( s,  s,  s));</span>
<span class="fc" id="L147">        checkVector(r.getAxis(RotationConvention.VECTOR_OPERATOR), createVector(-s, -s, -s));</span>
<span class="fc" id="L148">        checkAngle(r.getAngle(), 2 * FastMath.PI / 3);</span>

        try {
<span class="fc" id="L151">            new FieldRotation&lt;&gt;(createAxis(0, 0, 0),</span>
<span class="nc" id="L152">                                   createAngle(2 * FastMath.PI / 3),</span>
                                   RotationConvention.FRAME_TRANSFORM);
<span class="nc" id="L154">            Assert.fail(&quot;an exception should have been thrown&quot;);</span>
<span class="fc" id="L155">        } catch (MathIllegalArgumentException e) {</span>
<span class="nc" id="L156">        }</span>

<span class="fc" id="L158">        r = new FieldRotation&lt;&gt;(createAxis(0, 0, 1),</span>
<span class="fc" id="L159">                                   createAngle(1.5 * FastMath.PI),</span>
                                   RotationConvention.FRAME_TRANSFORM);
<span class="fc" id="L161">        checkVector(r.getAxis(RotationConvention.FRAME_TRANSFORM), createVector(0, 0, -1));</span>
<span class="fc" id="L162">        checkVector(r.getAxis(RotationConvention.VECTOR_OPERATOR), createVector(0, 0, +1));</span>
<span class="fc" id="L163">        checkAngle(r.getAngle(), 0.5 * FastMath.PI);</span>

<span class="fc" id="L165">        r = new FieldRotation&lt;&gt;(createAxis(0, 1, 0),</span>
<span class="fc" id="L166">                                   createAngle(FastMath.PI),</span>
                                   RotationConvention.FRAME_TRANSFORM);
<span class="fc" id="L168">        checkVector(r.getAxis(RotationConvention.FRAME_TRANSFORM), createVector(0, +1, 0));</span>
<span class="fc" id="L169">        checkVector(r.getAxis(RotationConvention.VECTOR_OPERATOR), createVector(0, -1, 0));</span>
<span class="fc" id="L170">        checkAngle(r.getAngle(), FastMath.PI);</span>

<span class="fc" id="L172">        checkVector(createRotation(1, 0, 0, 0, false).getAxis(RotationConvention.FRAME_TRANSFORM), createVector(-1, 0, 0));</span>
<span class="fc" id="L173">        checkVector(createRotation(1, 0, 0, 0, false).getAxis(RotationConvention.VECTOR_OPERATOR), createVector(+1, 0, 0));</span>

<span class="fc" id="L175">    }</span>

    @Test
    public void testRevert() {
<span class="fc" id="L179">        double a = 0.001;</span>
<span class="fc" id="L180">        double b = 0.36;</span>
<span class="fc" id="L181">        double c = 0.48;</span>
<span class="fc" id="L182">        double d = 0.8;</span>
<span class="fc" id="L183">        FieldRotation&lt;Dfp&gt; r = createRotation(a, b, c, d, true);</span>
<span class="fc" id="L184">        FieldRotation&lt;Dfp&gt; reverted = r.revert();</span>
<span class="fc" id="L185">        FieldRotation&lt;Dfp&gt; rrT = r.applyTo(reverted);</span>
<span class="fc" id="L186">        checkRotationDS(rrT, 1, 0, 0, 0);</span>
<span class="fc" id="L187">        FieldRotation&lt;Dfp&gt; rTr = reverted.applyTo(r);</span>
<span class="fc" id="L188">        checkRotationDS(rTr, 1, 0, 0, 0);</span>
<span class="fc" id="L189">        Assert.assertEquals(r.getAngle().getReal(), reverted.getAngle().getReal(), 1.0e-15);</span>
<span class="fc" id="L190">        Assert.assertEquals(-1,</span>
<span class="fc" id="L191">                            FieldVector3D.dotProduct(r.getAxis(RotationConvention.VECTOR_OPERATOR),</span>
<span class="fc" id="L192">                                                     reverted.getAxis(RotationConvention.VECTOR_OPERATOR)).getReal(),</span>
                            1.0e-15);
<span class="fc" id="L194">    }</span>

    @Test
    public void testRevertVectorOperator() {
<span class="fc" id="L198">        double a = 0.001;</span>
<span class="fc" id="L199">        double b = 0.36;</span>
<span class="fc" id="L200">        double c = 0.48;</span>
<span class="fc" id="L201">        double d = 0.8;</span>
<span class="fc" id="L202">        FieldRotation&lt;Dfp&gt; r = createRotation(a, b, c, d, true);</span>
<span class="fc" id="L203">        FieldRotation&lt;Dfp&gt; reverted = r.revert();</span>
<span class="fc" id="L204">        FieldRotation&lt;Dfp&gt; rrT = r.compose(reverted, RotationConvention.VECTOR_OPERATOR);</span>
<span class="fc" id="L205">        checkRotationDS(rrT, 1, 0, 0, 0);</span>
<span class="fc" id="L206">        FieldRotation&lt;Dfp&gt; rTr = reverted.compose(r, RotationConvention.VECTOR_OPERATOR);</span>
<span class="fc" id="L207">        checkRotationDS(rTr, 1, 0, 0, 0);</span>
<span class="fc" id="L208">        Assert.assertEquals(r.getAngle().getReal(), reverted.getAngle().getReal(), 1.0e-15);</span>
<span class="fc" id="L209">        Assert.assertEquals(-1,</span>
<span class="fc" id="L210">                            FieldVector3D.dotProduct(r.getAxis(RotationConvention.VECTOR_OPERATOR),</span>
<span class="fc" id="L211">                                                     reverted.getAxis(RotationConvention.VECTOR_OPERATOR)).getReal(),</span>
                            1.0e-15);
<span class="fc" id="L213">    }</span>

    @Test
    public void testRevertFrameTransform() {
<span class="fc" id="L217">        double a = 0.001;</span>
<span class="fc" id="L218">        double b = 0.36;</span>
<span class="fc" id="L219">        double c = 0.48;</span>
<span class="fc" id="L220">        double d = 0.8;</span>
<span class="fc" id="L221">        FieldRotation&lt;Dfp&gt; r = createRotation(a, b, c, d, true);</span>
<span class="fc" id="L222">        FieldRotation&lt;Dfp&gt; reverted = r.revert();</span>
<span class="fc" id="L223">        FieldRotation&lt;Dfp&gt; rrT = r.compose(reverted, RotationConvention.FRAME_TRANSFORM);</span>
<span class="fc" id="L224">        checkRotationDS(rrT, 1, 0, 0, 0);</span>
<span class="fc" id="L225">        FieldRotation&lt;Dfp&gt; rTr = reverted.compose(r, RotationConvention.FRAME_TRANSFORM);</span>
<span class="fc" id="L226">        checkRotationDS(rTr, 1, 0, 0, 0);</span>
<span class="fc" id="L227">        Assert.assertEquals(r.getAngle().getReal(), reverted.getAngle().getReal(), 1.0e-15);</span>
<span class="fc" id="L228">        Assert.assertEquals(-1,</span>
<span class="fc" id="L229">                            FieldVector3D.dotProduct(r.getAxis(RotationConvention.FRAME_TRANSFORM),</span>
<span class="fc" id="L230">                                                     reverted.getAxis(RotationConvention.FRAME_TRANSFORM)).getReal(),</span>
                            1.0e-15);
<span class="fc" id="L232">    }</span>

    @Test
    public void testVectorOnePair() throws MathArithmeticException {

<span class="fc" id="L237">        FieldVector3D&lt;Dfp&gt; u = createVector(3, 2, 1);</span>
<span class="fc" id="L238">        FieldVector3D&lt;Dfp&gt; v = createVector(-4, 2, 2);</span>
<span class="fc" id="L239">        FieldRotation&lt;Dfp&gt; r = new FieldRotation&lt;&gt;(u, v);</span>
<span class="fc" id="L240">        checkVector(r.applyTo(u.scalarMultiply(v.getNorm())), v.scalarMultiply(u.getNorm()));</span>

<span class="fc" id="L242">        checkAngle(new FieldRotation&lt;&gt;(u, u.negate()).getAngle(), FastMath.PI);</span>

        try {
<span class="nc" id="L245">            new FieldRotation&lt;&gt;(u, createVector(0, 0, 0));</span>
<span class="nc" id="L246">            Assert.fail(&quot;an exception should have been thrown&quot;);</span>
<span class="fc" id="L247">        } catch (MathArithmeticException e) {</span>
            // expected behavior
<span class="nc" id="L249">        }</span>

<span class="fc" id="L251">    }</span>

    @Test
    public void testVectorTwoPairs() throws MathArithmeticException {

<span class="fc" id="L256">        FieldVector3D&lt;Dfp&gt; u1 = createVector(3, 0, 0);</span>
<span class="fc" id="L257">        FieldVector3D&lt;Dfp&gt; u2 = createVector(0, 5, 0);</span>
<span class="fc" id="L258">        FieldVector3D&lt;Dfp&gt; v1 = createVector(0, 0, 2);</span>
<span class="fc" id="L259">        FieldVector3D&lt;Dfp&gt; v2 = createVector(-2, 0, 2);</span>
<span class="fc" id="L260">        FieldRotation&lt;Dfp&gt; r = new FieldRotation&lt;&gt;(u1, u2, v1, v2);</span>
<span class="fc" id="L261">        checkVector(r.applyTo(createVector(1, 0, 0)), createVector(0, 0, 1));</span>
<span class="fc" id="L262">        checkVector(r.applyTo(createVector(0, 1, 0)), createVector(-1, 0, 0));</span>

<span class="fc" id="L264">        r = new FieldRotation&lt;&gt;(u1, u2, u1.negate(), u2.negate());</span>
<span class="fc" id="L265">        FieldVector3D&lt;Dfp&gt; axis = r.getAxis(RotationConvention.VECTOR_OPERATOR);</span>
<span class="pc bpc" id="L266" title="1 of 2 branches missed.">        if (FieldVector3D.dotProduct(axis, createVector(0, 0, 1)).getReal() &gt; 0) {</span>
<span class="nc" id="L267">            checkVector(axis, createVector(0, 0, 1));</span>
        } else {
<span class="fc" id="L269">            checkVector(axis, createVector(0, 0, -1));</span>
        }
<span class="fc" id="L271">        checkAngle(r.getAngle(), FastMath.PI);</span>

<span class="fc" id="L273">        double sqrt = FastMath.sqrt(2) / 2;</span>
<span class="fc" id="L274">        r = new FieldRotation&lt;&gt;(createVector(1, 0, 0),  createVector(0, 1, 0),</span>
<span class="fc" id="L275">                           createVector(0.5, 0.5,  sqrt),</span>
<span class="fc" id="L276">                           createVector(0.5, 0.5, -sqrt));</span>
<span class="fc" id="L277">        checkRotationDS(r, sqrt, 0.5, 0.5, 0);</span>

<span class="fc" id="L279">        r = new FieldRotation&lt;&gt;(u1, u2, u1, FieldVector3D.crossProduct(u1, u2));</span>
<span class="fc" id="L280">        checkRotationDS(r, sqrt, -sqrt, 0, 0);</span>

<span class="fc" id="L282">        checkRotationDS(new FieldRotation&lt;&gt;(u1, u2, u1, u2), 1, 0, 0, 0);</span>

        try {
<span class="nc" id="L285">            new FieldRotation&lt;&gt;(u1, u2, createVector(0, 0, 0), v2);</span>
<span class="nc" id="L286">            Assert.fail(&quot;an exception should have been thrown&quot;);</span>
<span class="fc" id="L287">        } catch (MathArithmeticException e) {</span>
            // expected behavior
<span class="nc" id="L289">        }</span>

<span class="fc" id="L291">    }</span>

    @Test
    public void testMatrix()
            throws NotARotationMatrixException {

        try {
<span class="nc" id="L298">            createRotation(new double[][] {</span>
                { 0.0, 1.0, 0.0 },
                { 1.0, 0.0, 0.0 }
            }, 1.0e-7);
<span class="nc" id="L302">            Assert.fail(&quot;Expecting NotARotationMatrixException&quot;);</span>
<span class="fc" id="L303">        } catch (NotARotationMatrixException nrme) {</span>
            // expected behavior
<span class="nc" id="L305">        }</span>

        try {
<span class="nc" id="L308">            createRotation(new double[][] {</span>
                {  0.445888,  0.797184, -0.407040 },
                {  0.821760, -0.184320,  0.539200 },
                { -0.354816,  0.574912,  0.737280 }
            }, 1.0e-7);
<span class="nc" id="L313">            Assert.fail(&quot;Expecting NotARotationMatrixException&quot;);</span>
<span class="fc" id="L314">        } catch (NotARotationMatrixException nrme) {</span>
            // expected behavior
<span class="nc" id="L316">        }</span>

        try {
<span class="nc" id="L319">            createRotation(new double[][] {</span>
                {  0.4,  0.8, -0.4 },
                { -0.4,  0.6,  0.7 },
                {  0.8, -0.2,  0.5 }
            }, 1.0e-15);
<span class="nc" id="L324">            Assert.fail(&quot;Expecting NotARotationMatrixException&quot;);</span>
<span class="fc" id="L325">        } catch (NotARotationMatrixException nrme) {</span>
            // expected behavior
<span class="nc" id="L327">        }</span>

<span class="fc" id="L329">        checkRotationDS(createRotation(new double[][] {</span>
            {  0.445888,  0.797184, -0.407040 },
            { -0.354816,  0.574912,  0.737280 },
            {  0.821760, -0.184320,  0.539200 }
        }, 1.0e-10),
        0.8, 0.288, 0.384, 0.36);

<span class="fc" id="L336">        checkRotationDS(createRotation(new double[][] {</span>
            {  0.539200,  0.737280,  0.407040 },
            {  0.184320, -0.574912,  0.797184 },
            {  0.821760, -0.354816, -0.445888 }
        }, 1.0e-10),
        0.36, 0.8, 0.288, 0.384);

<span class="fc" id="L343">        checkRotationDS(createRotation(new double[][] {</span>
            { -0.445888,  0.797184, -0.407040 },
            {  0.354816,  0.574912,  0.737280 },
            {  0.821760,  0.184320, -0.539200 }
        }, 1.0e-10),
        0.384, 0.36, 0.8, 0.288);

<span class="fc" id="L350">        checkRotationDS(createRotation(new double[][] {</span>
            { -0.539200,  0.737280,  0.407040 },
            { -0.184320, -0.574912,  0.797184 },
            {  0.821760,  0.354816,  0.445888 }
        }, 1.0e-10),
        0.288, 0.384, 0.36, 0.8);

<span class="fc" id="L357">        double[][] m1 = { { 0.0, 1.0, 0.0 },</span>
            { 0.0, 0.0, 1.0 },
            { 1.0, 0.0, 0.0 } };
<span class="fc" id="L360">        FieldRotation&lt;Dfp&gt; r = createRotation(m1, 1.0e-7);</span>
<span class="fc" id="L361">        checkVector(r.applyTo(createVector(1, 0, 0)), createVector(0, 0, 1));</span>
<span class="fc" id="L362">        checkVector(r.applyTo(createVector(0, 1, 0)), createVector(1, 0, 0));</span>
<span class="fc" id="L363">        checkVector(r.applyTo(createVector(0, 0, 1)), createVector(0, 1, 0));</span>

<span class="fc" id="L365">        double[][] m2 = { { 0.83203, -0.55012, -0.07139 },</span>
            { 0.48293,  0.78164, -0.39474 },
            { 0.27296,  0.29396,  0.91602 } };
<span class="fc" id="L368">        r = createRotation(m2, 1.0e-12);</span>

<span class="fc" id="L370">        Dfp[][] m3 = r.getMatrix();</span>
<span class="fc" id="L371">        double d00 = m2[0][0] - m3[0][0].getReal();</span>
<span class="fc" id="L372">        double d01 = m2[0][1] - m3[0][1].getReal();</span>
<span class="fc" id="L373">        double d02 = m2[0][2] - m3[0][2].getReal();</span>
<span class="fc" id="L374">        double d10 = m2[1][0] - m3[1][0].getReal();</span>
<span class="fc" id="L375">        double d11 = m2[1][1] - m3[1][1].getReal();</span>
<span class="fc" id="L376">        double d12 = m2[1][2] - m3[1][2].getReal();</span>
<span class="fc" id="L377">        double d20 = m2[2][0] - m3[2][0].getReal();</span>
<span class="fc" id="L378">        double d21 = m2[2][1] - m3[2][1].getReal();</span>
<span class="fc" id="L379">        double d22 = m2[2][2] - m3[2][2].getReal();</span>

<span class="pc bpc" id="L381" title="1 of 2 branches missed.">        Assert.assertTrue(FastMath.abs(d00) &lt; 6.0e-6);</span>
<span class="pc bpc" id="L382" title="1 of 2 branches missed.">        Assert.assertTrue(FastMath.abs(d01) &lt; 6.0e-6);</span>
<span class="pc bpc" id="L383" title="1 of 2 branches missed.">        Assert.assertTrue(FastMath.abs(d02) &lt; 6.0e-6);</span>
<span class="pc bpc" id="L384" title="1 of 2 branches missed.">        Assert.assertTrue(FastMath.abs(d10) &lt; 6.0e-6);</span>
<span class="pc bpc" id="L385" title="1 of 2 branches missed.">        Assert.assertTrue(FastMath.abs(d11) &lt; 6.0e-6);</span>
<span class="pc bpc" id="L386" title="1 of 2 branches missed.">        Assert.assertTrue(FastMath.abs(d12) &lt; 6.0e-6);</span>
<span class="pc bpc" id="L387" title="1 of 2 branches missed.">        Assert.assertTrue(FastMath.abs(d20) &lt; 6.0e-6);</span>
<span class="pc bpc" id="L388" title="1 of 2 branches missed.">        Assert.assertTrue(FastMath.abs(d21) &lt; 6.0e-6);</span>
<span class="pc bpc" id="L389" title="1 of 2 branches missed.">        Assert.assertTrue(FastMath.abs(d22) &lt; 6.0e-6);</span>

<span class="pc bpc" id="L391" title="1 of 2 branches missed.">        Assert.assertTrue(FastMath.abs(d00) &gt; 4.0e-7);</span>
<span class="pc bpc" id="L392" title="1 of 2 branches missed.">        Assert.assertTrue(FastMath.abs(d01) &gt; 4.0e-7);</span>
<span class="pc bpc" id="L393" title="1 of 2 branches missed.">        Assert.assertTrue(FastMath.abs(d02) &gt; 4.0e-7);</span>
<span class="pc bpc" id="L394" title="1 of 2 branches missed.">        Assert.assertTrue(FastMath.abs(d10) &gt; 4.0e-7);</span>
<span class="pc bpc" id="L395" title="1 of 2 branches missed.">        Assert.assertTrue(FastMath.abs(d11) &gt; 4.0e-7);</span>
<span class="pc bpc" id="L396" title="1 of 2 branches missed.">        Assert.assertTrue(FastMath.abs(d12) &gt; 4.0e-7);</span>
<span class="pc bpc" id="L397" title="1 of 2 branches missed.">        Assert.assertTrue(FastMath.abs(d20) &gt; 4.0e-7);</span>
<span class="pc bpc" id="L398" title="1 of 2 branches missed.">        Assert.assertTrue(FastMath.abs(d21) &gt; 4.0e-7);</span>
<span class="pc bpc" id="L399" title="1 of 2 branches missed.">        Assert.assertTrue(FastMath.abs(d22) &gt; 4.0e-7);</span>

<span class="fc bfc" id="L401" title="All 2 branches covered.">        for (int i = 0; i &lt; 3; ++i) {</span>
<span class="fc bfc" id="L402" title="All 2 branches covered.">            for (int j = 0; j &lt; 3; ++j) {</span>
<span class="fc" id="L403">                double m3tm3 = m3[i][0].getReal() * m3[j][0].getReal() +</span>
<span class="fc" id="L404">                               m3[i][1].getReal() * m3[j][1].getReal() +</span>
<span class="fc" id="L405">                               m3[i][2].getReal() * m3[j][2].getReal();</span>
<span class="fc bfc" id="L406" title="All 2 branches covered.">                if (i == j) {</span>
<span class="pc bpc" id="L407" title="1 of 2 branches missed.">                    Assert.assertTrue(FastMath.abs(m3tm3 - 1.0) &lt; 1.0e-10);</span>
                } else {
<span class="pc bpc" id="L409" title="1 of 2 branches missed.">                    Assert.assertTrue(FastMath.abs(m3tm3) &lt; 1.0e-10);</span>
                }
            }
        }

<span class="fc" id="L414">        checkVector(r.applyTo(createVector(1, 0, 0)),</span>
                    new FieldVector3D&lt;&gt;(m3[0][0], m3[1][0], m3[2][0]));
<span class="fc" id="L416">        checkVector(r.applyTo(createVector(0, 1, 0)),</span>
                    new FieldVector3D&lt;&gt;(m3[0][1], m3[1][1], m3[2][1]));
<span class="fc" id="L418">        checkVector(r.applyTo(createVector(0, 0, 1)),</span>
                    new FieldVector3D&lt;&gt;(m3[0][2], m3[1][2], m3[2][2]));

<span class="fc" id="L421">        double[][] m4 = { { 1.0,  0.0,  0.0 },</span>
            { 0.0, -1.0,  0.0 },
            { 0.0,  0.0, -1.0 } };
<span class="fc" id="L424">        r = createRotation(m4, 1.0e-7);</span>
<span class="fc" id="L425">        checkAngle(r.getAngle(), FastMath.PI);</span>

        try {
<span class="fc" id="L428">            double[][] m5 = { { 0.0, 0.0, 1.0 },</span>
                { 0.0, 1.0, 0.0 },
                { 1.0, 0.0, 0.0 } };
<span class="nc" id="L431">            r = createRotation(m5, 1.0e-7);</span>
<span class="nc" id="L432">            Assert.fail(&quot;got &quot; + r + &quot;, should have caught an exception&quot;);</span>
<span class="fc" id="L433">        } catch (NotARotationMatrixException e) {</span>
            // expected
<span class="nc" id="L435">        }</span>

<span class="fc" id="L437">    }</span>

    @Test
    @Deprecated
    public void testAnglesDeprecated()
            throws CardanEulerSingularityException {

<span class="fc" id="L444">        DfpField field = new DfpField(15);</span>

<span class="fc" id="L446">        RotationOrder[] CardanOrders = {</span>
            RotationOrder.XYZ, RotationOrder.XZY, RotationOrder.YXZ,
            RotationOrder.YZX, RotationOrder.ZXY, RotationOrder.ZYX
        };

<span class="fc bfc" id="L451" title="All 2 branches covered.">        for (int i = 0; i &lt; CardanOrders.length; ++i) {</span>
<span class="fc bfc" id="L452" title="All 2 branches covered.">            for (double alpha1 = 0.1; alpha1 &lt; 6.2; alpha1 += 2.0) {</span>
<span class="fc bfc" id="L453" title="All 2 branches covered.">                for (double alpha2 = -1.55; alpha2 &lt; 1.55; alpha2 += 0.8) {</span>
<span class="fc bfc" id="L454" title="All 2 branches covered.">                    for (double alpha3 = 0.1; alpha3 &lt; 6.2; alpha3 += 2.0) {</span>
<span class="fc" id="L455">                        FieldRotation&lt;Dfp&gt; r = new FieldRotation&lt;&gt;(CardanOrders[i],</span>
<span class="fc" id="L456">                                                                      field.newDfp(alpha1),</span>
<span class="fc" id="L457">                                                                      field.newDfp(alpha2),</span>
<span class="fc" id="L458">                                                                      field.newDfp(alpha3));</span>
<span class="fc" id="L459">                        Dfp[] angles = r.getAngles(CardanOrders[i]);</span>
<span class="fc" id="L460">                        checkAngle(angles[0], alpha1);</span>
<span class="fc" id="L461">                        checkAngle(angles[1], alpha2);</span>
<span class="fc" id="L462">                        checkAngle(angles[2], alpha3);</span>
                    }
                }
            }
        }

<span class="fc" id="L468">        RotationOrder[] EulerOrders = {</span>
            RotationOrder.XYX, RotationOrder.XZX, RotationOrder.YXY,
            RotationOrder.YZY, RotationOrder.ZXZ, RotationOrder.ZYZ
        };

<span class="fc bfc" id="L473" title="All 2 branches covered.">        for (int i = 0; i &lt; EulerOrders.length; ++i) {</span>
<span class="fc bfc" id="L474" title="All 2 branches covered.">            for (double alpha1 = 0.1; alpha1 &lt; 6.2; alpha1 += 2.0) {</span>
<span class="fc bfc" id="L475" title="All 2 branches covered.">                for (double alpha2 = 0.05; alpha2 &lt; 3.1; alpha2 += 0.8) {</span>
<span class="fc bfc" id="L476" title="All 2 branches covered.">                    for (double alpha3 = 0.1; alpha3 &lt; 6.2; alpha3 += 2.0) {</span>
<span class="fc" id="L477">                        FieldRotation&lt;Dfp&gt; r = new FieldRotation&lt;&gt;(EulerOrders[i],</span>
<span class="fc" id="L478">                                                                      field.newDfp(alpha1),</span>
<span class="fc" id="L479">                                                                      field.newDfp(alpha2),</span>
<span class="fc" id="L480">                                                                      field.newDfp(alpha3));</span>
<span class="fc" id="L481">                        Dfp[] angles = r.getAngles(EulerOrders[i]);</span>
<span class="fc" id="L482">                        checkAngle(angles[0], alpha1);</span>
<span class="fc" id="L483">                        checkAngle(angles[1], alpha2);</span>
<span class="fc" id="L484">                        checkAngle(angles[2], alpha3);</span>
                    }
                }
            }
        }

<span class="fc" id="L490">    }</span>

    @Test
    public void testAngles()
        throws CardanEulerSingularityException {

<span class="fc" id="L496">        DfpField field = new DfpField(15);</span>

<span class="fc bfc" id="L498" title="All 2 branches covered.">        for (RotationConvention convention : RotationConvention.values()) {</span>
<span class="fc" id="L499">            RotationOrder[] CardanOrders = {</span>
                RotationOrder.XYZ, RotationOrder.XZY, RotationOrder.YXZ,
                RotationOrder.YZX, RotationOrder.ZXY, RotationOrder.ZYX
            };

<span class="fc bfc" id="L504" title="All 2 branches covered.">            for (int i = 0; i &lt; CardanOrders.length; ++i) {</span>
<span class="fc bfc" id="L505" title="All 2 branches covered.">                for (double alpha1 = 0.1; alpha1 &lt; 6.2; alpha1 += 2.0) {</span>
<span class="fc bfc" id="L506" title="All 2 branches covered.">                    for (double alpha2 = -1.55; alpha2 &lt; 1.55; alpha2 += 0.8) {</span>
<span class="fc bfc" id="L507" title="All 2 branches covered.">                        for (double alpha3 = 0.1; alpha3 &lt; 6.2; alpha3 += 2.0) {</span>
<span class="fc" id="L508">                            FieldRotation&lt;Dfp&gt; r = new FieldRotation&lt;&gt;(CardanOrders[i],</span>
                                                                          convention,
<span class="fc" id="L510">                                                                          field.newDfp(alpha1),</span>
<span class="fc" id="L511">                                                                          field.newDfp(alpha2),</span>
<span class="fc" id="L512">                                                                          field.newDfp(alpha3));</span>
<span class="fc" id="L513">                            Dfp[] angles = r.getAngles(CardanOrders[i], convention);</span>
<span class="fc" id="L514">                            checkAngle(angles[0], alpha1);</span>
<span class="fc" id="L515">                            checkAngle(angles[1], alpha2);</span>
<span class="fc" id="L516">                            checkAngle(angles[2], alpha3);</span>
                        }
                    }
                }
            }

<span class="fc" id="L522">            RotationOrder[] EulerOrders = {</span>
                RotationOrder.XYX, RotationOrder.XZX, RotationOrder.YXY,
                RotationOrder.YZY, RotationOrder.ZXZ, RotationOrder.ZYZ
            };

<span class="fc bfc" id="L527" title="All 2 branches covered.">            for (int i = 0; i &lt; EulerOrders.length; ++i) {</span>
<span class="fc bfc" id="L528" title="All 2 branches covered.">                for (double alpha1 = 0.1; alpha1 &lt; 6.2; alpha1 += 2.0) {</span>
<span class="fc bfc" id="L529" title="All 2 branches covered.">                    for (double alpha2 = 0.05; alpha2 &lt; 3.1; alpha2 += 0.8) {</span>
<span class="fc bfc" id="L530" title="All 2 branches covered.">                        for (double alpha3 = 0.1; alpha3 &lt; 6.2; alpha3 += 2.0) {</span>
<span class="fc" id="L531">                            FieldRotation&lt;Dfp&gt; r = new FieldRotation&lt;&gt;(EulerOrders[i],</span>
                                                                          convention,
<span class="fc" id="L533">                                                                          field.newDfp(alpha1),</span>
<span class="fc" id="L534">                                                                          field.newDfp(alpha2),</span>
<span class="fc" id="L535">                                                                          field.newDfp(alpha3));</span>
<span class="fc" id="L536">                            Dfp[] angles = r.getAngles(EulerOrders[i], convention);</span>
<span class="fc" id="L537">                            checkAngle(angles[0], alpha1);</span>
<span class="fc" id="L538">                            checkAngle(angles[1], alpha2);</span>
<span class="fc" id="L539">                            checkAngle(angles[2], alpha3);</span>
                        }
                    }
                }
            }
        }

<span class="fc" id="L546">    }</span>

    @Test
    public void testSingularities() {

<span class="fc" id="L551">        DfpField field = new DfpField(20);</span>
<span class="fc bfc" id="L552" title="All 2 branches covered.">        for (RotationConvention convention : RotationConvention.values()) {</span>
<span class="fc" id="L553">            RotationOrder[] CardanOrders = {</span>
                RotationOrder.XYZ, RotationOrder.XZY, RotationOrder.YXZ,
                RotationOrder.YZX, RotationOrder.ZXY, RotationOrder.ZYX
            };

<span class="fc" id="L558">            double[] singularCardanAngle = { FastMath.PI / 2, -FastMath.PI / 2 };</span>
<span class="fc bfc" id="L559" title="All 2 branches covered.">            for (int i = 0; i &lt; CardanOrders.length; ++i) {</span>
<span class="fc bfc" id="L560" title="All 2 branches covered.">                for (int j = 0; j &lt; singularCardanAngle.length; ++j) {</span>
<span class="fc" id="L561">                    FieldRotation&lt;Dfp&gt; r = new FieldRotation&lt;&gt;(CardanOrders[i],</span>
                                                                  convention,
<span class="fc" id="L563">                                                                  field.newDfp(0.1),</span>
<span class="fc" id="L564">                                                                  field.newDfp(singularCardanAngle[j]),</span>
<span class="fc" id="L565">                                                                  field.newDfp(0.3));</span>
                    try {
<span class="nc" id="L567">                        r.getAngles(CardanOrders[i], convention);</span>
<span class="nc" id="L568">                        Assert.fail(&quot;an exception should have been caught&quot;);</span>
<span class="fc" id="L569">                    } catch (CardanEulerSingularityException cese) {</span>
                        // expected behavior
<span class="nc" id="L571">                    }</span>
                }
            }

<span class="fc" id="L575">            RotationOrder[] EulerOrders = {</span>
                RotationOrder.XYX, RotationOrder.XZX, RotationOrder.YXY,
                RotationOrder.YZY, RotationOrder.ZXZ, RotationOrder.ZYZ
            };

<span class="fc" id="L580">            double[] singularEulerAngle = { 0, FastMath.PI };</span>
<span class="fc bfc" id="L581" title="All 2 branches covered.">            for (int i = 0; i &lt; EulerOrders.length; ++i) {</span>
<span class="fc bfc" id="L582" title="All 2 branches covered.">                for (int j = 0; j &lt; singularEulerAngle.length; ++j) {</span>
<span class="fc" id="L583">                    FieldRotation&lt;Dfp&gt; r = new FieldRotation&lt;&gt;(EulerOrders[i],</span>
                                                                  convention,
<span class="fc" id="L585">                                                                  field.newDfp(0.1),</span>
<span class="fc" id="L586">                                                                  field.newDfp(singularEulerAngle[j]),</span>
<span class="fc" id="L587">                                                                  field.newDfp(0.3));</span>
                    try {
<span class="nc" id="L589">                        r.getAngles(EulerOrders[i], convention);</span>
<span class="nc" id="L590">                        Assert.fail(&quot;an exception should have been caught&quot;);</span>
<span class="fc" id="L591">                    } catch (CardanEulerSingularityException cese) {</span>
                        // expected behavior
<span class="nc" id="L593">                    }</span>
                }
            }

        }
<span class="fc" id="L598">    }</span>

    @Test
    public void testQuaternion() throws MathIllegalArgumentException {

<span class="fc" id="L603">        FieldRotation&lt;Dfp&gt; r1 = new FieldRotation&lt;&gt;(createVector(2, -3, 5),</span>
<span class="fc" id="L604">                                                       createAngle(1.7),</span>
                                                       RotationConvention.VECTOR_OPERATOR);
<span class="fc" id="L606">        double n = 23.5;</span>
<span class="fc" id="L607">        FieldRotation&lt;Dfp&gt; r2 = new FieldRotation&lt;&gt;(r1.getQ0().multiply(n), r1.getQ1().multiply(n),</span>
<span class="fc" id="L608">                                                       r1.getQ2().multiply(n), r1.getQ3().multiply(n),</span>
                                                       true);
<span class="fc bfc" id="L610" title="All 2 branches covered.">        for (double x = -0.9; x &lt; 0.9; x += 0.2) {</span>
<span class="fc bfc" id="L611" title="All 2 branches covered.">            for (double y = -0.9; y &lt; 0.9; y += 0.2) {</span>
<span class="fc bfc" id="L612" title="All 2 branches covered.">                for (double z = -0.9; z &lt; 0.9; z += 0.2) {</span>
<span class="fc" id="L613">                    FieldVector3D&lt;Dfp&gt; u = createVector(x, y, z);</span>
<span class="fc" id="L614">                    checkVector(r2.applyTo(u), r1.applyTo(u));</span>
                }
            }
        }

<span class="fc" id="L619">        r1 = createRotation(0.288,  0.384,  0.36,  0.8, false);</span>
<span class="fc" id="L620">        checkRotationDS(r1,</span>
<span class="fc" id="L621">                        -r1.getQ0().getReal(), -r1.getQ1().getReal(),</span>
<span class="fc" id="L622">                        -r1.getQ2().getReal(), -r1.getQ3().getReal());</span>

<span class="fc" id="L624">    }</span>

    @Test
    public void testApplyToRotation() throws MathIllegalArgumentException {

<span class="fc" id="L629">        FieldRotation&lt;Dfp&gt; r1       = new FieldRotation&lt;&gt;(createVector(2, -3, 5),</span>
<span class="fc" id="L630">                                                             createAngle(1.7),</span>
                                                             RotationConvention.VECTOR_OPERATOR);
<span class="fc" id="L632">        FieldRotation&lt;Dfp&gt; r2       = new FieldRotation&lt;&gt;(createVector(-1, 3, 2),</span>
<span class="fc" id="L633">                                                             createAngle(0.3),</span>
                                                             RotationConvention.VECTOR_OPERATOR);
<span class="fc" id="L635">        FieldRotation&lt;Dfp&gt; r3       = r2.applyTo(r1);</span>
<span class="fc" id="L636">        FieldRotation&lt;Dfp&gt; r3Double = r2.applyTo(new Rotation(r1.getQ0().getReal(),</span>
<span class="fc" id="L637">                                                      r1.getQ1().getReal(),</span>
<span class="fc" id="L638">                                                      r1.getQ2().getReal(),</span>
<span class="fc" id="L639">                                                      r1.getQ3().getReal(),</span>
                                                      false));

<span class="fc bfc" id="L642" title="All 2 branches covered.">        for (double x = -0.9; x &lt; 0.9; x += 0.2) {</span>
<span class="fc bfc" id="L643" title="All 2 branches covered.">            for (double y = -0.9; y &lt; 0.9; y += 0.2) {</span>
<span class="fc bfc" id="L644" title="All 2 branches covered.">                for (double z = -0.9; z &lt; 0.9; z += 0.2) {</span>
<span class="fc" id="L645">                    FieldVector3D&lt;Dfp&gt; u = createVector(x, y, z);</span>
<span class="fc" id="L646">                    checkVector(r2.applyTo(r1.applyTo(u)), r3.applyTo(u));</span>
<span class="fc" id="L647">                    checkVector(r2.applyTo(r1.applyTo(u)), r3Double.applyTo(u));</span>
                }
            }
        }

<span class="fc" id="L652">    }</span>

    @Test
    public void testComposeVectorOperator() throws MathIllegalArgumentException {

<span class="fc" id="L657">        FieldRotation&lt;Dfp&gt; r1       = new FieldRotation&lt;&gt;(createVector(2, -3, 5),</span>
<span class="fc" id="L658">                                                             createAngle(1.7),</span>
                                                             RotationConvention.VECTOR_OPERATOR);
<span class="fc" id="L660">        FieldRotation&lt;Dfp&gt; r2       = new FieldRotation&lt;&gt;(createVector(-1, 3, 2),</span>
<span class="fc" id="L661">                                                             createAngle(0.3),</span>
                                                             RotationConvention.VECTOR_OPERATOR);
<span class="fc" id="L663">        FieldRotation&lt;Dfp&gt; r3       = r2.compose(r1, RotationConvention.VECTOR_OPERATOR);</span>
<span class="fc" id="L664">        FieldRotation&lt;Dfp&gt; r3Double = r2.compose(new Rotation(r1.getQ0().getReal(),</span>
<span class="fc" id="L665">                                                      r1.getQ1().getReal(),</span>
<span class="fc" id="L666">                                                      r1.getQ2().getReal(),</span>
<span class="fc" id="L667">                                                      r1.getQ3().getReal(),</span>
                                                      false),
                                                 RotationConvention.VECTOR_OPERATOR);

<span class="fc bfc" id="L671" title="All 2 branches covered.">        for (double x = -0.9; x &lt; 0.9; x += 0.2) {</span>
<span class="fc bfc" id="L672" title="All 2 branches covered.">            for (double y = -0.9; y &lt; 0.9; y += 0.2) {</span>
<span class="fc bfc" id="L673" title="All 2 branches covered.">                for (double z = -0.9; z &lt; 0.9; z += 0.2) {</span>
<span class="fc" id="L674">                    FieldVector3D&lt;Dfp&gt; u = createVector(x, y, z);</span>
<span class="fc" id="L675">                    checkVector(r2.applyTo(r1.applyTo(u)), r3.applyTo(u));</span>
<span class="fc" id="L676">                    checkVector(r2.applyTo(r1.applyTo(u)), r3Double.applyTo(u));</span>
                }
            }
        }

<span class="fc" id="L681">    }</span>

    @Test
    public void testComposeFrameTransform() throws MathIllegalArgumentException {

<span class="fc" id="L686">        FieldRotation&lt;Dfp&gt; r1       = new FieldRotation&lt;&gt;(createVector(2, -3, 5),</span>
<span class="fc" id="L687">                                                             createAngle(1.7),</span>
                                                             RotationConvention.FRAME_TRANSFORM);
<span class="fc" id="L689">        FieldRotation&lt;Dfp&gt; r2       = new FieldRotation&lt;&gt;(createVector(-1, 3, 2),</span>
<span class="fc" id="L690">                                                             createAngle(0.3),</span>
                                                             RotationConvention.FRAME_TRANSFORM);
<span class="fc" id="L692">        FieldRotation&lt;Dfp&gt; r3       = r2.compose(r1, RotationConvention.FRAME_TRANSFORM);</span>
<span class="fc" id="L693">        FieldRotation&lt;Dfp&gt; r3Double = r2.compose(new Rotation(r1.getQ0().getReal(),</span>
<span class="fc" id="L694">                                                      r1.getQ1().getReal(),</span>
<span class="fc" id="L695">                                                      r1.getQ2().getReal(),</span>
<span class="fc" id="L696">                                                      r1.getQ3().getReal(),</span>
                                                      false),
                                                 RotationConvention.FRAME_TRANSFORM);
<span class="fc" id="L699">        FieldRotation&lt;Dfp&gt; r4 = r1.compose(r2, RotationConvention.VECTOR_OPERATOR);</span>
<span class="fc" id="L700">        Assert.assertEquals(0.0, FieldRotation.distance(r3, r4).getReal(), 1.0e-15);</span>

<span class="fc bfc" id="L702" title="All 2 branches covered.">        for (double x = -0.9; x &lt; 0.9; x += 0.2) {</span>
<span class="fc bfc" id="L703" title="All 2 branches covered.">            for (double y = -0.9; y &lt; 0.9; y += 0.2) {</span>
<span class="fc bfc" id="L704" title="All 2 branches covered.">                for (double z = -0.9; z &lt; 0.9; z += 0.2) {</span>
<span class="fc" id="L705">                    FieldVector3D&lt;Dfp&gt; u = createVector(x, y, z);</span>
<span class="fc" id="L706">                    checkVector(r1.applyTo(r2.applyTo(u)), r3.applyTo(u));</span>
<span class="fc" id="L707">                    checkVector(r1.applyTo(r2.applyTo(u)), r3Double.applyTo(u));</span>
                }
            }
        }

<span class="fc" id="L712">    }</span>

    @Test
    public void testApplyInverseToRotation() throws MathIllegalArgumentException {

<span class="fc" id="L717">        FieldRotation&lt;Dfp&gt; r1 = new FieldRotation&lt;&gt;(createVector(2, -3, 5),</span>
<span class="fc" id="L718">                                                       createAngle(1.7),</span>
                                                       RotationConvention.VECTOR_OPERATOR);
<span class="fc" id="L720">        FieldRotation&lt;Dfp&gt; r2 = new FieldRotation&lt;&gt;(createVector(-1, 3, 2),</span>
<span class="fc" id="L721">                                                       createAngle(0.3),</span>
                                                       RotationConvention.VECTOR_OPERATOR);
<span class="fc" id="L723">        FieldRotation&lt;Dfp&gt; r3 = r2.applyInverseTo(r1);</span>
<span class="fc" id="L724">        FieldRotation&lt;Dfp&gt; r3Double = r2.applyInverseTo(new Rotation(r1.getQ0().getReal(),</span>
<span class="fc" id="L725">                                                             r1.getQ1().getReal(),</span>
<span class="fc" id="L726">                                                             r1.getQ2().getReal(),</span>
<span class="fc" id="L727">                                                             r1.getQ3().getReal(),</span>
                                                             false));

<span class="fc bfc" id="L730" title="All 2 branches covered.">        for (double x = -0.9; x &lt; 0.9; x += 0.2) {</span>
<span class="fc bfc" id="L731" title="All 2 branches covered.">            for (double y = -0.9; y &lt; 0.9; y += 0.2) {</span>
<span class="fc bfc" id="L732" title="All 2 branches covered.">                for (double z = -0.9; z &lt; 0.9; z += 0.2) {</span>
<span class="fc" id="L733">                    FieldVector3D&lt;Dfp&gt; u = createVector(x, y, z);</span>
<span class="fc" id="L734">                    checkVector(r2.applyInverseTo(r1.applyTo(u)), r3.applyTo(u));</span>
<span class="fc" id="L735">                    checkVector(r2.applyInverseTo(r1.applyTo(u)), r3Double.applyTo(u));</span>
                }
            }
        }

<span class="fc" id="L740">    }</span>

    @Test
    public void testComposeInverseVectorOperator() throws MathIllegalArgumentException {

<span class="fc" id="L745">        FieldRotation&lt;Dfp&gt; r1 = new FieldRotation&lt;&gt;(createVector(2, -3, 5),</span>
<span class="fc" id="L746">                                                       createAngle(1.7),</span>
                                                       RotationConvention.VECTOR_OPERATOR);
<span class="fc" id="L748">        FieldRotation&lt;Dfp&gt; r2 = new FieldRotation&lt;&gt;(createVector(-1, 3, 2),</span>
<span class="fc" id="L749">                                                       createAngle(0.3),</span>
                                                       RotationConvention.VECTOR_OPERATOR);
<span class="fc" id="L751">        FieldRotation&lt;Dfp&gt; r3 = r2.composeInverse(r1, RotationConvention.VECTOR_OPERATOR);</span>
<span class="fc" id="L752">        FieldRotation&lt;Dfp&gt; r3Double = r2.composeInverse(new Rotation(r1.getQ0().getReal(),</span>
<span class="fc" id="L753">                                                             r1.getQ1().getReal(),</span>
<span class="fc" id="L754">                                                             r1.getQ2().getReal(),</span>
<span class="fc" id="L755">                                                             r1.getQ3().getReal(),</span>
                                                             false),
                                                        RotationConvention.VECTOR_OPERATOR);

<span class="fc bfc" id="L759" title="All 2 branches covered.">        for (double x = -0.9; x &lt; 0.9; x += 0.2) {</span>
<span class="fc bfc" id="L760" title="All 2 branches covered.">            for (double y = -0.9; y &lt; 0.9; y += 0.2) {</span>
<span class="fc bfc" id="L761" title="All 2 branches covered.">                for (double z = -0.9; z &lt; 0.9; z += 0.2) {</span>
<span class="fc" id="L762">                    FieldVector3D&lt;Dfp&gt; u = createVector(x, y, z);</span>
<span class="fc" id="L763">                    checkVector(r2.applyInverseTo(r1.applyTo(u)), r3.applyTo(u));</span>
<span class="fc" id="L764">                    checkVector(r2.applyInverseTo(r1.applyTo(u)), r3Double.applyTo(u));</span>
                }
            }
        }

<span class="fc" id="L769">    }</span>

    @Test
    public void testComposeInverseFrameTransform() throws MathIllegalArgumentException {

<span class="fc" id="L774">        FieldRotation&lt;Dfp&gt; r1 = new FieldRotation&lt;&gt;(createVector(2, -3, 5),</span>
<span class="fc" id="L775">                                                       createAngle(1.7),</span>
                                                       RotationConvention.FRAME_TRANSFORM);
<span class="fc" id="L777">        FieldRotation&lt;Dfp&gt; r2 = new FieldRotation&lt;&gt;(createVector(-1, 3, 2),</span>
<span class="fc" id="L778">                                                       createAngle(0.3),</span>
                                                       RotationConvention.FRAME_TRANSFORM);
<span class="fc" id="L780">        FieldRotation&lt;Dfp&gt; r3 = r2.composeInverse(r1, RotationConvention.FRAME_TRANSFORM);</span>
<span class="fc" id="L781">        FieldRotation&lt;Dfp&gt; r3Double = r2.composeInverse(new Rotation(r1.getQ0().getReal(),</span>
<span class="fc" id="L782">                                                             r1.getQ1().getReal(),</span>
<span class="fc" id="L783">                                                             r1.getQ2().getReal(),</span>
<span class="fc" id="L784">                                                             r1.getQ3().getReal(),</span>
                                                             false),
                                                        RotationConvention.FRAME_TRANSFORM);
<span class="fc" id="L787">        FieldRotation&lt;Dfp&gt; r4 = r1.revert().composeInverse(r2.revert(), RotationConvention.VECTOR_OPERATOR);</span>
<span class="fc" id="L788">        Assert.assertEquals(0.0, FieldRotation.distance(r3, r4).getReal(), 1.0e-15);</span>

<span class="fc bfc" id="L790" title="All 2 branches covered.">        for (double x = -0.9; x &lt; 0.9; x += 0.2) {</span>
<span class="fc bfc" id="L791" title="All 2 branches covered.">            for (double y = -0.9; y &lt; 0.9; y += 0.2) {</span>
<span class="fc bfc" id="L792" title="All 2 branches covered.">                for (double z = -0.9; z &lt; 0.9; z += 0.2) {</span>
<span class="fc" id="L793">                    FieldVector3D&lt;Dfp&gt; u = createVector(x, y, z);</span>
<span class="fc" id="L794">                    checkVector(r1.applyTo(r2.applyInverseTo(u)), r3.applyTo(u));</span>
<span class="fc" id="L795">                    checkVector(r1.applyTo(r2.applyInverseTo(u)), r3Double.applyTo(u));</span>
                }
            }
        }

<span class="fc" id="L800">    }</span>

    @Test
    public void testDoubleVectors() throws MathIllegalArgumentException {
<span class="fc" id="L804">        UniformRandomProvider random = RandomSource.create(RandomSource.WELL_1024_A,</span>
<span class="fc" id="L805">                                                           0x180b41cfeeffaf67l);</span>
<span class="fc" id="L806">        UnitSphereSampler g = new UnitSphereSampler(3, random);</span>
<span class="fc bfc" id="L807" title="All 2 branches covered.">        for (int i = 0; i &lt; 10; ++i) {</span>
<span class="fc" id="L808">            double[] unit = g.nextVector();</span>
<span class="fc" id="L809">            FieldRotation&lt;Dfp&gt; r = new FieldRotation&lt;&gt;(createVector(unit[0], unit[1], unit[2]),</span>
<span class="fc" id="L810">                                                          createAngle(random.nextDouble()),</span>
                                                          RotationConvention.VECTOR_OPERATOR);

<span class="fc bfc" id="L813" title="All 2 branches covered.">            for (double x = -0.9; x &lt; 0.9; x += 0.4) {</span>
<span class="fc bfc" id="L814" title="All 2 branches covered.">                for (double y = -0.9; y &lt; 0.9; y += 0.4) {</span>
<span class="fc bfc" id="L815" title="All 2 branches covered.">                    for (double z = -0.9; z &lt; 0.9; z += 0.4) {</span>
<span class="fc" id="L816">                        FieldVector3D&lt;Dfp&gt; uds   = createVector(x, y, z);</span>
<span class="fc" id="L817">                        FieldVector3D&lt;Dfp&gt; ruds  = r.applyTo(uds);</span>
<span class="fc" id="L818">                        FieldVector3D&lt;Dfp&gt; rIuds = r.applyInverseTo(uds);</span>
<span class="fc" id="L819">                        Cartesian3D   u     = new Cartesian3D(x, y, z);</span>
<span class="fc" id="L820">                        FieldVector3D&lt;Dfp&gt; ru    = r.applyTo(u);</span>
<span class="fc" id="L821">                        FieldVector3D&lt;Dfp&gt; rIu   = r.applyInverseTo(u);</span>
<span class="fc" id="L822">                        Dfp[] ruArray = new Dfp[3];</span>
<span class="fc" id="L823">                        r.applyTo(new double[] { x, y, z}, ruArray);</span>
<span class="fc" id="L824">                        Dfp[] rIuArray = new Dfp[3];</span>
<span class="fc" id="L825">                        r.applyInverseTo(new double[] { x, y, z}, rIuArray);</span>
<span class="fc" id="L826">                        checkVector(ruds, ru);</span>
<span class="fc" id="L827">                        checkVector(ruds, new FieldVector3D&lt;&gt;(ruArray));</span>
<span class="fc" id="L828">                        checkVector(rIuds, rIu);</span>
<span class="fc" id="L829">                        checkVector(rIuds, new FieldVector3D&lt;&gt;(rIuArray));</span>
                    }
                }
            }
        }

<span class="fc" id="L835">    }</span>

    @Test
    public void testDoubleRotations() throws MathIllegalArgumentException {
<span class="fc" id="L839">        UniformRandomProvider random = RandomSource.create(RandomSource.WELL_1024_A,</span>
<span class="fc" id="L840">                                                           0x180b41cfeeffaf67l);</span>
<span class="fc" id="L841">        DfpField field = new DfpField(20);</span>
<span class="fc" id="L842">        UnitSphereSampler g = new UnitSphereSampler(3, random);</span>
<span class="fc bfc" id="L843" title="All 2 branches covered.">        for (int i = 0; i &lt; 10; ++i) {</span>
<span class="fc" id="L844">            double[] unit1 = g.nextVector();</span>
<span class="fc" id="L845">            Rotation r1 = new Rotation(new Cartesian3D(unit1[0], unit1[1], unit1[2]),</span>
<span class="fc" id="L846">                                      random.nextDouble(), RotationConvention.VECTOR_OPERATOR);</span>
<span class="fc" id="L847">            FieldRotation&lt;Dfp&gt; r1Prime = new FieldRotation&lt;&gt;(field.newDfp(r1.getQ0()),</span>
<span class="fc" id="L848">                                                                field.newDfp(r1.getQ1()),</span>
<span class="fc" id="L849">                                                                field.newDfp(r1.getQ2()),</span>
<span class="fc" id="L850">                                                                field.newDfp(r1.getQ3()),</span>
                                                                false);
<span class="fc" id="L852">            double[] unit2 = g.nextVector();</span>
<span class="fc" id="L853">            FieldRotation&lt;Dfp&gt; r2 = new FieldRotation&lt;&gt;(createVector(unit2[0], unit2[1], unit2[2]),</span>
<span class="fc" id="L854">                                                           createAngle(random.nextDouble()),</span>
                                                           RotationConvention.VECTOR_OPERATOR);

<span class="fc" id="L857">            FieldRotation&lt;Dfp&gt; rA = FieldRotation.applyTo(r1, r2);</span>
<span class="fc" id="L858">            FieldRotation&lt;Dfp&gt; rB = r1Prime.compose(r2, RotationConvention.VECTOR_OPERATOR);</span>
<span class="fc" id="L859">            FieldRotation&lt;Dfp&gt; rC = FieldRotation.applyInverseTo(r1, r2);</span>
<span class="fc" id="L860">            FieldRotation&lt;Dfp&gt; rD = r1Prime.composeInverse(r2, RotationConvention.VECTOR_OPERATOR);</span>

<span class="fc bfc" id="L862" title="All 2 branches covered.">            for (double x = -0.9; x &lt; 0.9; x += 0.4) {</span>
<span class="fc bfc" id="L863" title="All 2 branches covered.">                for (double y = -0.9; y &lt; 0.9; y += 0.4) {</span>
<span class="fc bfc" id="L864" title="All 2 branches covered.">                    for (double z = -0.9; z &lt; 0.9; z += 0.4) {</span>

<span class="fc" id="L866">                        FieldVector3D&lt;Dfp&gt; uds   = createVector(x, y, z);</span>
<span class="fc" id="L867">                        checkVector(r1Prime.applyTo(uds), FieldRotation.applyTo(r1, uds));</span>
<span class="fc" id="L868">                        checkVector(r1Prime.applyInverseTo(uds), FieldRotation.applyInverseTo(r1, uds));</span>
<span class="fc" id="L869">                        checkVector(rA.applyTo(uds), rB.applyTo(uds));</span>
<span class="fc" id="L870">                        checkVector(rA.applyInverseTo(uds), rB.applyInverseTo(uds));</span>
<span class="fc" id="L871">                        checkVector(rC.applyTo(uds), rD.applyTo(uds));</span>
<span class="fc" id="L872">                        checkVector(rC.applyInverseTo(uds), rD.applyInverseTo(uds));</span>

                    }
                }
            }
        }

<span class="fc" id="L879">    }</span>

    @Test
    public void testArray() throws MathIllegalArgumentException {

<span class="fc" id="L884">        FieldRotation&lt;Dfp&gt; r = new FieldRotation&lt;&gt;(createAxis(2, -3, 5),</span>
<span class="fc" id="L885">                                                      createAngle(1.7),</span>
                                                      RotationConvention.VECTOR_OPERATOR);

<span class="fc bfc" id="L888" title="All 2 branches covered.">        for (double x = -0.9; x &lt; 0.9; x += 0.2) {</span>
<span class="fc bfc" id="L889" title="All 2 branches covered.">            for (double y = -0.9; y &lt; 0.9; y += 0.2) {</span>
<span class="fc bfc" id="L890" title="All 2 branches covered.">                for (double z = -0.9; z &lt; 0.9; z += 0.2) {</span>
<span class="fc" id="L891">                    FieldVector3D&lt;Dfp&gt; u = createVector(x, y, z);</span>
<span class="fc" id="L892">                    FieldVector3D&lt;Dfp&gt; v = r.applyTo(u);</span>
<span class="fc" id="L893">                    Dfp[] out = new Dfp[3];</span>
<span class="fc" id="L894">                    r.applyTo(new Dfp[] { u.getX(), u.getY(), u.getZ() }, out);</span>
<span class="fc" id="L895">                    Assert.assertEquals(v.getX().getReal(), out[0].getReal(), 1.0e-10);</span>
<span class="fc" id="L896">                    Assert.assertEquals(v.getY().getReal(), out[1].getReal(), 1.0e-10);</span>
<span class="fc" id="L897">                    Assert.assertEquals(v.getZ().getReal(), out[2].getReal(), 1.0e-10);</span>
<span class="fc" id="L898">                    r.applyInverseTo(out, out);</span>
<span class="fc" id="L899">                    Assert.assertEquals(u.getX().getReal(), out[0].getReal(), 1.0e-10);</span>
<span class="fc" id="L900">                    Assert.assertEquals(u.getY().getReal(), out[1].getReal(), 1.0e-10);</span>
<span class="fc" id="L901">                    Assert.assertEquals(u.getZ().getReal(), out[2].getReal(), 1.0e-10);</span>
                }
            }
        }

<span class="fc" id="L906">    }</span>

    @Test
    public void testApplyInverseTo() throws MathIllegalArgumentException {

<span class="fc" id="L911">        Dfp[] in      = new Dfp[3];</span>
<span class="fc" id="L912">        Dfp[] out     = new Dfp[3];</span>
<span class="fc" id="L913">        Dfp[] rebuilt = new Dfp[3];</span>
<span class="fc" id="L914">        FieldRotation&lt;Dfp&gt; r = new FieldRotation&lt;&gt;(createVector(2, -3, 5),</span>
<span class="fc" id="L915">                                                      createAngle(1.7),</span>
                                                      RotationConvention.VECTOR_OPERATOR);
<span class="fc bfc" id="L917" title="All 2 branches covered.">        for (double lambda = 0; lambda &lt; 6.2; lambda += 0.2) {</span>
<span class="fc bfc" id="L918" title="All 2 branches covered.">            for (double phi = -1.55; phi &lt; 1.55; phi += 0.2) {</span>
<span class="fc" id="L919">                FieldVector3D&lt;Dfp&gt; u = createVector(FastMath.cos(lambda) * FastMath.cos(phi),</span>
<span class="fc" id="L920">                                          FastMath.sin(lambda) * FastMath.cos(phi),</span>
<span class="fc" id="L921">                                          FastMath.sin(phi));</span>
<span class="fc" id="L922">                r.applyInverseTo(r.applyTo(u));</span>
<span class="fc" id="L923">                checkVector(u, r.applyInverseTo(r.applyTo(u)));</span>
<span class="fc" id="L924">                checkVector(u, r.applyTo(r.applyInverseTo(u)));</span>
<span class="fc" id="L925">                in[0] = u.getX();</span>
<span class="fc" id="L926">                in[1] = u.getY();</span>
<span class="fc" id="L927">                in[2] = u.getZ();</span>
<span class="fc" id="L928">                r.applyTo(in, out);</span>
<span class="fc" id="L929">                r.applyInverseTo(out, rebuilt);</span>
<span class="fc" id="L930">                Assert.assertEquals(in[0].getReal(), rebuilt[0].getReal(), 1.0e-12);</span>
<span class="fc" id="L931">                Assert.assertEquals(in[1].getReal(), rebuilt[1].getReal(), 1.0e-12);</span>
<span class="fc" id="L932">                Assert.assertEquals(in[2].getReal(), rebuilt[2].getReal(), 1.0e-12);</span>
            }
        }

<span class="fc" id="L936">        r = createRotation(1, 0, 0, 0, false);</span>
<span class="fc bfc" id="L937" title="All 2 branches covered.">        for (double lambda = 0; lambda &lt; 6.2; lambda += 0.2) {</span>
<span class="fc bfc" id="L938" title="All 2 branches covered.">            for (double phi = -1.55; phi &lt; 1.55; phi += 0.2) {</span>
<span class="fc" id="L939">                FieldVector3D&lt;Dfp&gt; u = createVector(FastMath.cos(lambda) * FastMath.cos(phi),</span>
<span class="fc" id="L940">                                          FastMath.sin(lambda) * FastMath.cos(phi),</span>
<span class="fc" id="L941">                                          FastMath.sin(phi));</span>
<span class="fc" id="L942">                checkVector(u, r.applyInverseTo(r.applyTo(u)));</span>
<span class="fc" id="L943">                checkVector(u, r.applyTo(r.applyInverseTo(u)));</span>
            }
        }

<span class="fc" id="L947">        r = new FieldRotation&lt;&gt;(createVector(0, 0, 1), createAngle(FastMath.PI), RotationConvention.VECTOR_OPERATOR);</span>
<span class="fc bfc" id="L948" title="All 2 branches covered.">        for (double lambda = 0; lambda &lt; 6.2; lambda += 0.2) {</span>
<span class="fc bfc" id="L949" title="All 2 branches covered.">            for (double phi = -1.55; phi &lt; 1.55; phi += 0.2) {</span>
<span class="fc" id="L950">                FieldVector3D&lt;Dfp&gt; u = createVector(FastMath.cos(lambda) * FastMath.cos(phi),</span>
<span class="fc" id="L951">                                          FastMath.sin(lambda) * FastMath.cos(phi),</span>
<span class="fc" id="L952">                                          FastMath.sin(phi));</span>
<span class="fc" id="L953">                checkVector(u, r.applyInverseTo(r.applyTo(u)));</span>
<span class="fc" id="L954">                checkVector(u, r.applyTo(r.applyInverseTo(u)));</span>
            }
        }

<span class="fc" id="L958">    }</span>

    @Test
    public void testIssue639() throws MathArithmeticException{
<span class="fc" id="L962">        FieldVector3D&lt;Dfp&gt; u1 = createVector(-1321008684645961.0 /  268435456.0,</span>
                                   -5774608829631843.0 /  268435456.0,
                                   -3822921525525679.0 / 4294967296.0);
<span class="fc" id="L965">        FieldVector3D&lt;Dfp&gt; u2 =createVector( -5712344449280879.0 /    2097152.0,</span>
                                   -2275058564560979.0 /    1048576.0,
                                   4423475992255071.0 /      65536.0);
<span class="fc" id="L968">        FieldRotation&lt;Dfp&gt; rot = new FieldRotation&lt;&gt;(u1, u2, createVector(1, 0, 0),createVector(0, 0, 1));</span>
<span class="fc" id="L969">        Assert.assertEquals( 0.6228370359608200639829222, rot.getQ0().getReal(), 1.0e-15);</span>
<span class="fc" id="L970">        Assert.assertEquals( 0.0257707621456498790029987, rot.getQ1().getReal(), 1.0e-15);</span>
<span class="fc" id="L971">        Assert.assertEquals(-0.0000000002503012255839931, rot.getQ2().getReal(), 1.0e-15);</span>
<span class="fc" id="L972">        Assert.assertEquals(-0.7819270390861109450724902, rot.getQ3().getReal(), 1.0e-15);</span>
<span class="fc" id="L973">    }</span>

    @Test
    public void testIssue801() throws MathArithmeticException {
<span class="fc" id="L977">        FieldVector3D&lt;Dfp&gt; u1 = createVector(0.9999988431610581, -0.0015210774290851095, 0.0);</span>
<span class="fc" id="L978">        FieldVector3D&lt;Dfp&gt; u2 = createVector(0.0, 0.0, 1.0);</span>

<span class="fc" id="L980">        FieldVector3D&lt;Dfp&gt; v1 = createVector(0.9999999999999999, 0.0, 0.0);</span>
<span class="fc" id="L981">        FieldVector3D&lt;Dfp&gt; v2 = createVector(0.0, 0.0, -1.0);</span>

<span class="fc" id="L983">        FieldRotation&lt;Dfp&gt; quat = new FieldRotation&lt;&gt;(u1, u2, v1, v2);</span>
<span class="fc" id="L984">        double q2 = quat.getQ0().getReal() * quat.getQ0().getReal() +</span>
<span class="fc" id="L985">                    quat.getQ1().getReal() * quat.getQ1().getReal() +</span>
<span class="fc" id="L986">                    quat.getQ2().getReal() * quat.getQ2().getReal() +</span>
<span class="fc" id="L987">                    quat.getQ3().getReal() * quat.getQ3().getReal();</span>
<span class="fc" id="L988">        Assert.assertEquals(1.0, q2, 1.0e-14);</span>
<span class="fc" id="L989">        Assert.assertEquals(0.0, FieldVector3D.angle(v1, quat.applyTo(u1)).getReal(), 1.0e-14);</span>
<span class="fc" id="L990">        Assert.assertEquals(0.0, FieldVector3D.angle(v2, quat.applyTo(u2)).getReal(), 1.0e-14);</span>

<span class="fc" id="L992">    }</span>

    private void checkAngle(Dfp a1, double a2) {
<span class="fc" id="L995">        Assert.assertEquals(a1.getReal(), PlaneAngleRadians.normalize(a2, a1.getReal()), 1.0e-10);</span>
<span class="fc" id="L996">    }</span>

    private void checkRotationDS(FieldRotation&lt;Dfp&gt; r, double q0, double q1, double q2, double q3) {
<span class="fc" id="L999">        FieldRotation&lt;Dfp&gt; rPrime = createRotation(q0, q1, q2, q3, false);</span>
<span class="fc" id="L1000">        Assert.assertEquals(0, FieldRotation.distance(r, rPrime).getReal(), 1.0e-12);</span>
<span class="fc" id="L1001">    }</span>

    private FieldRotation&lt;Dfp&gt; createRotation(double q0, double q1, double q2, double q3,
                                      boolean needsNormalization) {
<span class="fc" id="L1005">        DfpField field = new DfpField(20);</span>
<span class="fc" id="L1006">        return new FieldRotation&lt;&gt;(field.newDfp(q0),</span>
<span class="fc" id="L1007">                                      field.newDfp(q1),</span>
<span class="fc" id="L1008">                                      field.newDfp(q2),</span>
<span class="fc" id="L1009">                                      field.newDfp(q3),</span>
                                      needsNormalization);
    }

    private FieldRotation&lt;Dfp&gt; createRotation(double[][] m, double threshold) {
<span class="fc" id="L1014">        DfpField field = new DfpField(20);</span>
<span class="fc" id="L1015">        Dfp[][] mds = new Dfp[m.length][m[0].length];</span>
<span class="fc bfc" id="L1016" title="All 2 branches covered.">        for (int i = 0; i &lt; m.length; ++i) {</span>
<span class="fc bfc" id="L1017" title="All 2 branches covered.">            for (int j = 0; j &lt; m[i].length; ++j) {</span>
<span class="fc" id="L1018">                mds[i][j] = field.newDfp(m[i][j]);</span>
            }
        }
<span class="fc" id="L1021">        return new FieldRotation&lt;&gt;(mds, threshold);</span>
    }

    private FieldVector3D&lt;Dfp&gt; createVector(double x, double y, double z) {
<span class="fc" id="L1025">        DfpField field = new DfpField(20);</span>
<span class="fc" id="L1026">        return new FieldVector3D&lt;&gt;(field.newDfp(x), field.newDfp(y), field.newDfp(z));</span>
    }

    private FieldVector3D&lt;Dfp&gt; createAxis(double x, double y, double z) {
<span class="fc" id="L1030">        DfpField field = new DfpField(20);</span>
<span class="fc" id="L1031">        return new FieldVector3D&lt;&gt;(field.newDfp(x), field.newDfp(y), field.newDfp(z));</span>
    }

    private Dfp createAngle(double alpha) {
<span class="fc" id="L1035">        return new DfpField(20).newDfp(alpha);</span>
    }

    private void checkVector(FieldVector3D&lt;Dfp&gt; u, FieldVector3D&lt;Dfp&gt; v) {
<span class="fc" id="L1039">        Assert.assertEquals(u.getX().getReal(), v.getX().getReal(), 1.0e-12);</span>
<span class="fc" id="L1040">        Assert.assertEquals(u.getY().getReal(), v.getY().getReal(), 1.0e-12);</span>
<span class="fc" id="L1041">        Assert.assertEquals(u.getZ().getReal(), v.getZ().getReal(), 1.0e-12);</span>
<span class="fc" id="L1042">    }</span>

}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.1.201803210924</span></div></body></html>