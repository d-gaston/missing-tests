<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>RotationTest.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">commons_math4$All_in_commons_math4.exec</a> &gt; <a href="index.source.html" class="el_package">org.apache.commons.math4.geometry.euclidean.threed</a> &gt; <span class="el_source">RotationTest.java</span></div><h1>RotationTest.java</h1><pre class="source lang-java linenums">/*
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the &quot;License&quot;); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package org.apache.commons.math4.geometry.euclidean.threed;

import org.apache.commons.numbers.angle.PlaneAngleRadians;
import org.apache.commons.math4.exception.MathArithmeticException;
import org.apache.commons.math4.exception.MathIllegalArgumentException;
import org.apache.commons.math4.geometry.euclidean.threed.CardanEulerSingularityException;
import org.apache.commons.math4.geometry.euclidean.threed.NotARotationMatrixException;
import org.apache.commons.math4.geometry.euclidean.threed.Rotation;
import org.apache.commons.math4.geometry.euclidean.threed.RotationOrder;
import org.apache.commons.math4.geometry.euclidean.threed.Cartesian3D;
import org.apache.commons.math4.util.FastMath;
import org.junit.Assert;
import org.junit.Test;


<span class="fc" id="L33">public class RotationTest {</span>

  @Test
  public void testIdentity() {

<span class="fc" id="L38">    Rotation r = Rotation.IDENTITY;</span>
<span class="fc" id="L39">    checkVector(r.applyTo(Cartesian3D.PLUS_I), Cartesian3D.PLUS_I);</span>
<span class="fc" id="L40">    checkVector(r.applyTo(Cartesian3D.PLUS_J), Cartesian3D.PLUS_J);</span>
<span class="fc" id="L41">    checkVector(r.applyTo(Cartesian3D.PLUS_K), Cartesian3D.PLUS_K);</span>
<span class="fc" id="L42">    checkAngle(r.getAngle(), 0);</span>

<span class="fc" id="L44">    r = new Rotation(-1, 0, 0, 0, false);</span>
<span class="fc" id="L45">    checkVector(r.applyTo(Cartesian3D.PLUS_I), Cartesian3D.PLUS_I);</span>
<span class="fc" id="L46">    checkVector(r.applyTo(Cartesian3D.PLUS_J), Cartesian3D.PLUS_J);</span>
<span class="fc" id="L47">    checkVector(r.applyTo(Cartesian3D.PLUS_K), Cartesian3D.PLUS_K);</span>
<span class="fc" id="L48">    checkAngle(r.getAngle(), 0);</span>

<span class="fc" id="L50">    r = new Rotation(42, 0, 0, 0, true);</span>
<span class="fc" id="L51">    checkVector(r.applyTo(Cartesian3D.PLUS_I), Cartesian3D.PLUS_I);</span>
<span class="fc" id="L52">    checkVector(r.applyTo(Cartesian3D.PLUS_J), Cartesian3D.PLUS_J);</span>
<span class="fc" id="L53">    checkVector(r.applyTo(Cartesian3D.PLUS_K), Cartesian3D.PLUS_K);</span>
<span class="fc" id="L54">    checkAngle(r.getAngle(), 0);</span>

<span class="fc" id="L56">  }</span>

  @Test
  @Deprecated
  public void testAxisAngleDeprecated() throws MathIllegalArgumentException {

<span class="fc" id="L62">    Rotation r = new Rotation(new Cartesian3D(10, 10, 10), 2 * FastMath.PI / 3);</span>
<span class="fc" id="L63">    checkVector(r.applyTo(Cartesian3D.PLUS_I), Cartesian3D.PLUS_J);</span>
<span class="fc" id="L64">    checkVector(r.applyTo(Cartesian3D.PLUS_J), Cartesian3D.PLUS_K);</span>
<span class="fc" id="L65">    checkVector(r.applyTo(Cartesian3D.PLUS_K), Cartesian3D.PLUS_I);</span>
<span class="fc" id="L66">    double s = 1 / FastMath.sqrt(3);</span>
<span class="fc" id="L67">    checkVector(r.getAxis(), new Cartesian3D(s, s, s));</span>
<span class="fc" id="L68">    checkAngle(r.getAngle(), 2 * FastMath.PI / 3);</span>

    try {
<span class="nc" id="L71">      new Rotation(new Cartesian3D(0, 0, 0), 2 * FastMath.PI / 3);</span>
<span class="nc" id="L72">      Assert.fail(&quot;an exception should have been thrown&quot;);</span>
<span class="fc" id="L73">    } catch (MathIllegalArgumentException e) {</span>
<span class="nc" id="L74">    }</span>

<span class="fc" id="L76">    r = new Rotation(Cartesian3D.PLUS_K, 1.5 * FastMath.PI);</span>
<span class="fc" id="L77">    checkVector(r.getAxis(), new Cartesian3D(0, 0, -1));</span>
<span class="fc" id="L78">    checkAngle(r.getAngle(), 0.5 * FastMath.PI);</span>

<span class="fc" id="L80">    r = new Rotation(Cartesian3D.PLUS_J, FastMath.PI);</span>
<span class="fc" id="L81">    checkVector(r.getAxis(), Cartesian3D.PLUS_J);</span>
<span class="fc" id="L82">    checkAngle(r.getAngle(), FastMath.PI);</span>

<span class="fc" id="L84">    checkVector(Rotation.IDENTITY.getAxis(), Cartesian3D.PLUS_I);</span>

<span class="fc" id="L86">  }</span>

  @Test
  public void testAxisAngleVectorOperator() throws MathIllegalArgumentException {

<span class="fc" id="L91">    Rotation r = new Rotation(new Cartesian3D(10, 10, 10), 2 * FastMath.PI / 3, RotationConvention.VECTOR_OPERATOR);</span>
<span class="fc" id="L92">    checkVector(r.applyTo(Cartesian3D.PLUS_I), Cartesian3D.PLUS_J);</span>
<span class="fc" id="L93">    checkVector(r.applyTo(Cartesian3D.PLUS_J), Cartesian3D.PLUS_K);</span>
<span class="fc" id="L94">    checkVector(r.applyTo(Cartesian3D.PLUS_K), Cartesian3D.PLUS_I);</span>
<span class="fc" id="L95">    double s = 1 / FastMath.sqrt(3);</span>
<span class="fc" id="L96">    checkVector(r.getAxis(RotationConvention.VECTOR_OPERATOR), new Cartesian3D( s,  s,  s));</span>
<span class="fc" id="L97">    checkVector(r.getAxis(RotationConvention.FRAME_TRANSFORM), new Cartesian3D(-s, -s, -s));</span>
<span class="fc" id="L98">    checkAngle(r.getAngle(), 2 * FastMath.PI / 3);</span>

    try {
<span class="nc" id="L101">      new Rotation(new Cartesian3D(0, 0, 0), 2 * FastMath.PI / 3, RotationConvention.VECTOR_OPERATOR);</span>
<span class="nc" id="L102">      Assert.fail(&quot;an exception should have been thrown&quot;);</span>
<span class="fc" id="L103">    } catch (MathIllegalArgumentException e) {</span>
<span class="nc" id="L104">    }</span>

<span class="fc" id="L106">    r = new Rotation(Cartesian3D.PLUS_K, 1.5 * FastMath.PI, RotationConvention.VECTOR_OPERATOR);</span>
<span class="fc" id="L107">    checkVector(r.getAxis(RotationConvention.VECTOR_OPERATOR), new Cartesian3D(0, 0, -1));</span>
<span class="fc" id="L108">    checkVector(r.getAxis(RotationConvention.FRAME_TRANSFORM), new Cartesian3D(0, 0, +1));</span>
<span class="fc" id="L109">    checkAngle(r.getAngle(), 0.5 * FastMath.PI);</span>

<span class="fc" id="L111">    r = new Rotation(Cartesian3D.PLUS_J, FastMath.PI, RotationConvention.VECTOR_OPERATOR);</span>
<span class="fc" id="L112">    checkVector(r.getAxis(RotationConvention.VECTOR_OPERATOR), Cartesian3D.PLUS_J);</span>
<span class="fc" id="L113">    checkVector(r.getAxis(RotationConvention.FRAME_TRANSFORM), Cartesian3D.MINUS_J);</span>
<span class="fc" id="L114">    checkAngle(r.getAngle(), FastMath.PI);</span>

<span class="fc" id="L116">    checkVector(Rotation.IDENTITY.getAxis(RotationConvention.VECTOR_OPERATOR), Cartesian3D.PLUS_I);</span>
<span class="fc" id="L117">    checkVector(Rotation.IDENTITY.getAxis(RotationConvention.FRAME_TRANSFORM), Cartesian3D.MINUS_I);</span>

<span class="fc" id="L119">  }</span>

  @Test
  public void testAxisAngleFrameTransform() throws MathIllegalArgumentException {

<span class="fc" id="L124">    Rotation r = new Rotation(new Cartesian3D(10, 10, 10), 2 * FastMath.PI / 3, RotationConvention.FRAME_TRANSFORM);</span>
<span class="fc" id="L125">    checkVector(r.applyTo(Cartesian3D.PLUS_I), Cartesian3D.PLUS_K);</span>
<span class="fc" id="L126">    checkVector(r.applyTo(Cartesian3D.PLUS_J), Cartesian3D.PLUS_I);</span>
<span class="fc" id="L127">    checkVector(r.applyTo(Cartesian3D.PLUS_K), Cartesian3D.PLUS_J);</span>
<span class="fc" id="L128">    double s = 1 / FastMath.sqrt(3);</span>
<span class="fc" id="L129">    checkVector(r.getAxis(RotationConvention.FRAME_TRANSFORM), new Cartesian3D( s,  s,  s));</span>
<span class="fc" id="L130">    checkVector(r.getAxis(RotationConvention.VECTOR_OPERATOR), new Cartesian3D(-s, -s, -s));</span>
<span class="fc" id="L131">    checkAngle(r.getAngle(), 2 * FastMath.PI / 3);</span>

    try {
<span class="nc" id="L134">      new Rotation(new Cartesian3D(0, 0, 0), 2 * FastMath.PI / 3, RotationConvention.FRAME_TRANSFORM);</span>
<span class="nc" id="L135">      Assert.fail(&quot;an exception should have been thrown&quot;);</span>
<span class="fc" id="L136">    } catch (MathIllegalArgumentException e) {</span>
<span class="nc" id="L137">    }</span>

<span class="fc" id="L139">    r = new Rotation(Cartesian3D.PLUS_K, 1.5 * FastMath.PI, RotationConvention.FRAME_TRANSFORM);</span>
<span class="fc" id="L140">    checkVector(r.getAxis(RotationConvention.FRAME_TRANSFORM), new Cartesian3D(0, 0, -1));</span>
<span class="fc" id="L141">    checkVector(r.getAxis(RotationConvention.VECTOR_OPERATOR), new Cartesian3D(0, 0, +1));</span>
<span class="fc" id="L142">    checkAngle(r.getAngle(), 0.5 * FastMath.PI);</span>

<span class="fc" id="L144">    r = new Rotation(Cartesian3D.PLUS_J, FastMath.PI, RotationConvention.FRAME_TRANSFORM);</span>
<span class="fc" id="L145">    checkVector(r.getAxis(RotationConvention.FRAME_TRANSFORM), Cartesian3D.PLUS_J);</span>
<span class="fc" id="L146">    checkVector(r.getAxis(RotationConvention.VECTOR_OPERATOR), Cartesian3D.MINUS_J);</span>
<span class="fc" id="L147">    checkAngle(r.getAngle(), FastMath.PI);</span>

<span class="fc" id="L149">    checkVector(Rotation.IDENTITY.getAxis(RotationConvention.FRAME_TRANSFORM), Cartesian3D.MINUS_I);</span>
<span class="fc" id="L150">    checkVector(Rotation.IDENTITY.getAxis(RotationConvention.VECTOR_OPERATOR), Cartesian3D.PLUS_I);</span>

<span class="fc" id="L152">  }</span>

  @Test
  public void testRevertDeprecated() {
<span class="fc" id="L156">    Rotation r = new Rotation(0.001, 0.36, 0.48, 0.8, true);</span>
<span class="fc" id="L157">    Rotation reverted = r.revert();</span>
<span class="fc" id="L158">    checkRotation(r.applyTo(reverted), 1, 0, 0, 0);</span>
<span class="fc" id="L159">    checkRotation(reverted.applyTo(r), 1, 0, 0, 0);</span>
<span class="fc" id="L160">    Assert.assertEquals(r.getAngle(), reverted.getAngle(), 1.0e-12);</span>
<span class="fc" id="L161">    Assert.assertEquals(-1,</span>
<span class="fc" id="L162">                        Cartesian3D.dotProduct(r.getAxis(RotationConvention.VECTOR_OPERATOR),</span>
<span class="fc" id="L163">                                           reverted.getAxis(RotationConvention.VECTOR_OPERATOR)),</span>
                        1.0e-12);
<span class="fc" id="L165">  }</span>

  @Test
  public void testRevertVectorOperator() {
<span class="fc" id="L169">    Rotation r = new Rotation(0.001, 0.36, 0.48, 0.8, true);</span>
<span class="fc" id="L170">    Rotation reverted = r.revert();</span>
<span class="fc" id="L171">    checkRotation(r.compose(reverted, RotationConvention.VECTOR_OPERATOR), 1, 0, 0, 0);</span>
<span class="fc" id="L172">    checkRotation(reverted.compose(r, RotationConvention.VECTOR_OPERATOR), 1, 0, 0, 0);</span>
<span class="fc" id="L173">    Assert.assertEquals(r.getAngle(), reverted.getAngle(), 1.0e-12);</span>
<span class="fc" id="L174">    Assert.assertEquals(-1,</span>
<span class="fc" id="L175">                        Cartesian3D.dotProduct(r.getAxis(RotationConvention.VECTOR_OPERATOR),</span>
<span class="fc" id="L176">                                           reverted.getAxis(RotationConvention.VECTOR_OPERATOR)),</span>
                        1.0e-12);
<span class="fc" id="L178">  }</span>

  @Test
  public void testRevertFrameTransform() {
<span class="fc" id="L182">    Rotation r = new Rotation(0.001, 0.36, 0.48, 0.8, true);</span>
<span class="fc" id="L183">    Rotation reverted = r.revert();</span>
<span class="fc" id="L184">    checkRotation(r.compose(reverted, RotationConvention.FRAME_TRANSFORM), 1, 0, 0, 0);</span>
<span class="fc" id="L185">    checkRotation(reverted.compose(r, RotationConvention.FRAME_TRANSFORM), 1, 0, 0, 0);</span>
<span class="fc" id="L186">    Assert.assertEquals(r.getAngle(), reverted.getAngle(), 1.0e-12);</span>
<span class="fc" id="L187">    Assert.assertEquals(-1,</span>
<span class="fc" id="L188">                        Cartesian3D.dotProduct(r.getAxis(RotationConvention.FRAME_TRANSFORM),</span>
<span class="fc" id="L189">                                           reverted.getAxis(RotationConvention.FRAME_TRANSFORM)),</span>
                        1.0e-12);
<span class="fc" id="L191">  }</span>

  @Test
  public void testVectorOnePair() throws MathArithmeticException {

<span class="fc" id="L196">    Cartesian3D u = new Cartesian3D(3, 2, 1);</span>
<span class="fc" id="L197">    Cartesian3D v = new Cartesian3D(-4, 2, 2);</span>
<span class="fc" id="L198">    Rotation r = new Rotation(u, v);</span>
<span class="fc" id="L199">    checkVector(r.applyTo(u.scalarMultiply(v.getNorm())), v.scalarMultiply(u.getNorm()));</span>

<span class="fc" id="L201">    checkAngle(new Rotation(u, u.negate()).getAngle(), FastMath.PI);</span>

    try {
<span class="nc" id="L204">        new Rotation(u, Cartesian3D.ZERO);</span>
<span class="nc" id="L205">        Assert.fail(&quot;an exception should have been thrown&quot;);</span>
<span class="fc" id="L206">    } catch (MathArithmeticException e) {</span>
        // expected behavior
<span class="nc" id="L208">    }</span>

<span class="fc" id="L210">  }</span>

  @Test
  public void testVectorTwoPairs() throws MathArithmeticException {

<span class="fc" id="L215">    Cartesian3D u1 = new Cartesian3D(3, 0, 0);</span>
<span class="fc" id="L216">    Cartesian3D u2 = new Cartesian3D(0, 5, 0);</span>
<span class="fc" id="L217">    Cartesian3D v1 = new Cartesian3D(0, 0, 2);</span>
<span class="fc" id="L218">    Cartesian3D v2 = new Cartesian3D(-2, 0, 2);</span>
<span class="fc" id="L219">    Rotation r = new Rotation(u1, u2, v1, v2);</span>
<span class="fc" id="L220">    checkVector(r.applyTo(Cartesian3D.PLUS_I), Cartesian3D.PLUS_K);</span>
<span class="fc" id="L221">    checkVector(r.applyTo(Cartesian3D.PLUS_J), Cartesian3D.MINUS_I);</span>

<span class="fc" id="L223">    r = new Rotation(u1, u2, u1.negate(), u2.negate());</span>
<span class="fc" id="L224">    Cartesian3D axis = r.getAxis(RotationConvention.VECTOR_OPERATOR);</span>
<span class="pc bpc" id="L225" title="1 of 2 branches missed.">    if (Cartesian3D.dotProduct(axis, Cartesian3D.PLUS_K) &gt; 0) {</span>
<span class="nc" id="L226">      checkVector(axis, Cartesian3D.PLUS_K);</span>
    } else {
<span class="fc" id="L228">      checkVector(axis, Cartesian3D.MINUS_K);</span>
    }
<span class="fc" id="L230">    checkAngle(r.getAngle(), FastMath.PI);</span>

<span class="fc" id="L232">    double sqrt = FastMath.sqrt(2) / 2;</span>
<span class="fc" id="L233">    r = new Rotation(Cartesian3D.PLUS_I,  Cartesian3D.PLUS_J,</span>
                     new Cartesian3D(0.5, 0.5,  sqrt),
                     new Cartesian3D(0.5, 0.5, -sqrt));
<span class="fc" id="L236">    checkRotation(r, sqrt, 0.5, 0.5, 0);</span>

<span class="fc" id="L238">    r = new Rotation(u1, u2, u1, Cartesian3D.crossProduct(u1, u2));</span>
<span class="fc" id="L239">    checkRotation(r, sqrt, -sqrt, 0, 0);</span>

<span class="fc" id="L241">    checkRotation(new Rotation(u1, u2, u1, u2), 1, 0, 0, 0);</span>

    try {
<span class="nc" id="L244">        new Rotation(u1, u2, Cartesian3D.ZERO, v2);</span>
<span class="nc" id="L245">        Assert.fail(&quot;an exception should have been thrown&quot;);</span>
<span class="fc" id="L246">    } catch (MathArithmeticException e) {</span>
      // expected behavior
<span class="nc" id="L248">    }</span>

<span class="fc" id="L250">  }</span>

  @Test
  public void testMatrix()
    throws NotARotationMatrixException {

    try {
<span class="nc" id="L257">      new Rotation(new double[][] {</span>
                     { 0.0, 1.0, 0.0 },
                     { 1.0, 0.0, 0.0 }
                   }, 1.0e-7);
<span class="nc" id="L261">      Assert.fail(&quot;Expecting NotARotationMatrixException&quot;);</span>
<span class="fc" id="L262">    } catch (NotARotationMatrixException nrme) {</span>
      // expected behavior
<span class="nc" id="L264">    }</span>

    try {
<span class="nc" id="L267">      new Rotation(new double[][] {</span>
                     {  0.445888,  0.797184, -0.407040 },
                     {  0.821760, -0.184320,  0.539200 },
                     { -0.354816,  0.574912,  0.737280 }
                   }, 1.0e-7);
<span class="nc" id="L272">      Assert.fail(&quot;Expecting NotARotationMatrixException&quot;);</span>
<span class="fc" id="L273">    } catch (NotARotationMatrixException nrme) {</span>
      // expected behavior
<span class="nc" id="L275">    }</span>

    try {
<span class="nc" id="L278">        new Rotation(new double[][] {</span>
                       {  0.4,  0.8, -0.4 },
                       { -0.4,  0.6,  0.7 },
                       {  0.8, -0.2,  0.5 }
                     }, 1.0e-15);
<span class="nc" id="L283">        Assert.fail(&quot;Expecting NotARotationMatrixException&quot;);</span>
<span class="fc" id="L284">      } catch (NotARotationMatrixException nrme) {</span>
        // expected behavior
<span class="nc" id="L286">      }</span>

<span class="fc" id="L288">    checkRotation(new Rotation(new double[][] {</span>
                                 {  0.445888,  0.797184, -0.407040 },
                                 { -0.354816,  0.574912,  0.737280 },
                                 {  0.821760, -0.184320,  0.539200 }
                               }, 1.0e-10),
                  0.8, 0.288, 0.384, 0.36);

<span class="fc" id="L295">    checkRotation(new Rotation(new double[][] {</span>
                                 {  0.539200,  0.737280,  0.407040 },
                                 {  0.184320, -0.574912,  0.797184 },
                                 {  0.821760, -0.354816, -0.445888 }
                              }, 1.0e-10),
                  0.36, 0.8, 0.288, 0.384);

<span class="fc" id="L302">    checkRotation(new Rotation(new double[][] {</span>
                                 { -0.445888,  0.797184, -0.407040 },
                                 {  0.354816,  0.574912,  0.737280 },
                                 {  0.821760,  0.184320, -0.539200 }
                               }, 1.0e-10),
                  0.384, 0.36, 0.8, 0.288);

<span class="fc" id="L309">    checkRotation(new Rotation(new double[][] {</span>
                                 { -0.539200,  0.737280,  0.407040 },
                                 { -0.184320, -0.574912,  0.797184 },
                                 {  0.821760,  0.354816,  0.445888 }
                               }, 1.0e-10),
                  0.288, 0.384, 0.36, 0.8);

<span class="fc" id="L316">    double[][] m1 = { { 0.0, 1.0, 0.0 },</span>
                      { 0.0, 0.0, 1.0 },
                      { 1.0, 0.0, 0.0 } };
<span class="fc" id="L319">    Rotation r = new Rotation(m1, 1.0e-7);</span>
<span class="fc" id="L320">    checkVector(r.applyTo(Cartesian3D.PLUS_I), Cartesian3D.PLUS_K);</span>
<span class="fc" id="L321">    checkVector(r.applyTo(Cartesian3D.PLUS_J), Cartesian3D.PLUS_I);</span>
<span class="fc" id="L322">    checkVector(r.applyTo(Cartesian3D.PLUS_K), Cartesian3D.PLUS_J);</span>

<span class="fc" id="L324">    double[][] m2 = { { 0.83203, -0.55012, -0.07139 },</span>
                      { 0.48293,  0.78164, -0.39474 },
                      { 0.27296,  0.29396,  0.91602 } };
<span class="fc" id="L327">    r = new Rotation(m2, 1.0e-12);</span>

<span class="fc" id="L329">    double[][] m3 = r.getMatrix();</span>
<span class="fc" id="L330">    double d00 = m2[0][0] - m3[0][0];</span>
<span class="fc" id="L331">    double d01 = m2[0][1] - m3[0][1];</span>
<span class="fc" id="L332">    double d02 = m2[0][2] - m3[0][2];</span>
<span class="fc" id="L333">    double d10 = m2[1][0] - m3[1][0];</span>
<span class="fc" id="L334">    double d11 = m2[1][1] - m3[1][1];</span>
<span class="fc" id="L335">    double d12 = m2[1][2] - m3[1][2];</span>
<span class="fc" id="L336">    double d20 = m2[2][0] - m3[2][0];</span>
<span class="fc" id="L337">    double d21 = m2[2][1] - m3[2][1];</span>
<span class="fc" id="L338">    double d22 = m2[2][2] - m3[2][2];</span>

<span class="pc bpc" id="L340" title="1 of 2 branches missed.">    Assert.assertTrue(FastMath.abs(d00) &lt; 6.0e-6);</span>
<span class="pc bpc" id="L341" title="1 of 2 branches missed.">    Assert.assertTrue(FastMath.abs(d01) &lt; 6.0e-6);</span>
<span class="pc bpc" id="L342" title="1 of 2 branches missed.">    Assert.assertTrue(FastMath.abs(d02) &lt; 6.0e-6);</span>
<span class="pc bpc" id="L343" title="1 of 2 branches missed.">    Assert.assertTrue(FastMath.abs(d10) &lt; 6.0e-6);</span>
<span class="pc bpc" id="L344" title="1 of 2 branches missed.">    Assert.assertTrue(FastMath.abs(d11) &lt; 6.0e-6);</span>
<span class="pc bpc" id="L345" title="1 of 2 branches missed.">    Assert.assertTrue(FastMath.abs(d12) &lt; 6.0e-6);</span>
<span class="pc bpc" id="L346" title="1 of 2 branches missed.">    Assert.assertTrue(FastMath.abs(d20) &lt; 6.0e-6);</span>
<span class="pc bpc" id="L347" title="1 of 2 branches missed.">    Assert.assertTrue(FastMath.abs(d21) &lt; 6.0e-6);</span>
<span class="pc bpc" id="L348" title="1 of 2 branches missed.">    Assert.assertTrue(FastMath.abs(d22) &lt; 6.0e-6);</span>

<span class="pc bpc" id="L350" title="1 of 2 branches missed.">    Assert.assertTrue(FastMath.abs(d00) &gt; 4.0e-7);</span>
<span class="pc bpc" id="L351" title="1 of 2 branches missed.">    Assert.assertTrue(FastMath.abs(d01) &gt; 4.0e-7);</span>
<span class="pc bpc" id="L352" title="1 of 2 branches missed.">    Assert.assertTrue(FastMath.abs(d02) &gt; 4.0e-7);</span>
<span class="pc bpc" id="L353" title="1 of 2 branches missed.">    Assert.assertTrue(FastMath.abs(d10) &gt; 4.0e-7);</span>
<span class="pc bpc" id="L354" title="1 of 2 branches missed.">    Assert.assertTrue(FastMath.abs(d11) &gt; 4.0e-7);</span>
<span class="pc bpc" id="L355" title="1 of 2 branches missed.">    Assert.assertTrue(FastMath.abs(d12) &gt; 4.0e-7);</span>
<span class="pc bpc" id="L356" title="1 of 2 branches missed.">    Assert.assertTrue(FastMath.abs(d20) &gt; 4.0e-7);</span>
<span class="pc bpc" id="L357" title="1 of 2 branches missed.">    Assert.assertTrue(FastMath.abs(d21) &gt; 4.0e-7);</span>
<span class="pc bpc" id="L358" title="1 of 2 branches missed.">    Assert.assertTrue(FastMath.abs(d22) &gt; 4.0e-7);</span>

<span class="fc bfc" id="L360" title="All 2 branches covered.">    for (int i = 0; i &lt; 3; ++i) {</span>
<span class="fc bfc" id="L361" title="All 2 branches covered.">      for (int j = 0; j &lt; 3; ++j) {</span>
<span class="fc" id="L362">        double m3tm3 = m3[i][0] * m3[j][0]</span>
                     + m3[i][1] * m3[j][1]
                     + m3[i][2] * m3[j][2];
<span class="fc bfc" id="L365" title="All 2 branches covered.">        if (i == j) {</span>
<span class="pc bpc" id="L366" title="1 of 2 branches missed.">          Assert.assertTrue(FastMath.abs(m3tm3 - 1.0) &lt; 1.0e-10);</span>
        } else {
<span class="pc bpc" id="L368" title="1 of 2 branches missed.">          Assert.assertTrue(FastMath.abs(m3tm3) &lt; 1.0e-10);</span>
        }
      }
    }

<span class="fc" id="L373">    checkVector(r.applyTo(Cartesian3D.PLUS_I),</span>
                new Cartesian3D(m3[0][0], m3[1][0], m3[2][0]));
<span class="fc" id="L375">    checkVector(r.applyTo(Cartesian3D.PLUS_J),</span>
                new Cartesian3D(m3[0][1], m3[1][1], m3[2][1]));
<span class="fc" id="L377">    checkVector(r.applyTo(Cartesian3D.PLUS_K),</span>
                new Cartesian3D(m3[0][2], m3[1][2], m3[2][2]));

<span class="fc" id="L380">    double[][] m4 = { { 1.0,  0.0,  0.0 },</span>
                      { 0.0, -1.0,  0.0 },
                      { 0.0,  0.0, -1.0 } };
<span class="fc" id="L383">    r = new Rotation(m4, 1.0e-7);</span>
<span class="fc" id="L384">    checkAngle(r.getAngle(), FastMath.PI);</span>

    try {
<span class="fc" id="L387">      double[][] m5 = { { 0.0, 0.0, 1.0 },</span>
                        { 0.0, 1.0, 0.0 },
                        { 1.0, 0.0, 0.0 } };
<span class="nc" id="L390">      r = new Rotation(m5, 1.0e-7);</span>
<span class="nc" id="L391">      Assert.fail(&quot;got &quot; + r + &quot;, should have caught an exception&quot;);</span>
<span class="fc" id="L392">    } catch (NotARotationMatrixException e) {</span>
      // expected
<span class="nc" id="L394">    }</span>

<span class="fc" id="L396">  }</span>

  @Test
  @Deprecated
  public void testAnglesDeprecated()
    throws CardanEulerSingularityException {

<span class="fc" id="L403">    RotationOrder[] CardanOrders = {</span>
      RotationOrder.XYZ, RotationOrder.XZY, RotationOrder.YXZ,
      RotationOrder.YZX, RotationOrder.ZXY, RotationOrder.ZYX
    };

<span class="fc bfc" id="L408" title="All 2 branches covered.">    for (int i = 0; i &lt; CardanOrders.length; ++i) {</span>
<span class="fc bfc" id="L409" title="All 2 branches covered.">      for (double alpha1 = 0.1; alpha1 &lt; 6.2; alpha1 += 0.3) {</span>
<span class="fc bfc" id="L410" title="All 2 branches covered.">        for (double alpha2 = -1.55; alpha2 &lt; 1.55; alpha2 += 0.3) {</span>
<span class="fc bfc" id="L411" title="All 2 branches covered.">          for (double alpha3 = 0.1; alpha3 &lt; 6.2; alpha3 += 0.3) {</span>
<span class="fc" id="L412">            Rotation r = new Rotation(CardanOrders[i], alpha1, alpha2, alpha3);</span>
<span class="fc" id="L413">            double[] angles = r.getAngles(CardanOrders[i]);</span>
<span class="fc" id="L414">            checkAngle(angles[0], alpha1);</span>
<span class="fc" id="L415">            checkAngle(angles[1], alpha2);</span>
<span class="fc" id="L416">            checkAngle(angles[2], alpha3);</span>
          }
        }
      }
    }

<span class="fc" id="L422">    RotationOrder[] EulerOrders = {</span>
            RotationOrder.XYX, RotationOrder.XZX, RotationOrder.YXY,
            RotationOrder.YZY, RotationOrder.ZXZ, RotationOrder.ZYZ
    };

<span class="fc bfc" id="L427" title="All 2 branches covered.">    for (int i = 0; i &lt; EulerOrders.length; ++i) {</span>
<span class="fc bfc" id="L428" title="All 2 branches covered.">      for (double alpha1 = 0.1; alpha1 &lt; 6.2; alpha1 += 0.3) {</span>
<span class="fc bfc" id="L429" title="All 2 branches covered.">        for (double alpha2 = 0.05; alpha2 &lt; 3.1; alpha2 += 0.3) {</span>
<span class="fc bfc" id="L430" title="All 2 branches covered.">          for (double alpha3 = 0.1; alpha3 &lt; 6.2; alpha3 += 0.3) {</span>
<span class="fc" id="L431">            Rotation r = new Rotation(EulerOrders[i],</span>
                                      alpha1, alpha2, alpha3);
<span class="fc" id="L433">            double[] angles = r.getAngles(EulerOrders[i]);</span>
<span class="fc" id="L434">            checkAngle(angles[0], alpha1);</span>
<span class="fc" id="L435">            checkAngle(angles[1], alpha2);</span>
<span class="fc" id="L436">            checkAngle(angles[2], alpha3);</span>
          }
        }
      }
    }

<span class="fc" id="L442">  }</span>

  @Test
  public void testAngles()
      throws CardanEulerSingularityException {

<span class="fc bfc" id="L448" title="All 2 branches covered.">      for (RotationConvention convention : RotationConvention.values()) {</span>
<span class="fc" id="L449">          RotationOrder[] CardanOrders = {</span>
              RotationOrder.XYZ, RotationOrder.XZY, RotationOrder.YXZ,
              RotationOrder.YZX, RotationOrder.ZXY, RotationOrder.ZYX
          };

<span class="fc bfc" id="L454" title="All 2 branches covered.">          for (int i = 0; i &lt; CardanOrders.length; ++i) {</span>
<span class="fc bfc" id="L455" title="All 2 branches covered.">              for (double alpha1 = 0.1; alpha1 &lt; 6.2; alpha1 += 0.3) {</span>
<span class="fc bfc" id="L456" title="All 2 branches covered.">                  for (double alpha2 = -1.55; alpha2 &lt; 1.55; alpha2 += 0.3) {</span>
<span class="fc bfc" id="L457" title="All 2 branches covered.">                      for (double alpha3 = 0.1; alpha3 &lt; 6.2; alpha3 += 0.3) {</span>
<span class="fc" id="L458">                          Rotation r = new Rotation(CardanOrders[i], convention, alpha1, alpha2, alpha3);</span>
<span class="fc" id="L459">                          double[] angles = r.getAngles(CardanOrders[i], convention);</span>
<span class="fc" id="L460">                          checkAngle(angles[0], alpha1);</span>
<span class="fc" id="L461">                          checkAngle(angles[1], alpha2);</span>
<span class="fc" id="L462">                          checkAngle(angles[2], alpha3);</span>
                      }
                  }
              }
          }

<span class="fc" id="L468">          RotationOrder[] EulerOrders = {</span>
              RotationOrder.XYX, RotationOrder.XZX, RotationOrder.YXY,
              RotationOrder.YZY, RotationOrder.ZXZ, RotationOrder.ZYZ
          };

<span class="fc bfc" id="L473" title="All 2 branches covered.">          for (int i = 0; i &lt; EulerOrders.length; ++i) {</span>
<span class="fc bfc" id="L474" title="All 2 branches covered.">              for (double alpha1 = 0.1; alpha1 &lt; 6.2; alpha1 += 0.3) {</span>
<span class="fc bfc" id="L475" title="All 2 branches covered.">                  for (double alpha2 = 0.05; alpha2 &lt; 3.1; alpha2 += 0.3) {</span>
<span class="fc bfc" id="L476" title="All 2 branches covered.">                      for (double alpha3 = 0.1; alpha3 &lt; 6.2; alpha3 += 0.3) {</span>
<span class="fc" id="L477">                          Rotation r = new Rotation(EulerOrders[i], convention,</span>
                                                    alpha1, alpha2, alpha3);
<span class="fc" id="L479">                          double[] angles = r.getAngles(EulerOrders[i], convention);</span>
<span class="fc" id="L480">                          checkAngle(angles[0], alpha1);</span>
<span class="fc" id="L481">                          checkAngle(angles[1], alpha2);</span>
<span class="fc" id="L482">                          checkAngle(angles[2], alpha3);</span>
                      }
                  }
              }
          }
      }

<span class="fc" id="L489">  }</span>

  @Test
  public void testSingularities() {

<span class="fc bfc" id="L494" title="All 2 branches covered.">      for (RotationConvention convention : RotationConvention.values()) {</span>
<span class="fc" id="L495">          RotationOrder[] CardanOrders = {</span>
              RotationOrder.XYZ, RotationOrder.XZY, RotationOrder.YXZ,
              RotationOrder.YZX, RotationOrder.ZXY, RotationOrder.ZYX
          };

<span class="fc" id="L500">          double[] singularCardanAngle = { FastMath.PI / 2, -FastMath.PI / 2 };</span>
<span class="fc bfc" id="L501" title="All 2 branches covered.">          for (int i = 0; i &lt; CardanOrders.length; ++i) {</span>
<span class="fc bfc" id="L502" title="All 2 branches covered.">              for (int j = 0; j &lt; singularCardanAngle.length; ++j) {</span>
<span class="fc" id="L503">                  Rotation r = new Rotation(CardanOrders[i], convention, 0.1, singularCardanAngle[j], 0.3);</span>
                  try {
<span class="nc" id="L505">                      r.getAngles(CardanOrders[i], convention);</span>
<span class="nc" id="L506">                      Assert.fail(&quot;an exception should have been caught&quot;);</span>
<span class="fc" id="L507">                  } catch (CardanEulerSingularityException cese) {</span>
                      // expected behavior
<span class="nc" id="L509">                  }</span>
              }
          }

<span class="fc" id="L513">          RotationOrder[] EulerOrders = {</span>
              RotationOrder.XYX, RotationOrder.XZX, RotationOrder.YXY,
              RotationOrder.YZY, RotationOrder.ZXZ, RotationOrder.ZYZ
          };

<span class="fc" id="L518">          double[] singularEulerAngle = { 0, FastMath.PI };</span>
<span class="fc bfc" id="L519" title="All 2 branches covered.">          for (int i = 0; i &lt; EulerOrders.length; ++i) {</span>
<span class="fc bfc" id="L520" title="All 2 branches covered.">              for (int j = 0; j &lt; singularEulerAngle.length; ++j) {</span>
<span class="fc" id="L521">                  Rotation r = new Rotation(EulerOrders[i], convention, 0.1, singularEulerAngle[j], 0.3);</span>
                  try {
<span class="nc" id="L523">                      r.getAngles(EulerOrders[i], convention);</span>
<span class="nc" id="L524">                      Assert.fail(&quot;an exception should have been caught&quot;);</span>
<span class="fc" id="L525">                  } catch (CardanEulerSingularityException cese) {</span>
                      // expected behavior
<span class="nc" id="L527">                  }</span>
              }
          }
      }


<span class="fc" id="L533">  }</span>

  @Test
  public void testQuaternion() throws MathIllegalArgumentException {

<span class="fc" id="L538">    Rotation r1 = new Rotation(new Cartesian3D(2, -3, 5), 1.7, RotationConvention.VECTOR_OPERATOR);</span>
<span class="fc" id="L539">    double n = 23.5;</span>
<span class="fc" id="L540">    Rotation r2 = new Rotation(n * r1.getQ0(), n * r1.getQ1(),</span>
<span class="fc" id="L541">                               n * r1.getQ2(), n * r1.getQ3(),</span>
                               true);
<span class="fc bfc" id="L543" title="All 2 branches covered.">    for (double x = -0.9; x &lt; 0.9; x += 0.2) {</span>
<span class="fc bfc" id="L544" title="All 2 branches covered.">      for (double y = -0.9; y &lt; 0.9; y += 0.2) {</span>
<span class="fc bfc" id="L545" title="All 2 branches covered.">        for (double z = -0.9; z &lt; 0.9; z += 0.2) {</span>
<span class="fc" id="L546">          Cartesian3D u = new Cartesian3D(x, y, z);</span>
<span class="fc" id="L547">          checkVector(r2.applyTo(u), r1.applyTo(u));</span>
        }
      }
    }

<span class="fc" id="L552">    r1 = new Rotation( 0.288,  0.384,  0.36,  0.8, false);</span>
<span class="fc" id="L553">    checkRotation(r1, -r1.getQ0(), -r1.getQ1(), -r1.getQ2(), -r1.getQ3());</span>

<span class="fc" id="L555">  }</span>

  @Test
  public void testApplyTo() throws MathIllegalArgumentException {

<span class="fc" id="L560">    Rotation r1 = new Rotation(new Cartesian3D(2, -3, 5), 1.7, RotationConvention.VECTOR_OPERATOR);</span>
<span class="fc" id="L561">    Rotation r2 = new Rotation(new Cartesian3D(-1, 3, 2), 0.3, RotationConvention.VECTOR_OPERATOR);</span>
<span class="fc" id="L562">    Rotation r3 = r2.applyTo(r1);</span>

<span class="fc bfc" id="L564" title="All 2 branches covered.">    for (double x = -0.9; x &lt; 0.9; x += 0.2) {</span>
<span class="fc bfc" id="L565" title="All 2 branches covered.">      for (double y = -0.9; y &lt; 0.9; y += 0.2) {</span>
<span class="fc bfc" id="L566" title="All 2 branches covered.">        for (double z = -0.9; z &lt; 0.9; z += 0.2) {</span>
<span class="fc" id="L567">          Cartesian3D u = new Cartesian3D(x, y, z);</span>
<span class="fc" id="L568">          checkVector(r2.applyTo(r1.applyTo(u)), r3.applyTo(u));</span>
        }
      }
    }

<span class="fc" id="L573">  }</span>

  @Test
  public void testComposeVectorOperator() throws MathIllegalArgumentException {

<span class="fc" id="L578">    Rotation r1 = new Rotation(new Cartesian3D(2, -3, 5), 1.7, RotationConvention.VECTOR_OPERATOR);</span>
<span class="fc" id="L579">    Rotation r2 = new Rotation(new Cartesian3D(-1, 3, 2), 0.3, RotationConvention.VECTOR_OPERATOR);</span>
<span class="fc" id="L580">    Rotation r3 = r2.compose(r1, RotationConvention.VECTOR_OPERATOR);</span>

<span class="fc bfc" id="L582" title="All 2 branches covered.">    for (double x = -0.9; x &lt; 0.9; x += 0.2) {</span>
<span class="fc bfc" id="L583" title="All 2 branches covered.">      for (double y = -0.9; y &lt; 0.9; y += 0.2) {</span>
<span class="fc bfc" id="L584" title="All 2 branches covered.">        for (double z = -0.9; z &lt; 0.9; z += 0.2) {</span>
<span class="fc" id="L585">          Cartesian3D u = new Cartesian3D(x, y, z);</span>
<span class="fc" id="L586">          checkVector(r2.applyTo(r1.applyTo(u)), r3.applyTo(u));</span>
        }
      }
    }

<span class="fc" id="L591">  }</span>

  @Test
  public void testComposeFrameTransform() throws MathIllegalArgumentException {

<span class="fc" id="L596">    Rotation r1 = new Rotation(new Cartesian3D(2, -3, 5), 1.7, RotationConvention.FRAME_TRANSFORM);</span>
<span class="fc" id="L597">    Rotation r2 = new Rotation(new Cartesian3D(-1, 3, 2), 0.3, RotationConvention.FRAME_TRANSFORM);</span>
<span class="fc" id="L598">    Rotation r3 = r2.compose(r1, RotationConvention.FRAME_TRANSFORM);</span>
<span class="fc" id="L599">    Rotation r4 = r1.compose(r2, RotationConvention.VECTOR_OPERATOR);</span>
<span class="fc" id="L600">    Assert.assertEquals(0.0, Rotation.distance(r3, r4), 1.0e-15);</span>

<span class="fc bfc" id="L602" title="All 2 branches covered.">    for (double x = -0.9; x &lt; 0.9; x += 0.2) {</span>
<span class="fc bfc" id="L603" title="All 2 branches covered.">      for (double y = -0.9; y &lt; 0.9; y += 0.2) {</span>
<span class="fc bfc" id="L604" title="All 2 branches covered.">        for (double z = -0.9; z &lt; 0.9; z += 0.2) {</span>
<span class="fc" id="L605">          Cartesian3D u = new Cartesian3D(x, y, z);</span>
<span class="fc" id="L606">          checkVector(r1.applyTo(r2.applyTo(u)), r3.applyTo(u));</span>
        }
      }
    }

<span class="fc" id="L611">  }</span>

  @Test
  public void testApplyInverseToRotation() throws MathIllegalArgumentException {

<span class="fc" id="L616">    Rotation r1 = new Rotation(new Cartesian3D(2, -3, 5), 1.7, RotationConvention.VECTOR_OPERATOR);</span>
<span class="fc" id="L617">    Rotation r2 = new Rotation(new Cartesian3D(-1, 3, 2), 0.3, RotationConvention.VECTOR_OPERATOR);</span>
<span class="fc" id="L618">    Rotation r3 = r2.applyInverseTo(r1);</span>

<span class="fc bfc" id="L620" title="All 2 branches covered.">    for (double x = -0.9; x &lt; 0.9; x += 0.2) {</span>
<span class="fc bfc" id="L621" title="All 2 branches covered.">      for (double y = -0.9; y &lt; 0.9; y += 0.2) {</span>
<span class="fc bfc" id="L622" title="All 2 branches covered.">        for (double z = -0.9; z &lt; 0.9; z += 0.2) {</span>
<span class="fc" id="L623">          Cartesian3D u = new Cartesian3D(x, y, z);</span>
<span class="fc" id="L624">          checkVector(r2.applyInverseTo(r1.applyTo(u)), r3.applyTo(u));</span>
        }
      }
    }

<span class="fc" id="L629">  }</span>

  @Test
  public void testComposeInverseVectorOperator() throws MathIllegalArgumentException {

<span class="fc" id="L634">    Rotation r1 = new Rotation(new Cartesian3D(2, -3, 5), 1.7, RotationConvention.VECTOR_OPERATOR);</span>
<span class="fc" id="L635">    Rotation r2 = new Rotation(new Cartesian3D(-1, 3, 2), 0.3, RotationConvention.VECTOR_OPERATOR);</span>
<span class="fc" id="L636">    Rotation r3 = r2.composeInverse(r1, RotationConvention.VECTOR_OPERATOR);</span>

<span class="fc bfc" id="L638" title="All 2 branches covered.">    for (double x = -0.9; x &lt; 0.9; x += 0.2) {</span>
<span class="fc bfc" id="L639" title="All 2 branches covered.">      for (double y = -0.9; y &lt; 0.9; y += 0.2) {</span>
<span class="fc bfc" id="L640" title="All 2 branches covered.">        for (double z = -0.9; z &lt; 0.9; z += 0.2) {</span>
<span class="fc" id="L641">          Cartesian3D u = new Cartesian3D(x, y, z);</span>
<span class="fc" id="L642">          checkVector(r2.applyInverseTo(r1.applyTo(u)), r3.applyTo(u));</span>
        }
      }
    }

<span class="fc" id="L647">  }</span>

  @Test
  public void testComposeInverseFrameTransform() throws MathIllegalArgumentException {

<span class="fc" id="L652">    Rotation r1 = new Rotation(new Cartesian3D(2, -3, 5), 1.7, RotationConvention.FRAME_TRANSFORM);</span>
<span class="fc" id="L653">    Rotation r2 = new Rotation(new Cartesian3D(-1, 3, 2), 0.3, RotationConvention.FRAME_TRANSFORM);</span>
<span class="fc" id="L654">    Rotation r3 = r2.composeInverse(r1, RotationConvention.FRAME_TRANSFORM);</span>
<span class="fc" id="L655">    Rotation r4 = r1.revert().composeInverse(r2.revert(), RotationConvention.VECTOR_OPERATOR);</span>
<span class="fc" id="L656">    Assert.assertEquals(0.0, Rotation.distance(r3, r4), 1.0e-15);</span>

<span class="fc bfc" id="L658" title="All 2 branches covered.">    for (double x = -0.9; x &lt; 0.9; x += 0.2) {</span>
<span class="fc bfc" id="L659" title="All 2 branches covered.">      for (double y = -0.9; y &lt; 0.9; y += 0.2) {</span>
<span class="fc bfc" id="L660" title="All 2 branches covered.">        for (double z = -0.9; z &lt; 0.9; z += 0.2) {</span>
<span class="fc" id="L661">          Cartesian3D u = new Cartesian3D(x, y, z);</span>
<span class="fc" id="L662">          checkVector(r1.applyTo(r2.applyInverseTo(u)), r3.applyTo(u));</span>
        }
      }
    }

<span class="fc" id="L667">  }</span>

  @Test
  public void testArray() throws MathIllegalArgumentException {

<span class="fc" id="L672">      Rotation r = new Rotation(new Cartesian3D(2, -3, 5), 1.7, RotationConvention.VECTOR_OPERATOR);</span>

<span class="fc bfc" id="L674" title="All 2 branches covered.">      for (double x = -0.9; x &lt; 0.9; x += 0.2) {</span>
<span class="fc bfc" id="L675" title="All 2 branches covered.">          for (double y = -0.9; y &lt; 0.9; y += 0.2) {</span>
<span class="fc bfc" id="L676" title="All 2 branches covered.">              for (double z = -0.9; z &lt; 0.9; z += 0.2) {</span>
<span class="fc" id="L677">                  Cartesian3D u = new Cartesian3D(x, y, z);</span>
<span class="fc" id="L678">                  Cartesian3D v = r.applyTo(u);</span>
<span class="fc" id="L679">                  double[] inOut = new double[] { x, y, z };</span>
<span class="fc" id="L680">                  r.applyTo(inOut, inOut);</span>
<span class="fc" id="L681">                  Assert.assertEquals(v.getX(), inOut[0], 1.0e-10);</span>
<span class="fc" id="L682">                  Assert.assertEquals(v.getY(), inOut[1], 1.0e-10);</span>
<span class="fc" id="L683">                  Assert.assertEquals(v.getZ(), inOut[2], 1.0e-10);</span>
<span class="fc" id="L684">                  r.applyInverseTo(inOut, inOut);</span>
<span class="fc" id="L685">                  Assert.assertEquals(u.getX(), inOut[0], 1.0e-10);</span>
<span class="fc" id="L686">                  Assert.assertEquals(u.getY(), inOut[1], 1.0e-10);</span>
<span class="fc" id="L687">                  Assert.assertEquals(u.getZ(), inOut[2], 1.0e-10);</span>
              }
          }
      }

<span class="fc" id="L692">  }</span>

  @Test
  public void testApplyInverseTo() throws MathIllegalArgumentException {

<span class="fc" id="L697">    Rotation r = new Rotation(new Cartesian3D(2, -3, 5), 1.7, RotationConvention.VECTOR_OPERATOR);</span>
<span class="fc bfc" id="L698" title="All 2 branches covered.">    for (double lambda = 0; lambda &lt; 6.2; lambda += 0.2) {</span>
<span class="fc bfc" id="L699" title="All 2 branches covered.">      for (double phi = -1.55; phi &lt; 1.55; phi += 0.2) {</span>
<span class="fc" id="L700">          Cartesian3D u = new Cartesian3D(FastMath.cos(lambda) * FastMath.cos(phi),</span>
<span class="fc" id="L701">                                    FastMath.sin(lambda) * FastMath.cos(phi),</span>
<span class="fc" id="L702">                                    FastMath.sin(phi));</span>
<span class="fc" id="L703">          r.applyInverseTo(r.applyTo(u));</span>
<span class="fc" id="L704">          checkVector(u, r.applyInverseTo(r.applyTo(u)));</span>
<span class="fc" id="L705">          checkVector(u, r.applyTo(r.applyInverseTo(u)));</span>
      }
    }

<span class="fc" id="L709">    r = Rotation.IDENTITY;</span>
<span class="fc bfc" id="L710" title="All 2 branches covered.">    for (double lambda = 0; lambda &lt; 6.2; lambda += 0.2) {</span>
<span class="fc bfc" id="L711" title="All 2 branches covered.">      for (double phi = -1.55; phi &lt; 1.55; phi += 0.2) {</span>
<span class="fc" id="L712">          Cartesian3D u = new Cartesian3D(FastMath.cos(lambda) * FastMath.cos(phi),</span>
<span class="fc" id="L713">                                    FastMath.sin(lambda) * FastMath.cos(phi),</span>
<span class="fc" id="L714">                                    FastMath.sin(phi));</span>
<span class="fc" id="L715">          checkVector(u, r.applyInverseTo(r.applyTo(u)));</span>
<span class="fc" id="L716">          checkVector(u, r.applyTo(r.applyInverseTo(u)));</span>
      }
    }

<span class="fc" id="L720">    r = new Rotation(Cartesian3D.PLUS_K, FastMath.PI, RotationConvention.VECTOR_OPERATOR);</span>
<span class="fc bfc" id="L721" title="All 2 branches covered.">    for (double lambda = 0; lambda &lt; 6.2; lambda += 0.2) {</span>
<span class="fc bfc" id="L722" title="All 2 branches covered.">      for (double phi = -1.55; phi &lt; 1.55; phi += 0.2) {</span>
<span class="fc" id="L723">          Cartesian3D u = new Cartesian3D(FastMath.cos(lambda) * FastMath.cos(phi),</span>
<span class="fc" id="L724">                                    FastMath.sin(lambda) * FastMath.cos(phi),</span>
<span class="fc" id="L725">                                    FastMath.sin(phi));</span>
<span class="fc" id="L726">          checkVector(u, r.applyInverseTo(r.applyTo(u)));</span>
<span class="fc" id="L727">          checkVector(u, r.applyTo(r.applyInverseTo(u)));</span>
      }
    }

<span class="fc" id="L731">  }</span>

  @Test
  public void testIssue639() throws MathArithmeticException{
<span class="fc" id="L735">      Cartesian3D u1 = new Cartesian3D(-1321008684645961.0 /  268435456.0,</span>
                                 -5774608829631843.0 /  268435456.0,
                                 -3822921525525679.0 / 4294967296.0);
<span class="fc" id="L738">      Cartesian3D u2 =new Cartesian3D( -5712344449280879.0 /    2097152.0,</span>
                                 -2275058564560979.0 /    1048576.0,
                                  4423475992255071.0 /      65536.0);
<span class="fc" id="L741">      Rotation rot = new Rotation(u1, u2, Cartesian3D.PLUS_I,Cartesian3D.PLUS_K);</span>
<span class="fc" id="L742">      Assert.assertEquals( 0.6228370359608200639829222, rot.getQ0(), 1.0e-15);</span>
<span class="fc" id="L743">      Assert.assertEquals( 0.0257707621456498790029987, rot.getQ1(), 1.0e-15);</span>
<span class="fc" id="L744">      Assert.assertEquals(-0.0000000002503012255839931, rot.getQ2(), 1.0e-15);</span>
<span class="fc" id="L745">      Assert.assertEquals(-0.7819270390861109450724902, rot.getQ3(), 1.0e-15);</span>
<span class="fc" id="L746">  }</span>

  @Test
  public void testIssue801() throws MathArithmeticException {
<span class="fc" id="L750">      Cartesian3D u1 = new Cartesian3D(0.9999988431610581, -0.0015210774290851095, 0.0);</span>
<span class="fc" id="L751">      Cartesian3D u2 = new Cartesian3D(0.0, 0.0, 1.0);</span>

<span class="fc" id="L753">      Cartesian3D v1 = new Cartesian3D(0.9999999999999999, 0.0, 0.0);</span>
<span class="fc" id="L754">      Cartesian3D v2 = new Cartesian3D(0.0, 0.0, -1.0);</span>

<span class="fc" id="L756">      Rotation quat = new Rotation(u1, u2, v1, v2);</span>
<span class="fc" id="L757">      double q2 = quat.getQ0() * quat.getQ0() +</span>
<span class="fc" id="L758">                  quat.getQ1() * quat.getQ1() +</span>
<span class="fc" id="L759">                  quat.getQ2() * quat.getQ2() +</span>
<span class="fc" id="L760">                  quat.getQ3() * quat.getQ3();</span>
<span class="fc" id="L761">      Assert.assertEquals(1.0, q2, 1.0e-14);</span>
<span class="fc" id="L762">      Assert.assertEquals(0.0, Cartesian3D.angle(v1, quat.applyTo(u1)), 1.0e-14);</span>
<span class="fc" id="L763">      Assert.assertEquals(0.0, Cartesian3D.angle(v2, quat.applyTo(u2)), 1.0e-14);</span>

<span class="fc" id="L765">  }</span>

  @Test
  public void testGithubPullRequest22A() {
<span class="fc" id="L769">      final RotationOrder order = RotationOrder.ZYX;</span>
<span class="fc" id="L770">      final double xRotation = FastMath.toDegrees(30);</span>
<span class="fc" id="L771">      final double yRotation = FastMath.toDegrees(20);</span>
<span class="fc" id="L772">      final double zRotation = FastMath.toDegrees(10);</span>
<span class="fc" id="L773">      final Cartesian3D startingVector = Cartesian3D.PLUS_I;</span>
<span class="fc" id="L774">      Cartesian3D appliedIndividually = startingVector;</span>
<span class="fc" id="L775">      appliedIndividually = new Rotation(order, RotationConvention.FRAME_TRANSFORM, zRotation, 0, 0).applyTo(appliedIndividually);</span>
<span class="fc" id="L776">      appliedIndividually = new Rotation(order, RotationConvention.FRAME_TRANSFORM, 0, yRotation, 0).applyTo(appliedIndividually);</span>
<span class="fc" id="L777">      appliedIndividually = new Rotation(order, RotationConvention.FRAME_TRANSFORM, 0, 0, xRotation).applyTo(appliedIndividually);</span>

<span class="fc" id="L779">      final Cartesian3D bad = new Rotation(order, RotationConvention.FRAME_TRANSFORM, zRotation, yRotation, xRotation).applyTo(startingVector);</span>

<span class="fc" id="L781">      Assert.assertEquals(bad.getX(), appliedIndividually.getX(), 1e-12);</span>
<span class="fc" id="L782">      Assert.assertEquals(bad.getY(), appliedIndividually.getY(), 1e-12);</span>
<span class="fc" id="L783">      Assert.assertEquals(bad.getZ(), appliedIndividually.getZ(), 1e-12);</span>
<span class="fc" id="L784">  }</span>

  @Test
  public void testGithubPullRequest22B() {
<span class="fc" id="L788">      final RotationOrder order = RotationOrder.ZYX;</span>
<span class="fc" id="L789">      final double xRotation = FastMath.toDegrees(30);</span>
<span class="fc" id="L790">      final double yRotation = FastMath.toDegrees(20);</span>
<span class="fc" id="L791">      final double zRotation = FastMath.toDegrees(10);</span>
<span class="fc" id="L792">      final Cartesian3D startingVector = Cartesian3D.PLUS_I;</span>
<span class="fc" id="L793">      Cartesian3D appliedIndividually = startingVector;</span>
<span class="fc" id="L794">      appliedIndividually = new Rotation(order, RotationConvention.FRAME_TRANSFORM, zRotation, 0, 0).applyTo(appliedIndividually);</span>
<span class="fc" id="L795">      appliedIndividually = new Rotation(order, RotationConvention.FRAME_TRANSFORM, 0, yRotation, 0).applyTo(appliedIndividually);</span>
<span class="fc" id="L796">      appliedIndividually = new Rotation(order, RotationConvention.FRAME_TRANSFORM, 0, 0, xRotation).applyTo(appliedIndividually);</span>

<span class="fc" id="L798">      final Rotation r1 = new Rotation(order.getA1(), zRotation, RotationConvention.FRAME_TRANSFORM);</span>
<span class="fc" id="L799">      final Rotation r2 = new Rotation(order.getA2(), yRotation, RotationConvention.FRAME_TRANSFORM);</span>
<span class="fc" id="L800">      final Rotation r3 = new Rotation(order.getA3(), xRotation, RotationConvention.FRAME_TRANSFORM);</span>
<span class="fc" id="L801">      final Rotation composite = r1.compose(r2.compose(r3,</span>
                                                       RotationConvention.FRAME_TRANSFORM),
                                            RotationConvention.FRAME_TRANSFORM);
<span class="fc" id="L804">      final Cartesian3D good = composite.applyTo(startingVector);</span>

<span class="fc" id="L806">      Assert.assertEquals(good.getX(), appliedIndividually.getX(), 1e-12);</span>
<span class="fc" id="L807">      Assert.assertEquals(good.getY(), appliedIndividually.getY(), 1e-12);</span>
<span class="fc" id="L808">      Assert.assertEquals(good.getZ(), appliedIndividually.getZ(), 1e-12);</span>
<span class="fc" id="L809">  }</span>

  private void checkVector(Cartesian3D v1, Cartesian3D v2) {
<span class="pc bpc" id="L812" title="1 of 2 branches missed.">    Assert.assertTrue(v1.subtract(v2).getNorm() &lt; 1.0e-10);</span>
<span class="fc" id="L813">  }</span>

  private void checkAngle(double a1, double a2) {
<span class="fc" id="L816">    Assert.assertEquals(a1, PlaneAngleRadians.normalize(a2, a1), 1.0e-10);</span>
<span class="fc" id="L817">  }</span>

  private void checkRotation(Rotation r, double q0, double q1, double q2, double q3) {
<span class="fc" id="L820">    Assert.assertEquals(0, Rotation.distance(r, new Rotation(q0, q1, q2, q3, false)), 1.0e-12);</span>
<span class="fc" id="L821">  }</span>

}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.1.201803210924</span></div></body></html>