<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>SphericalPolygonsSetTest.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">commons_math4$All_in_commons_math4.exec</a> &gt; <a href="index.source.html" class="el_package">org.apache.commons.math4.geometry.spherical.twod</a> &gt; <span class="el_source">SphericalPolygonsSetTest.java</span></div><h1>SphericalPolygonsSetTest.java</h1><pre class="source lang-java linenums">/*
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the &quot;License&quot;); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.commons.math4.geometry.spherical.twod;

import java.util.ArrayList;
import java.util.List;
import org.junit.Assert;
import org.junit.Test;
import org.apache.commons.rng.UniformRandomProvider;
import org.apache.commons.rng.simple.RandomSource;
import org.apache.commons.rng.sampling.UnitSphereSampler;
import org.apache.commons.math4.geometry.enclosing.EnclosingBall;
import org.apache.commons.math4.geometry.euclidean.threed.Rotation;
import org.apache.commons.math4.geometry.euclidean.threed.Cartesian3D;
import org.apache.commons.math4.geometry.partitioning.RegionFactory;
import org.apache.commons.math4.geometry.partitioning.SubHyperplane;
import org.apache.commons.math4.geometry.partitioning.Region.Location;
import org.apache.commons.math4.geometry.spherical.oned.ArcsSet;
import org.apache.commons.math4.geometry.spherical.oned.Sphere1D;
import org.apache.commons.math4.geometry.spherical.twod.Circle;
import org.apache.commons.math4.geometry.spherical.twod.Edge;
import org.apache.commons.math4.geometry.spherical.twod.S2Point;
import org.apache.commons.math4.geometry.spherical.twod.Sphere2D;
import org.apache.commons.math4.geometry.spherical.twod.SphericalPolygonsSet;
import org.apache.commons.math4.geometry.spherical.twod.SubCircle;
import org.apache.commons.math4.geometry.spherical.twod.Vertex;
import org.apache.commons.math4.util.FastMath;
import org.apache.commons.math4.util.MathUtils;

<span class="fc" id="L44">public class SphericalPolygonsSetTest {</span>

    @Test
    public void testFullSphere() {
<span class="fc" id="L48">        SphericalPolygonsSet full = new SphericalPolygonsSet(1.0e-10);</span>
<span class="fc" id="L49">        UnitSphereSampler random =</span>
<span class="fc" id="L50">                new UnitSphereSampler(3, RandomSource.create(RandomSource.WELL_1024_A,</span>
<span class="fc" id="L51">                                                             0x852fd2a0ed8d2f6dl));</span>
<span class="fc bfc" id="L52" title="All 2 branches covered.">        for (int i = 0; i &lt; 1000; ++i) {</span>
<span class="fc" id="L53">            Cartesian3D v = new Cartesian3D(random.nextVector());</span>
<span class="fc" id="L54">            Assert.assertEquals(Location.INSIDE, full.checkPoint(new S2Point(v)));</span>
        }
<span class="fc" id="L56">        Assert.assertEquals(4 * FastMath.PI, new SphericalPolygonsSet(0.01, new S2Point[0]).getSize(), 1.0e-10);</span>
<span class="fc" id="L57">        Assert.assertEquals(0, new SphericalPolygonsSet(0.01, new S2Point[0]).getBoundarySize(), 1.0e-10);</span>
<span class="fc" id="L58">        Assert.assertEquals(0, full.getBoundaryLoops().size());</span>
<span class="pc bpc" id="L59" title="1 of 2 branches missed.">        Assert.assertTrue(full.getEnclosingCap().getRadius() &gt; 0);</span>
<span class="fc" id="L60">        Assert.assertTrue(Double.isInfinite(full.getEnclosingCap().getRadius()));</span>
<span class="fc" id="L61">    }</span>

    @Test
    public void testEmpty() {
<span class="fc" id="L65">        SphericalPolygonsSet empty =</span>
<span class="fc" id="L66">            (SphericalPolygonsSet) new RegionFactory&lt;Sphere2D&gt;().getComplement(new SphericalPolygonsSet(1.0e-10));</span>
<span class="fc" id="L67">        UnitSphereSampler random =</span>
<span class="fc" id="L68">                new UnitSphereSampler(3, RandomSource.create(RandomSource.WELL_1024_A,</span>
<span class="fc" id="L69">                                                             0x76d9205d6167b6ddl));</span>
<span class="fc bfc" id="L70" title="All 2 branches covered.">        for (int i = 0; i &lt; 1000; ++i) {</span>
<span class="fc" id="L71">            Cartesian3D v = new Cartesian3D(random.nextVector());</span>
<span class="fc" id="L72">            Assert.assertEquals(Location.OUTSIDE, empty.checkPoint(new S2Point(v)));</span>
        }
<span class="fc" id="L74">        Assert.assertEquals(0, empty.getSize(), 1.0e-10);</span>
<span class="fc" id="L75">        Assert.assertEquals(0, empty.getBoundarySize(), 1.0e-10);</span>
<span class="fc" id="L76">        Assert.assertEquals(0, empty.getBoundaryLoops().size());</span>
<span class="pc bpc" id="L77" title="1 of 2 branches missed.">        Assert.assertTrue(empty.getEnclosingCap().getRadius() &lt; 0);</span>
<span class="fc" id="L78">        Assert.assertTrue(Double.isInfinite(empty.getEnclosingCap().getRadius()));</span>
<span class="fc" id="L79">    }</span>

    @Test
    public void testSouthHemisphere() {
<span class="fc" id="L83">        double tol = 0.01;</span>
<span class="fc" id="L84">        double sinTol = FastMath.sin(tol);</span>
<span class="fc" id="L85">        SphericalPolygonsSet south = new SphericalPolygonsSet(Cartesian3D.MINUS_K, tol);</span>
<span class="fc" id="L86">        UnitSphereSampler random =</span>
<span class="fc" id="L87">                new UnitSphereSampler(3, RandomSource.create(RandomSource.WELL_1024_A,</span>
<span class="fc" id="L88">                                                             0x6b9d4a6ad90d7b0bl));</span>
<span class="fc bfc" id="L89" title="All 2 branches covered.">        for (int i = 0; i &lt; 1000; ++i) {</span>
<span class="fc" id="L90">            Cartesian3D v = new Cartesian3D(random.nextVector());</span>
<span class="fc bfc" id="L91" title="All 2 branches covered.">            if (v.getZ() &lt; -sinTol) {</span>
<span class="fc" id="L92">                Assert.assertEquals(Location.INSIDE, south.checkPoint(new S2Point(v)));</span>
<span class="fc bfc" id="L93" title="All 2 branches covered.">            } else if (v.getZ() &gt; sinTol) {</span>
<span class="fc" id="L94">                Assert.assertEquals(Location.OUTSIDE, south.checkPoint(new S2Point(v)));</span>
            } else {
<span class="fc" id="L96">                Assert.assertEquals(Location.BOUNDARY, south.checkPoint(new S2Point(v)));</span>
            }
        }
<span class="fc" id="L99">        Assert.assertEquals(1, south.getBoundaryLoops().size());</span>

<span class="fc" id="L101">        EnclosingBall&lt;Sphere2D, S2Point&gt; southCap = south.getEnclosingCap();</span>
<span class="fc" id="L102">        Assert.assertEquals(0.0, S2Point.MINUS_K.distance(southCap.getCenter()), 1.0e-10);</span>
<span class="fc" id="L103">        Assert.assertEquals(0.5 * FastMath.PI, southCap.getRadius(), 1.0e-10);</span>

<span class="fc" id="L105">        EnclosingBall&lt;Sphere2D, S2Point&gt; northCap =</span>
<span class="fc" id="L106">                ((SphericalPolygonsSet) new RegionFactory&lt;Sphere2D&gt;().getComplement(south)).getEnclosingCap();</span>
<span class="fc" id="L107">        Assert.assertEquals(0.0, S2Point.PLUS_K.distance(northCap.getCenter()), 1.0e-10);</span>
<span class="fc" id="L108">        Assert.assertEquals(0.5 * FastMath.PI, northCap.getRadius(), 1.0e-10);</span>

<span class="fc" id="L110">    }</span>

    @Test
    public void testPositiveOctantByIntersection() {
<span class="fc" id="L114">        double tol = 0.01;</span>
<span class="fc" id="L115">        double sinTol = FastMath.sin(tol);</span>
<span class="fc" id="L116">        RegionFactory&lt;Sphere2D&gt; factory = new RegionFactory&lt;&gt;();</span>
<span class="fc" id="L117">        SphericalPolygonsSet plusX = new SphericalPolygonsSet(Cartesian3D.PLUS_I, tol);</span>
<span class="fc" id="L118">        SphericalPolygonsSet plusY = new SphericalPolygonsSet(Cartesian3D.PLUS_J, tol);</span>
<span class="fc" id="L119">        SphericalPolygonsSet plusZ = new SphericalPolygonsSet(Cartesian3D.PLUS_K, tol);</span>
<span class="fc" id="L120">        SphericalPolygonsSet octant =</span>
<span class="fc" id="L121">                (SphericalPolygonsSet) factory.intersection(factory.intersection(plusX, plusY), plusZ);</span>
<span class="fc" id="L122">        UnitSphereSampler random =</span>
<span class="fc" id="L123">                new UnitSphereSampler(3, RandomSource.create(RandomSource.WELL_1024_A,</span>
<span class="fc" id="L124">                                                             0x9c9802fde3cbcf25l));</span>
<span class="fc bfc" id="L125" title="All 2 branches covered.">        for (int i = 0; i &lt; 1000; ++i) {</span>
<span class="fc" id="L126">            Cartesian3D v = new Cartesian3D(random.nextVector());</span>
<span class="fc bfc" id="L127" title="All 6 branches covered.">            if ((v.getX() &gt; sinTol) &amp;&amp; (v.getY() &gt; sinTol) &amp;&amp; (v.getZ() &gt; sinTol)) {</span>
<span class="fc" id="L128">                Assert.assertEquals(Location.INSIDE, octant.checkPoint(new S2Point(v)));</span>
<span class="fc bfc" id="L129" title="All 6 branches covered.">            } else if ((v.getX() &lt; -sinTol) || (v.getY() &lt; -sinTol) || (v.getZ() &lt; -sinTol)) {</span>
<span class="fc" id="L130">                Assert.assertEquals(Location.OUTSIDE, octant.checkPoint(new S2Point(v)));</span>
            } else {
<span class="fc" id="L132">                Assert.assertEquals(Location.BOUNDARY, octant.checkPoint(new S2Point(v)));</span>
            }
        }

<span class="fc" id="L136">        List&lt;Vertex&gt; loops = octant.getBoundaryLoops();</span>
<span class="fc" id="L137">        Assert.assertEquals(1, loops.size());</span>
<span class="fc" id="L138">        boolean xPFound = false;</span>
<span class="fc" id="L139">        boolean yPFound = false;</span>
<span class="fc" id="L140">        boolean zPFound = false;</span>
<span class="fc" id="L141">        boolean xVFound = false;</span>
<span class="fc" id="L142">        boolean yVFound = false;</span>
<span class="fc" id="L143">        boolean zVFound = false;</span>
<span class="fc" id="L144">        Vertex first = loops.get(0);</span>
<span class="fc" id="L145">        int count = 0;</span>
<span class="fc bfc" id="L146" title="All 4 branches covered.">        for (Vertex v = first; count == 0 || v != first; v = v.getOutgoing().getEnd()) {</span>
<span class="fc" id="L147">            ++count;</span>
<span class="fc" id="L148">            Edge e = v.getIncoming();</span>
<span class="pc bpc" id="L149" title="1 of 2 branches missed.">            Assert.assertTrue(v == e.getStart().getOutgoing().getEnd());</span>
<span class="fc bfc" id="L150" title="All 4 branches covered.">            xPFound = xPFound || e.getCircle().getPole().distance(Cartesian3D.PLUS_I) &lt; 1.0e-10;</span>
<span class="pc bpc" id="L151" title="1 of 4 branches missed.">            yPFound = yPFound || e.getCircle().getPole().distance(Cartesian3D.PLUS_J) &lt; 1.0e-10;</span>
<span class="pc bpc" id="L152" title="1 of 4 branches missed.">            zPFound = zPFound || e.getCircle().getPole().distance(Cartesian3D.PLUS_K) &lt; 1.0e-10;</span>
<span class="fc" id="L153">            Assert.assertEquals(0.5 * FastMath.PI, e.getLength(), 1.0e-10);</span>
<span class="pc bpc" id="L154" title="1 of 4 branches missed.">            xVFound = xVFound || v.getLocation().getVector().distance(Cartesian3D.PLUS_I) &lt; 1.0e-10;</span>
<span class="pc bpc" id="L155" title="1 of 4 branches missed.">            yVFound = yVFound || v.getLocation().getVector().distance(Cartesian3D.PLUS_J) &lt; 1.0e-10;</span>
<span class="fc bfc" id="L156" title="All 4 branches covered.">            zVFound = zVFound || v.getLocation().getVector().distance(Cartesian3D.PLUS_K) &lt; 1.0e-10;</span>
        }
<span class="fc" id="L158">        Assert.assertTrue(xPFound);</span>
<span class="fc" id="L159">        Assert.assertTrue(yPFound);</span>
<span class="fc" id="L160">        Assert.assertTrue(zPFound);</span>
<span class="fc" id="L161">        Assert.assertTrue(xVFound);</span>
<span class="fc" id="L162">        Assert.assertTrue(yVFound);</span>
<span class="fc" id="L163">        Assert.assertTrue(zVFound);</span>
<span class="fc" id="L164">        Assert.assertEquals(3, count);</span>

<span class="fc" id="L166">        Assert.assertEquals(0.0,</span>
<span class="fc" id="L167">                            ((S2Point) octant.getBarycenter()).distance(new S2Point(new Cartesian3D(1, 1, 1))),</span>
                            1.0e-10);
<span class="fc" id="L169">        Assert.assertEquals(0.5 * FastMath.PI, octant.getSize(), 1.0e-10);</span>

<span class="fc" id="L171">        EnclosingBall&lt;Sphere2D, S2Point&gt; cap = octant.getEnclosingCap();</span>
<span class="fc" id="L172">        Assert.assertEquals(0.0, octant.getBarycenter().distance(cap.getCenter()), 1.0e-10);</span>
<span class="fc" id="L173">        Assert.assertEquals(FastMath.acos(1.0 / FastMath.sqrt(3)), cap.getRadius(), 1.0e-10);</span>

<span class="fc" id="L175">        EnclosingBall&lt;Sphere2D, S2Point&gt; reversedCap =</span>
<span class="fc" id="L176">                ((SphericalPolygonsSet) factory.getComplement(octant)).getEnclosingCap();</span>
<span class="fc" id="L177">        Assert.assertEquals(0, reversedCap.getCenter().distance(new S2Point(new Cartesian3D(-1, -1, -1))), 1.0e-10);</span>
<span class="fc" id="L178">        Assert.assertEquals(FastMath.PI - FastMath.asin(1.0 / FastMath.sqrt(3)), reversedCap.getRadius(), 1.0e-10);</span>

<span class="fc" id="L180">    }</span>

    @Test
    public void testPositiveOctantByVertices() {
<span class="fc" id="L184">        double tol = 0.01;</span>
<span class="fc" id="L185">        double sinTol = FastMath.sin(tol);</span>
<span class="fc" id="L186">        SphericalPolygonsSet octant = new SphericalPolygonsSet(tol, S2Point.PLUS_I, S2Point.PLUS_J, S2Point.PLUS_K);</span>
<span class="fc" id="L187">        UnitSphereSampler random =</span>
<span class="fc" id="L188">                new UnitSphereSampler(3, RandomSource.create(RandomSource.WELL_1024_A,</span>
<span class="fc" id="L189">                                                             0xb8fc5acc91044308l));</span>
<span class="fc bfc" id="L190" title="All 2 branches covered.">        for (int i = 0; i &lt; 1000; ++i) {</span>
<span class="fc" id="L191">            Cartesian3D v = new Cartesian3D(random.nextVector());</span>
<span class="fc bfc" id="L192" title="All 6 branches covered.">            if ((v.getX() &gt; sinTol) &amp;&amp; (v.getY() &gt; sinTol) &amp;&amp; (v.getZ() &gt; sinTol)) {</span>
<span class="fc" id="L193">                Assert.assertEquals(Location.INSIDE, octant.checkPoint(new S2Point(v)));</span>
<span class="fc bfc" id="L194" title="All 6 branches covered.">            } else if ((v.getX() &lt; -sinTol) || (v.getY() &lt; -sinTol) || (v.getZ() &lt; -sinTol)) {</span>
<span class="fc" id="L195">                Assert.assertEquals(Location.OUTSIDE, octant.checkPoint(new S2Point(v)));</span>
            } else {
<span class="fc" id="L197">                Assert.assertEquals(Location.BOUNDARY, octant.checkPoint(new S2Point(v)));</span>
            }
        }
<span class="fc" id="L200">    }</span>

    @Test
    public void testNonConvex() {
<span class="fc" id="L204">        double tol = 0.01;</span>
<span class="fc" id="L205">        double sinTol = FastMath.sin(tol);</span>
<span class="fc" id="L206">        RegionFactory&lt;Sphere2D&gt; factory = new RegionFactory&lt;&gt;();</span>
<span class="fc" id="L207">        SphericalPolygonsSet plusX = new SphericalPolygonsSet(Cartesian3D.PLUS_I, tol);</span>
<span class="fc" id="L208">        SphericalPolygonsSet plusY = new SphericalPolygonsSet(Cartesian3D.PLUS_J, tol);</span>
<span class="fc" id="L209">        SphericalPolygonsSet plusZ = new SphericalPolygonsSet(Cartesian3D.PLUS_K, tol);</span>
<span class="fc" id="L210">        SphericalPolygonsSet threeOctants =</span>
<span class="fc" id="L211">                (SphericalPolygonsSet) factory.difference(plusZ, factory.intersection(plusX, plusY));</span>

<span class="fc" id="L213">        UnitSphereSampler random =</span>
<span class="fc" id="L214">                new UnitSphereSampler(3, RandomSource.create(RandomSource.WELL_1024_A,</span>
<span class="fc" id="L215">                                                             0x9c9802fde3cbcf25l));</span>
<span class="fc bfc" id="L216" title="All 2 branches covered.">        for (int i = 0; i &lt; 1000; ++i) {</span>
<span class="fc" id="L217">            Cartesian3D v = new Cartesian3D(random.nextVector());</span>
<span class="fc bfc" id="L218" title="All 6 branches covered.">            if (((v.getX() &lt; -sinTol) || (v.getY() &lt; -sinTol)) &amp;&amp; (v.getZ() &gt; sinTol)) {</span>
<span class="fc" id="L219">                Assert.assertEquals(Location.INSIDE, threeOctants.checkPoint(new S2Point(v)));</span>
<span class="fc bfc" id="L220" title="All 6 branches covered.">            } else if (((v.getX() &gt; sinTol) &amp;&amp; (v.getY() &gt; sinTol)) || (v.getZ() &lt; -sinTol)) {</span>
<span class="fc" id="L221">                Assert.assertEquals(Location.OUTSIDE, threeOctants.checkPoint(new S2Point(v)));</span>
            } else {
<span class="fc" id="L223">                Assert.assertEquals(Location.BOUNDARY, threeOctants.checkPoint(new S2Point(v)));</span>
            }
        }

<span class="fc" id="L227">        List&lt;Vertex&gt; loops = threeOctants.getBoundaryLoops();</span>
<span class="fc" id="L228">        Assert.assertEquals(1, loops.size());</span>
<span class="fc" id="L229">        boolean xPFound = false;</span>
<span class="fc" id="L230">        boolean yPFound = false;</span>
<span class="fc" id="L231">        boolean zPFound = false;</span>
<span class="fc" id="L232">        boolean xVFound = false;</span>
<span class="fc" id="L233">        boolean yVFound = false;</span>
<span class="fc" id="L234">        boolean zVFound = false;</span>
<span class="fc" id="L235">        Vertex first = loops.get(0);</span>
<span class="fc" id="L236">        int count = 0;</span>
<span class="fc" id="L237">        double sumPoleX = 0;</span>
<span class="fc" id="L238">        double sumPoleY = 0;</span>
<span class="fc" id="L239">        double sumPoleZ = 0;</span>
<span class="fc bfc" id="L240" title="All 4 branches covered.">        for (Vertex v = first; count == 0 || v != first; v = v.getOutgoing().getEnd()) {</span>
<span class="fc" id="L241">            ++count;</span>
<span class="fc" id="L242">            Edge e = v.getIncoming();</span>
<span class="pc bpc" id="L243" title="1 of 2 branches missed.">            Assert.assertTrue(v == e.getStart().getOutgoing().getEnd());</span>
<span class="fc bfc" id="L244" title="All 2 branches covered.">            if (e.getCircle().getPole().distance(Cartesian3D.MINUS_I) &lt; 1.0e-10) {</span>
<span class="fc" id="L245">                xPFound = true;</span>
<span class="fc" id="L246">                sumPoleX += e.getLength();</span>
<span class="fc bfc" id="L247" title="All 2 branches covered.">            } else if (e.getCircle().getPole().distance(Cartesian3D.MINUS_J) &lt; 1.0e-10) {</span>
<span class="fc" id="L248">                yPFound = true;</span>
<span class="fc" id="L249">                sumPoleY += e.getLength();</span>
            } else {
<span class="fc" id="L251">                Assert.assertEquals(0.0, e.getCircle().getPole().distance(Cartesian3D.PLUS_K), 1.0e-10);</span>
<span class="fc" id="L252">                zPFound = true;</span>
<span class="fc" id="L253">                sumPoleZ += e.getLength();</span>
            }
<span class="fc bfc" id="L255" title="All 4 branches covered.">            xVFound = xVFound || v.getLocation().getVector().distance(Cartesian3D.PLUS_I) &lt; 1.0e-10;</span>
<span class="pc bpc" id="L256" title="1 of 4 branches missed.">            yVFound = yVFound || v.getLocation().getVector().distance(Cartesian3D.PLUS_J) &lt; 1.0e-10;</span>
<span class="fc bfc" id="L257" title="All 4 branches covered.">            zVFound = zVFound || v.getLocation().getVector().distance(Cartesian3D.PLUS_K) &lt; 1.0e-10;</span>
        }
<span class="fc" id="L259">        Assert.assertTrue(xPFound);</span>
<span class="fc" id="L260">        Assert.assertTrue(yPFound);</span>
<span class="fc" id="L261">        Assert.assertTrue(zPFound);</span>
<span class="fc" id="L262">        Assert.assertTrue(xVFound);</span>
<span class="fc" id="L263">        Assert.assertTrue(yVFound);</span>
<span class="fc" id="L264">        Assert.assertTrue(zVFound);</span>
<span class="fc" id="L265">        Assert.assertEquals(0.5 * FastMath.PI, sumPoleX, 1.0e-10);</span>
<span class="fc" id="L266">        Assert.assertEquals(0.5 * FastMath.PI, sumPoleY, 1.0e-10);</span>
<span class="fc" id="L267">        Assert.assertEquals(1.5 * FastMath.PI, sumPoleZ, 1.0e-10);</span>

<span class="fc" id="L269">        Assert.assertEquals(1.5 * FastMath.PI, threeOctants.getSize(), 1.0e-10);</span>

<span class="fc" id="L271">    }</span>

    @Test
    public void testModeratlyComplexShape() {
<span class="fc" id="L275">        double tol = 0.01;</span>
<span class="fc" id="L276">        List&lt;SubHyperplane&lt;Sphere2D&gt;&gt; boundary = new ArrayList&lt;&gt;();</span>
<span class="fc" id="L277">        boundary.add(create(Cartesian3D.MINUS_J, Cartesian3D.PLUS_I,  Cartesian3D.PLUS_K,  tol, 0.0, 0.5 * FastMath.PI));</span>
<span class="fc" id="L278">        boundary.add(create(Cartesian3D.MINUS_I, Cartesian3D.PLUS_K,  Cartesian3D.PLUS_J,  tol, 0.0, 0.5 * FastMath.PI));</span>
<span class="fc" id="L279">        boundary.add(create(Cartesian3D.PLUS_K,  Cartesian3D.PLUS_J,  Cartesian3D.MINUS_I, tol, 0.0, 0.5 * FastMath.PI));</span>
<span class="fc" id="L280">        boundary.add(create(Cartesian3D.MINUS_J, Cartesian3D.MINUS_I, Cartesian3D.MINUS_K, tol, 0.0, 0.5 * FastMath.PI));</span>
<span class="fc" id="L281">        boundary.add(create(Cartesian3D.MINUS_I, Cartesian3D.MINUS_K, Cartesian3D.MINUS_J, tol, 0.0, 0.5 * FastMath.PI));</span>
<span class="fc" id="L282">        boundary.add(create(Cartesian3D.PLUS_K,  Cartesian3D.MINUS_J, Cartesian3D.PLUS_I,  tol, 0.0, 0.5 * FastMath.PI));</span>
<span class="fc" id="L283">        SphericalPolygonsSet polygon = new SphericalPolygonsSet(boundary, tol);</span>

<span class="fc" id="L285">        Assert.assertEquals(Location.OUTSIDE, polygon.checkPoint(new S2Point(new Cartesian3D( 1,  1,  1).normalize())));</span>
<span class="fc" id="L286">        Assert.assertEquals(Location.INSIDE,  polygon.checkPoint(new S2Point(new Cartesian3D(-1,  1,  1).normalize())));</span>
<span class="fc" id="L287">        Assert.assertEquals(Location.INSIDE,  polygon.checkPoint(new S2Point(new Cartesian3D(-1, -1,  1).normalize())));</span>
<span class="fc" id="L288">        Assert.assertEquals(Location.INSIDE,  polygon.checkPoint(new S2Point(new Cartesian3D( 1, -1,  1).normalize())));</span>
<span class="fc" id="L289">        Assert.assertEquals(Location.OUTSIDE, polygon.checkPoint(new S2Point(new Cartesian3D( 1,  1, -1).normalize())));</span>
<span class="fc" id="L290">        Assert.assertEquals(Location.OUTSIDE, polygon.checkPoint(new S2Point(new Cartesian3D(-1,  1, -1).normalize())));</span>
<span class="fc" id="L291">        Assert.assertEquals(Location.INSIDE,  polygon.checkPoint(new S2Point(new Cartesian3D(-1, -1, -1).normalize())));</span>
<span class="fc" id="L292">        Assert.assertEquals(Location.OUTSIDE, polygon.checkPoint(new S2Point(new Cartesian3D( 1, -1, -1).normalize())));</span>

<span class="fc" id="L294">        Assert.assertEquals(MathUtils.TWO_PI, polygon.getSize(), 1.0e-10);</span>
<span class="fc" id="L295">        Assert.assertEquals(3 * FastMath.PI, polygon.getBoundarySize(), 1.0e-10);</span>

<span class="fc" id="L297">        List&lt;Vertex&gt; loops = polygon.getBoundaryLoops();</span>
<span class="fc" id="L298">        Assert.assertEquals(1, loops.size());</span>
<span class="fc" id="L299">        boolean pXFound = false;</span>
<span class="fc" id="L300">        boolean mXFound = false;</span>
<span class="fc" id="L301">        boolean pYFound = false;</span>
<span class="fc" id="L302">        boolean mYFound = false;</span>
<span class="fc" id="L303">        boolean pZFound = false;</span>
<span class="fc" id="L304">        boolean mZFound = false;</span>
<span class="fc" id="L305">        Vertex first = loops.get(0);</span>
<span class="fc" id="L306">        int count = 0;</span>
<span class="fc bfc" id="L307" title="All 4 branches covered.">        for (Vertex v = first; count == 0 || v != first; v = v.getOutgoing().getEnd()) {</span>
<span class="fc" id="L308">            ++count;</span>
<span class="fc" id="L309">            Edge e = v.getIncoming();</span>
<span class="pc bpc" id="L310" title="1 of 2 branches missed.">            Assert.assertTrue(v == e.getStart().getOutgoing().getEnd());</span>
<span class="pc bpc" id="L311" title="1 of 4 branches missed.">            pXFound = pXFound || v.getLocation().getVector().distance(Cartesian3D.PLUS_I)  &lt; 1.0e-10;</span>
<span class="fc bfc" id="L312" title="All 4 branches covered.">            mXFound = mXFound || v.getLocation().getVector().distance(Cartesian3D.MINUS_I) &lt; 1.0e-10;</span>
<span class="fc bfc" id="L313" title="All 4 branches covered.">            pYFound = pYFound || v.getLocation().getVector().distance(Cartesian3D.PLUS_J)  &lt; 1.0e-10;</span>
<span class="pc bpc" id="L314" title="1 of 4 branches missed.">            mYFound = mYFound || v.getLocation().getVector().distance(Cartesian3D.MINUS_J) &lt; 1.0e-10;</span>
<span class="fc bfc" id="L315" title="All 4 branches covered.">            pZFound = pZFound || v.getLocation().getVector().distance(Cartesian3D.PLUS_K)  &lt; 1.0e-10;</span>
<span class="fc bfc" id="L316" title="All 4 branches covered.">            mZFound = mZFound || v.getLocation().getVector().distance(Cartesian3D.MINUS_K) &lt; 1.0e-10;</span>
<span class="fc" id="L317">            Assert.assertEquals(0.5 * FastMath.PI, e.getLength(), 1.0e-10);</span>
        }
<span class="fc" id="L319">        Assert.assertTrue(pXFound);</span>
<span class="fc" id="L320">        Assert.assertTrue(mXFound);</span>
<span class="fc" id="L321">        Assert.assertTrue(pYFound);</span>
<span class="fc" id="L322">        Assert.assertTrue(mYFound);</span>
<span class="fc" id="L323">        Assert.assertTrue(pZFound);</span>
<span class="fc" id="L324">        Assert.assertTrue(mZFound);</span>
<span class="fc" id="L325">        Assert.assertEquals(6, count);</span>

<span class="fc" id="L327">    }</span>

    @Test
    public void testSeveralParts() {
<span class="fc" id="L331">        double tol = 0.01;</span>
<span class="fc" id="L332">        double sinTol = FastMath.sin(tol);</span>
<span class="fc" id="L333">        List&lt;SubHyperplane&lt;Sphere2D&gt;&gt; boundary = new ArrayList&lt;&gt;();</span>

        // first part: +X, +Y, +Z octant
<span class="fc" id="L336">        boundary.add(create(Cartesian3D.PLUS_J,  Cartesian3D.PLUS_K,  Cartesian3D.PLUS_I,  tol, 0.0, 0.5 * FastMath.PI));</span>
<span class="fc" id="L337">        boundary.add(create(Cartesian3D.PLUS_K,  Cartesian3D.PLUS_I,  Cartesian3D.PLUS_J,  tol, 0.0, 0.5 * FastMath.PI));</span>
<span class="fc" id="L338">        boundary.add(create(Cartesian3D.PLUS_I,  Cartesian3D.PLUS_J,  Cartesian3D.PLUS_K,  tol, 0.0, 0.5 * FastMath.PI));</span>

        // first part: -X, -Y, -Z octant
<span class="fc" id="L341">        boundary.add(create(Cartesian3D.MINUS_J, Cartesian3D.MINUS_I, Cartesian3D.MINUS_K, tol, 0.0, 0.5 * FastMath.PI));</span>
<span class="fc" id="L342">        boundary.add(create(Cartesian3D.MINUS_I, Cartesian3D.MINUS_K, Cartesian3D.MINUS_J, tol, 0.0, 0.5 * FastMath.PI));</span>
<span class="fc" id="L343">        boundary.add(create(Cartesian3D.MINUS_K, Cartesian3D.MINUS_J, Cartesian3D.MINUS_I,  tol, 0.0, 0.5 * FastMath.PI));</span>

<span class="fc" id="L345">        SphericalPolygonsSet polygon = new SphericalPolygonsSet(boundary, tol);</span>

<span class="fc" id="L347">        UnitSphereSampler random =</span>
<span class="fc" id="L348">                new UnitSphereSampler(3, RandomSource.create(RandomSource.WELL_1024_A,</span>
<span class="fc" id="L349">                                                             0xcc5ce49949e0d3ecl));</span>
<span class="fc bfc" id="L350" title="All 2 branches covered.">        for (int i = 0; i &lt; 1000; ++i) {</span>
<span class="fc" id="L351">            Cartesian3D v = new Cartesian3D(random.nextVector());</span>
<span class="fc bfc" id="L352" title="All 6 branches covered.">            if ((v.getX() &lt; -sinTol) &amp;&amp; (v.getY() &lt; -sinTol) &amp;&amp; (v.getZ() &lt; -sinTol)) {</span>
<span class="fc" id="L353">                Assert.assertEquals(Location.INSIDE, polygon.checkPoint(new S2Point(v)));</span>
<span class="fc bfc" id="L354" title="All 6 branches covered.">            } else if ((v.getX() &lt; sinTol) &amp;&amp; (v.getY() &lt; sinTol) &amp;&amp; (v.getZ() &lt; sinTol)) {</span>
<span class="fc" id="L355">                Assert.assertEquals(Location.BOUNDARY, polygon.checkPoint(new S2Point(v)));</span>
<span class="fc bfc" id="L356" title="All 6 branches covered.">            } else if ((v.getX() &gt; sinTol) &amp;&amp; (v.getY() &gt; sinTol) &amp;&amp; (v.getZ() &gt; sinTol)) {</span>
<span class="fc" id="L357">                Assert.assertEquals(Location.INSIDE, polygon.checkPoint(new S2Point(v)));</span>
<span class="fc bfc" id="L358" title="All 6 branches covered.">            } else if ((v.getX() &gt; -sinTol) &amp;&amp; (v.getY() &gt; -sinTol) &amp;&amp; (v.getZ() &gt; -sinTol)) {</span>
<span class="fc" id="L359">                Assert.assertEquals(Location.BOUNDARY, polygon.checkPoint(new S2Point(v)));</span>
            } else {
<span class="fc" id="L361">                Assert.assertEquals(Location.OUTSIDE, polygon.checkPoint(new S2Point(v)));</span>
            }
        }

<span class="fc" id="L365">        Assert.assertEquals(FastMath.PI, polygon.getSize(), 1.0e-10);</span>
<span class="fc" id="L366">        Assert.assertEquals(3 * FastMath.PI, polygon.getBoundarySize(), 1.0e-10);</span>

        // there should be two separate boundary loops
<span class="fc" id="L369">        Assert.assertEquals(2, polygon.getBoundaryLoops().size());</span>

<span class="fc" id="L371">    }</span>

    @Test
    public void testPartWithHole() {
<span class="fc" id="L375">        double tol = 0.01;</span>
<span class="fc" id="L376">        double alpha = 0.7;</span>
<span class="fc" id="L377">        S2Point center = new S2Point(new Cartesian3D(1, 1, 1));</span>
<span class="fc" id="L378">        SphericalPolygonsSet hexa = new SphericalPolygonsSet(center.getVector(), Cartesian3D.PLUS_K, alpha, 6, tol);</span>
<span class="fc" id="L379">        SphericalPolygonsSet hole  = new SphericalPolygonsSet(tol,</span>
                                                              new S2Point(FastMath.PI / 6, FastMath.PI / 3),
                                                              new S2Point(FastMath.PI / 3, FastMath.PI / 3),
                                                              new S2Point(FastMath.PI / 4, FastMath.PI / 6));
<span class="fc" id="L383">        SphericalPolygonsSet hexaWithHole =</span>
<span class="fc" id="L384">                (SphericalPolygonsSet) new RegionFactory&lt;Sphere2D&gt;().difference(hexa, hole);</span>

<span class="fc bfc" id="L386" title="All 2 branches covered.">        for (double phi = center.getPhi() - alpha + 0.1; phi &lt; center.getPhi() + alpha - 0.1; phi += 0.07) {</span>
<span class="fc" id="L387">            Location l = hexaWithHole.checkPoint(new S2Point(FastMath.PI / 4, phi));</span>
<span class="fc bfc" id="L388" title="All 4 branches covered.">            if (phi &lt; FastMath.PI / 6 || phi &gt; FastMath.PI / 3) {</span>
<span class="fc" id="L389">                Assert.assertEquals(Location.INSIDE,  l);</span>
            } else {
<span class="fc" id="L391">                Assert.assertEquals(Location.OUTSIDE, l);</span>
            }
        }

        // there should be two separate boundary loops
<span class="fc" id="L396">        Assert.assertEquals(2, hexaWithHole.getBoundaryLoops().size());</span>

<span class="fc" id="L398">        Assert.assertEquals(hexa.getBoundarySize() + hole.getBoundarySize(), hexaWithHole.getBoundarySize(), 1.0e-10);</span>
<span class="fc" id="L399">        Assert.assertEquals(hexa.getSize() - hole.getSize(), hexaWithHole.getSize(), 1.0e-10);</span>

<span class="fc" id="L401">    }</span>

    @Test
    public void testConcentricSubParts() {
<span class="fc" id="L405">        double tol = 0.001;</span>
<span class="fc" id="L406">        Cartesian3D center = new Cartesian3D(1, 1, 1);</span>
<span class="fc" id="L407">        SphericalPolygonsSet hexaOut   = new SphericalPolygonsSet(center, Cartesian3D.PLUS_K, 0.9,  6, tol);</span>
<span class="fc" id="L408">        SphericalPolygonsSet hexaIn    = new SphericalPolygonsSet(center, Cartesian3D.PLUS_K, 0.8,  6, tol);</span>
<span class="fc" id="L409">        SphericalPolygonsSet pentaOut  = new SphericalPolygonsSet(center, Cartesian3D.PLUS_K, 0.7,  5, tol);</span>
<span class="fc" id="L410">        SphericalPolygonsSet pentaIn   = new SphericalPolygonsSet(center, Cartesian3D.PLUS_K, 0.6,  5, tol);</span>
<span class="fc" id="L411">        SphericalPolygonsSet quadriOut = new SphericalPolygonsSet(center, Cartesian3D.PLUS_K, 0.5,  4, tol);</span>
<span class="fc" id="L412">        SphericalPolygonsSet quadriIn  = new SphericalPolygonsSet(center, Cartesian3D.PLUS_K, 0.4,  4, tol);</span>
<span class="fc" id="L413">        SphericalPolygonsSet triOut    = new SphericalPolygonsSet(center, Cartesian3D.PLUS_K, 0.25, 3, tol);</span>
<span class="fc" id="L414">        SphericalPolygonsSet triIn     = new SphericalPolygonsSet(center, Cartesian3D.PLUS_K, 0.15, 3, tol);</span>

<span class="fc" id="L416">        RegionFactory&lt;Sphere2D&gt; factory = new RegionFactory&lt;&gt;();</span>
<span class="fc" id="L417">        SphericalPolygonsSet hexa   = (SphericalPolygonsSet) factory.difference(hexaOut,   hexaIn);</span>
<span class="fc" id="L418">        SphericalPolygonsSet penta  = (SphericalPolygonsSet) factory.difference(pentaOut,  pentaIn);</span>
<span class="fc" id="L419">        SphericalPolygonsSet quadri = (SphericalPolygonsSet) factory.difference(quadriOut, quadriIn);</span>
<span class="fc" id="L420">        SphericalPolygonsSet tri    = (SphericalPolygonsSet) factory.difference(triOut,    triIn);</span>
<span class="fc" id="L421">        SphericalPolygonsSet concentric =</span>
<span class="fc" id="L422">                (SphericalPolygonsSet) factory.union(factory.union(hexa, penta), factory.union(quadri, tri));</span>

        // there should be two separate boundary loops
<span class="fc" id="L425">        Assert.assertEquals(8, concentric.getBoundaryLoops().size());</span>

<span class="fc" id="L427">        Assert.assertEquals(hexaOut.getBoundarySize()   + hexaIn.getBoundarySize()   +</span>
<span class="fc" id="L428">                            pentaOut.getBoundarySize()  + pentaIn.getBoundarySize()  +</span>
<span class="fc" id="L429">                            quadriOut.getBoundarySize() + quadriIn.getBoundarySize() +</span>
<span class="fc" id="L430">                            triOut.getBoundarySize()    + triIn.getBoundarySize(),</span>
<span class="fc" id="L431">                            concentric.getBoundarySize(), 1.0e-10);</span>
<span class="fc" id="L432">        Assert.assertEquals(hexaOut.getSize()   - hexaIn.getSize()   +</span>
<span class="fc" id="L433">                            pentaOut.getSize()  - pentaIn.getSize()  +</span>
<span class="fc" id="L434">                            quadriOut.getSize() - quadriIn.getSize() +</span>
<span class="fc" id="L435">                            triOut.getSize()    - triIn.getSize(),</span>
<span class="fc" id="L436">                            concentric.getSize(), 1.0e-10);</span>

        // we expect lots of sign changes as we traverse all concentric rings
<span class="fc" id="L439">        double phi = new S2Point(center).getPhi();</span>
<span class="fc" id="L440">        Assert.assertEquals(+0.207, concentric.projectToBoundary(new S2Point(-0.60,  phi)).getOffset(), 0.01);</span>
<span class="fc" id="L441">        Assert.assertEquals(-0.048, concentric.projectToBoundary(new S2Point(-0.21,  phi)).getOffset(), 0.01);</span>
<span class="fc" id="L442">        Assert.assertEquals(+0.027, concentric.projectToBoundary(new S2Point(-0.10,  phi)).getOffset(), 0.01);</span>
<span class="fc" id="L443">        Assert.assertEquals(-0.041, concentric.projectToBoundary(new S2Point( 0.01,  phi)).getOffset(), 0.01);</span>
<span class="fc" id="L444">        Assert.assertEquals(+0.049, concentric.projectToBoundary(new S2Point( 0.16,  phi)).getOffset(), 0.01);</span>
<span class="fc" id="L445">        Assert.assertEquals(-0.038, concentric.projectToBoundary(new S2Point( 0.29,  phi)).getOffset(), 0.01);</span>
<span class="fc" id="L446">        Assert.assertEquals(+0.097, concentric.projectToBoundary(new S2Point( 0.48,  phi)).getOffset(), 0.01);</span>
<span class="fc" id="L447">        Assert.assertEquals(-0.022, concentric.projectToBoundary(new S2Point( 0.64,  phi)).getOffset(), 0.01);</span>
<span class="fc" id="L448">        Assert.assertEquals(+0.072, concentric.projectToBoundary(new S2Point( 0.79,  phi)).getOffset(), 0.01);</span>
<span class="fc" id="L449">        Assert.assertEquals(-0.022, concentric.projectToBoundary(new S2Point( 0.93,  phi)).getOffset(), 0.01);</span>
<span class="fc" id="L450">        Assert.assertEquals(+0.091, concentric.projectToBoundary(new S2Point( 1.08,  phi)).getOffset(), 0.01);</span>
<span class="fc" id="L451">        Assert.assertEquals(-0.037, concentric.projectToBoundary(new S2Point( 1.28,  phi)).getOffset(), 0.01);</span>
<span class="fc" id="L452">        Assert.assertEquals(+0.051, concentric.projectToBoundary(new S2Point( 1.40,  phi)).getOffset(), 0.01);</span>
<span class="fc" id="L453">        Assert.assertEquals(-0.041, concentric.projectToBoundary(new S2Point( 1.55,  phi)).getOffset(), 0.01);</span>
<span class="fc" id="L454">        Assert.assertEquals(+0.027, concentric.projectToBoundary(new S2Point( 1.67,  phi)).getOffset(), 0.01);</span>
<span class="fc" id="L455">        Assert.assertEquals(-0.044, concentric.projectToBoundary(new S2Point( 1.79,  phi)).getOffset(), 0.01);</span>
<span class="fc" id="L456">        Assert.assertEquals(+0.201, concentric.projectToBoundary(new S2Point( 2.16,  phi)).getOffset(), 0.01);</span>

<span class="fc" id="L458">    }</span>

    @Test
    public void testGeographicalMap() {

<span class="fc" id="L463">        SphericalPolygonsSet continental = buildSimpleZone(new double[][] {</span>
          { 51.14850,  2.51357 }, { 50.94660,  1.63900 }, { 50.12717,  1.33876 }, { 49.34737, -0.98946 },
          { 49.77634, -1.93349 }, { 48.64442, -1.61651 }, { 48.90169, -3.29581 }, { 48.68416, -4.59234 },
          { 47.95495, -4.49155 }, { 47.57032, -2.96327 }, { 46.01491, -1.19379 }, { 44.02261, -1.38422 },
          { 43.42280, -1.90135 }, { 43.03401, -1.50277 }, { 42.34338,  1.82679 }, { 42.47301,  2.98599 },
          { 43.07520,  3.10041 }, { 43.39965,  4.55696 }, { 43.12889,  6.52924 }, { 43.69384,  7.43518 },
          { 44.12790,  7.54959 }, { 45.02851,  6.74995 }, { 45.33309,  7.09665 }, { 46.42967,  6.50009 },
          { 46.27298,  6.02260 }, { 46.72577,  6.03738 }, { 47.62058,  7.46675 }, { 49.01778,  8.09927 },
          { 49.20195,  6.65822 }, { 49.44266,  5.89775 }, { 49.98537,  4.79922 }
        });
<span class="fc" id="L473">        SphericalPolygonsSet corsica = buildSimpleZone(new double[][] {</span>
          { 42.15249,  9.56001 }, { 43.00998,  9.39000 }, { 42.62812,  8.74600 }, { 42.25651,  8.54421 },
          { 41.58361,  8.77572 }, { 41.38000,  9.22975 }
        });
<span class="fc" id="L477">        RegionFactory&lt;Sphere2D&gt; factory = new RegionFactory&lt;&gt;();</span>
<span class="fc" id="L478">        SphericalPolygonsSet zone = (SphericalPolygonsSet) factory.union(continental, corsica);</span>
<span class="fc" id="L479">        EnclosingBall&lt;Sphere2D, S2Point&gt; enclosing = zone.getEnclosingCap();</span>
<span class="fc" id="L480">        Cartesian3D enclosingCenter = ((S2Point) enclosing.getCenter()).getVector();</span>

<span class="fc" id="L482">        double step = FastMath.toRadians(0.1);</span>
<span class="fc bfc" id="L483" title="All 2 branches covered.">        for (Vertex loopStart : zone.getBoundaryLoops()) {</span>
<span class="fc" id="L484">            int count = 0;</span>
<span class="fc bfc" id="L485" title="All 4 branches covered.">            for (Vertex v = loopStart; count == 0 || v != loopStart; v = v.getOutgoing().getEnd()) {</span>
<span class="fc" id="L486">                ++count;</span>
<span class="fc bfc" id="L487" title="All 2 branches covered.">                for (int i = 0; i &lt; FastMath.ceil(v.getOutgoing().getLength() / step); ++i) {</span>
<span class="fc" id="L488">                    Cartesian3D p = v.getOutgoing().getPointAt(i * step);</span>
<span class="pc bpc" id="L489" title="1 of 2 branches missed.">                    Assert.assertTrue(Cartesian3D.angle(p, enclosingCenter) &lt;= enclosing.getRadius());</span>
                }
            }
<span class="fc" id="L492">        }</span>

<span class="fc" id="L494">        S2Point supportPointA = s2Point(48.68416, -4.59234);</span>
<span class="fc" id="L495">        S2Point supportPointB = s2Point(41.38000,  9.22975);</span>
<span class="fc" id="L496">        Assert.assertEquals(enclosing.getRadius(), supportPointA.distance(enclosing.getCenter()), 1.0e-10);</span>
<span class="fc" id="L497">        Assert.assertEquals(enclosing.getRadius(), supportPointB.distance(enclosing.getCenter()), 1.0e-10);</span>
<span class="fc" id="L498">        Assert.assertEquals(0.5 * supportPointA.distance(supportPointB), enclosing.getRadius(), 1.0e-10);</span>
<span class="fc" id="L499">        Assert.assertEquals(2, enclosing.getSupportSize());</span>

<span class="fc" id="L501">        EnclosingBall&lt;Sphere2D, S2Point&gt; continentalInscribed =</span>
<span class="fc" id="L502">                ((SphericalPolygonsSet) factory.getComplement(continental)).getEnclosingCap();</span>
<span class="fc" id="L503">        Cartesian3D continentalCenter = ((S2Point) continentalInscribed.getCenter()).getVector();</span>
<span class="fc" id="L504">        Assert.assertEquals(2.2, FastMath.toDegrees(FastMath.PI - continentalInscribed.getRadius()), 0.1);</span>
<span class="fc bfc" id="L505" title="All 2 branches covered.">        for (Vertex loopStart : continental.getBoundaryLoops()) {</span>
<span class="fc" id="L506">            int count = 0;</span>
<span class="fc bfc" id="L507" title="All 4 branches covered.">            for (Vertex v = loopStart; count == 0 || v != loopStart; v = v.getOutgoing().getEnd()) {</span>
<span class="fc" id="L508">                ++count;</span>
<span class="fc bfc" id="L509" title="All 2 branches covered.">                for (int i = 0; i &lt; FastMath.ceil(v.getOutgoing().getLength() / step); ++i) {</span>
<span class="fc" id="L510">                    Cartesian3D p = v.getOutgoing().getPointAt(i * step);</span>
<span class="pc bpc" id="L511" title="1 of 2 branches missed.">                    Assert.assertTrue(Cartesian3D.angle(p, continentalCenter) &lt;= continentalInscribed.getRadius());</span>
                }
            }
<span class="fc" id="L514">        }</span>

<span class="fc" id="L516">        EnclosingBall&lt;Sphere2D, S2Point&gt; corsicaInscribed =</span>
<span class="fc" id="L517">                ((SphericalPolygonsSet) factory.getComplement(corsica)).getEnclosingCap();</span>
<span class="fc" id="L518">        Cartesian3D corsicaCenter = ((S2Point) corsicaInscribed.getCenter()).getVector();</span>
<span class="fc" id="L519">        Assert.assertEquals(0.34, FastMath.toDegrees(FastMath.PI - corsicaInscribed.getRadius()), 0.01);</span>
<span class="fc bfc" id="L520" title="All 2 branches covered.">        for (Vertex loopStart : corsica.getBoundaryLoops()) {</span>
<span class="fc" id="L521">            int count = 0;</span>
<span class="fc bfc" id="L522" title="All 4 branches covered.">            for (Vertex v = loopStart; count == 0 || v != loopStart; v = v.getOutgoing().getEnd()) {</span>
<span class="fc" id="L523">                ++count;</span>
<span class="fc bfc" id="L524" title="All 2 branches covered.">                for (int i = 0; i &lt; FastMath.ceil(v.getOutgoing().getLength() / step); ++i) {</span>
<span class="fc" id="L525">                    Cartesian3D p = v.getOutgoing().getPointAt(i * step);</span>
<span class="pc bpc" id="L526" title="1 of 2 branches missed.">                    Assert.assertTrue(Cartesian3D.angle(p, corsicaCenter) &lt;= corsicaInscribed.getRadius());</span>
                }
            }
<span class="fc" id="L529">        }</span>

<span class="fc" id="L531">    }</span>

    private SubCircle create(Cartesian3D pole, Cartesian3D x, Cartesian3D y,
                             double tolerance, double ... limits) {
<span class="fc" id="L535">        RegionFactory&lt;Sphere1D&gt; factory = new RegionFactory&lt;&gt;();</span>
<span class="fc" id="L536">        Circle circle = new Circle(pole, tolerance);</span>
<span class="fc" id="L537">        Circle phased =</span>
<span class="fc" id="L538">                (Circle) Circle.getTransform(new Rotation(circle.getXAxis(), circle.getYAxis(), x, y)).apply(circle);</span>
<span class="fc" id="L539">        ArcsSet set = (ArcsSet) factory.getComplement(new ArcsSet(tolerance));</span>
<span class="fc bfc" id="L540" title="All 2 branches covered.">        for (int i = 0; i &lt; limits.length; i += 2) {</span>
<span class="fc" id="L541">            set = (ArcsSet) factory.union(set, new ArcsSet(limits[i], limits[i + 1], tolerance));</span>
        }
<span class="fc" id="L543">        return new SubCircle(phased, set);</span>
    }

    private SphericalPolygonsSet buildSimpleZone(double[][] points) {
<span class="fc" id="L547">        final S2Point[] vertices = new S2Point[points.length];</span>
<span class="fc bfc" id="L548" title="All 2 branches covered.">        for (int i = 0; i &lt; points.length; ++i) {</span>
<span class="fc" id="L549">            vertices[i] = s2Point(points[i][0], points[i][1]);</span>
        }
<span class="fc" id="L551">        return new SphericalPolygonsSet(1.0e-10, vertices);</span>
    }

    private S2Point s2Point(double latitude, double longitude) {
<span class="fc" id="L555">        return new S2Point(FastMath.toRadians(longitude), FastMath.toRadians(90.0 - latitude));</span>
    }

}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.1.201803210924</span></div></body></html>