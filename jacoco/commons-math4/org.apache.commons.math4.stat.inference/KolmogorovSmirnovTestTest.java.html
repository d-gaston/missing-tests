<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>KolmogorovSmirnovTestTest.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">commons_math4$All_in_commons_math4.exec</a> &gt; <a href="index.source.html" class="el_package">org.apache.commons.math4.stat.inference</a> &gt; <span class="el_source">KolmogorovSmirnovTestTest.java</span></div><h1>KolmogorovSmirnovTestTest.java</h1><pre class="source lang-java linenums">/*
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the &quot;License&quot;); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package org.apache.commons.math4.stat.inference;

import java.lang.reflect.Method;
import java.util.Arrays;

import org.apache.commons.math4.TestUtils;
import org.apache.commons.statistics.distribution.NormalDistribution;
import org.apache.commons.statistics.distribution.UniformContinuousDistribution;
import org.apache.commons.rng.simple.RandomSource;
import org.apache.commons.rng.UniformRandomProvider;
import org.apache.commons.numbers.combinatorics.BinomialCoefficient;
import org.apache.commons.math4.util.FastMath;
import org.apache.commons.math4.util.MathArrays;
import org.apache.commons.math4.exception.NotANumberException;
import org.junit.Assert;
import org.junit.Test;

/**
 * Test cases for {@link KolmogorovSmirnovTest}.
 *
 * @since 3.3
 */
<span class="fc" id="L40">public class KolmogorovSmirnovTestTest {</span>
    private static final double TOLERANCE = 1e-10;
    private static final int MONTE_CARLO_ITERATIONS = 1000000;
    private static final int LARGE_SAMPLE_PRODUCT = 10000;

    // Random N(0,1) values generated using R rnorm
<span class="fc" id="L46">    protected static final double[] gaussian = {</span>
        0.26055895, -0.63665233, 1.51221323, 0.61246988, -0.03013003, -1.73025682, -0.51435805, 0.70494168, 0.18242945,
        0.94734336, -0.04286604, -0.37931719, -1.07026403, -2.05861425, 0.11201862, 0.71400136, -0.52122185,
        -0.02478725, -1.86811649, -1.79907688, 0.15046279, 1.32390193, 1.55889719, 1.83149171, -0.03948003,
        -0.98579207, -0.76790540, 0.89080682, 0.19532153, 0.40692841, 0.15047336, -0.58546562, -0.39865469, 0.77604271,
        -0.65188221, -1.80368554, 0.65273365, -0.75283102, -1.91022150, -0.07640869, -1.08681188, -0.89270600,
        2.09017508, 0.43907981, 0.10744033, -0.70961218, 1.15707300, 0.44560525, -2.04593349, 0.53816843, -0.08366640,
        0.24652218, 1.80549401, -0.99220707, -1.14589408, -0.27170290, -0.49696855, 0.00968353, -1.87113545,
        -1.91116529, 0.97151891, -0.73576115, -0.59437029, 0.72148436, 0.01747695, -0.62601157, -1.00971538,
        -1.42691397, 1.03250131, -0.30672627, -0.15353992, -1.19976069, -0.68364218, 0.37525652, -0.46592881,
        -0.52116168, -0.17162202, 1.04679215, 0.25165971, -0.04125231, -0.23756244, -0.93389975, 0.75551407,
        0.08347445, -0.27482228, -0.4717632, -0.1867746, -0.1166976, 0.5763333, 0.1307952, 0.7630584, -0.3616248,
        2.1383790, -0.7946630, 0.0231885, 0.7919195, 1.6057144, -0.3802508, 0.1229078, 1.5252901, -0.8543149, 0.3025040
    };

    // Random N(0, 1.6) values generated using R rnorm
<span class="fc" id="L62">    protected static final double[] gaussian2 = {</span>
        2.88041498038308, -0.632349445671017, 0.402121295225571, 0.692626364613243, 1.30693446815426,
        -0.714176317131286, -0.233169206599583, 1.09113298322107, -1.53149079994305, 1.23259966205809,
        1.01389927412503, 0.0143898711497477, -0.512813545447559, 2.79364360835469, 0.662008875538092,
        1.04861546834788, -0.321280099931466, 0.250296656278743, 1.75820367603736, -2.31433523590905,
        -0.462694696086403, 0.187725700950191, -2.24410950019152, 2.83473751105445, 0.252460174391016,
        1.39051945380281, -1.56270144203134, 0.998522814471644, -1.50147469080896, 0.145307533554146,
        0.469089457043406, -0.0914780723809334, -0.123446939266548, -0.610513388160565, -3.71548343891957,
        -0.329577317349478, -0.312973794075871, 2.02051909758923, 2.85214308266271, 0.0193222002327237,
        -0.0322422268266562, 0.514736012106768, 0.231484953375887, -2.22468798953629, 1.42197716075595,
        2.69988043856357, 0.0443757119128293, 0.721536984407798, -0.0445688839903234, -0.294372724550705,
        0.234041580912698, -0.868973119365727, 1.3524893453845, -0.931054600134503, -0.263514296006792,
        0.540949457402918, -0.882544288773685, -0.34148675747989, 1.56664494810034, 2.19850536566584,
        -0.667972122928022, -0.70889669526203, -0.00251758193079668, 2.39527162977682, -2.7559594317269,
        -0.547393502656671, -2.62144031572617, 2.81504147017922, -1.02036850201042, -1.00713927602786,
        -0.520197775122254, 1.00625480138649, 2.46756916531313, 1.64364743727799, 0.704545210648595,
        -0.425885789416992, -1.78387854908546, -0.286783886710481, 0.404183648369076, -0.369324280845769,
        -0.0391185138840443, 2.41257787857293, 2.49744281317859, -0.826964496939021, -0.792555379958975,
        1.81097685787403, -0.475014580016638, 1.23387615291805, 0.646615294802053, 1.88496377454523, 1.20390698380814,
        -0.27812153371728, 2.50149494533101, 0.406964323253817, -1.72253451309982, 1.98432494184332, 2.2223658560333,
        0.393086362404685, -0.504073151377089, -0.0484610869883821
    };

    // Random uniform (0, 1) generated using R runif
<span class="fc" id="L86">    protected static final double[] uniform = {</span>
        0.7930305, 0.6424382, 0.8747699, 0.7156518, 0.1845909, 0.2022326, 0.4877206, 0.8928752, 0.2293062, 0.4222006,
        0.1610459, 0.2830535, 0.9946345, 0.7329499, 0.26411126, 0.87958133, 0.29827437, 0.39185988, 0.38351185,
        0.36359611, 0.48646472, 0.05577866, 0.56152250, 0.52672013, 0.13171783, 0.95864085, 0.03060207, 0.33514887,
        0.72508148, 0.38901437, 0.9978665, 0.5981300, 0.1065388, 0.7036991, 0.1071584, 0.4423963, 0.1107071, 0.6437221,
        0.58523872, 0.05044634, 0.65999539, 0.37367260, 0.73270024, 0.47473755, 0.74661163, 0.50765549, 0.05377347,
        0.40998009, 0.55235182, 0.21361998, 0.63117971, 0.18109222, 0.89153510, 0.23203248, 0.6177106, 0.6856418,
        0.2158557, 0.9870501, 0.2036914, 0.2100311, 0.9065020, 0.7459159, 0.56631790, 0.06753629, 0.39684629,
        0.52504615, 0.14199103, 0.78551120, 0.90503321, 0.80452362, 0.9960115, 0.8172592, 0.5831134, 0.8794187,
        0.2021501, 0.2923505, 0.9561824, 0.8792248, 0.85201008, 0.02945562, 0.26200374, 0.11382818, 0.17238856,
        0.36449473, 0.69688273, 0.96216330, 0.4859432, 0.4503438, 0.1917656, 0.8357845, 0.9957812, 0.4633570,
        0.8654599, 0.4597996, 0.68190289, 0.58887855, 0.09359396, 0.98081979, 0.73659533, 0.89344777, 0.18903099,
        0.97660425
    };

    /** Unit normal distribution, unit normal data */
    @Test
    public void testOneSampleGaussianGaussian() {
<span class="fc" id="L104">        final KolmogorovSmirnovTest test = new KolmogorovSmirnovTest();</span>
<span class="fc" id="L105">        final NormalDistribution unitNormal = new NormalDistribution(0d, 1d);</span>
        // Uncomment to run exact test - takes about a minute. Same value is used in R tests and for
        // approx.
        // Assert.assertEquals(0.3172069207622391, test.kolmogorovSmirnovTest(unitNormal, gaussian,
        // true), TOLERANCE);
<span class="fc" id="L110">        Assert.assertEquals(0.3172069207622391, test.kolmogorovSmirnovTest(unitNormal, gaussian, false), TOLERANCE);</span>
<span class="fc" id="L111">        Assert.assertFalse(test.kolmogorovSmirnovTest(unitNormal, gaussian, 0.05));</span>
<span class="fc" id="L112">        Assert.assertEquals(0.0932947561266756, test.kolmogorovSmirnovStatistic(unitNormal, gaussian), TOLERANCE);</span>
<span class="fc" id="L113">    }</span>

    /** Unit normal distribution, unit normal data, small dataset */
    @Test
    public void testOneSampleGaussianGaussianSmallSample() {
<span class="fc" id="L118">        final KolmogorovSmirnovTest test = new KolmogorovSmirnovTest();</span>
<span class="fc" id="L119">        final NormalDistribution unitNormal = new NormalDistribution(0d, 1d);</span>
<span class="fc" id="L120">        final double[] shortGaussian = new double[50];</span>
<span class="fc" id="L121">        System.arraycopy(gaussian, 0, shortGaussian, 0, 50);</span>
<span class="fc" id="L122">        Assert.assertEquals(0.683736463728347, test.kolmogorovSmirnovTest(unitNormal, shortGaussian, false), TOLERANCE);</span>
<span class="fc" id="L123">        Assert.assertFalse(test.kolmogorovSmirnovTest(unitNormal, gaussian, 0.05));</span>
<span class="fc" id="L124">        Assert.assertEquals(0.09820779969463278, test.kolmogorovSmirnovStatistic(unitNormal, shortGaussian), TOLERANCE);</span>
<span class="fc" id="L125">    }</span>

    /** Unit normal distribution, uniform data */
    @Test
    public void testOneSampleGaussianUniform() {
<span class="fc" id="L130">        final KolmogorovSmirnovTest test = new KolmogorovSmirnovTest();</span>
<span class="fc" id="L131">        final NormalDistribution unitNormal = new NormalDistribution(0d, 1d);</span>
        // Uncomment to run exact test - takes a long time. Same value is used in R tests and for
        // approx.
        // Assert.assertEquals(0.3172069207622391, test.kolmogorovSmirnovTest(unitNormal, uniform,
        // true), TOLERANCE);
<span class="fc" id="L136">        Assert.assertEquals(8.881784197001252E-16, test.kolmogorovSmirnovTest(unitNormal, uniform, false), TOLERANCE);</span>
<span class="fc" id="L137">        Assert.assertFalse(test.kolmogorovSmirnovTest(unitNormal, gaussian, 0.05));</span>
<span class="fc" id="L138">        Assert.assertEquals(0.5117493931609258, test.kolmogorovSmirnovStatistic(unitNormal, uniform), TOLERANCE);</span>
<span class="fc" id="L139">    }</span>

    /** Uniform distribution, uniform data */
    // @Test - takes about 6 seconds, uncomment for
    public void testOneSampleUniformUniform() {
<span class="nc" id="L144">        final KolmogorovSmirnovTest test = new KolmogorovSmirnovTest();</span>
<span class="nc" id="L145">        final UniformContinuousDistribution unif = new UniformContinuousDistribution(-0.5, 0.5);</span>
<span class="nc" id="L146">        Assert.assertEquals(8.881784197001252E-16, test.kolmogorovSmirnovTest(unif, uniform, false), TOLERANCE);</span>
<span class="nc" id="L147">        Assert.assertTrue(test.kolmogorovSmirnovTest(unif, uniform, 0.05));</span>
<span class="nc" id="L148">        Assert.assertEquals(0.5400666982352942, test.kolmogorovSmirnovStatistic(unif, uniform), TOLERANCE);</span>
<span class="nc" id="L149">    }</span>

    /** Uniform distribution, uniform data, small dataset */
    @Test
    public void testOneSampleUniformUniformSmallSample() {
<span class="fc" id="L154">        final KolmogorovSmirnovTest test = new KolmogorovSmirnovTest();</span>
<span class="fc" id="L155">        final UniformContinuousDistribution unif = new UniformContinuousDistribution(-0.5, 0.5);</span>
<span class="fc" id="L156">        final double[] shortUniform = new double[20];</span>
<span class="fc" id="L157">        System.arraycopy(uniform, 0, shortUniform, 0, 20);</span>
<span class="fc" id="L158">        Assert.assertEquals(4.117594598618268E-9, test.kolmogorovSmirnovTest(unif, shortUniform, false), TOLERANCE);</span>
<span class="fc" id="L159">        Assert.assertTrue(test.kolmogorovSmirnovTest(unif, shortUniform, 0.05));</span>
<span class="fc" id="L160">        Assert.assertEquals(0.6610459, test.kolmogorovSmirnovStatistic(unif, shortUniform), TOLERANCE);</span>
<span class="fc" id="L161">    }</span>

    /** Uniform distribution, unit normal dataset */
    @Test
    public void testOneSampleUniformGaussian() {
<span class="fc" id="L166">        final KolmogorovSmirnovTest test = new KolmogorovSmirnovTest();</span>
<span class="fc" id="L167">        final UniformContinuousDistribution unif = new UniformContinuousDistribution(-0.5, 0.5);</span>
        // Value was obtained via exact test, validated against R. Running exact test takes a long
        // time.
<span class="fc" id="L170">        Assert.assertEquals(4.9405812774239166E-11, test.kolmogorovSmirnovTest(unif, gaussian, false), TOLERANCE);</span>
<span class="fc" id="L171">        Assert.assertTrue(test.kolmogorovSmirnovTest(unif, gaussian, 0.05));</span>
<span class="fc" id="L172">        Assert.assertEquals(0.3401058049019608, test.kolmogorovSmirnovStatistic(unif, gaussian), TOLERANCE);</span>
<span class="fc" id="L173">    }</span>

    /** Small samples - exact p-value, checked against R */
    @Test
    public void testTwoSampleSmallSampleExact() {
<span class="fc" id="L178">        final KolmogorovSmirnovTest test = new KolmogorovSmirnovTest();</span>
<span class="fc" id="L179">        final double[] smallSample1 = {</span>
            6, 7, 9, 13, 19, 21, 22, 23, 24
        };
<span class="fc" id="L182">        final double[] smallSample2 = {</span>
            10, 11, 12, 16, 20, 27, 28, 32, 44, 54
        };
        // Reference values from R, version 3.2.0 - R uses non-strict inequality in null hypothesis
<span class="fc" id="L186">        Assert</span>
<span class="fc" id="L187">            .assertEquals(0.105577085453247, test.kolmogorovSmirnovTest(smallSample1, smallSample2, false), TOLERANCE);</span>
<span class="fc" id="L188">        Assert.assertEquals(0.5, test.kolmogorovSmirnovStatistic(smallSample1, smallSample2), TOLERANCE);</span>
<span class="fc" id="L189">    }</span>

    /** Small samples - exact p-value, checked against R */
    @Test
    public void testTwoSampleSmallSampleExact2() {
<span class="fc" id="L194">        final KolmogorovSmirnovTest test = new KolmogorovSmirnovTest();</span>
<span class="fc" id="L195">        final double[] smallSample1 = {</span>
            6, 7, 9, 13, 19, 21, 22, 23, 24, 29, 30, 34, 36, 41, 45, 47, 51, 63, 33, 91
        };
<span class="fc" id="L198">        final double[] smallSample2 = {</span>
            10, 11, 12, 16, 20, 27, 28, 32, 44, 54, 56, 57, 64, 69, 71, 80, 81, 88, 90
        };
        // Reference values from R, version 3.2.0 - R uses non-strict inequality in null hypothesis
<span class="fc" id="L202">        Assert</span>
<span class="fc" id="L203">            .assertEquals(0.0462986609, test.kolmogorovSmirnovTest(smallSample1, smallSample2, false), TOLERANCE);</span>
<span class="fc" id="L204">        Assert.assertEquals(0.4263157895, test.kolmogorovSmirnovStatistic(smallSample1, smallSample2), TOLERANCE);</span>
<span class="fc" id="L205">    }</span>

    /** Small samples - exact p-value, checked against R */
    @Test
    public void testTwoSampleSmallSampleExact3() {
<span class="fc" id="L210">        final KolmogorovSmirnovTest test = new KolmogorovSmirnovTest();</span>
<span class="fc" id="L211">        final double[] smallSample1 = {</span>
            -10, -5, 17, 21, 22, 23, 24, 30, 44, 50, 56, 57, 59, 67, 73, 75, 77, 78, 79, 80, 81, 83, 84, 85, 88, 90,
            92, 93, 94, 95, 98, 100, 101, 103, 105, 110
        };
<span class="fc" id="L215">        final double[] smallSample2 = {</span>
            -2, -1, 0, 10, 14, 15, 16, 20, 25, 26, 27, 31, 32, 33, 34, 45, 47, 48, 51, 52, 53, 54, 60, 61, 62, 63,
            74, 82, 106, 107, 109, 11, 112, 113, 114
        };
        // Reference values from R, version 3.2.0 - R uses non-strict inequality in null hypothesis
<span class="fc" id="L220">        Assert</span>
<span class="fc" id="L221">            .assertEquals(0.00300743602, test.kolmogorovSmirnovTest(smallSample1, smallSample2, false), TOLERANCE);</span>
<span class="fc" id="L222">        Assert.assertEquals(0.4103174603, test.kolmogorovSmirnovStatistic(smallSample1, smallSample2), TOLERANCE);</span>
<span class="fc" id="L223">        Assert</span>
<span class="fc" id="L224">        .assertEquals(0.00300743602, test.kolmogorovSmirnovTest(smallSample2, smallSample1, false), TOLERANCE);</span>
<span class="fc" id="L225">    }</span>

    /**
     * Checks exact p-value computations using critical values from Table 9 in V.K Rohatgi, An
     * Introduction to Probability and Mathematical Statistics, Wiley, 1976, ISBN 0-471-73135-8.
     */
    @Test
    public void testTwoSampleExactP() {
<span class="fc" id="L233">        checkExactTable(4, 6, 5d / 6d, 0.01d);</span>
<span class="fc" id="L234">        checkExactTable(4, 7, 17d / 28d, 0.2d);</span>
<span class="fc" id="L235">        checkExactTable(6, 7, 29d / 42d, 0.05d);</span>
<span class="fc" id="L236">        checkExactTable(4, 10, 7d / 10d, 0.05d);</span>
<span class="fc" id="L237">        checkExactTable(5, 15, 11d / 15d, 0.02d);</span>
<span class="fc" id="L238">        checkExactTable(9, 10, 31d / 45d, 0.01d);</span>
<span class="fc" id="L239">        checkExactTable(7, 10, 43d / 70d, 0.05d);</span>
<span class="fc" id="L240">    }</span>

    @Test
    public void testTwoSampleApproximateCritialValues() {
<span class="fc" id="L244">        final double tol = .01;</span>
<span class="fc" id="L245">        final double[] alpha = {</span>
            0.10, 0.05, 0.025, 0.01, 0.005, 0.001
        };
        // From Wikipedia KS article - TODO: get (and test) more precise values
<span class="fc" id="L249">        final double[] c = {</span>
            1.22, 1.36, 1.48, 1.63, 1.73, 1.95
        };
<span class="fc" id="L252">        final int k[] = {</span>
            60, 100, 500
        };
        double n;
        double m;
<span class="fc bfc" id="L257" title="All 2 branches covered.">        for (int i = 0; i &lt; k.length; i++) {</span>
<span class="fc bfc" id="L258" title="All 2 branches covered.">            for (int j = 0; j &lt; i; j++) {</span>
<span class="fc" id="L259">                n = k[i];</span>
<span class="fc" id="L260">                m = k[j];</span>
<span class="fc bfc" id="L261" title="All 2 branches covered.">                for (int l = 0; l &lt; alpha.length; l++) {</span>
<span class="fc" id="L262">                    final double dCrit = c[l] * FastMath.sqrt((n + m) / (n * m));</span>
<span class="fc" id="L263">                    checkApproximateTable(k[i], k[j], dCrit, alpha[l], tol);</span>
                }
            }
        }
<span class="fc" id="L267">    }</span>

    @Test
    public void testPelzGoodApproximation() {
<span class="fc" id="L271">        KolmogorovSmirnovTest ksTest = new KolmogorovSmirnovTest();</span>
<span class="fc" id="L272">        final double d[] = {0.15, 0.20, 0.25, 0.3, 0.35, 0.4};</span>
<span class="fc" id="L273">        final int n[] = {141, 150, 180, 220, 1000};</span>
        // Reference values computed using the Pelz method from
        // http://simul.iro.umontreal.ca/ksdir/KolmogorovSmirnovDist.java
<span class="fc" id="L276">        final double ref[] = {</span>
            0.9968940168727819, 0.9979326624184857, 0.9994677598604506, 0.9999128354780209, 0.9999999999998661,
            0.9999797514476236, 0.9999902122242081, 0.9999991327060908, 0.9999999657681911, 0.9999999999977929,
            0.9999999706444976, 0.9999999906571532, 0.9999999997949596, 0.999999999998745, 0.9999999999993876,
            0.9999999999916627, 0.9999999999984447, 0.9999999999999936, 0.999999999999341, 0.9999999999971508,
            0.9999999999999877, 0.9999999999999191, 0.9999999999999254, 0.9999999999998178, 0.9999999999917788,
            0.9999999999998556, 0.9999999999992014, 0.9999999999988859, 0.9999999999999325, 0.9999999999821726
        };

<span class="fc" id="L285">        final double tol = 10e-15;</span>
<span class="fc" id="L286">        int k = 0;</span>
<span class="fc bfc" id="L287" title="All 2 branches covered.">        for (int i = 0; i &lt; 6; i++) {</span>
<span class="fc bfc" id="L288" title="All 2 branches covered.">            for (int j = 0; j &lt; 5; j++, k++) {</span>
<span class="fc" id="L289">                Assert.assertEquals(ref[k], ksTest.pelzGood(d[i], n[j]), tol);</span>
            }
        }
<span class="fc" id="L292">    }</span>

    /** Verifies large sample approximate p values against R */
    @Test
    public void testTwoSampleApproximateP() {
<span class="fc" id="L297">        final KolmogorovSmirnovTest test = new KolmogorovSmirnovTest();</span>
        // Reference values from R, version 2.15.3
<span class="fc" id="L299">        Assert.assertEquals(0.0319983962391632, test.kolmogorovSmirnovTest(gaussian, gaussian2), TOLERANCE);</span>
<span class="fc" id="L300">        Assert.assertEquals(0.202352941176471, test.kolmogorovSmirnovStatistic(gaussian, gaussian2), TOLERANCE);</span>
<span class="fc" id="L301">    }</span>

    /**
     * MATH-1181
     * Verify that large sample method is selected for sample product &gt; Integer.MAX_VALUE
     * (integer overflow in sample product)
     */
    @Test(timeout=5000)
    public void testTwoSampleProductSizeOverflow() {
<span class="fc" id="L310">        final int n = 50000;</span>
<span class="fc" id="L311">        Assert.assertTrue(n * n &lt; 0);</span>
<span class="fc" id="L312">        double[] x = new double[n];</span>
<span class="fc" id="L313">        double[] y = new double[n];</span>
<span class="fc" id="L314">        final KolmogorovSmirnovTest test = new KolmogorovSmirnovTest();</span>
<span class="fc" id="L315">        Assert.assertFalse(Double.isNaN(test.kolmogorovSmirnovTest(x, y)));</span>
<span class="fc" id="L316">    }</span>

    /**
     * Verifies that Monte Carlo simulation gives results close to exact p values.
     */
    @Test
    public void testTwoSampleMonteCarlo() {
<span class="fc" id="L323">        final KolmogorovSmirnovTest test = new KolmogorovSmirnovTest();</span>
<span class="fc" id="L324">        final UniformRandomProvider rng = RandomSource.create(RandomSource.WELL_19937_C, 1000);</span>
<span class="fc" id="L325">        final int sampleSize = 14;</span>
<span class="fc" id="L326">        final double tol = .001;</span>
<span class="fc" id="L327">        final double[] shortUniform = new double[sampleSize];</span>
<span class="fc" id="L328">        System.arraycopy(uniform, 0, shortUniform, 0, sampleSize);</span>
<span class="fc" id="L329">        final double[] shortGaussian = new double[sampleSize];</span>
<span class="fc" id="L330">        final double[] shortGaussian2 = new double[sampleSize];</span>
<span class="fc" id="L331">        System.arraycopy(gaussian, 0, shortGaussian, 0, sampleSize);</span>
<span class="fc" id="L332">        System.arraycopy(gaussian, 10, shortGaussian2, 0, sampleSize);</span>
<span class="fc" id="L333">        final double[] d = {</span>
<span class="fc" id="L334">            test.kolmogorovSmirnovStatistic(shortGaussian, shortUniform),</span>
<span class="fc" id="L335">            test.kolmogorovSmirnovStatistic(shortGaussian2, shortGaussian)</span>
        };
<span class="fc bfc" id="L337" title="All 2 branches covered.">        for (double dv : d) {</span>
<span class="fc" id="L338">            double exactPStrict = test.exactP(dv, sampleSize, sampleSize, true);</span>
<span class="fc" id="L339">            double exactPNonStrict = test.exactP(dv, sampleSize, sampleSize, false);</span>
<span class="fc" id="L340">            double montePStrict = test.monteCarloP(dv, sampleSize, sampleSize, true,</span>
                                                   MONTE_CARLO_ITERATIONS, rng);
<span class="fc" id="L342">            double montePNonStrict = test.monteCarloP(dv, sampleSize, sampleSize, false,</span>
                                                      MONTE_CARLO_ITERATIONS, rng);
<span class="fc" id="L344">            Assert.assertEquals(exactPStrict, montePStrict, tol);</span>
<span class="fc" id="L345">            Assert.assertEquals(exactPNonStrict, montePNonStrict, tol);</span>
        }
<span class="fc" id="L347">    }</span>

    @Test
    public void testTwoSampleMonteCarloDifferentSampleSizes() {
<span class="fc" id="L351">        final KolmogorovSmirnovTest test = new KolmogorovSmirnovTest();</span>
<span class="fc" id="L352">        final UniformRandomProvider rng = RandomSource.create(RandomSource.WELL_19937_C, 1000);</span>
<span class="fc" id="L353">        final int sampleSize1 = 14;</span>
<span class="fc" id="L354">        final int sampleSize2 = 7;</span>
<span class="fc" id="L355">        final double d = 0.3;</span>
<span class="fc" id="L356">        final boolean strict = false;</span>
<span class="fc" id="L357">        final double tol = 1e-2;</span>
<span class="fc" id="L358">        Assert.assertEquals(test.exactP(d, sampleSize1, sampleSize2, strict),</span>
<span class="fc" id="L359">                            test.monteCarloP(d, sampleSize1, sampleSize2, strict,</span>
                                             MONTE_CARLO_ITERATIONS, rng),
                            tol);
<span class="fc" id="L362">    }</span>

    /**
     * Performance test for monteCarlo method. Disabled by default.
     */
    // @Test
    public void testTwoSampleMonteCarloPerformance() {
<span class="nc" id="L369">        int numIterations = 100_000;</span>
<span class="nc" id="L370">        int N = (int)Math.sqrt(LARGE_SAMPLE_PRODUCT);</span>
<span class="nc" id="L371">        final KolmogorovSmirnovTest test = new KolmogorovSmirnovTest();</span>
<span class="nc" id="L372">        final UniformRandomProvider rng = RandomSource.create(RandomSource.WELL_19937_C, 1000);</span>
<span class="nc bnc" id="L373" title="All 2 branches missed.">        for (int n = 2; n &lt;= N; ++n) {</span>
<span class="nc" id="L374">            long startMillis = System.currentTimeMillis();</span>
<span class="nc" id="L375">            int m = LARGE_SAMPLE_PRODUCT/n;</span>
<span class="nc" id="L376">            Assert.assertEquals(0d, test.monteCarloP(Double.POSITIVE_INFINITY, n, m, true, numIterations, rng), 0d);</span>
<span class="nc" id="L377">            long endMillis = System.currentTimeMillis();</span>
<span class="nc" id="L378">            System.out.println(&quot;n=&quot; + n + &quot;, m=&quot; + m + &quot;, time=&quot; + (endMillis-startMillis)/1000d + &quot;s&quot;);</span>
        }
<span class="nc" id="L380">    }</span>

    @Test
    public void testTwoSampleWithManyTies() {
        // MATH-1197
<span class="fc" id="L385">        final double[] x = {</span>
            0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000,
            0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000,
            0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000,
            0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000,
            0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000,
            0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000,
            0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000,
            0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000,
            0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000,
            0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000,
            0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000,
            0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000,
            0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000,
            0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000,
            0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000,
            0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000,
            0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000,
            0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000,
            0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000,
            0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000,
            0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000,
            0.000000, 2.202653, 2.202653, 2.202653, 2.202653, 2.202653,
            2.202653, 2.202653, 2.202653, 2.202653, 2.202653, 2.202653,
            2.202653, 2.202653, 2.202653, 2.202653, 2.202653, 2.202653,
            2.202653, 2.202653, 2.202653, 2.202653, 2.202653, 2.202653,
            2.202653, 2.202653, 2.202653, 2.202653, 2.202653, 2.202653,
            2.202653, 2.202653, 2.202653, 2.202653, 2.202653, 2.202653,
            3.181199, 3.181199, 3.181199, 3.181199, 3.181199, 3.181199,
            3.723539, 3.723539, 3.723539, 3.723539, 4.383482, 4.383482,
            4.383482, 4.383482, 5.320671, 5.320671, 5.320671, 5.717284,
            6.964001, 7.352165, 8.710510, 8.710510, 8.710510, 8.710510,
            8.710510, 8.710510, 9.539004, 9.539004, 10.720619, 17.726077,
            17.726077, 17.726077, 17.726077, 22.053875, 23.799144, 27.355308,
            30.584960, 30.584960, 30.584960, 30.584960, 30.751808
        };

<span class="fc" id="L422">        final double[] y = {</span>
            0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000,
            0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000,
            0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000,
            0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000,
            0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000,
            0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000,
            0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000,
            0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000,
            0.000000, 0.000000, 0.000000, 2.202653, 2.202653, 2.202653,
            2.202653, 2.202653, 2.202653, 2.202653, 2.202653, 3.061758,
            3.723539, 5.628420, 5.628420, 5.628420, 5.628420, 5.628420,
            6.916982, 6.916982, 6.916982, 10.178538, 10.178538, 10.178538,
            10.178538, 10.178538
        };

<span class="fc" id="L438">        final KolmogorovSmirnovTest test = new KolmogorovSmirnovTest();</span>

<span class="fc" id="L440">        Assert.assertEquals(0.0640394088, test.kolmogorovSmirnovStatistic(x, y), 1e-6);</span>
<span class="fc" id="L441">        Assert.assertEquals(0.9792777290, test.kolmogorovSmirnovTest(x, y), 1e-6);</span>

<span class="fc" id="L443">    }</span>

    @Test
    public void testTwoSampleWithManyTiesAndVerySmallDelta() {
        // Cf. MATH-1405

<span class="fc" id="L449">        final double[] x = {</span>
            0.0, 0.0,
            1.0, 1.0,
            1.5,
            1.6,
            1.7,
            1.8,
            1.9,
            2.0,
            2.000000000000001
        };

<span class="fc" id="L461">        final double[] y = {</span>
            0.0, 0.0,
            10.0, 10.0,
            11.0, 11.0, 11.0,
            15.0,
            16.0,
            17.0,
            18.0,
            19.0,
            20.0,
            20.000000000000001
        };

<span class="fc" id="L474">        final KolmogorovSmirnovTest test = new KolmogorovSmirnovTest();</span>
<span class="fc" id="L475">        Assert.assertEquals(1.12173015e-5, test.kolmogorovSmirnovTest(x, y), 1e-6);</span>
<span class="fc" id="L476">    }</span>

    @Test
    public void testTwoSampleWithManyTiesAndExtremeValues() {
        // Cf. MATH-1405

<span class="fc" id="L482">        final double[] largeX = {</span>
            Double.MAX_VALUE, Double.MAX_VALUE,
            1e40, 1e40,
            2e40, 2e40,
            1e30,
            2e30,
            3e30,
            4e30,
            5e10,
            6e10,
            7e10,
            8e10
        };

<span class="fc" id="L496">        final double[] smallY = {</span>
            Double.MIN_VALUE,
            2 * Double.MIN_VALUE,
            1e-40, 1e-40,
            2e-40, 2e-40,
            1e-30,
            2e-30,
            3e-30,
            4e-30,
            5e-10,
            6e-10,
            7e-10,
            8e-10
        };

<span class="fc" id="L511">        final KolmogorovSmirnovTest test = new KolmogorovSmirnovTest();</span>
<span class="fc" id="L512">        Assert.assertEquals(0, test.kolmogorovSmirnovTest(largeX, smallY), 1e-10);</span>
<span class="fc" id="L513">    }</span>

    @Test(expected=NotANumberException.class)
    public void testTwoSampleWithTiesAndNaN1() {
        // Cf. MATH-1405

<span class="fc" id="L519">        final double[] x = { 1, Double.NaN, 3, 4 };</span>
<span class="fc" id="L520">        final double[] y = { 1, 2, 3, 4 };</span>
<span class="nc" id="L521">        new KolmogorovSmirnovTest().kolmogorovSmirnovTest(x, y);</span>
<span class="nc" id="L522">    }</span>

    @Test(expected=NotANumberException.class)
    public void testTwoSampleWithTiesAndNaN2() {
        // Cf. MATH-1405

<span class="fc" id="L528">        final double[] x = { 1, 2, 3, 4 };</span>
<span class="fc" id="L529">        final double[] y = { 1, 2, Double.NaN, 4 };</span>

<span class="nc" id="L531">        new KolmogorovSmirnovTest().kolmogorovSmirnovTest(x, y);</span>
<span class="nc" id="L532">    }</span>

    @Test
    public void testTwoSamplesAllEqual() {
<span class="fc" id="L536">        int iterations = 10_000;</span>
<span class="fc" id="L537">        final KolmogorovSmirnovTest test = new KolmogorovSmirnovTest();</span>
<span class="fc" id="L538">        final UniformRandomProvider rng = RandomSource.create(RandomSource.WELL_19937_C, 1000);</span>
<span class="fc bfc" id="L539" title="All 2 branches covered.">        for (int i = 2; i &lt; 30; ++i) {</span>
            // testing values with ties
<span class="fc" id="L541">            double[] values = new double[i];</span>
<span class="fc" id="L542">            Arrays.fill(values, i);</span>
            // testing values without ties
<span class="fc" id="L544">            double[] ascendingValues = new double[i];</span>
<span class="fc bfc" id="L545" title="All 2 branches covered.">            for (int j = 0; j &lt; ascendingValues.length; j++) {</span>
<span class="fc" id="L546">                ascendingValues[j] = j;</span>
            }

<span class="fc" id="L549">            Assert.assertEquals(0., test.kolmogorovSmirnovStatistic(values, values), 0.);</span>
<span class="fc" id="L550">            Assert.assertEquals(0., test.kolmogorovSmirnovStatistic(ascendingValues, ascendingValues), 0.);</span>

<span class="fc bfc" id="L552" title="All 2 branches covered.">            if (i &lt; 10) {</span>
<span class="fc" id="L553">                Assert.assertEquals(1.0, test.exactP(0, values.length, values.length, true), 0.);</span>
<span class="fc" id="L554">                Assert.assertEquals(1.0, test.exactP(0, values.length, values.length, false), 0.);</span>
            }

<span class="fc" id="L557">            Assert.assertEquals(1.0, test.monteCarloP(0, values.length, values.length, true, iterations, rng), 0.);</span>
<span class="fc" id="L558">            Assert.assertEquals(1.0, test.monteCarloP(0, values.length, values.length, false, iterations, rng), 0.);</span>

<span class="fc" id="L560">            Assert.assertEquals(1.0, test.approximateP(0, values.length, values.length), 0.);</span>
<span class="fc" id="L561">            Assert.assertEquals(1.0, test.approximateP(0, values.length, values.length), 0.);</span>
        }
<span class="fc" id="L563">    }</span>

    /**
     * JIRA: MATH-1245
     *
     * Verify that D-values are not viewed as distinct when they are mathematically equal
     * when computing p-statistics for small sample tests. Reference values are from R 3.2.0.
     */
    @Test
    public void testDRounding() {
<span class="fc" id="L573">        final double tol = 1e-12;</span>
<span class="fc" id="L574">        final double[] x = {0, 2, 3, 4, 5, 6, 7, 8, 9, 12};</span>
<span class="fc" id="L575">        final double[] y = {1, 10, 11, 13, 14, 15, 16, 17, 18};</span>
<span class="fc" id="L576">        final KolmogorovSmirnovTest test = new KolmogorovSmirnovTest();</span>
<span class="fc" id="L577">        Assert.assertEquals(0.0027495724090154106, test.kolmogorovSmirnovTest(x, y,false), tol);</span>

<span class="fc" id="L579">        final double[] x1 = {2, 4, 6, 8, 9, 10, 11, 12, 13};</span>
<span class="fc" id="L580">        final double[] y1 = {0, 1, 3, 5, 7};</span>
<span class="fc" id="L581">        Assert.assertEquals(0.085914085914085896, test.kolmogorovSmirnovTest(x1, y1, false), tol);</span>

<span class="fc" id="L583">        final double[] x2 = {4, 6, 7, 8, 9, 10, 11};</span>
<span class="fc" id="L584">        final double[] y2 = {0, 1, 2, 3, 5};</span>
<span class="fc" id="L585">        Assert.assertEquals(0.015151515151515027, test.kolmogorovSmirnovTest(x2, y2, false), tol);</span>
<span class="fc" id="L586">    }</span>

    /**
     * JIRA: MATH-1245
     *
     * Verify that D-values are not viewed as distinct when they are mathematically equal
     * when computing p-statistics for small sample tests. Reference values are from R 3.2.0.
     */
    @Test
    public void testDRoundingMonteCarlo() {
<span class="fc" id="L596">        final double tol = 1e-2;</span>
<span class="fc" id="L597">        final int iterations = 1000000;</span>
<span class="fc" id="L598">        final KolmogorovSmirnovTest test = new KolmogorovSmirnovTest();</span>
<span class="fc" id="L599">        final UniformRandomProvider rng = RandomSource.create(RandomSource.WELL_19937_C, 1000);</span>

<span class="fc" id="L601">        final double[] x = {0, 2, 3, 4, 5, 6, 7, 8, 9, 12};</span>
<span class="fc" id="L602">        final double[] y = {1, 10, 11, 13, 14, 15, 16, 17, 18};</span>
<span class="fc" id="L603">        double d = test.kolmogorovSmirnovStatistic(x, y);</span>
<span class="fc" id="L604">        Assert.assertEquals(0.0027495724090154106, test.monteCarloP(d, x.length, y.length, false, iterations, rng), tol);</span>

<span class="fc" id="L606">        final double[] x1 = {2, 4, 6, 8, 9, 10, 11, 12, 13};</span>
<span class="fc" id="L607">        final double[] y1 = {0, 1, 3, 5, 7};</span>
<span class="fc" id="L608">        d = test.kolmogorovSmirnovStatistic(x1, y1);</span>
<span class="fc" id="L609">        Assert.assertEquals(0.085914085914085896, test.monteCarloP(d, x1.length, y1.length, false, iterations, rng), tol);</span>

<span class="fc" id="L611">        final double[] x2 = {4, 6, 7, 8, 9, 10, 11};</span>
<span class="fc" id="L612">        final double[] y2 = {0, 1, 2, 3, 5};</span>
<span class="fc" id="L613">        d = test.kolmogorovSmirnovStatistic(x2, y2);</span>
<span class="fc" id="L614">        Assert.assertEquals(0.015151515151515027, test.monteCarloP(d, x2.length, y2.length, false, iterations, rng), tol);</span>
<span class="fc" id="L615">    }</span>

    @Test
    public void testFillBooleanArrayRandomlyWithFixedNumberTrueValues() throws Exception {
<span class="fc" id="L619">        Method method = KolmogorovSmirnovTest.class.getDeclaredMethod(&quot;fillBooleanArrayRandomlyWithFixedNumberTrueValues&quot;,</span>
                                                                      boolean[].class, Integer.TYPE, UniformRandomProvider.class);
<span class="fc" id="L621">        method.setAccessible(true);</span>

<span class="fc" id="L623">        final int[][] parameters = {{5, 1}, {5, 2}, {5, 3}, {5, 4}, {8, 1}, {8, 2}, {8, 3}, {8, 4}, {8, 5}, {8, 6}, {8, 7}};</span>

<span class="fc" id="L625">        final double alpha = 0.001;</span>
<span class="fc" id="L626">        final int numIterations = 1000000;</span>

<span class="fc" id="L628">        final UniformRandomProvider rng = RandomSource.create(RandomSource.WELL_19937_C, 0);</span>

<span class="fc bfc" id="L630" title="All 2 branches covered.">        for (final int[] parameter : parameters) {</span>

<span class="fc" id="L632">            final int arraySize = parameter[0];</span>
<span class="fc" id="L633">            final int numberOfTrueValues = parameter[1];</span>

<span class="fc" id="L635">            final boolean[] b = new boolean[arraySize];</span>
<span class="fc" id="L636">            final long[] counts = new long[1 &lt;&lt; arraySize];</span>

<span class="fc bfc" id="L638" title="All 2 branches covered.">            for (int i = 0; i &lt; numIterations; ++i) {</span>
<span class="fc" id="L639">                method.invoke(KolmogorovSmirnovTest.class, b, numberOfTrueValues, rng);</span>
<span class="fc" id="L640">                int x = 0;</span>
<span class="fc bfc" id="L641" title="All 2 branches covered.">                for (int j = 0; j &lt; arraySize; ++j) {</span>
<span class="fc bfc" id="L642" title="All 2 branches covered.">                    x = ((x &lt;&lt; 1) | ((b[j])?1:0));</span>
                }
<span class="fc" id="L644">                counts[x] += 1;</span>
            }

<span class="fc" id="L647">            final int numCombinations = (int) BinomialCoefficient.value(arraySize, numberOfTrueValues);</span>

<span class="fc" id="L649">            final long[] observed = new long[numCombinations];</span>
<span class="fc" id="L650">            final double[] expected = new double[numCombinations];</span>
<span class="fc" id="L651">            Arrays.fill(expected, numIterations / (double) numCombinations);</span>

<span class="fc" id="L653">            int observedIdx = 0;</span>

<span class="fc bfc" id="L655" title="All 2 branches covered.">            for (int i = 0; i &lt; (1 &lt;&lt; arraySize); ++i) {</span>
<span class="fc bfc" id="L656" title="All 2 branches covered.">                if (Integer.bitCount(i) == numberOfTrueValues) {</span>
<span class="fc" id="L657">                    observed[observedIdx] = counts[i];</span>
<span class="fc" id="L658">                    observedIdx += 1;</span>
                }
                else {
<span class="fc" id="L661">                    Assert.assertEquals(0, counts[i]);</span>
                }
            }

<span class="fc" id="L665">            Assert.assertEquals(numCombinations, observedIdx);</span>
<span class="fc" id="L666">            TestUtils.assertChiSquareAccept(expected, observed, alpha);</span>
        }
<span class="fc" id="L668">    }</span>

    /**
     * Test an example with ties in the data.  Reference data is R 3.2.0,
     * ks.boot implemented in Matching (Version 4.8-3.4, Build Date: 2013/10/28)
     */
    @Test
    public void testBootstrapSmallSamplesWithTies() {
<span class="fc" id="L676">        final double[] x = {0, 2, 4, 6, 8, 8, 10, 15, 22, 30, 33, 36, 38};</span>
<span class="fc" id="L677">        final double[] y = {9, 17, 20, 33, 40, 51, 60, 60, 72, 90, 101};</span>
<span class="fc" id="L678">        final KolmogorovSmirnovTest test = new KolmogorovSmirnovTest();</span>
<span class="fc" id="L679">        final UniformRandomProvider rng = RandomSource.create(RandomSource.WELL_19937_C, 2000);</span>
<span class="fc" id="L680">        Assert.assertEquals(0.0059, test.bootstrap(x, y, 10000, false, rng), 1E-3);</span>
<span class="fc" id="L681">    }</span>

    /**
     * Reference data is R 3.2.0, ks.boot implemented in
     * Matching (Version 4.8-3.4, Build Date: 2013/10/28)
     */
    @Test
    public void testBootstrapLargeSamples() {
<span class="fc" id="L689">        final KolmogorovSmirnovTest test = new KolmogorovSmirnovTest();</span>
<span class="fc" id="L690">        final UniformRandomProvider rng = RandomSource.create(RandomSource.WELL_19937_C, 1000);</span>
<span class="fc" id="L691">        Assert.assertEquals(0.0237, test.bootstrap(gaussian, gaussian2, 10000, true, rng), 1E-2);</span>
<span class="fc" id="L692">    }</span>

    /**
     * Test an example where D-values are close (subject to rounding).
     * Reference data is R 3.2.0, ks.boot implemented in
     * Matching (Version 4.8-3.4, Build Date: 2013/10/28)
     */
    @Test
    public void testBootstrapRounding() {
<span class="fc" id="L701">        final double[] x = {2,4,6,8,9,10,11,12,13};</span>
<span class="fc" id="L702">        final double[] y = {0,1,3,5,7};</span>
<span class="fc" id="L703">        final KolmogorovSmirnovTest test = new KolmogorovSmirnovTest();</span>
<span class="fc" id="L704">        final UniformRandomProvider rng = RandomSource.create(RandomSource.WELL_19937_C, 1000);</span>
<span class="fc" id="L705">        Assert.assertEquals(0.06303, test.bootstrap(x, y, 10000, false, rng), 1E-2);</span>
<span class="fc" id="L706">    }</span>

    @Test
    public void testFixTiesNoOp() throws Exception {
<span class="fc" id="L710">        final double[] x = {0, 1, 2, 3, 4};</span>
<span class="fc" id="L711">        final double[] y = {5, 6, 7, 8};</span>
<span class="fc" id="L712">        final double[] origX = MathArrays.copyOf(x);</span>
<span class="fc" id="L713">        final double[] origY = MathArrays.copyOf(y);</span>
<span class="fc" id="L714">        fixTies(x,y);</span>
<span class="fc" id="L715">        Assert.assertArrayEquals(origX, x, 0);</span>
<span class="fc" id="L716">        Assert.assertArrayEquals(origY, y, 0);</span>
<span class="fc" id="L717">    }</span>

    /**
     * Verify that fixTies is deterministic, i.e,
     * x = x', y = y' =&gt; fixTies(x,y) = fixTies(x', y')
     */
    @Test
    public void testFixTiesConsistency() throws Exception {
<span class="fc" id="L725">        final double[] x = {0, 1, 2, 3, 4, 2};</span>
<span class="fc" id="L726">        final double[] y = {5, 6, 7, 8, 1, 2};</span>
<span class="fc" id="L727">        final double[] xP = MathArrays.copyOf(x);</span>
<span class="fc" id="L728">        final double[] yP = MathArrays.copyOf(y);</span>
<span class="fc" id="L729">        checkFixTies(x, y);</span>
<span class="fc" id="L730">        final double[] fixedX = MathArrays.copyOf(x);</span>
<span class="fc" id="L731">        final double[] fixedY = MathArrays.copyOf(y);</span>
<span class="fc" id="L732">        checkFixTies(xP, yP);</span>
<span class="fc" id="L733">        Assert.assertArrayEquals(fixedX, xP, 0);</span>
<span class="fc" id="L734">        Assert.assertArrayEquals(fixedY, yP, 0);</span>
<span class="fc" id="L735">    }</span>

    @Test
    public void testFixTies() throws Exception {
<span class="fc" id="L739">        checkFixTies(new double[] {0, 1, 1, 4, 0}, new double[] {0, 5, 0.5, 0.55, 7});</span>
<span class="fc" id="L740">        checkFixTies(new double[] {1, 1, 1, 1, 1}, new double[] {1, 1});</span>
<span class="fc" id="L741">        checkFixTies(new double[] {1, 2, 3}, new double[] {1});</span>
<span class="fc" id="L742">        checkFixTies(new double[] {1, 1, 0, 1, 0}, new double[] {});</span>
<span class="fc" id="L743">    }</span>

    /**
     * Checks that fixTies eliminates ties in the data but does not otherwise
     * perturb the ordering.
     */
    private void checkFixTies(double[] x, double[] y) throws Exception {
<span class="fc" id="L750">        final double[] origCombined = MathArrays.concatenate(x, y);</span>
<span class="fc" id="L751">        fixTies(x, y);</span>
<span class="fc" id="L752">        Assert.assertFalse(hasTies(x, y));</span>
<span class="fc" id="L753">        final double[] combined = MathArrays.concatenate(x, y);</span>
<span class="fc bfc" id="L754" title="All 2 branches covered.">        for (int i = 0; i &lt; combined.length; i++) {</span>
<span class="fc bfc" id="L755" title="All 2 branches covered.">            for (int j = 0; j &lt; i; j++) {</span>
<span class="pc bpc" id="L756" title="1 of 2 branches missed.">                Assert.assertTrue(combined[i] != combined[j]);</span>
<span class="fc bfc" id="L757" title="All 2 branches covered.">                if (combined[i] &lt; combined[j]) {</span>
<span class="pc bpc" id="L758" title="1 of 4 branches missed.">                    Assert.assertTrue(origCombined[i] &lt; origCombined[j]</span>
                                          || origCombined[i] == origCombined[j]);
                }
            }

        }
<span class="fc" id="L764">    }</span>

    /**
     * Verifies the inequality exactP(criticalValue, n, m, true) &lt; alpha &lt; exactP(criticalValue, n,
     * m, false).
     *
     * Note that the validity of this check depends on the fact that alpha lies strictly between two
     * attained values of the distribution and that criticalValue is one of the attained values. The
     * critical value table (reference below) uses attained values. This test therefore also
     * verifies that criticalValue is attained.
     *
     * @param n first sample size
     * @param m second sample size
     * @param criticalValue critical value
     * @param alpha significance level
     */
    private void checkExactTable(int n, int m, double criticalValue, double alpha) {
<span class="fc" id="L781">        final KolmogorovSmirnovTest test = new KolmogorovSmirnovTest();</span>
<span class="pc bpc" id="L782" title="1 of 2 branches missed.">        Assert.assertTrue(test.exactP(criticalValue, n, m, true) &lt; alpha);</span>
<span class="pc bpc" id="L783" title="1 of 2 branches missed.">        Assert.assertTrue(test.exactP(criticalValue, n, m, false) &gt; alpha);</span>
<span class="fc" id="L784">    }</span>

    /**
     * Verifies that approximateP(criticalValue, n, m) is within epsilon of alpha.
     *
     * @param n first sample size
     * @param m second sample size
     * @param criticalValue critical value (from table)
     * @param alpha significance level
     * @param epsilon tolerance
     */
    private void checkApproximateTable(int n, int m, double criticalValue, double alpha, double epsilon) {
<span class="fc" id="L796">        final KolmogorovSmirnovTest test = new KolmogorovSmirnovTest();</span>
<span class="fc" id="L797">        Assert.assertEquals(alpha, test.approximateP(criticalValue, n, m), epsilon);</span>
<span class="fc" id="L798">    }</span>

    /**
     * Reflection hack to expose private fixTies method for testing.
     */
    private static void fixTies(double[] x, double[] y) throws Exception {
<span class="fc" id="L804">        Method method = KolmogorovSmirnovTest.class.getDeclaredMethod(&quot;fixTies&quot;,</span>
                                                                      double[].class, double[].class);
<span class="fc" id="L806">        method.setAccessible(true);</span>
<span class="fc" id="L807">        method.invoke(KolmogorovSmirnovTest.class, x, y);</span>
<span class="fc" id="L808">    }</span>

    /**
     * Reflection hack to expose private hasTies method.
     */
    private static boolean hasTies(double[] x, double[] y) throws Exception {
<span class="fc" id="L814">        Method method = KolmogorovSmirnovTest.class.getDeclaredMethod(&quot;hasTies&quot;,</span>
                                                                      double[].class, double[].class);
<span class="fc" id="L816">        method.setAccessible(true);</span>
<span class="fc" id="L817">        return (boolean) method.invoke(KolmogorovSmirnovTest.class, x, y);</span>
    }

}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.1.201803210924</span></div></body></html>